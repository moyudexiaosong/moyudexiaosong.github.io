<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>机器学习汇总</title>
    <link href="/2022/06/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6%E5%AE%89%E6%8E%92/"/>
    <url>/2022/06/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6%E5%AE%89%E6%8E%92/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>机器学习，人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CANopen网络协议</title>
    <link href="/2022/06/17/Canopen%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/06/17/Canopen%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="canopen简介"><a href="#canopen简介" class="headerlink" title="canopen简介"></a>canopen简介</h2><blockquote><p><strong><em>应用层的目的是向应用程序提供网络接口，直接向用户提供服务。\</em></strong></p></blockquote><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>应用层协议(application layer protocol)定义了运行在不同端系统上的应用程序进程如何相互传递报文。</p><p><em>CANopen是基于CAN协议的应用层协议，可以理解为用户层，即规定了用户、软件、网络终端等之间用来进行信息交换的约定。</em></p><p>CANOpen协议主要内容分为三大块，如下图CANopen 的设备模型。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220616163527713.png" alt="image-20220616163527713"></p><h3 id="通信对象"><a href="#通信对象" class="headerlink" title="通信对象"></a>通信对象</h3><p>CANopen协议中常用的通信对象包含如下几点：</p><h6 id="1）-网络管理对象-NMT"><a href="#1）-网络管理对象-NMT" class="headerlink" title="1） 网络管理对象(NMT)"></a>1） 网络管理对象(NMT)</h6><p>网络管理对象基于主从通信模式， 用于<u>管理</u>和<u>监控</u>网络中的各个节点，主要实现三种功能：节点状态控制、错误控制和<u>节点启动</u>。</p><blockquote><p>在CANOpen网络中，分主站和从站，而通常由主站来管理整个网络。比如：复位、停止等。</p><p>NMT网络管理主要包含以下<strong>6种状态</strong>：</p><p><strong>1.初始化（Initializing）：</strong>节点上电后对功能部件包括 CAN 控制器进行初始化；</p><p><strong>2.应用层复位（Application Reset）：</strong>节点中的应用程序复位（开始），比如开关量输出、模拟量输出的初始值；</p><p><strong>3.通讯复位（Communication reset）：</strong>节点中的CANopen通讯复位（开始），从这个时刻起，此节点就可以进行CANopen通讯了；</p><p><strong>4.预操作状态（Pre-operational）：</strong>节点的CANopen通讯处于操作就绪状态，此时此节点不能进行PDO通信，而可以进行SDO进行参数配置和NMT网络管理的操作；</p><p><strong>5.操作状态（operational）：</strong>节点收到NMT主机发来的启动命令后， CANopen通讯被激活， PDO通信启动后， 按照对象字典里面规定的规则进行传输，同样SDO也可以对节点进行数据传输和参数修改；</p><p><strong>6.停止状态（Stopped）：</strong> 节点收到NMT主机发来的停止命令后，节点的PDO通信被停止，但SDO和NMT网络管理依然可以对节点进行操作；</p></blockquote><p>为了<strong>监控 CANopen 节点是否在线与目前的节点状态</strong>。 CANopen 应用中通常都要求在线上电的从站定时发送状态报文（心跳报文），以便于主站确认从站是否故障、是否脱离网络。</p><h6 id="2）-服务数据对象-SDO"><a href="#2）-服务数据对象-SDO" class="headerlink" title="2） 服务数据对象 (SDO)"></a>2） 服务数据对象 (SDO)</h6><p><strong>·</strong>包括接收 SDO(R-SDO) 和发送 SDO(T-SDO)。</p><p><strong>·</strong>通过使用索引和子索引， SDO 使客户机能够访问设备对象字典中的项。</p><p><strong>·</strong>协议是确认服务类型，为每个消息生成一个应答。 SDO 请求和应答报文总是包含 8 个字节。</p><h6 id="3）-过程数据对象-PDO"><a href="#3）-过程数据对象-PDO" class="headerlink" title="3） 过程数据对象(PDO)"></a>3） 过程数据对象(PDO)</h6><p><strong>·</strong>包括接收 PDO(RPDO) 和发送 PDO(TPDO)。</p><p><strong>·</strong>用来传输实时数据，为单向传输，无需接受节点回应CAN报文来确认，数据从一个创建者传到一个或多个接收者。数据传送限制在 1 到 8 个字节。</p><p><strong>·</strong>PDO 包含同步和异步两种传输方式，由该 PDO 对应的通信参数决定。</p><blockquote><p>PDO同步和异步的区别</p><p>1）  同步传输：通过接收同步对象实现同步，按触发方式又可分为非周期传输和周期传输。非周期传输由远程帧预触发，或者由设备子协议中规定的对象特定事件预触发。周期传输则通过接收同步对象来实现，可以设置1~240个同步对象触发。</p><p>2）  异步传输：由特定事件触发。按触发方式又可分为2种：一种通过发送与PDO的COB-ID相同的远程帧来触发；另一种由设备子协议中规定的对象特定事件来触发（如定时传输、数据变化传输等）。</p></blockquote><p><strong>·</strong>PDO 消息的内容是预定义的，由该 PDO 对应的映射参数决定。</p><h6 id="4）-同步对象-SYNC"><a href="#4）-同步对象-SYNC" class="headerlink" title="4） 同步对象 (SYNC)"></a>4） 同步对象 (SYNC)</h6><p>同步对象是由 CANopen 主站周期性地广播到 CAN 总线的报文，用来实现基本的<em>网络时钟信号</em>，每个设备可以根据自己的配置，决定<em>是否使用该事件来跟其它网络设备进行同步通信</em>。</p><h6 id="5）-紧急报文-EMCY"><a href="#5）-紧急报文-EMCY" class="headerlink" title="5） 紧急报文 (EMCY)"></a>5） 紧急报文 (EMCY)</h6><p>设备内部通信故障或者应用故障错误时发送的报文。</p><p><a href="https://www.zhihu.com/question/51340422">参考链接</a></p><h3 id="对象字典"><a href="#对象字典" class="headerlink" title="对象字典"></a>对象字典</h3><p> CANopen对象字典是CANopen协议最为核心的概念。所谓的“对象字典”，就是一个有序的对象组；每个对象采用一个16位的索引值来寻址。为了访问数据结构中的元素，同时定义了一个8位的子索引，对象字典的结构如表所示。</p><h3 id="如何利用CANopen控制伺服电机"><a href="#如何利用CANopen控制伺服电机" class="headerlink" title="如何利用CANopen控制伺服电机"></a>如何利用CANopen控制伺服电机</h3>]]></content>
    
    
    
    <tags>
      
      <tag>陈师兄的项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week01</title>
    <link href="/2022/06/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0week01/"/>
    <url>/2022/06/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0week01/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h3 id="1-1-什么是机器学习"><a href="#1-1-什么是机器学习" class="headerlink" title="1.1 什么是机器学习"></a>1.1 什么是机器学习</h3><p>类似人类通过对经验的利用对新情况做出有效的决策，计算机通过计算的手段，利用经验来改善系统自身的性能。</p><p>在计算机系统中，”经验”通常以”数据”形式存在，因此机器学习所研究的主要内容，是关于在计算机上从数据中产生”<strong>模型”(model)</strong>的算法，即”学习算法”(learningalgorithm).有了学习算法，我们把经验数据提供给它，它就能基于这些数据产生模型；在面对新的情况时(例如看到一个没剖开的西瓜)，模型会给我们提供相应的判断(例如好瓜).</p><p>如果说计算机科学是研究关于”算法”的学问，那么类似的，可以说机器学习是研究关于”学习算法”的学问.</p><h3 id="1-2-基本术语"><a href="#1-2-基本术语" class="headerlink" title="1.2 基本术语"></a>1.2 基本术语</h3><p>假定我们收集了一批关于西瓜的数据，例如(色泽=青绿；根蒂=蜷缩；敲声=浊响)，(色泽=乌黑；根蒂:稍蜷；敲声=沉闷)，(色泽=浅自；根蒂硬挺；敲声=清脆)…</p><p>每对括号内是一条<strong>记录</strong>，=的意思是”取值为”。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220617192915496.png" alt="image-20220617192915496"></p><p>从数据中学得模型的过程称为<u><strong>“学习”(learning)或”训练”(training)</strong></u>,这个过程通过执行某个学习算法来完成学得模型对应了关于数据的某种潜在的规律，因此亦称<strong><u>“假设”</u></strong>(hypothesis)；这种潜在规律自身，则称为<u><strong>“真相”或”真实”(ground-truth)</strong></u>，学习过程就是为了找出或逼近真相.本书有时将模型称为<u><strong>“学习器”(learner)</strong></u>，可看作学习算法在给定数据和参数空间上的实例化.</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220617200149951-5467313-5467314-5467315.png" alt="image-20220617200149951"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220617200824722-5467707.png" alt="image-20220617200824722"></p><p>学得模型后，使用其进预测的过程称为<u><strong>“测试”(testing)</strong></u>，被预测的样本称为<u><strong>“测试样本”(testingsample)</strong></u>.例如在学得$f$后，对测试例，可得到其预测标记$ν=f(x)$.</p><p><u><strong>“聚类”(clustering)</strong></u>，即将训练集中的西瓜分成若干组，每组称为一个”<u><strong>簇</strong></u>“(cluster)；这些自动形成的簇可能对应一些潜在的概念划分，例如”浅色瓜””深色瓜”，这些概念事先是不知道的，而且学习过程中使用的训练样本通常不拥有标记信息.</p><p>根据<u>训练数据是否拥有标记信息</u>，学习任务可大致划分为两大类”监督学习”(supervisedlearning)和”<strong>无监督学习</strong>“(unsupervisedlearning)，分类和回归是前者的代表，而聚类则是后者的代表.</p><p><u>学得模型适用于新样本的能力</u>，称为”<strong><u>泛化</u></strong>“(generalization)能力.具有强泛化能力的模型能很好地适用于整个样本空间.通常假设样本空间的样本均服从独立同分布，一般而言，训练样本越多，我们得到的关于分布的信息越多，这样就越有可能通过学习获得具有强泛化能力的模型.</p><h3 id="1-3-假设空间"><a href="#1-3-假设空间" class="headerlink" title="1.3 假设空间"></a>1.3 假设空间</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618134035759.png" alt="image-20220618134035759" style="zoom: 50%;" /></p><p>归纳学习有<strong>狭义</strong>与<strong>广义</strong>之分：</p><p>广义的归纳学习大体相当于<u>从样例中学习</u>。</p><p>狭义的归纳学习则要求<u>从训练数据中学得概念(concept)</u>，因此亦称为<u><strong>“概念学习”或”概念形成”</strong></u>。</p><p>举一个西瓜数据集的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">色泽</th><th style="text-align:center">根蒂</th><th style="text-align:center">敲声</th><th style="text-align:center">好瓜</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">青绿</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">乌黑</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">青绿</td><td style="text-align:center">硬挺</td><td style="text-align:center">清脆</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">乌黑</td><td style="text-align:center">稍缩</td><td style="text-align:center">沉闷</td><td style="text-align:center">否</td></tr></tbody></table></div><p>这里要学习的目标是”好瓜”，表1.1第一行虽然是好瓜，但这是一个已经见过的瓜，不属于“泛化”的范畴，因此引入一个概念——<u><strong>假设空间</strong></u>，里面包含所有假设。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618104530154.png" alt="image-20220618104530154"></p><p>搜索过程中可以不断删除<u><strong>与正例不一致</strong></u>的假设、和(或)<u><strong>与反例一致</strong></u>的假设，最终获得与训练集一致(即<u>对所有训练样本能够进行正确判断</u>)的假设，这就是我们学得的结果.</p><p>与训练集一致的”假设集合”称之为”版本空间”(versionspace).例如，在西瓜问题中，与表1.1训练集所对应的版本空间如图1.2所示.<a href="https://blog.csdn.net/qq_18433441/article/details/55682732">详细过程</a></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618110202690.png" alt="image-20220618110202690"></p><h3 id="1-4-归纳偏好"><a href="#1-4-归纳偏好" class="headerlink" title="1.4 归纳偏好"></a>1.4 归纳偏好</h3><p>通过学习得到的模型对应了假设空间中的一个假设，但很可能存在有多个与训练集一致的假设，但与它们对应的模型在面临新样本的时候，却会产生不同的输出.</p><p>机器学习算法在学习过程中对某种类型假设的偏好，称为”<strong><u>归纳偏好</u></strong>“(inductivebias),或简称为”偏好”。<u>任何一个有效的机器学习算法必有其归纳偏好</u>。</p><p>“奥卡姆剃刀”(Occam’srazor)原则：”若有多个假设与观察一致，则选最简单的那个。</p><p>在具体的现实问题中，这个假设是否成立，即算法的归纳偏好是否与问题本身匹配，大多数时候直接决定了算法能否取得好的性能.脱离具体问题，空泛地谈论”什么学习算法更好”毫无意义，因为若考虑所有潜在的问题，则所有学习算法都一样好.</p><h3 id="1-5-习题"><a href="#1-5-习题" class="headerlink" title="1.5 习题"></a>1.5 习题</h3><h4 id="1-5-1"><a href="#1-5-1" class="headerlink" title="1.5.1"></a>1.5.1</h4><p><em>表1. 1 中若只包含编号为 1 和 4 的两个样例，试给出相应的版本空间.</em></p><div class="table-container"><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">色泽</th><th style="text-align:center">根蒂</th><th style="text-align:center">敲声</th><th style="text-align:center">好瓜</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">青绿</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">乌黑</td><td style="text-align:center">稍缩</td><td style="text-align:center">沉闷</td><td style="text-align:center">否</td></tr></tbody></table></div><p>表1.1的训练数据集对应的假设空间应该如下：</p><p>搜索过程中可以不断删除与正例不一致的假设、和（或）与反例一致的假设。最终将会获得与训练集一致（即对所有训练样本能够进行正确判断）的假设，这就是我们学得的结果。</p><p>按照上述过程进行学习：</p><p>编号1可以删除：3，5，6，8，9，11-15，17-21，23-30，32-49</p><p>编号4可以删除：3，6，15，21，30，48，即剩余假设空间中无可删除的假设</p><p>学习过后剩余的假设为：</p><p>1，2，4，7，10。</p><p>这就是最后的“假设集合”，也就是<strong>“版本空间”</strong>。</p><p>1 色泽＝＊，根蒂＝＊，敲声＝＊<br>2 色泽＝青绿，根蒂＝＊，敲声＝＊<br>3 色泽＝乌黑，根蒂＝＊，敲声＝＊<br>4 色泽＝＊，根蒂＝蜷缩，敲声＝＊<br>5 色泽＝＊，根蒂＝硬挺，敲声＝＊<br>6 色泽＝＊，根蒂＝稍蜷，敲声＝＊<br>7 色泽＝＊，根蒂＝＊，敲声＝浊响<br>8 色泽＝＊，根蒂＝＊，敲声＝清脆<br>9 色泽＝＊，根蒂＝＊，敲声＝沉闷<br>10 色泽＝青绿，根蒂＝蜷缩，敲声＝＊<br>11 色泽＝青绿，根蒂＝硬挺，敲声＝＊<br>12 色泽＝青绿，根蒂＝稍蜷，敲声＝＊<br>13 色泽＝乌黑，根蒂＝蜷缩，敲声＝＊<br>14 色泽＝乌黑，根蒂＝硬挺，敲声＝＊<br>15 色泽＝乌黑，根蒂＝稍蜷，敲声＝＊<br>16 色泽＝青绿，根蒂＝＊，敲声＝浊响<br>17 色泽＝青绿，根蒂＝＊，敲声＝清脆<br>18 色泽＝青绿，根蒂＝＊，敲声＝沉闷<br>19 色泽＝乌黑，根蒂＝＊，敲声＝浊响<br>20 色泽＝乌黑，根蒂＝＊，敲声＝清脆<br>21 色泽＝乌黑，根蒂＝＊，敲声＝沉闷<br>22 色泽＝＊，根蒂＝蜷缩，敲声＝浊响<br>23 色泽＝＊，根蒂＝蜷缩，敲声＝清脆<br>24 色泽＝＊，根蒂＝蜷缩，敲声＝沉闷<br>25 色泽＝＊，根蒂＝硬挺，敲声＝浊响<br>26 色泽＝＊，根蒂＝硬挺，敲声＝清脆<br>27 色泽＝＊，根蒂＝硬挺，敲声＝沉闷<br>28 色泽＝＊，根蒂＝稍蜷，敲声＝浊响<br>29 色泽＝＊，根蒂＝稍蜷，敲声＝清脆<br>30 色泽＝＊，根蒂＝稍蜷，敲声＝沉闷<br>31 色泽＝青绿，根蒂＝蜷缩，敲声＝浊响<br>32 色泽＝青绿，根蒂＝蜷缩，敲声＝清脆<br>33 色泽＝青绿，根蒂＝蜷缩，敲声＝沉闷<br>34 色泽＝青绿，根蒂＝硬挺，敲声＝浊响<br>35 色泽＝青绿，根蒂＝硬挺，敲声＝清脆<br>36 色泽＝青绿，根蒂＝硬挺，敲声＝沉闷<br>37 色泽＝青绿，根蒂＝稍蜷，敲声＝浊响<br>38 色泽＝青绿，根蒂＝稍蜷，敲声＝清脆<br>39 色泽＝青绿，根蒂＝稍蜷，敲声＝沉闷<br>40 色泽＝乌黑，根蒂＝蜷缩，敲声＝浊响<br>41 色泽＝乌黑，根蒂＝蜷缩，敲声＝清脆<br>42 色泽＝乌黑，根蒂＝蜷缩，敲声＝沉闷<br>43 色泽＝乌黑，根蒂＝硬挺，敲声＝浊响<br>44 色泽＝乌黑，根蒂＝硬挺，敲声＝清脆<br>45 色泽＝乌黑，根蒂＝硬挺，敲声＝沉闷<br>46 色泽＝乌黑，根蒂＝稍蜷，敲声＝浊响<br>47 色泽＝乌黑，根蒂＝稍蜷，敲声＝清脆<br>48 色泽＝乌黑，根蒂＝稍蜷，敲声＝沉闷<br>49 Ø</p><h4 id="1-5-2"><a href="#1-5-2" class="headerlink" title="1.5.2"></a>1.5.2</h4><p><a href="https://blog.csdn.net/qq_26371477/article/details/102292685?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-102292685-blog-103812745.pc_relevant_antiscanv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-102292685-blog-103812745.pc_relevant_antiscanv3&amp;utm_relevant_index=10">代码实现</a></p><p><em>与使用单个合取式来进行假设表示相比，使用”析合范式”将使得假设空间具有更强的表示能力.例如</em></p><p><em>好瓜$\leftrightarrow$((色泽=all)$\cap$(根蒂=蜷缩) $\cap$(敲声=all )) $\cup$ ((色泽=乌黑) $\cap$ (根蒂= all)$\cap$(敲声=沉闷)),</em></p><p>会把”(色泽=青绿)$\cap$(根蒂=蜷缩) $\cap$(敲声=清脆 <em>)”以及”(色泽=乌黑)$\cap$(根蒂=硬挺) $\cap$(敲声=沉闷 </em>)”都分类为”好瓜”。若使用最 多包含 $k$个合取式的析合范式来表达表1. 1 西瓜分类问题的假设空 间 ,试估算共有多少种可能的假设.*</p><blockquote><p>知识储备</p><p>合取式：是用合取真值联结词“∧”将两个或两个以上的命题联结起来而形成的命题形式。</p><p>析取式：用析取真值连接词“∨”将两个或两个以上的命题联结而成的一种命题形式</p><p>合取：相当于交集但不是交集</p><p>析取：相当于并集但不是并集</p><p>合取范式（合析范式）：有限个简单析取式构成的合取式</p><p>析取范式（析合范式）：由有限个简单合取式构成的析取式称为析取范式。</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">色泽</th><th style="text-align:center">根蒂</th><th style="text-align:center">敲声</th><th style="text-align:center">好瓜</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">青绿</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">乌黑</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">青绿</td><td style="text-align:center">硬挺</td><td style="text-align:center">清脆</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">乌黑</td><td style="text-align:center">稍缩</td><td style="text-align:center">沉闷</td><td style="text-align:center">否</td></tr></tbody></table></div><p>表中4个样例，3种属性，属性个数分别为2，3，3，假若考虑没有泛化属性和空集的情况下，剔除含通配符和相同的项，得到无冗余的假设空间共有2$\times$3$\times$3=18种假设，这18种假设的自由组合成的析合范式能够唯一的表示所有的假设。</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">色泽=青绿</td><td style="text-align:center">色泽=乌黑</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">根蒂=蜷缩</td><td style="text-align:center">根蒂=稍蜷</td><td style="text-align:center">根蒂=硬挺</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">敲声=浊响</td><td style="text-align:center">敲声=清脆</td><td style="text-align:center">敲声=沉闷</td></tr></tbody></table></div><p>可列集合为（$a_1<script type="math/tex">b_1</script>c_1$, $a_1b_1c_2$ ,……, $a_2b_3c_3$)，将其简化为（$1,2,3,……,18$),</p><p>$k=1$时，所有的析合范式为：$(1,2,3,……18)$。</p><p>$k=2$时，所有的析合范式为：$((1,2),(1,3),(1,4),(1,5),……(16,17),(16,18),(17,18))$。</p><p>有可能的析合范式的个数为：$17+16+……+3+2+1$=153。</p><p>$k=3$时，析合范式的个数为816,代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">result=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">17</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((i+<span class="hljs-number">1</span>),<span class="hljs-number">19</span>):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((j+<span class="hljs-number">1</span>),<span class="hljs-number">19</span>):<br>            <span class="hljs-built_in">print</span>((i,j,k))<br>            result=result+<span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>$k=4$时，析合范式的个数为3060,代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">result=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> a1 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">16</span>):<span class="hljs-comment">#这里16和循环次数相加就等于20</span><br>    <span class="hljs-keyword">for</span> a2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((a1+<span class="hljs-number">1</span>),<span class="hljs-number">19</span>):<br>        <span class="hljs-keyword">for</span> a3 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((a2+<span class="hljs-number">1</span>),<span class="hljs-number">19</span>):<br>            <span class="hljs-keyword">for</span> a4  <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((a3  + <span class="hljs-number">1</span>), <span class="hljs-number">19</span>):<br>                <span class="hljs-built_in">print</span>((a1 ,a2 ,a3 ,a4 ))<br>                result=result+<span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><h4 id="1-5-3"><a href="#1-5-3" class="headerlink" title="*1.5.3"></a>*1.5.3</h4><p>若数据包含噪声，则假设空间中有可能不存在与所有训练样本都一致 的假设，在此情形下，试设计一种归纳偏好用于假设选择.</p><p><u>不会</u></p><p>数据包含噪声，其含义就是，存在训练集本身的部分数据，其<u>属性取值对应的标记值是错误的</u>。对于噪声，最理想的情况是去除所有噪声，即将这部分“错误”的数据剔除出训练集。但事实上，单从数据集本身来剔除噪声并无通用的办法，甚至无法直接判断哪些数据属于噪声。</p><p>通俗来讲，我们可以先认为所有不矛盾的数据是正确的，只有哪些属性值相同但标记值不同的数据，“相互矛盾”的情况下，才剔除一部分数据使矛盾消除，此时剔除的方法可以归纳为一种偏好。 </p><p>例如，属性值相同的两个数据，其标记值分别为正例和反例，可以设计归纳偏好为：<u>始终保留正例的数据，或始终保留反例的数据。</u><br><a href="https://blog.csdn.net/MaxQuYY/article/details/120287245">原文链接</a></p><h4 id="1-5-4"><a href="#1-5-4" class="headerlink" title="*1.5.4"></a>*1.5.4</h4><p>换用其它性能度量，试证明没有免费的午餐定理成立。</p><p><a href="https://zhuanlan.zhihu.com/p/48493722">公式推导</a></p><h4 id="1-5-5"><a href="#1-5-5" class="headerlink" title="1.5.5"></a>1.5.5</h4><p>试述机器学习能在互联网搜索的哪些环节起什么作用.</p><ol><li>在向搜索引擎提交信息阶段，能够从提交文本中进行信息提取，进行语义分析。</li><li>在搜索引擎进行信息匹配阶段，能够提高问题与各个信息的匹配程度。</li><li>在向用户展示搜索结果的阶段，能够根据用户对结果感兴趣的程度进行排序。 </li></ol><h1 id="第二章-模型评估与选择"><a href="#第二章-模型评估与选择" class="headerlink" title="第二章 模型评估与选择"></a>第二章 模型评估与选择</h1><h3 id="章节主要内容"><a href="#章节主要内容" class="headerlink" title="章节主要内容"></a>章节主要内容</h3><p>在第一章绪论中，我们知道要根据具体的问题选择具体的算法和归纳偏好。那么要怎么判定我们的选择是正确的呢？这就需要拥有一套规范的模型评估与选择方法论了。</p><p>具体的章节思路可参考如下图解。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5328356-6afc770c7199ac3d.jpeg" alt="img"></p><p><a href="https://www.jianshu.com/p/8e369f73a0cc">参考链接</a></p><h3 id="2-1-经验误差与过拟合"><a href="#2-1-经验误差与过拟合" class="headerlink" title="2.1 经验误差与过拟合"></a><strong>2.1 </strong>经验误差与过拟合</h3><p>——机器学习为什么需要一套模型评估与选择方法论？</p><p>在前一章的学习中，我们知道<u>机器学习是对数据集的泛化过程，即从输入的数据中归纳出一套能适用于所有潜在样本的“普遍规律”</u>。可因为训练数据不够充分，机器学习出来的模型并没办法涵盖所有的情况，这就会导致学习器的实际预测输出与样本的真实输出之间存在“误差”。</p><p>学习器在训练集上的误差称为“经验误差”，在新样本上的误差称为“泛化误差”。很明显，要使得分类器尽可能的有用，我们应该要让泛化误差仅可能的小。可惜在现实环境中，我们很难知道新样本是什么样的，所以我们实际能做的只有努力使经验误差最小化。</p><p>但如果将算法设计的尽可能百分百的满足所有训练样本，就忘了学习器真正要达到的是泛化误差尽可能小，而不是目前的折中方案降低经验误差。而在降低经验误差的道路上，有着机器学习领域最大的难题之一：<u><strong>“过拟合”</strong></u>。</p><p>“过拟合”是指学习器对训练样本学的太好了，导致泛化程度不够（机器学习本身就是一个泛化过程），没法适应新的数据样本。与之相反的还有一个“欠拟合”的概念，就是对训练样本中的一般规律都没学习好。举个例子，你通过姚明这个训练样本来学习一个人类判断器，如果你将身高两米二十以上作为判断是否是人的依据，那就是过拟合了；而如果你没有“直立行走”这样的特征都没有找出来作为判断是否是人的标准，那就是欠拟合了。</p><p>所以，为什么需要一套模型评估与选择的方法论呢？<u><strong>因为我们的训练数据没法真正代表真实的样本空间，而泛化误差无法直接获得，经验误差又因为过拟合的存在而不适合作为标准，所以我们才需要一套模型评估与选择的方法论。</strong></u></p><h4 id="2-1-1-相关概念"><a href="#2-1-1-相关概念" class="headerlink" title="2.1.1 相关概念"></a>2.1.1 相关概念</h4><p>误差分为训练误差、经验误差和泛化误差，前两种为在学习集上的误差，最后一种是在新样本上的误差。</p><p>错误率$E$=分类错误的样本数$a$/总样本数$m$</p><p>精度=$1 - $ 错误率=$1-\frac{a}{m}$</p><p>误差=学习器的实际预测输出-真实输出</p><p><strong>欠拟合与过拟合的例子</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618142530466.png" alt="image-20220618142530466"></p><h3 id="2-2-评估方法"><a href="#2-2-评估方法" class="headerlink" title="2.2  评估方法"></a><strong>2.2 </strong> 评估方法</h3><p>——在已经知道为什么要对模型进行评估后，在不知道泛化误差的情况下，我们该如何进行评估呢？</p><p>一个合理的思路是：<u>既然我们没法拿到新样本来进行泛化误差计算，那么我们可以从训练样本中取出一部分来，假装它是一组新样本，并用这些样本计算出来的误差作为泛化误差的近似。</u>这组选出来的样本被称为“测试集”，测试集上的误差被称为测试误差。我们学习本书的一个主要目的是学会机器学习领域的脉络和背后逻辑，这种评估思路是科学研究领域的一个常用思路。领悟这种思路有助于我们解决其它领域上的问题）</p><p>不过我们需要注意一点，那就是测试集应该尽量不与训练集重合，否则测试集计算出的误差将没法准确代表该学习器的泛化能力。</p><p>基于这个考虑，书中列出了以下几种把包含$m$个样例的数据集$D$划分为训练集$S$和测试集$T$的办法。</p><h4 id="［1］留出法（hold-out）"><a href="#［1］留出法（hold-out）" class="headerlink" title="［1］留出法（hold-out）"></a><strong>［1］留出法（hold-out）</strong></h4><p>直接将$D$划分为互斥的两部分$S和T$，在$S$上训练出模型后，用$T$来评估测试误差，即 $D=S\cup T$，$S\cap T=\empty$。</p><p>需要注意的是训练/测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外的偏差而对最终结果产生影响。</p><blockquote><p>“分层采样” (stratified sampling)：一种保留类别比例的采样方式. 例如通过对 D 进行分层采样而获得含 70% 样本的训练集 S 和含 30% 样本的测试集 T， 若 D 包含 500 个正例、 500 个反例，则分层采样得到的 S 应包含 350 个正例、 350 个反例?而 T 则包含 150 个正例和 150 个反例；若 S、 T 中样本类别比例差别很大，则误差估计将由于训练/测试数据分布的差异 而产生偏差.</p></blockquote><p>在样本数量上的划分上，为了平衡模型的准确性与测试结果的保真性，常见做法是将大约 2/3～ 4/5 的样本用于训练，剩余样本用于测试（一般而言，测试集至少应含 30 个样例）。</p><h4 id="［2］交叉验证法（cross-validation）"><a href="#［2］交叉验证法（cross-validation）" class="headerlink" title="［2］交叉验证法（cross validation）"></a><strong>［2］交叉验证法（cross validation）</strong></h4><p>将数据集 $D $划 分为 $k $个互斥子集，即$D=D_1\cup D_2\cup ……\cup D_k$，$D_i\cap D_j=\empty $，每次用$k-1 $个子集的并集作为训练集，余下的那个子集作为测试集；对获得的 $k$组训练/测试集进行 $k$ 次训练和测试，得到这 $k$ 个测试结果的均值。</p><p>显然，交叉验证法评估结果的稳定性和保真性在很大程度上取决于 $k $的取值，为强调这一点，通常把交叉验证法称为 “$ k $折交叉验证” (k-fold cross validation). $k $最常用的取值是 10，此时称为 10 折交叉验 证；其他常用的$k$值有 5、 20 等.</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618155420458.png" alt="image-20220618155420458"></p><p>交叉验证法的一 个特例:留一法(Leave-One-Out，简称 LOO) . 假定数据集 $D$ 中包含 $m$ 个样本，令 $k=m$ ，即子集数量设定为样本数量。</p><blockquote><p>10次10 折交叉验证法与100 次留出法都是进行了 100 次训练/测试</p></blockquote><h4 id="［3］自助法（bootstrapping）"><a href="#［3］自助法（bootstrapping）" class="headerlink" title="［3］自助法（bootstrapping）"></a><strong>［3］自助法（bootstrapping）</strong></h4><p>每次从$D$中随机复制一个样本到$D1$中，重复$m$次，会得到一个拥有$m$个数据样本的$D1$数据集。显然，$D$中的一部分数据会多次出现在$D1$中，而另一部分样本不出现。根据平均分布概率计算，大约有36.8%的数据不会被复制到$D1$中。</p><p>可以做一个简单的估计，样本在 $m$ 次采样中始终不被采到的概率是 $(1-\frac{1}{m})^m$， 取极限得到$\lim_{m\to \infin}(1-\frac{1}{m})^m \to \frac{1}{e} \approx. 0.368$</p><p>于是我们可将$ D’ $用作训练集， $D/D’ $用作测试集；这样实际评估的模型与期望评估的模型都使用 $m $个训练样本，而我们仍有数据总量约 $1/3$ 的，没在训练集中出现的样本用于测试。这样的测试结果，亦称”包外估计” (out-of-bag estimate).</p><h4 id="［4］注意点"><a href="#［4］注意点" class="headerlink" title="［4］注意点"></a><strong>［4］注意点</strong></h4><p>训练/测试集的划分要尽可能保持数据分布一致性。</p><p>单次划分往往不够稳定可靠，一般要采用若干次随机划分、重复进行实验评估后取平均值作为评估结果。</p><p>训练/测试集的划分比例没有完美答案，训练样本多会使得模型更接近$D$，测试样本多会使得评估结果更可靠，这其中的取舍因人/场景而异。常见的训练/测试划分比例是2:1～4:1。</p><h4 id="［5］调参"><a href="#［5］调参" class="headerlink" title="［5］调参"></a><strong>［5］调参</strong></h4><p>不同的参数其实就代表着不同的模型了。一般参数分两种：一类是算法的参数，亦称“超参数”，如聚类要分的簇数量$k$；一类是模型的参数，如神经网络中每个节点的权重。前者多为人工选择一组候选，后者是让机器自己学习。</p><p>常用的做法是对每个参数选定一个范围和变化步长，<u>例如在 [0， 0.2] 范围内以 0.05 为步长，则实际要评估的候选参数值有 5 个，最终是从这 5 个候选值中产生选定值。简单估算一下：假定算法有 3 个参数，每个参数仅考虑 5 个候选 值，这样对每一组训练/测试集就有 53 = 125 个模型需考察；</u>很多强大的学习算 法有大量参数需设定，这将导致极大的调参工程量，例如大型”深度学习模型甚至有上百亿个参数。</p><p>调参是机器学习的重点，也是决定模型性能的关键。一般调参过程中，会将训练数据再次划分为训练集和验证集（validation set）。具体包含关系如下：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220619171542448.png" alt="image-20220619171542448"></p><h4 id="［6］适用性"><a href="#［6］适用性" class="headerlink" title="［6］适用性"></a><strong>［6］适用性</strong></h4><p>自助法在数据集较小、难以有效划分训练/测试集时很有用</p><p>自助法产生的数据集改变了初始数据集的分布，这会引入估计偏差。因此，在初始数据量足够时，留出法和交叉验证法更常用一些。</p><p>留出法和交叉验证法由于都把数据集中的一部分用来测试，没有参与训练，因此必然会引入一些因训练样本规模不同而导致的估计偏差，留一法受影响较小，但计算复杂度又太高了。</p><h3 id="2-3-性能度量"><a href="#2-3-性能度量" class="headerlink" title="2.3  性能度量"></a><strong>2.3 </strong> 性能度量</h3><p>——在了解了有效可行实验评估方法后，接下来我们需要了解一下具体的衡量模型泛化能力的评价标准，即性能度量（performance measure）</p><p>性能度量反映了任务需求，使用不同的性能度量会导致对模型的评判结果不同。这意味着模型的“好坏”是相对的，什么样的模型是好的，不仅取决于算法和数据，还决定于任务需求。</p><p>在预测任务中，给定样例集 $D = {(x1 , y1) , (x2 ， y2)， . . . , (xm, ym)} $， 其中 $yi$ 是示例 $xi$ 的真实标记。要评估学习器 $f$ 的性能，就要把学习器预测结果 $f(x)$  与真实标记  $y$ 进行比较。</p><p>回归任务<strong>最常用的性能度量</strong>是”<strong>均方误差</strong>“ (mean squared error)：</p><script type="math/tex; mode=display">E(f;D)=\frac{1}{m}\sum_{i=1}^{m}(f(xi)-yi)^2</script><p>更一般的，对于数据分布 $Ð$ 和概率密度函数 $p(.) $， 均方误差可描述为</p><script type="math/tex; mode=display">E(f;Ð)=\int_{x～Ð}(f(x)-y)^2p(x)dx</script><h4 id="2-3-1-错误率与精度"><a href="#2-3-1-错误率与精度" class="headerlink" title="2.3.1 错误率与精度"></a>2.3.1 错误率与精度</h4><p>对样例集 $D$，分类错误率定义为：</p><script type="math/tex; mode=display">E(f;D)=\frac{1}{m}\sum_{i=1}^{m}I(f(xi)\ne yi)</script><p>精度则定义为：</p><script type="math/tex; mode=display">acc(f;D)=\frac{1}{m}\sum_{i=1}^{m}I(f(xi)= yi)=1-E(f;D)</script><p>更一般的，对于数据分布 $Ð$ 和概率密度函数 $p(.)$ ，错误率与精度可分别描述为</p><script type="math/tex; mode=display">E(f;Ð)=\int_{x～Ð}(f(x)\ne y)p(x)dx</script><script type="math/tex; mode=display">acc(f;Ð)=\int_{x～Ð}(f(x)= y)p(x)dx=1-E(f;Ð)</script><h4 id="2-3-2-查准率、查全率与-F1"><a href="#2-3-2-查准率、查全率与-F1" class="headerlink" title="2.3.2 查准率、查全率与$F1$"></a>2.3.2 查准率、查全率与$F1$</h4><p>查准率和查全率可以理解为”挑出的西瓜中有多少比例是好瓜”，或者”所有好瓜中有多少比例被挑了出来”，或者”检索出的信息中有多少比例是用户感兴趣的” 和”用户感兴趣的信息中有多少被检索出来了”。</p><p>对于二分类问题，可将样例根据其真实类别与学习器预测类别的组合划分为真正例 (true positive) 、假正例 (false positive) 、真反例 (true negative) 、 假反例 (false negative) 四种情形，令 $TP、 FP、 TN、 FN$ 分别表示其对应的样例数，则显然有 $TP+FP+TN+FN=样例总数$。分类结果的误差矩阵或者精度矩阵称为”混淆矩阵” (confusion matrix)。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618175331853.png" alt="image-20220618175331853"></p><p>查准率 $P $ 与查全率 $R$ 分别定义为：</p><p>$P=\frac{TP}{TP+FP}$  =  真正例 / 预测出的正例</p><p>$R=\frac{TP}{TP+FN}$ =。真正例 / 实际上的正例</p><p>二者通常呈反比。</p><p>举个例子：假设有10个西瓜，6个好瓜，4个坏瓜。我们将这十个瓜按照预测结果排序，最可能是好瓜的排在前头，最不可能的排在最后，然后控制学习器的分类阀值来依次逐个把样本作为好瓜来进行预测，则可以计算出不同的阀值时的$P$和$R$如下表所示：</p><div class="table-container"><table><thead><tr><th>指标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>TP</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td></tr><tr><td>FN</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>FP</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>TN</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>P</td><td>X</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>6/7</td><td>6/8</td><td>6/9</td><td>6/10</td></tr><tr><td>R</td><td>0</td><td>1/6</td><td>2/6</td><td>3/6</td><td>4/6</td><td>5/6</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>由上边例子可以看到，P和R的值也基本满足了一方升高，另一方下降的状况，通常只有在一些简单的任务（比如我举的这个）中，才可能使查全率和查准率都很高。以查准率为纵轴、查全率为横轴作图，就得到了查准率－查全率曲线，简称“P-R曲线”。</p><p>再举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//20160721114615857-20220619182907525.png" alt="img"></p><p>Inst#是样本序号，图中有20个样本。Class是ground truth 标签，p是positive样本（正例），n当然就是negative（负例） score是分类器对于该样本属于正例的可能性的打分。因为一般模型输出的不是0,1的标注，而是小数，相当于置信度。</p><p>然后设置一个从高到低的阈值y，大于等于阈值y的被正式标注为正例，小于阈值y的被我正式标注为负例。</p><p>显然，设置n个阈值，就能得到n种标注结果，评判模型好不好使。</p><p>比如阈值0.9，只有第一个样本被判断为正例，那么我的查准率precision就是100%，但是查全率recall就是10%。阈值0.1，所有样本都被我判断为正例，查全率是100%，查准率就是50%</p><p>最后我能得到若干对precision，recall值(P,R) :  (1, 0.1),… ,(0.5,1),将这若干对画在图上，再连接起来就是这个pr曲线了。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//20160721111312507.png" alt="img"></p><p>在进行比较时，若一个学习器的P-R曲线被另一个学习器的曲线完全“包住”，则可断言后者的性能优于前者。当曲线有相交时，很难断言两者的优劣。真要判别时，“平衡点”（Break-Even Point）是一个不错的度量方法。下图是一个具体的示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618181148275.png" alt="image-20220618181148275"></p><p>平衡点(Break-Event Point，简称 BEP)，它是” 查准率=查全率”时的取值，例如上图中基于 BEP的比较，可认为学习器 A 优于 B。</p><p>但 BEP 还是过于简化了些，更常用的是 F1 度量：</p><script type="math/tex; mode=display">F1=\frac{2\times P\times R}{P+R}=\frac{2\times TP}{样例总数+TP-TN}</script><p>$F1$ 是基于查准率与查 全率的调和平均 (harinonic mean)定义的:</p><script type="math/tex; mode=display">\frac{1}{F1}=\frac{1}{2}.(\frac{1}{P}+\frac{1}{R})</script><p>在不同的条件下，对查准率和查全率的重视程度有所不同。比如在大数据推送时，为了少打扰用户，更希望能推荐用户感兴趣的广告，此时查准率要比查全率更重要；在追捕逃犯时，为了不漏掉逃犯，此时查全率比查准率更重要。为了表达出对查准率/查全率的不同偏好，定义了$F1 $度量的一般形式</p><script type="math/tex; mode=display">F_\beta=\frac{(1+\beta^2)\times P \times R}{(\beta^2 \times P)+R}</script><p>$ß&gt; 1$ 时查全率有更大影响 ; $ß &lt; 1$ 时查准率有更大影响。</p><p>很多时候我们有多个二分类混淆矩阵，例如进行多次训练/测试，每次得到一个混淆矩阵；或是在多个数据集上进行训练/测试，希望估计算法的”全局” 性能；甚或是执行多分类任务，每两两类别的组合都对应一个混淆矩阵，总之，我们希望在 $n$ 个二分类混淆矩阵上综合考察查准率和查全率。</p><p>一种直接的做法是先在各混淆矩阵上分别计算出查准率和查全率，记为 $(P_1， R_1 ) ， (P_2 ， R_2) ，…… ， (Pn ， Rn)$ ，再计算平均值，这样就得到”宏查准率” ($macro-P$) 、”宏查全率” ($macro-R$) ，以及相应的”宏 $F1$” ($macro-F1$):</p><script type="math/tex; mode=display">macro-P=\frac{1}{n}\sum^n_{i=1}P_i</script><script type="math/tex; mode=display">macro-R=\frac{1}{n}\sum^n_{i=1}R_i</script><script type="math/tex; mode=display">macro-F1=\frac{2\times macro-P \times macro-R}{macro-P+macro-R}</script><p>还可先将各混 淆矩阵的对应元素进行平均，得到 $TP 、FP 、 TN 、FN$ 的平均值，分别记为 $\overline{TP}、 \overline{FP}、 \overline{TN}、 \overline{FN}$，再基于这些平均值计算出”微查准率 “(micro-P) 、 “微查全率” (micro-R)和”微F1” (micro-F1):</p><script type="math/tex; mode=display">micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FP}}</script><script type="math/tex; mode=display">micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FN}}</script><script type="math/tex; mode=display">micro-F1=\frac{2\times micro-P\times micro-R}{micro-P+micro-R}</script><h4 id="2-3-3-ROC-与-AUC"><a href="#2-3-3-ROC-与-AUC" class="headerlink" title="2.3.3 ROC 与 AUC"></a>2.3.3 ROC 与 AUC</h4><p>ROC：“受试者工作特征”（receiver operating characteristic）曲线，与P-R 曲线类似，只不过取用“真正利率”（TPR ）作为纵轴，“假正例率”（FPR）作为横轴 ，两者分别定义为</p><script type="math/tex; mode=display">TPR=\frac{TP}{TP+FN},FPR=\frac{FP}{TN+FP}</script><p>显示 ROC 曲线的图称为 “ROC 图”，显然，对角线对应于 “随机猜测” 模型，而点 ($0，1)$ 则对应于将所有正例排在所有反例之前的”理想模型”。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220619155415423.png" alt="image-20220619155415423"></p><p>现实任务中测试样例有限 ，无法产生图 a 中的光滑 ROC 曲线，只能绘制出如图 b 所示的近似 ROC 曲线。绘图过程很简单：给定 $m^+ $个正例和$m^-$ 个反例，根据学习器预测结果对样例进行排序，然后把分类阈值设为最大，即把所有样例均预测为反例，此时真正例率和假正例率均为 0， 在坐标$ (0， 0)$ 处标记一个点。然后，将分类阈值依次设为每个样例的预测值，即依次将每个样例划分为正例。设前一个标记点坐标为 $(x， y) $， 当前若为真正例，则对应标记点的坐标为 $(x， y + \frac{1}{m^+})$ ;当前若为假正例，则对应标记点的坐标为 ($( x + \frac{1}{m^-},y)$ ，然后用线段连接相邻点即得。</p><p>​        进行学习器的比较时，与 P-R 图相似， 若一个学习器的 ROC 曲线被另 一个学习器的曲线完全”包住”， 则可断言后者的性能优于前者；若两个学习 器 的 ROC 曲线发生交叉，则难以一般性地断言两者孰优孰劣。此时如果一定要进行比较，则较为合理的判据是比较 ROC 曲线下的面积，即 AUC (Area Under ROC Curve) 。</p><p>​        从定义可知， AUC 可通过对 ROC 曲 线下各部分的面积求和而得,估算为</p><script type="math/tex; mode=display">AUC=\frac{1}{2}\sum^{m-1}_{i=1}(x_{i+1}-x_i).(y_i+y_{i+1})</script><h4 id="2-3-4-代价敏感错误率与代价曲线"><a href="#2-3-4-代价敏感错误率与代价曲线" class="headerlink" title="2.3.4 代价敏感错误率与代价曲线"></a>2.3.4 代价敏感错误率与代价曲线</h4><p>代价敏感错误率代表数据的平均总体代价。</p><p>不同类型的错误所造成的后果不同，为权衡不同类型错误所造成的不同损失，可为错误赋予”非均等代价” (unequa1 cost)。以二分类任务为例，我们可根据任务的领域知识设定一个”代价矩阵” (cost matrix) ，其中 $cost_{ij} $表示将第$ i $类样本预测为第 $j $类样本的代价。一般来说， $cost_{ii} = 0$；若将第 0 类判别为第 1 类所造成的损失更大，则 $cost_{01} &gt; cost_{10}$; 损失程度相差越大， $cost_{01} 与 cost_{10}$ 值的差别越大。</p><div class="table-container"><table><thead><tr><th style="text-align:center">真实</th><th style="text-align:center">预测</th><th style="text-align:center">类别</th><th></th></tr></thead><tbody><tr><td style="text-align:center">类别</td><td style="text-align:center">第0类</td><td style="text-align:center">第1类</td><td></td></tr><tr><td style="text-align:center">第0类</td><td style="text-align:center">0</td><td style="text-align:center">$cost_{01{}}$</td><td></td></tr><tr><td style="text-align:center">第1类</td><td style="text-align:center">$cost_{10}$</td><td style="text-align:center">0</td></tr></tbody></table></div><p>上面的例子中都隐式地假设了均等代价，所定义的错误率是直接计算错误次数。而在非均等代价下，我们所希望的不再是简单地最小化错误次数，而是希望最小化”总体代价” (total cost). 若将表中的第 0 类作为正类、第 1 类作为反类，令 $D^+$ 与 $D^-$分别代表样例集 D 的正例子集和反例子集，则”代价敏感” (cost-sensitive)错误率为</p><script type="math/tex; mode=display">E(f;D;cost)=\frac{1}{m}(\sum_{x_i\in D^+}I(f(x_i)\ne y_i)\times cost_{01}+\sum_{x_i\in D^-}I(f(x_i)\ne y_i)\times cost_{10})</script><p>在非均等代价下， ROC 曲线不能直接反映出学习器的期望总体代价，而”代价曲线” (cost curve) 则可达到该目的.代价曲线图的横轴是取值为 [0,1]的正例概率代价</p><script type="math/tex; mode=display">P(+)cost=\frac{p\times cost_{01}}{p\times cost_{01}+(1-p)\times cost_{10}}</script><p>其中 $p$ 是样例为正例的概率；纵轴是取值为 [0,1] 的归一化代价。</p><script type="math/tex; mode=display">P(+)cost=\frac{FNP\times p\times cost_{01}+FNP\times (1-p)\times cost_{10}}{p\times cost_{01}+(1-p)\times cost_{10}}</script><p>其中 $FPR$ 是假正例率， $FNR = 1 - TPR$ 是假反例率。</p><p>代价曲线的绘制很简单：ROC 曲线上每一点对应了代价平面上的一条线段 ， 设 ROC 曲线上点的坐标为 $(TPR， FPR)$ ，则可相应计算出 $FNR$，然后在代价平面上绘制 一条从 $(0， FPR)$ 到 $(1 ，FNR)$ 的线段，线段下的面积即表示了该条件下的期望总体代价；如此将 ROC 曲线上的每个点转化为代价平面上的一条线段，然后取所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220619191716330.png" alt="image-20220619191716330"></p><h3 id="2-4-比较检验"><a href="#2-4-比较检验" class="headerlink" title="2.4  比较检验"></a><strong>2.4 </strong> 比较检验</h3><p>——有了实验评估方法和性能度量，就要研究如何应用方法和度量指标去对学习器的性能进行评估比较了**</p><p>研究怎么来做“比较”是很有必要的，因为第一，我们要的是<strong>泛化性能</strong>，但是能用的只是测试性能；第二，测试性能和测试集的选择对测试结果有很大影响；第三，有的机器学习算法本身也有随机性，对同一测试集的多次测试结果也可能会不同。</p><p>为了解决这些问题，统计假设检验（hypothesis test）为我们提供了重要的依据。</p><h4 id="2-4-1-假设检验"><a href="#2-4-1-假设检验" class="headerlink" title="2.4.1 假设检验"></a>2.4.1 假设检验</h4><blockquote><p>西瓜书介绍的是假设检验方法，个人认为更好的方式应该是求泛化性能的置信区间，而不是进行假设检验。置信区间不仅可以得到泛化性能的一个区间，同时它也可以进行假设检验。所以，置信区间完全可以替换掉假设检验。</p><p>泛化性能的估计值 u=k/n，它是泛化性能p的一个无偏估计，E(u)=p，u的方差为 u<em>(1-u)/n，基于中心极限定理知道 u 渐进符合正态分布 N[p,u</em>(1-u)/n]。知道了u的抽样分布，u的置信区间就可以计算出来。</p><p><a href="https://zhuanlan.zhihu.com/p/259232881">如何计算置信区间</a></p></blockquote><p>假设检验中的“假设”是对学习器泛化错误率分布的某种猜想或判断，现实任务中学习器的泛化错误率不可知，只能获知其测试错误率，尽管二者未必相同，但肯定相似，因此， 可根据测试错误率估推出泛化错误率的分布。</p><p>然后通过假设的验证结果来对不同的学习器或模型的性能进行判断。比如假设“学习器A和B性能相同”，当该假设被拒绝时，说明学习器A和B具有显著差异，这时候错误率较低的学习器性能较优。</p><p>假设检验的具体逻辑和使用方法是这样的：</p><p>［1］设定一个假设，比如“一个机器学习真正的泛化错误率不大于0.3”</p><p>［2］设定一个置信概率“显著度a”，a的一般取值为0.05、0.1；a代表的意思是当我们的假设成立的概率在（1-a，1］的范围内时，我们认为是成立的。</p><p>［3］计算使假设在置信范围内成立的最大值是多少，比如根据上边［1］中的假设，要使泛化错误率不大于0.3成立，即泛化错误率小于0.3的概率大于（1-a）。要计算这个，我们要算出要使错误率大于0.3的概率之和小于a时的最大泛化错误率是多少。</p><p>［4］比较计算出的满足假设的最大值和我们实际计算出的值，如果我们实际计算出来的错误率已经大于最大可能的错误率了，说明假设不成立。</p><p>［5］在这里的假设中，假设不成立说明我们的学习器错误率要大于0.3啊，这是个很烂的学习器，我们还需要继续调优。</p><p>在实际实验时，我们会多次使用留出法或交叉验证法进行多次训练/测试，那么我们实际上会得到多个测试错误率（这里假设为$k$个）。我们可以通过求这些错误率的平均和方差来将假设检验转换为自由度为$k-1$的$ t $分布。通过查询 $t$ 检验常用临界表可以很方便的计算出假设是否成立。</p><p>书中提到的交叉验证 $t $检验、Friedman检验与Nemenyi后续检验都是基于一样的假设检验流程的稍微变化。其中交叉验证 $t$ 检验是针对两种学习器之间性能的比较，Friedman检验与Nemenyi后续检验是针对多个学习器之间性能的比较。在这里就不一一介绍了。</p><h3 id="2-5-偏差与方差"><a href="#2-5-偏差与方差" class="headerlink" title="2.5 偏差与方差"></a><strong>2.5 </strong>偏差与方差</h3><p>——对学习算法除了通过实验估计其泛化性能，我们还需要理解“为什么”具有这样的性能，“偏差与方差分解”（bias-variance decomposition）是解释学习算法泛化性能的一种重要工具。</p><p>省略具体的算法和公式推导过程，偏差与方差分解是对学习算法的期望泛化错误率的分解，分解结果是下边这个重要的公式</p><p>$E(f;D)=bias^2(x)+var(x)+\varepsilon^2$</p><p>也就是说，泛化误差可分解为偏差、方差与噪声之和。</p><p>其中，偏差度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法的拟合能力；方差度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所带来的影响；噪声则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。</p><p>偏差-方差分解说明，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。</p><p>一般来说，偏差与方差是有冲突的。要使偏差小则需要算法对数据充分拟合，这就有可能会导致过拟合，这样对新样本的适应性差，就会导致方差变高。反之亦然，拟合过低，偏差较大，但是方差会相对较低。</p><blockquote><p>很多学习算法都可控制训练程度，例如决策树可控制层数，神经网络可控制训练轮数，集成学习方法可控制基学习器个数。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220619224405067.png" alt="image-20220619224405067"></p><h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h3><p>泛化误差无法获得，经验误差因为过拟合的存在而不适合作为标准，导致我们需要专门的模型评估方法来测量学习器的效果。</p><p>专门的模型评估方法是通过从数据集中选取一部分数据作为测试集来对训练出的模型进行验证，以测试误差来近似泛化误差实现的。</p><p>测试误差体现在具体的性能度量指标上，我们要根据具体情况选择对应的指标。</p><p>假设检验是我们对学习器性能进行比较的有效方法。</p><p>泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。</p><p>通常来讲，更多的数据胜过更好的算法：对一批数据使用高明的算法，比不上用普通算法但是引入一部分外部数据源的效果要好。</p><p><a href="http://anand.typepad.com/datawocky/2008/03/more-data-usual.html">额外阅读</a></p><h3 id="2-7-习题"><a href="#2-7-习题" class="headerlink" title="2.7 习题"></a>2.7 习题</h3><h4 id="2-7-1"><a href="#2-7-1" class="headerlink" title="2.7.1"></a>2.7.1</h4><p><em>数据集包含 1000 个样本，其中 500 个正例、 500 个反例，将其划分为包含 70% 样本的训练集和 30% 样本的测试集用于留出法评估，试估算共有多少种划分方式。</em></p><p>500个正例和500个反例，根据分层抽样的原则，30%的测试样本共300个，其中必须包含150个正例和150个反例。若不考虑样本其他的分布情况，则选取方式为：从500个正例中随机抽取150个，再从500个反例中随机抽取150个，两个过程相互独立，则共有$(C_{500}^{150})^2$种方式。</p><h4 id="2-7-2"><a href="#2-7-2" class="headerlink" title="2.7.2"></a>2.7.2</h4><p><em>数据集包含 100 个样本，其中正、反例各一半，假定学习算法所产生的模型是将新样本预测为训练样本数较多的类别(训练样本数相同时进行随机猜测)，试给出用 10 折交叉验证法和留一法分别对错误率进行评估所得的结果。</em></p><p>10 折交叉验证法：将样本集划分为10个同分布不相交的子集，将其中9个作为训练集，1个作为测试集，每个划分可得到10次不同的训练和验证。对于题目所述的模型，总是将新样本预测为训练样本较多的类别，但每一次验证时，训练集的正例和反例一样多，将会进行随机猜测。每次都进行随即猜测，其错误率的期望是50%。</p><p>留一法：$k$折交叉验证中$k$等于样本个数的特例。在题目所述的情况下，即将100个样本每次取出1个样本用于测试，99个用于训练。当1个测试样本为正例时，99个训练样本为50个反例和49个正例，新样本将被预测为出现较多的反例，而测试样本的ground truth是正例，必然会预测错误。当测试样本为反例时同理必然会预测错误，此时错误率的期望为100%。</p><h4 id="2-7-3"><a href="#2-7-3" class="headerlink" title="2.7.3"></a>2.7.3</h4><p><em>若学习器 A 的 F1 值比学习器 B 高，试析 A 的 BEP 值是否也比 B 高。</em></p><p>F1：查准率P和查全率R的调和平均；</p><p>BEP：Beak-Even Point，P-R曲线上P = R时二者的取值。</p><p>F1和BEP有概念上的巨大差异，二者没有必然联系。P-R曲线的定义是：学习器将所有样本按“可能是正例”的概率从前向后排序，然后依次将前若干个样本按正例进行预测，所得出的预测结论。注意此时<u>BEP曲线只是衡量了学习器进行“排序”的性能，并不包含最终预测的结果。</u>也就是说，给定了P-R曲线的情况下，根据不同的预测策略，会产生不同的P和R。<u>而F1是一个确定的概念，是在P和R都确定的情况下计算出的二者的调和平均。</u>因此在同一P-R曲线上，F1在不同的位置有不同的取值。</p><p>因此对于题目所述的假设，我们很容易给出反例：对于R-P曲线完全相同的两个学习器，二者的P-R曲线上存在两个不同位置，使得对应的F1值不同。不妨设F1值较大的位置所对应的预测策略为学习器A，另一个为B，此时学习器A的F1值比学习器B高，但二者P-R曲线完全相同，也有相同的BEP值。</p><h4 id="2-7-4"><a href="#2-7-4" class="headerlink" title="2.7.4"></a>2.7.4</h4><p><em>试述真正例率(TPR) 、假正例率 (FPR)与查准率(P) 、查全率(R)之间的联系。</em></p><p>查全率: 真实正例被预测为正例的比例。<br>真正例率: 真实正例被预测为正例的比例。<br>显然查全率与真正例率是相等的。</p><p>查准率:预测为正例的实例中真实正例的比例。<br>假正例率: 真实反例被预测为正例的比例。<br>两者并没有直接的数值关系。</p><h4 id="2-7-5"><a href="#2-7-5" class="headerlink" title="*2.7.5"></a>*2.7.5</h4><p><em>试证明式(2.22).</em></p><p><a href="https://datawhalechina.github.io/pumpkin-book/#/chapter2/chapter2?id=_221">南瓜书中有证明，但同时，根据南瓜书的建议</a></p><blockquote><p>对于初学机器学习的小白，西瓜书第1章和第2章的公式<strong>强烈不建议深究</strong>，简单过一下即可，等你学得有点飘的时候再回来啃都来得及。</p></blockquote><h4 id="2-7-6"><a href="#2-7-6" class="headerlink" title="2.7.6"></a>2.7.6</h4><p><em>试述错误率与 ROC 曲线的联系。</em></p><p>ROC曲线本质上只反映学习器的“排序能力”，而具体的预测策略则取决于在ROC曲线上的哪一点作截断。当确定了一种预测策略时，才会对应一个确定的错误率。因此可以说，ROC曲线上的每一点，对应了学习器一种情况下的错误率。</p><h4 id="2-7-7"><a href="#2-7-7" class="headerlink" title="2.7.7"></a>2.7.7</h4><p><em>试证明任意一条 ROC 曲线都有一条代价曲线与之对应，反之亦然.</em></p><p>代价曲线、ROC曲线、P-R曲线都是为了描述某一学习器的“排序能力”而引入的概念。ROC曲线下方的面积仅能在“错误代价均等”的条件下反应学习器的排序质量，而在错误代价并不均等的情况下，引入代价矩阵后，应当使用代价曲线来反应考虑代价的排序质量。但不论使用哪一种曲线，衡量哪一种面积，一旦学习器给定，其排序质量是一定的，则三种曲线都是确定的。从这一角度来看，任意一条ROC曲线都对应了一个确定的学习器，而该学习器有唯一确定的代价曲线，反之亦然。</p><p>若要严格证明该结论，西瓜书给出了ROC曲线和代价曲线的转换方法：ROC曲线上每一点对应了代价平面上的一条线段，设ROC曲线上点的坐标为(FPR, TPR)，则可计算相应的FNR，然后再代价平面上绘制一条从(0, FPR)到(1, FNR)的线段，如此求出ROC曲线上所有点对应的线段，其下界围成的曲线即代价曲线。同理，在代价曲线上寻找一个连续的分段，将其线段计算出相应的FPR与FNR，再计算出TPR，即得到ROC曲线上的一个点，连接所有如此的到的点即得ROC曲线。</p><h4 id="2-7-8"><a href="#2-7-8" class="headerlink" title="2.7.8"></a>2.7.8</h4><p><em>Min-Max规范化与z-score规范化如下所示。试析二者的优缺点</em></p><p>Min−max规范化方法简单，而且保证规范化后所有元素都是正的，每当有新的元素进来，只有在该元素大于最大值或者小于最小值时才要重新计算全部元素。但是若存在一个极大(小)的元素，会导致其他元素变的非常小(大)。</p><p>z−score标准化对个别极端元素不敏感，且把所有元素分布在0的周围，一般情况下元素越多，0周围区间会分布大部分的元素，每当有新的元素进来，都要重新计算方差与均值。</p><h4 id="2-7-9"><a href="#2-7-9" class="headerlink" title="2.7.9"></a>2.7.9</h4><p><em>试述 χ2 检验过程.</em></p><p><a href="http://guoze.me/2015/09/07/chi-square/">参考链接</a></p><h4 id="2-7-10"><a href="#2-7-10" class="headerlink" title="2.7.10*"></a>2.7.10*</h4><p><em>试述在Friedman 检验中使用式 (2.34) 与 (2.35) 的区别.</em></p><p><a href="https://www.cnblogs.com/daigz1224/p/7163342.html">参考链接</a></p><h1 id="第-3-章-线性模型"><a href="#第-3-章-线性模型" class="headerlink" title="第 3 章 线性模型"></a>第 3 章 线性模型</h1><h3 id="章节主要内容-1"><a href="#章节主要内容-1" class="headerlink" title="章节主要内容"></a>章节主要内容</h3><p>线性模型形式简单、易于建模，许多功能更为强大的非线性模型可在线性模型的基础上通过引入层级结构或高维映射而得（神经网络就是一个例子，后边学习神经网络时会发现其实神经网络的每个神经元就是一个广义的线性模型）</p><p><a href="https://www.jianshu.com/p/04786709258b">思维导图</a></p><h4 id="3-1-基本形式"><a href="#3-1-基本形式" class="headerlink" title="3.1 基本形式"></a>3.1 基本形式</h4><p>——线性模型的背后逻辑以及变型思路</p><p>线性模型的本质是通过训练数据学习出一个通过样本数据的属性的线性组合来进行预测的函数。</p><p>线性模型具体是什么，简单来说和我们学过的线性函数是一样的，我们学过的线性函数形式一般为：$y = ax + b$，在这里$a，b$代表系数，也就是我们模型要学习的东西，代表的是属性，也就是我们的特征。</p><p>给定由 $d$ 个属性描述的示例$x=(x_1;x_2;……;x_d)$ ， 其中$x_i$是 $x$ 在第 $i$ 个属性上的取值，线性模型(linear model)试图学得一个通过属性的线性组合来进行预测的函数，即$f(x)=w_1x_1+w_2x_2+……+w_dx_d+b$ ，一般用向量形式写成$f(x)=w^Tx+b$ ，其中$w=(w_1;w_2;…;w_d)$ ，$w$ 和 $b$ 学得之后，模型就得以确定。</p><p>举一个例子，在西瓜样例中，</p><script type="math/tex; mode=display">f_{好瓜}(x)=0.2\times x_{色泽}+0.5\times x_{根蒂}+0.3\times x_{敲声}+1</script><p>其中0.2,0.5,0.3还有1 都是属于线性模型通过训练数据学到的系数，而其中的色泽，根蒂，敲声属于一个样本的各个特征，我们在本章中先从回归讲起，然后讨论二分类再讨论多分类问题。 </p><h4 id="3-2-线性回归"><a href="#3-2-线性回归" class="headerlink" title="3.2 线性回归"></a>3.2 线性回归</h4><p>——<strong>线性模型最基础的算法</strong></p><p>首先我们考虑最简单的问题，也就是只有一个输入属性的情况。</p><p>对离散属性，若属性值间存在”序” (order)关系，可通过连续化将其转化为连续值，例如二值属性”身高”的取值——“高” “矮”可转化为 {1.0,0.0}，三值属性”高度” 的取值”高” “中” “低”可转化为 {1.0, 0.5, 0.0}；若属性值间不存在序关 系，假定有 $k$ 个属性值，则通常转化为 $k$ 维向量，例如属性”瓜类”的取值”西瓜”、”南瓜”、”黄瓜”可转化为(0,0,1),(0,1,0),(1,0,0)。</p><p>线性回归试图学得$f(x_i)=wx_i+b$ ，使得$f(x_i)\approx y_i$ ，</p><p><u><em>如何确定 $ω$ 和 $b$ 呢？显然，关键在于如何衡量$ f(x) $与 $y$ 之间的差别。</em></u></p><p>这时候需要用到均方误差了，也就是我们常说的”欧式距离“，我们可以通过让均方误差最小化来求解需要的$w,b$。即</p><script type="math/tex; mode=display">(w^*,b^*)=arg\min_{(w,b)}\sum^m_{i=1}(f(x_i)-y_i)^2=arg\min_{(w,b)}\sum^m_{i=1}(y_i-wx_i-b)^2</script><p>求解$w$和$b$使所有样本到一条直线上的欧氏距离之和最小，称为线性回归模型的最小二乘”参数估计” (parameter estimation).。我们可将上式对 $ω $和 $b$ 分别求导，得到</p><script type="math/tex; mode=display">\frac{\partial{E_{w,b}}}{\partial w}=2(w\sum^m_{i=1}x_i^2-\sum^m_{i=1}x_i(y_i-b))</script><script type="math/tex; mode=display">\frac{\partial{E_{w,b}}}{\partial b}=2(mb-\sum^m_{i=1}(y_i-wx_i))</script><p>令导数等于0可得到$w$和$b$最优解的闭式解：</p><script type="math/tex; mode=display">w=\frac{\sum^m_{i=1}y_i(x_i-\overline{x})}{\sum^m_{i=1}x_i^2-\frac{1}{m}(\sum^m_{i=1}x_i)^2}</script><script type="math/tex; mode=display">b=\frac{1}{m}\sum^m_{i=1}(y_i-wx_i)</script><p>其中$\overline{x}=\frac{1}{m}\sum^m_{i=1}x_i$为 $x$ 的均值。</p><p>当我们的问题中存在的不止一个特征，我们称之为多元线性回归，形式与上述过程类似。<br>把$w,b$吸入向量模式，表示形式为$\hat{w}=(w;b)$，然后把数据集$D$表示为一个$m*(d+1)$的大小矩阵，前$d$行对应$d$个属性，最后一行元素置为$1$，即</p><script type="math/tex; mode=display">X=\left|    \begin{matrix}    x_{11} & x_{12} & \cdots & x_{1d} & 1\\    x_{21} & x_{22} & \cdots & x_{2d} & 1\\    \vdots & \vdots & \ddots & \vdots & \vdots\\    x_{m1} & x_{m2} & \cdots & x_{md} & 1 \\    \end{matrix}    \right|=\left|    \begin{matrix}    x_1^T &1\\    x_2^T &1\\    \vdots & \vdots\\    x_m^T &1\\    \end{matrix}    \right|</script><p>再把标记也写成向量形式$y=(y_1;y_2;…;y_m)$，则类似于单变量线性回归模型，有</p><script type="math/tex; mode=display">\hat{w}^*=argmin_{\hat{w}}(y-X\hat{w})^T{}(y-X\hat{w})</script><p>令$E_\hat{w}=(y-X\hat{w})^T{}(y-X\hat{w})$，对$\hat{w}$求导得到：</p><script type="math/tex; mode=display">\frac{\partial E_{\hat{w}}}{ \partial\hat w}=2X^T(X\hat w-y)</script><p>令上式为零可得 $\hat w$ 最优解的闭式解，但由于涉及矩阵逆的计算，比单变量情形要复杂一些，</p><p>下面说一下线性模型的变种，有时候我们的$y$和$x$之间不是线性变化，比如说y是跟随$x$呈现指数变化，这就导致了一个问题，$y=w<em>x+b$不能再表示他们之间的关系，那么这时候应该通过一个“<em>*联系函数</em></em>”，如上面我们举出来的例子，如果$y$和$wx+b$之间不再是线性而是指数变换，这是我们可以对$y$进行取对数操作</p><script type="math/tex; mode=display">ln y=w^Tx+b</script><p>这个取对的操作就相当于在原先的等式之间又加上了一个函数，这个函数我们就叫作联系函数，而我们把上面的式子叫做对数线性回归。<br> 我们再回味一下为什么这么做呢？因为$y$和$x$之间不再具有某种线性关系，取而代之的是一种指数关系，那我们怎么将这种指数关系表示出来呢？将$y$进行取对操作，这样$lny$又一次和$w*x+b$呈现一种线性关系，这实际上是一种空间映射。这就是”对数线性回归” (log-linear regression) ，它实际上是在试图让 $e^{w^Tx+ b} $ 逼近 $y$。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220620162127816.png" alt="image-20220620162127816"></p><p>如上图所示，这里的对数函数起到了将线性回归模型的预测值与真实标记联系起来的作用。</p><p>更一般地，考虑单调可微函数$ g(.) $， 令</p><script type="math/tex; mode=display">y=g^{-1}(w^Tx+b)</script><p>$g(.) $连续且充分光滑，这样得到的模型称为”广义线性模型” (generalized linear model) ，其中函数$g(.)$ 称为”联系函数” (link function).。显然?，对数线性回归是广义线性模型在$g(.) = ln(.) $时的特例.</p><h4 id="3-3-对数几率回归"><a href="#3-3-对数几率回归" class="headerlink" title="3.3 对数几率回归"></a>3.3 对数几率回归</h4><p>——<strong>线性回归函数的变型</strong></p><p>这里的对数几率回归是我们经常见到的一种算法：logistic回归，虽然它叫做回归算法，但实际上它是一种分类算法。</p><p>上一节说的是如何使用线性模型进行回归学习，但是如何利用线性模型进行分类算法呢？这时候就需要我们的联系函数，只要能找到一个函数可以将预测值与真实标签联系起来就可以。</p><p>考虑二分类任务，其输出标记$y$是[0，1]之中的一个，但是线性模型$w*x+b$预测出来是一个实际的值，我们应该把值转换成$0/1$，最理想的是”单位阶跃函数”</p><script type="math/tex; mode=display">y=\left\{\begin{array}{c}    0,z<0\\    0.5,z=0\\    1,z>0\end{array}\right.</script><p>即若预测值 $ z$ 大于零就判为正例，小于零则判为反例，预测值为临界值零则可任意判别，如图所示为单位阶跃函数与对数几率函数。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220620163011834.png" alt="image-20220620163011834"></p><p>从图中可看出单位阶跃函数并不连续，因此不能直接用作广义线性模型中的联系函数$g^-(.)$，于是我们用对数几率函数这种近似单位阶跃函数且单调可微的函数来作为其替代函数。</p><script type="math/tex; mode=display">y=\frac{1}{1+e^{-z}}</script><p>对数几率函数与对数函数是不同的，它是一种”Sigmod”函数，几率是什么意思呢？假设为正例的概率是$y$那么$y/1-y$就表示几率。</p><p>我们要时刻记住这个函数为什么出现在这里，他是为了将我们的输出转换成别的函数，这个对数几率函数将作为我们的<strong>联系函数</strong>。</p><p>我们将上一节讲的线性函数代入到对数几率函数中得到如下所示</p><script type="math/tex; mode=display">y=\frac{1}{1+e^{-(w^Tx+b)}}</script><p>进行变换之后我们将含$w$以及$b$的放在等式的一边，其余的放在另一边，如下所示</p><script type="math/tex; mode=display">ln\frac{y}{1-y}=w^Tx+b</script><p>由此可以看出，我们是在用线性回归模型的预测结果去逼近真实标记的对数几率(即几率的对数)，其中对数几率表示的是$x$做为正例的可能性。</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Labview</title>
    <link href="/2022/06/16/Labiew/"/>
    <url>/2022/06/16/Labiew/</url>
    
    <content type="html"><![CDATA[<h2 id="如何动态选择曲线可见性"><a href="#如何动态选择曲线可见性" class="headerlink" title="如何动态选择曲线可见性"></a>如何动态选择曲线可见性</h2><p>利用属性节点。首先找到属性节点，活动曲线。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//%20%20640-20220618100131554.jpeg" alt="图片"></p><p>首先给大家说明一下，LV里面，不管是列表框，还是表格，都会有一个活动单元格，活动曲线之类的。</p><p>你要操作某一个单元格或者曲线，首先你得让这个 单元格或者曲线变为活动单元格，然后才可以操纵活动单元格的属性。</p><p>所以，活动XX的，一定要在前面板中设置，不然你的属性，都是默认是对曲线0或者单元格0做的设置。</p><p>下面是用来设置曲线显示的方法，用了一个循环，集体设置属性。这个<u>最好放到一个事件结构里，避免反复轮询控件而降低程序使用效率</u>。</p><p><img src="Labiew.assets/640.png" alt="图片"></p><h2 id="错误簇的使用"><a href="#错误簇的使用" class="headerlink" title="错误簇的使用"></a>错误簇的使用</h2><p>错误簇其实就是一个簇，里面放了三个控件，一个布尔，一个代码，一个源。</p><p>按名称解绑簇 ，提取了错误簇里的 status元素。这个元素如果是真，表示有错误发生，可以用来停止while循环。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//640-20220617110331342.jpeg" alt="图片"></p><p>当然也有人利用错误簇强制vi执行顺序的，毕竟LabVIEW是数据流的编程。</p><p><strong>LabVIEW自带有一些函数是有错误，仍旧执行，可以通过查看帮助文档看相关介绍</strong></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//640-20220617110252573.jpeg" alt="图片"></p><h2 id="串口读取问题"><a href="#串口读取问题" class="headerlink" title="串口读取问题"></a>串口读取问题</h2><h4 id="用属性节点得到缓冲字节数"><a href="#用属性节点得到缓冲字节数" class="headerlink" title="用属性节点得到缓冲字节数"></a>用属性节点得到缓冲字节数</h4><p>读取缓冲区字节数这个“<strong>黄金组合</strong>”时，前面要加延时等待，等待仪器响应，等待缓冲区收到数据。如下图画圈地方所示。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//640-20220617115305652.jpeg" alt="图片"></p><h4 id="保证串口接收数据的完整性"><a href="#保证串口接收数据的完整性" class="headerlink" title="保证串口接收数据的完整性"></a>保证串口接收数据的完整性</h4><p>串口这块逻辑都是一样的，收到数据很容易，重点在于如何保证<strong>接收帧的完整性</strong>。</p><p>1，如何保证接收数据是正常接收的，这个可以在帧尾用校验码，累加求和，或者CRC校验。发送时候把校验码加在数据帧最后，解析时候在计算一下校验，对比下，不对则抛弃。</p><p>2，校验前，还是要获取一个正常排列的数据。比如接收10个字节，那么第一个字节帧头，确实是帧头，而不是错位的。有的就需要拼接了。</p><p>3，有些数据帧比较复杂，比如数据帧长度不一样，那要做的条件判断就很多了，需要一个一个解析。</p><p>建议采用两步读取的方法，第一次读取长度为1的数据。如果超时则忽略；如果不超时，延时一段时间再将所有数据读上来，然后再拼接上第一个字符。此方法最能保证传输完整性，相当于用第一个字符做硬触发。</p><h4 id="用串口助手可以正常发送接收，用LabVIEW编程却不能"><a href="#用串口助手可以正常发送接收，用LabVIEW编程却不能" class="headerlink" title="用串口助手可以正常发送接收，用LabVIEW编程却不能"></a>用串口助手可以<strong>正常发送接收</strong>，用LabVIEW编程却不能</h4><p>串口助手勾选了发送新行，LabVIEW没有对这个<strong>发送新行</strong>处理。</p><p>解决方法有好几种：</p><ol><li><p>最粗暴的，就是自己输入字符串控件里敲个回车。</p></li><li><p>正常点，在程序框图里，输入字符串控件后面，用连接字符串，默默地加上16进制的0D0A。也就是串口助手里的“发送新行”的功能。<strong>勾选“</strong>发送新行”时候，串口助手为我们默认都加了这两个字符。<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//640-20220617121224451.jpeg" alt="图片"></p></li><li><p>不想敲16进制的0D0A字符串也可以，字符串选板默认有一个常量，叫“行结束符常量”，用这个可以和0D0A一样的效果。<img src="Labiew.assets/640-20220617121301391.png" alt="图片"></p></li></ol><h4 id="高亮调试能收到数据，但是正常运行，就收不到数据"><a href="#高亮调试能收到数据，但是正常运行，就收不到数据" class="headerlink" title="高亮调试能收到数据，但是正常运行，就收不到数据"></a>高亮调试能收到数据，但是正常运行，就收不到数据</h4><p>这个问题最常见的解决方式，就是加<strong>等待延时</strong>，因为高亮执行时，写入缓冲区后，执行到读取缓冲区速度慢，这个时候缓冲区可以读取到数据。而正常执行，延时太短，缓冲区没有数据。可以把上述的100ms改大即可。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//640-20220617121650078.png" alt="图片"></p><p>当然，还有一个常见原因，就是程序读到数据了，但是一闪而过（以上这个程序只是举例，和真实案例有差距），因为这个程序字符串不能显示历史字符串。而串口助手都可以显示历史数据的。</p><h2 id="局部变量问题"><a href="#局部变量问题" class="headerlink" title="局部变量问题"></a>局部变量问题</h2><h4 id="情境一"><a href="#情境一" class="headerlink" title="情境一"></a>情境一</h4><p>TEST A的vi输出了一个结果Result A，然后给TEST B作为输入，但是TEST B的输入，却总是不对，导致TEST B计算有问题。</p><p><img src="Labiew.assets/640-20220617120217133.png" alt="图片"></p><p>以上程序中，看似Result A被TEST A赋值了。其实TEST B这个vi的输入值在整个程序一运行就执行了，数据流已经进入了TEST B的输入那儿。前面的A的vi输出并不会刷新后面B的输入。</p><p>估计有些初学者会说，上图用错误簇数据流限制了B 必须在A后面执行呀。是的，限制了。但是变量却无所谓的数据流限制，程序一运行就给B输入了。所以，一般建议大家规范编程，能用连线的尽量连线，局部变量除了上述问题外，还会存在其他问题。</p><h4 id="情境二"><a href="#情境二" class="headerlink" title="情境二"></a>情境二</h4><p><img src="Labiew.assets/640-20220617120616648.png" alt="图片"></p><p><img src="Labiew.assets/640-20220617120625395.png" alt="图片"></p><p>问题出在使用FOR解析读取的数据这儿。FOR有一个特性，输入是数组时候，可以不连接左上角的<strong>N</strong> 这个端子，FOR会自动按数组的大小执行对应次数。但是，这个VISA读取有时候串口读不到数据，是空的，那么这个FOR执行次数是0。</p><p>如果FOR执行次数是0，那么穿过FOR的连线，<strong>输出就会是默认值（一般是空）</strong>，也就是说，连线的数据，穿过了FOR后，数据无法传递给FOR后面的函数。所以，吃亏还是吃亏在了基础知识，但是很多人估计书本学习不会遇到，毕竟这个靠实际调试才会发现。</p><p>所以，如果要改程序，请用移位寄存器，稍微改一下就可以解决这个问题啦。如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//640-20220617120800417.png" alt="图片"></p><h2 id="Labview状态机的介绍与程序示例"><a href="#Labview状态机的介绍与程序示例" class="headerlink" title="Labview状态机的介绍与程序示例"></a>Labview状态机的介绍与程序示例</h2><h5 id="一、状态机简介"><a href="#一、状态机简介" class="headerlink" title="一、状态机简介"></a>一、状态机简介</h5><p>  状态机是在工程应用中使用最多的设计模型。使用状态机，我们可以很容易的实现程序流程图中的判断、分支。<br>  Labview状态机是由一个While循环、一个条件结构和一个移位寄存器组成的。其中while循环用来保证程序可以连续的运行；条件结构的各种分支中的代码用来描述状态机的各种状态，以及下一状态的选择；移位寄存器用来将之前状态所作出的选择传递到下一次循环的选择端子。</p><h5 id="二、状态机的基本框架"><a href="#二、状态机的基本框架" class="headerlink" title="二、状态机的基本框架"></a>二、状态机的基本框架</h5><p>  在程序框图中创建一个while循环，并在while循环上添加移位寄存器，然后再while循环内创建一个条件结构，条件结构的选择端是一个枚举常量，自定义枚举类型，保存后使用。</p><p><img src="Labiew.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><h5 id="三、例程"><a href="#三、例程" class="headerlink" title="三、例程"></a>三、例程</h5><p>按下开始按钮后，LED开始以输入的时间间隔闪烁，按下停止按钮，程序停止运行。</p><p><img src="Labiew.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70-20220617125048725.png" alt="在这里插入图片描述"></p><h6 id="程序框图"><a href="#程序框图" class="headerlink" title="程序框图"></a>程序框图</h6><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70-20220617125109791.png" alt="在这里插入图片描述"></p><p><img src="Labiew.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70-20220617125123967.png" alt="在这里插入图片描述"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SGFsZi1BIFN0dWRpbw==,size_16,color_FFFFFF,t_70-20220617125130498.png" alt="在这里插入图片描述"></p><p><strong>枚举类型的分支情况如下：</strong><br>  设置三项分别为：“开始”、“亮”、灭。然后在条件结构的分支处，<strong>右键-为每个值添加分支</strong><br>  其中左侧初始值与”开始“分支内的都是同一个枚举常量（即通过复制粘贴得到的）。</p><h6 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h6><p>初始条件的输入值为“开始”，进入“开始”的条件分支进行判断。</p><p>如果按钮按下，输出“亮”，并作为下一次条件的输入；<br>如果按钮未按下，输出“开始”，并作为下一次条件的输入，即保持原状态。<br>如果条件的输入为“亮”，此时条件输出“灭”，并作为下一次的输入。</p><p>如果条件的输入为“灭”，此时条件输出“亮”，并作为下一次的输入。</p><p>在“开始”和“灭”分支进行期间，为LED赋值False；在“亮”分支期间，为LED赋值True。</p><p>这样就实现了：启动程序后，程序一直循环执行“开始”分支，LED灯灭。按下按钮后，程序在“亮”分支和”灭“分支交替执行，实现LED灯的亮灭变化。</p><p>可以通过为while循环添加等待延时调整LED闪烁时间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>陈师兄的项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建Hexo博客</title>
    <link href="/2022/06/16/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/06/16/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo-GitHub-文章发布原理"><a href="#Hexo-GitHub-文章发布原理" class="headerlink" title="Hexo + GitHub 文章发布原理"></a>Hexo + GitHub 文章发布原理</h2><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a56bynskj20k909naaw.jpg" alt="image-20220616123316035"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a530lrdgj20qk0m5gol.jpg" alt="image-20220616112321010"></p><h2 id="step0-配置环境"><a href="#step0-配置环境" class="headerlink" title="step0.配置环境"></a>step0.配置环境</h2><p>Git</p><p>Node.js</p><p>step1.github上建立仓库</p><p><em>仓库名称和注册名一致</em></p><h2 id="step2-生成SSH-Keys"><a href="#step2-生成SSH-Keys" class="headerlink" title="step2.生成SSH Keys"></a><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a53aguqmj212f0j40vl.jpg" alt="image-20220616113621975">step2.生成SSH Keys</h2><p>在任意文件夹下进入Git Bash，输入ssh检测是否已经安装ssh</p><p>输入<code>ssh-keygen -t rsa -C &quot;注册GitHub用的邮箱&quot;</code></p><p>敲四次回车</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a53j6kxhj20tf0axq42.jpg" alt="image-20220616113950805">在以下文件夹中获得刚生成的密钥，pub里是公钥，复制公钥</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a53qm5b8j20so05o74j.jpg" alt="image-20220616114046868">在GitHub中粘贴</p><p>测试ssh是否绑定成功，<code>ssh -T git@github.com</code></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a54si3wlj20l201lt8q.jpg" alt="image-20220616121224727"></p><p>绑定成功</p><h2 id="step3-本地生成博客内容"><a href="#step3-本地生成博客内容" class="headerlink" title="step3.本地生成博客内容"></a>step3.本地生成博客内容</h2><p>新建文件夹Blog</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">npm install -g hexo-cli #安装hexo，Mac用户需要加sudo<br><br>hexo init #已安装过需要初始化<br><br>hexo g #生成<br><br>hexo s #启动服务，打开本地服务器<br></code></pre></td></tr></table></figure><h2 id="step4-发布博客到互联网"><a href="#step4-发布博客到互联网" class="headerlink" title="step4.发布博客到互联网"></a>step4.发布博客到互联网</h2><p>Hexo 博客文件夹目录结构如下：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a555r2doj21130793z4.jpg" alt="image-20220616122404265"></p><p>打开博客配置文件，做出如下修改</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a55jpj2ij20y305oq35.jpg" alt="image-20220616122503416"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">deploy:<br>  type: git<br>  repository: https://github.com/moyudexiaosong/moyudexiaosong.github.io<br>  branch: main<br></code></pre></td></tr></table></figure><p><code>npm install hexo-deployer-git --save #安装上传工具</code></p><p><code>hexo d</code> #上传互联网</p><p>第一次要输入注册名和密码，密码（令牌）</p><p>上传成功，找到网址</p><p>查看当前git用户名和邮箱</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">git config user.name<br>git config user.email<br></code></pre></td></tr></table></figure><p>修改</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">git config --global user.name &quot;zhangsan(新的用户名)&quot;<br>git config --global user.email &quot;123456@qq.com(新的邮箱)&quot;<br>git config --global user.password &quot;123456(新的密码)&quot;<br><span class="hljs-params">#</span> 这里的zhangsan和邮箱都是你修改之后的用户名和邮箱<br></code></pre></td></tr></table></figure><p>step4.安装主题</p><p><code>npm install --save hexo-theme-fluid</code></p><p>然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。</p><p>将_config.yml下的theme的值landscape修改为fluid，这样才能使用到主题fluids</p><h2 id="step5-hexo基本配置"><a href="#step5-hexo基本配置" class="headerlink" title="step5.hexo基本配置"></a>step5.hexo基本配置</h2><p>在文件根目录下的<code>_config.yml</code>，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考<a href="https://hexo.io/zh-cn/docs/configuration">官方的配置</a>描述。</p><h5 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h5><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>title</code></td><td style="text-align:center">网站标题</td></tr><tr><td style="text-align:center"><code>subtitle</code></td><td style="text-align:center">网站副标题</td></tr><tr><td style="text-align:center"><code>description</code></td><td style="text-align:center">网站描述</td></tr><tr><td style="text-align:center"><code>author</code></td><td style="text-align:center">您的名字</td></tr><tr><td style="text-align:center"><code>language</code></td><td style="text-align:center">网站使用的语言</td></tr><tr><td style="text-align:center"><code>timezone</code></td><td style="text-align:center">网站时区。Hexo 默认使用您电脑的时区。<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</td></tr></tbody></table></div><p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p><h6 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><h5 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h5><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">title: Hello World<br>date: 2013/7/13 20:46:25<br>---<br></code></pre></td></tr></table></figure><p>下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>layout</code></td><td style="text-align:center">布局</td></tr><tr><td style="text-align:center"><code>title</code></td><td style="text-align:center">标题</td></tr><tr><td style="text-align:center"><code>date</code></td><td style="text-align:center">建立日期</td></tr><tr><td style="text-align:center"><code>updated</code></td><td style="text-align:center">更新日期</td></tr><tr><td style="text-align:center"><code>comments</code></td><td style="text-align:center">开启文章的评论功能</td></tr><tr><td style="text-align:center"><code>tags</code></td><td style="text-align:center">标签（不适用于分页）</td></tr><tr><td style="text-align:center"><code>categories</code></td><td style="text-align:center">分类（不适用于分页）</td></tr><tr><td style="text-align:center"><code>permalink</code></td><td style="text-align:center">覆盖文章网址</td></tr></tbody></table></div><h6 id="layout（布局）"><a href="#layout（布局）" class="headerlink" title="layout（布局）"></a>layout（布局）</h6><p>当你每一次使用代码</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo new paper<br></code></pre></td></tr></table></figure><p>它其实默认使用的是<code>post</code>这个布局，也就是在<code>source</code>文件夹下的<code>_post</code>里面。</p><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>，它们分别对应不同的路径，而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><div class="table-container"><table><thead><tr><th style="text-align:center">布局</th><th style="text-align:center">路径</th></tr></thead><tbody><tr><td style="text-align:center"><code>post</code></td><td style="text-align:center"><code>source/_posts</code></td></tr><tr><td style="text-align:center"><code>page</code></td><td style="text-align:center"><code>source</code></td></tr><tr><td style="text-align:center"><code>draft</code></td><td style="text-align:center"><code>source/_drafts</code></td></tr></tbody></table></div><p>而new这个命令其实是：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo new [layout] &lt;title&gt; <span class="hljs-params">#</span>这个layout默认是post<br></code></pre></td></tr></table></figure><h6 id="page"><a href="#page" class="headerlink" title="page"></a>page</h6><p>如果你想另起一页，那么可以使用</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo new page board<br></code></pre></td></tr></table></figure><p>系统会自动给你在source文件夹下创建一个board文件夹，以及board文件夹中的index.md.</p><h6 id="draft"><a href="#draft" class="headerlink" title="draft"></a>draft</h6><p>draft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo new draft newpage<br></code></pre></td></tr></table></figure><p>如果你的草稿文件写的过程中，想要预览一下，那么可以使用</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo server --draft<br></code></pre></td></tr></table></figure><p>在本地端口中开启服务预览。</p><p>如果你的草稿文件写完了，想要发表到post中，</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo publish draft newpage<br></code></pre></td></tr></table></figure><p>就会自动把newpage.md发送到post中。</p><h2 id="Step6-Live2D看板娘"><a href="#Step6-Live2D看板娘" class="headerlink" title="Step6.Live2D看板娘"></a>Step6.Live2D看板娘</h2><p>安装插件</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-helper-live2d</span><br></code></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 是否启动</span><br>  <span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">local</span> <span class="hljs-comment"># 默认</span><br>  <span class="hljs-attr">pluginRootPath:</span> <span class="hljs-string">live2dw/</span>  <span class="hljs-comment"># 插件在站点上的根目录(相对路径)</span><br>  <span class="hljs-attr">pluginJsPath:</span> <span class="hljs-string">lib/</span>  <span class="hljs-comment"># 脚本文件相对与插件根目录路径</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span>  <span class="hljs-comment"># 模型文件相对与插件根目录路径</span><br>  <span class="hljs-attr">tagMode:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br>  <span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 调试, 是否在控制台输出日志</span><br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget</span>  <span class="hljs-comment"># 模型文件</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span> <span class="hljs-comment"># 定位方向 left right top bottom</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">150</span>  <span class="hljs-comment"># 小人宽度</span><br>    <span class="hljs-attr">height:</span> <span class="hljs-number">300</span> <span class="hljs-comment"># 小人高度</span><br>    <span class="hljs-attr">hOffset:</span> <span class="hljs-number">-15</span>  <span class="hljs-comment"># 水平偏移</span><br>    <span class="hljs-attr">vOffset:</span> <span class="hljs-number">-15</span>  <span class="hljs-comment"># 垂直偏移</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 手机端是否显示</span><br>  <span class="hljs-attr">react:</span><br>    <span class="hljs-attr">opacity:</span> <span class="hljs-number">0.7</span>  <span class="hljs-comment"># 模型透明度</span><br></code></pre></td></tr></table></figure><p>选择人物</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs gams">live2d-widget-<span class="hljs-keyword">model</span>-chitose<br>live2d-widget-<span class="hljs-keyword">model</span>-epsilon2_1<br>live2d-widget-<span class="hljs-keyword">model</span>-gf<br>live2d-widget-<span class="hljs-keyword">model</span>-haru/<span class="hljs-number">01</span> (use npm install --save live2d-widget-<span class="hljs-keyword">model</span>-haru)<br>live2d-widget-<span class="hljs-keyword">model</span>-haru/<span class="hljs-number">02</span> (use npm install --save live2d-widget-<span class="hljs-keyword">model</span>-haru)<br>live2d-widget-<span class="hljs-keyword">model</span>-haruto<br>live2d-widget-<span class="hljs-keyword">model</span>-hibiki<br>live2d-widget-<span class="hljs-keyword">model</span>-hijiki<br>live2d-widget-<span class="hljs-keyword">model</span>-izumi<br>live2d-widget-<span class="hljs-keyword">model</span>-koharu<br>live2d-widget-<span class="hljs-keyword">model</span>-miku<br>live2d-widget-<span class="hljs-keyword">model</span>-ni-j<br>live2d-widget-<span class="hljs-keyword">model</span>-nico<br>live2d-widget-<span class="hljs-keyword">model</span>-nietzsche<br>live2d-widget-<span class="hljs-keyword">model</span>-nipsilon<br>live2d-widget-<span class="hljs-keyword">model</span>-nito<br>live2d-widget-<span class="hljs-keyword">model</span>-shizuku<br>live2d-widget-<span class="hljs-keyword">model</span>-tororo<br>live2d-widget-<span class="hljs-keyword">model</span>-tsumiki<br>live2d-widget-<span class="hljs-keyword">model</span>-unitychan<br>live2d-widget-<span class="hljs-keyword">model</span>-wanko<br>live2d-widget-<span class="hljs-keyword">model</span>-z16<br></code></pre></td></tr></table></figure><p>进行安装</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save 上面对应的代码</span><br></code></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">model:</span><br><span class="hljs-symbol">    use:</span> live2d-widget  <span class="hljs-meta">## 选择的模型文件</span><br></code></pre></td></tr></table></figure><h2 id="Step7-设置图床"><a href="#Step7-设置图床" class="headerlink" title="Step7.设置图床"></a>Step7.设置图床</h2><h6 id="创建-GitHub-仓库"><a href="#创建-GitHub-仓库" class="headerlink" title="创建 GitHub 仓库"></a>创建 GitHub 仓库</h6><h6 id="使用-jsDelivr-进行-CDN-加速"><a href="#使用-jsDelivr-进行-CDN-加速" class="headerlink" title="使用 jsDelivr 进行 CDN 加速"></a>使用 jsDelivr 进行 CDN 加速</h6><h6 id="使用PicGo上传图片"><a href="#使用PicGo上传图片" class="headerlink" title="使用PicGo上传图片"></a>使用PicGo上传图片</h6><h6 id="Typora-配置-PicGo-上传"><a href="#Typora-配置-PicGo-上传" class="headerlink" title="Typora 配置 PicGo 上传"></a>Typora 配置 PicGo 上传</h6><ul><li><p>打开 PicGo 软件，找到<code>图床设置</code>中的<code>GitHub图床</code>，填写相关信息。</p></li><li><ul><li><strong>设定仓库名【必填】</strong>：填写<code>你的用户名/你的仓库名</code>，比如我的 yifeng-talking/pictures</li><li><strong>设定分支名【必填】</strong>：填写<code>main</code></li><li><strong>设定Token【必填】</strong>：在Github主页点击自己头像后，依次选择【Settings】-&gt;【Developer settings】-&gt;【Personal access tokens】-&gt;【Generate new token】，填写Note描述（随便），设置过期时间Expiration为永不过期No expiration，设定勾选【repo】，然后点击下方的【Generate token】生成一个Token，这个Token只会显示一次，自行保存，然后复制到 PicGo 中。</li><li>指定存储路径【选填】：填写图片要存储的路径，比如填【images/】，这样就会在仓库下创建一个名为 images 的文件夹，图片将会储存在此文件夹中，这里不填。</li><li><strong>设定自定义域名【选填】</strong>：图片上传后，PicGo 会按照【自定义域名+上传的图片名】的方式生成访问链接，放到剪贴板上，因为我们要使用 jsDeliver 进行加速，因而这里设置为<code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名</code>，比如我设置为<strong><a href="https://cdn.jsdelivr.net/gh/yifeng-talking/pictures">https://cdn.jsdelivr.net/gh/yifeng-talking/pictures</a></strong></li></ul></li><li><ul><li>打开 Typera，点击【文件】 -&gt; 【偏好设置】-&gt; 【图像】，然后进行如下配置，其中 PicGo 路径是你的 PicGo 的安装路径。</li></ul></li></ul><p>Step8.设置内联公式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-kramed --save<br></code></pre></td></tr></table></figure><p>更换Hexo的markdown渲染引擎，<a href="https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fsun11%2Fhexo-renderer-kramed">hexo-renderer-kramed</a>引擎是在默认的渲染引擎<a href="https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fhexojs%2Fhexo-renderer-marked">hexo-renderer-marked</a>的基础上修改了一些bug，两者比较接近，也比较轻量级。</p><p>执行上面的命令，先卸载原来的渲染引擎，再安装新的。</p><p>然后，跟换引擎后行间公式可以正确渲染了，但是这样还没有完全解决问题，行内公式的渲染还是有问题，因为<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fsun11%2Fhexo-renderer-kramed">hexo-renderer-kramed</a>引擎也有语义冲突的问题。接下来到博客根目录下，找到node_modules\kramed\lib\rules\inline.js，把第11行的escape变量的值做相应的修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br>  <span class="hljs-attr">escape</span>: <span class="hljs-regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span><br></code></pre></td></tr></table></figure><p>这一步是在原基础上取消了对\,{,}的转义(escape)。<br>同时把第20行的em变量也要做相应的修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*[\s\S])+?)\*(?!\*)/,</span><br>  <span class="hljs-attr">em</span>: <span class="hljs-regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span><br></code></pre></td></tr></table></figure><p>如果已经开启主题，需要先修改配置文件，再在文章的Front-matter里打开math开关，如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">math</span>: <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029?utm_source=app&amp;app_version=5.5.0">hexo史上最全搭建教程</a></p><p><a href="https://zhuanlan.zhihu.com/p/60578464#:~:text=%E4%BD%BF%E7%94%A8%20Hexo%2BGitHub%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89%201%20%E5%87%86%E5%A4%87%202%20%E8%BF%9E%E6%8E%A5%20Github....,Hexo%20%E5%88%B0%20GitHub%20Pages%206%20%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89....%207%20%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8">使用 Hexo+GitHub 搭建个人免费博客教程</a></p><p><a href="https://baijiahao.baidu.com/s?id=1710047962336524256&amp;wfr=spider&amp;for=pc">高速稳定图床</a></p><p><a href="https://www.jianshu.com/p/7ab21c7f0674">在Hexo中渲染MathJax数学公式</a></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarDown使用教程</title>
    <link href="/2022/06/16/MarkDown%E6%95%99%E7%A8%8B/"/>
    <url>/2022/06/16/MarkDown%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="MarkDown基础"><a href="#MarkDown基础" class="headerlink" title="MarkDown基础"></a>MarkDown基础</h1><p><a href="https://www.bilibili.com/video/av87982836#reply2366896129">基础篇视频讲解链接</a><br><a href="https://www.bilibili.com/video/av88551739/">画图篇视频讲解链接</a></p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 标题名字（井号的个数代表标题的级数）</span><br></code></pre></td></tr></table></figure><p>快捷键（<strong>⌘ + 数字</strong>）</p><h1 id="一级标题使用1个"><a href="#一级标题使用1个" class="headerlink" title="一级标题使用1个"></a>一级标题使用1个</h1><h2 id="二级标题使用2个"><a href="#二级标题使用2个" class="headerlink" title="二级标题使用2个"></a>二级标题使用2个</h2><h3 id="三级标题使用3个"><a href="#三级标题使用3个" class="headerlink" title="三级标题使用3个"></a>三级标题使用3个</h3><h4 id="四级标题使4用个"><a href="#四级标题使4用个" class="headerlink" title="四级标题使4用个"></a>四级标题使4用个</h4><h5 id="五级标题使用5个"><a href="#五级标题使用5个" class="headerlink" title="五级标题使用5个"></a>五级标题使用5个</h5><h6 id="六级标题使用6个"><a href="#六级标题使用6个" class="headerlink" title="六级标题使用6个"></a>六级标题使用6个</h6><h6 id="最多支持六级标题"><a href="#最多支持六级标题" class="headerlink" title="# 最多支持六级标题"></a># 最多支持六级标题</h6><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><h3 id="删除线（-⇧-）"><a href="#删除线（-⇧-）" class="headerlink" title="删除线（^ + ⇧ + `）"></a>删除线<strong>（^ + ⇧ + `）</strong></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这就是 ~~删除线~~ (使用波浪号)<br></code></pre></td></tr></table></figure><p>这就是 <del>删除线</del> (使用波浪号)</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 <span class="hljs-emphasis">*斜体*</span> 的 <span class="hljs-emphasis">_文本_</span><br></code></pre></td></tr></table></figure><p>这是用来 <em>斜体</em> 的 _文本_</p><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 <span class="hljs-strong">**加粗**</span> 的 <span class="hljs-strong">__文本__</span><br></code></pre></td></tr></table></figure><p>这是用来 <strong>加粗</strong> 的 <strong>文本</strong></p><h3 id="斜体-加粗（加粗⌘-b-斜体⌘-i）"><a href="#斜体-加粗（加粗⌘-b-斜体⌘-i）" class="headerlink" title="斜体+加粗（加粗⌘+b, 斜体⌘+i）"></a>斜体+加粗<strong>（加粗⌘+b, 斜体⌘+i）</strong></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 <span class="hljs-strong">**<span class="hljs-emphasis">*斜体+加粗*</span>**</span> 的 <span class="hljs-strong">__<span class="hljs-emphasis">_文本_</span>__</span><br></code></pre></td></tr></table></figure><p>这是用来 <strong><em>斜体+加粗</em></strong> 的 <strong>_文本_</strong></p><h3 id="下划线（⌘-u）"><a href="#下划线（⌘-u）" class="headerlink" title="下划线（⌘ + u）"></a>下划线<strong>（⌘ + u）</strong></h3><p>下划线是HTML语法</p><p><code>下划线</code> <u>下划线(快捷键<code>command</code>+<code>u</code>，视频中所有的快捷键都是针对Mac系统，其他系统可自行查找)</u></p><h3 id="高亮（需勾选扩展语法）"><a href="#高亮（需勾选扩展语法）" class="headerlink" title="高亮（需勾选扩展语法）"></a>高亮（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 ==斜体+加粗== 的文本<br></code></pre></td></tr></table></figure><p>这是用来 ==斜体+加粗== 的文本</p><h3 id="下标（需勾选扩展语法）"><a href="#下标（需勾选扩展语法）" class="headerlink" title="下标（需勾选扩展语法）"></a>下标（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">水 H~2~O <br>双氧水 H~2~O~2~ <br></code></pre></td></tr></table></figure><p>水 H~2~O </p><p>双氧水 H~2~O~2~</p><h3 id="上标（需勾选扩展语法）"><a href="#上标（需勾选扩展语法）" class="headerlink" title="上标（需勾选扩展语法）"></a>上标（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">面积 m^2^ <br>体积 m^3^<br></code></pre></td></tr></table></figure><p>面积 m^2^<br>体积 m^3^</p><h3 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h3><p> Emoji 支持表情符号，你可以用系统默认的 Emoji 符号（ Windows 用户不一定支持，自己试下~）。 也可以用图片的表情，输入 <code>:</code> 将会出现智能提示。  </p><h4 id="一些表情例子"><a href="#一些表情例子" class="headerlink" title="一些表情例子"></a>一些表情例子</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">:smile: :laughing: :dizzy<span class="hljs-emphasis">_face: :sob: :cold_</span>sweat: :sweat<span class="hljs-emphasis">_smile:  :cry: :triumph: :heart_</span>eyes: :relaxed: :sunglasses: :weary:<br><br>:+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat<span class="hljs-emphasis">_drops: :hankey: :exclamation: :anger:</span><br><span class="hljs-emphasis"></span><br></code></pre></td></tr></table></figure><p>:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile:  :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary: :+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger:</p><p>(  Mac: <code>control</code>+<code>command</code>+<code>space</code>点选)</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><h2 id="快速生成表格（⌘-⌥-T）"><a href="#快速生成表格（⌘-⌥-T）" class="headerlink" title="快速生成表格（⌘ + ⌥ + T）"></a><strong>快速生成表格（⌘ + ⌥ + T）</strong></h2><h2 id="按行选中（⌘-l）"><a href="#按行选中（⌘-l）" class="headerlink" title="按行选中（⌘ + l）"></a><strong>按行选中（⌘ + l）</strong></h2><p>使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">name | price<br>--- | ---<br>fried chicken | 19<br>cola|5<br></code></pre></td></tr></table></figure><blockquote><p>为了使 Markdown 更清晰，<code>|</code> 和 <code>-</code> 两侧需要至少有一个空格（最左侧和最右侧的 <code>|</code> 外就不需要了）。</p></blockquote><div class="table-container"><table><thead><tr><th>name</th><th>price</th></tr></thead><tbody><tr><td>fried chicken</td><td>19</td></tr><tr><td>cola</td><td>5</td></tr></tbody></table></div><p>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 <code>|</code> 来标记单元格边界，在表头下方的分隔线标记中加入 <code>:</code>，即可标记下方单元格内容的对齐方式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">|    name       | price |<br>| :------------ | :---: |<br>| fried chicken | 19    |<br>| cola          |  32   |<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">name</th><th style="text-align:center">price</th></tr></thead><tbody><tr><td style="text-align:left">fried chicken</td><td style="text-align:center">19</td></tr><tr><td style="text-align:left">cola</td><td style="text-align:center">32</td></tr></tbody></table></div><p>使用快捷键<code>command</code>+<code>opt</code>+<code>T</code>更方便(段落→表格→插入表格，即可查看快捷键)</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;“后悔创业”<br></code></pre></td></tr></table></figure><blockquote><p>“后悔创业”</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;也可以在引用中<br>&gt;&gt;使用嵌套的引用<br></code></pre></td></tr></table></figure><blockquote><p>也可以在引用中</p><blockquote><p>使用嵌套的引用</p></blockquote></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表—符号-空格（⌥-⌘-u）"><a href="#无序列表—符号-空格（⌥-⌘-u）" class="headerlink" title="无序列表—符号 空格（⌥ + ⌘ + u）"></a>无序列表—符号 空格<strong>（⌥ + ⌘ + u）</strong></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 可以使用 <span class="hljs-code">`*`</span> 作为标记<br><span class="hljs-bullet">+</span> 也可以使用 <span class="hljs-code">`+`</span><br><span class="hljs-bullet">-</span> 或者 <span class="hljs-code">`-`</span><br></code></pre></td></tr></table></figure><ul><li>可以使用 <code>*</code> 作为标记</li></ul><ul><li>也可以使用 <code>+</code></li></ul><ul><li>或者 <code>-</code></li></ul><h3 id="有序列表—数字-空格（⌥-⌘-o）"><a href="#有序列表—数字-空格（⌥-⌘-o）" class="headerlink" title="有序列表—数字 . 空格（⌥ + ⌘ + o）"></a>有序列表—数字 <code>.</code> 空格<strong>（⌥ + ⌘ + o）</strong></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 有序列表以数字和 <span class="hljs-code">`.`</span> 开始；<br><span class="hljs-bullet">3.</span> 数字的序列并不会影响生成的列表序列；<br><span class="hljs-bullet">4.</span> 但仍然推荐按照自然顺序（1.2.3...）编写。<br></code></pre></td></tr></table></figure><ol><li><p>有序列表以数字和 <code>.</code> 开始；</p></li><li><p>数字的序列并不会影响生成的列表序列；</p></li><li><p>但仍然推荐按照自然顺序（1.2.3…）编写。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">可以使用：数字\. 来取消显示为列表（用反斜杠进行转义）<br></code></pre></td></tr></table></figure></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码块（⌘-⌥-c）"><a href="#代码块（⌘-⌥-c）" class="headerlink" title="代码块（⌘ + ⌥ + c）"></a>代码块<strong>（⌘ + ⌥ + c）</strong></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">```语言名称</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">也可以通过 <span class="hljs-code">``，插入行内代码（`</span> 是 <span class="hljs-code">`Tab`</span> 键上边、数字 <span class="hljs-code">`1`</span> 键左侧的那个按键）：<br><br>例如 <span class="hljs-code">`Markdown`</span><br></code></pre></td></tr></table></figure><p><code>Markdown</code></p><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><p>代码块中的文本（包括 Markdown 语法）都会显示为原始内容</p><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>可以在一行中使用三个或更多的 <code>*</code>、<code>-</code> 或 <code>_</code> 来添加分隔线（``）：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-section">------</span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-section">___</span></span></span><br></code></pre></td></tr></table></figure><hr><hr><hr><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>跳转至文章开头<strong><em>（⌘ + 向上箭头）\</em></strong><br>跳转至文章结尾<strong><em>（⌘ + 向下箭头）\</em></strong></p><h3 id="外部跳转—超链接"><a href="#外部跳转—超链接" class="headerlink" title="外部跳转—超链接"></a>外部跳转—超链接</h3><p>格式为 <code>[link text](link)</code>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">帮助文档</span>](<span class="hljs-link">https://support.typora.io/Links/#faq</span>)<br></code></pre></td></tr></table></figure><p><a href="https://support.typora.io/Links/#faq">帮助文档</a></p><h3 id="内部跳转—本文件内跳（Typora支持）"><a href="#内部跳转—本文件内跳（Typora支持）" class="headerlink" title="内部跳转—本文件内跳（Typora支持）"></a>内部跳转—本文件内跳（Typora支持）</h3><p>格式为 <code>[link text](#要去的目的地--标题）</code>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">我想跳转</span>](<span class="hljs-link">#饼图（Pie）</span>)<br></code></pre></td></tr></table></figure><blockquote><p>Open Links in Typora</p><p>You can use <code>command+click</code> (macOS), or <code>ctrl+click</code> (Linux/Windows) on links in Typora to jump to target headings, or open them in Typora, or open in related apps.</p></blockquote><p><a href="#饼图（Pie）">我想跳转</a></p><h3 id="自动链接（⌘-k）"><a href="#自动链接（⌘-k）" class="headerlink" title="自动链接（⌘ + k）"></a>自动链接<strong>（⌘ + k）</strong></h3><p>使用 <code>&lt;&gt;</code> 包括的 URL 或邮箱地址会被自动转换为超链接：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml">&lt;https://www.baidu.com&gt;</span><br><br>&lt;123@email.com&gt;<br></code></pre></td></tr></table></figure><p><a href="https://www.baidu.com">https://www.baidu.com</a></p><p><a href="mailto:123@email.com">123@email.com</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">自己起的图片名字</span>](<span class="hljs-link">图片地址或者图片本地存储的路径</span>)<br></code></pre></td></tr></table></figure><h3 id="网上的图片"><a href="#网上的图片" class="headerlink" title="网上的图片"></a>网上的图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">friedChicken</span>](<span class="hljs-link">https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg</span>)<br></code></pre></td></tr></table></figure><p><img src="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg" alt="炸鸡"></p><h3 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">friedChicken</span>](<span class="hljs-link">friedChicken.jpg</span>)<br>在同一个文件夹里（用相对路径）<br>或者直接拷贝<br></code></pre></td></tr></table></figure><h2 id="利用Markdown画图（需勾选扩展语法）"><a href="#利用Markdown画图（需勾选扩展语法）" class="headerlink" title="利用Markdown画图（需勾选扩展语法）"></a>利用Markdown画图（需勾选扩展语法）</h2><p>markdown画图也是轻量级的，功能并不全。</p><p>Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。Mermaid 作为一个使用 JS 渲染的库，生成的不是一个“图片”，而是一段 HTML 代码。</p><p>（不同的编辑器渲染的可能不一样）</p><h3 id="流程图-graph"><a href="#流程图-graph" class="headerlink" title="流程图(graph)"></a>流程图(graph)</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph 方向描述<br><span class="hljs-code">    图表中的其他语句...</span><br></code></pre></td></tr></table></figure><p>关键字graph表示一个流程图的开始，同时需要指定该图的方向。</p><p>其中“方向描述”为：</p><div class="table-container"><table><thead><tr><th style="text-align:left">用词</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">TB</td><td style="text-align:left">从上到下</td></tr><tr><td style="text-align:left">BT</td><td style="text-align:left">从下到上</td></tr><tr><td style="text-align:left">RL</td><td style="text-align:left">从右到左</td></tr><tr><td style="text-align:left">LR</td><td style="text-align:left">从左到右</td></tr></tbody></table></div><blockquote><p>T = TOP，B = BOTTOM，L = LEFT，R = RIGHT，D = DOWN</p></blockquote><p>最常用的布局方向是TB、LR。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB;<br>  A--&gt;B<br>  B--&gt;C<br>  C--&gt;A<br> <br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB;  A--&gt;B  B--&gt;C  C--&gt;A</code></pre><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph LR;<br>  A--&gt;B<br>  B--&gt;C<br>  C--&gt;A<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph LR;  A--&gt;B  B--&gt;C  C--&gt;A</code></pre><h4 id="流程图常用符号及含义"><a href="#流程图常用符号及含义" class="headerlink" title="流程图常用符号及含义"></a>流程图常用符号及含义</h4><h5 id="节点形状"><a href="#节点形状" class="headerlink" title="节点形状"></a>节点形状</h5><div class="table-container"><table><thead><tr><th style="text-align:left">表述</th><th style="text-align:left">说明</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:left">id[文字]</td><td style="text-align:left">矩形节点</td><td>表示过程，也就是整个流程中的一个环节</td></tr><tr><td style="text-align:left">id(文字)</td><td style="text-align:left">圆角矩形节点</td><td>表示开始和结束</td></tr><tr><td style="text-align:left">id((文字))</td><td style="text-align:left">圆形节点</td><td>表示连接。为避免流程过长或有交叉，可将流程切开。成对</td></tr><tr><td style="text-align:left">id{文字}</td><td style="text-align:left">菱形节点</td><td>表示判断、决策</td></tr><tr><td style="text-align:left">id&gt;文字]</td><td style="text-align:left">右向旗帜状节点</td></tr></tbody></table></div><p><strong>单向箭头线段</strong>：表示流程进行方向</p><blockquote><p>id即为节点的唯一标识，A~F 是当前节点名字，类似于变量名，画图时便于引用</p><p>括号内是节点中要显示的文字，默认节点的名字和显示的文字都为A</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br>  A<br>  B(圆角矩形节点)<br>  C[矩形节点]<br>  D((圆形节点))<br>  E&#123;菱形节点&#125;<br>  F&gt;右向旗帜状节点] <br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB  A  B(圆角矩形节点)  C[矩形节点]  D((圆形节点))  E&#123;菱形节点&#125;  F&gt;右向旗帜状节点]</code></pre><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br><span class="hljs-code">    begin(出门)--&gt; buy[买炸鸡]</span><br><span class="hljs-code">    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;</span><br><span class="hljs-code">    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家)</span><br><span class="hljs-code">    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack</span><br><span class="hljs-code">    </span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB    begin(出门)--&gt; buy[买炸鸡]    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家)    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack    </code></pre><h5 id="连线"><a href="#连线" class="headerlink" title="连线"></a>连线</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br>  A1--&gt;B1<br>  A2---B2<br>  A3--text---B3<br>  A4--text--&gt;B4<br>  A5-.-B5<br>  A6-.-&gt;B6<br>  A7-.text.-B7<br>  A8-.text.-&gt;B8<br>  A9===B9<br>  A10==&gt;B10<br>  A11==text===B11<br>  A12==text==&gt;B12<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB  A1--&gt;B1  A2---B2  A3--text---B3  A4--text--&gt;B4  A5-.-B5  A6-.-&gt;B6  A7-.text.-B7  A8-.text.-&gt;B8  A9===B9  A10==&gt;B10  A11==text===B11  A12==text==&gt;B12</code></pre><pre><code class=" mermaid">graph TB A ---B</code></pre><h5 id="子图表"><a href="#子图表" class="headerlink" title="子图表"></a>子图表</h5><p>使用以下语法添加子图表</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">subgraph 子图表名称<br><span class="hljs-code">    子图表中的描述语句...</span><br><span class="hljs-code">end</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br><span class="hljs-code">  subgraph 买炸鸡前</span><br><span class="hljs-code">    begin(出门)--&gt; buy[出门买炸鸡]</span><br><span class="hljs-code">    end</span><br><span class="hljs-code">    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;</span><br><span class="hljs-code">    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack(回家)</span><br><span class="hljs-code">    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB  subgraph 买炸鸡前    begin(出门)--&gt; buy[出门买炸鸡]    end    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack(回家)    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack</code></pre><h3 id="序列图-sequence-diagram"><a href="#序列图-sequence-diagram" class="headerlink" title="序列图(sequence diagram)"></a>序列图(sequence diagram)</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram <br><span class="hljs-code">[参与者1][消息线][参与者2]:消息体</span><br><span class="hljs-code">    ...</span><br></code></pre></td></tr></table></figure><blockquote><p><code>sequenceDiagram</code> 为每幅时序图的固定开头</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">Title: 买炸鸡</span><br><span class="hljs-code">    救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？</span><br><span class="hljs-code">    炸鸡店小哥--&gt;&gt;救救: 没有，要现炸</span><br><span class="hljs-code"></span><br><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagramTitle: 买炸鸡    救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？    炸鸡店小哥--&gt;&gt;救救: 没有，要现炸</code></pre><h4 id="参与者（participant）"><a href="#参与者（participant）" class="headerlink" title="参与者（participant）"></a>参与者（participant）</h4><p>传统时序图概念中参与者有角色和类对象之分，但这里我们不做此区分，用参与者表示一切参与交互的事物，可以是人、类对象、系统等形式。中间竖直的线段从上至下表示时间的流逝。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 参与者 1</span><br><span class="hljs-code">    participant 参与者 2</span><br><span class="hljs-code">    ...</span><br><span class="hljs-code">    participant 简称 as 参与者 3 #该语法可以在接下来的描述中使用简称来代替参与者 3</span><br></code></pre></td></tr></table></figure><blockquote><p><code>participant &lt;参与者名称&gt;</code> 声明参与者，语句次序即为参与者横向排列次序。</p></blockquote><h4 id="消息线"><a href="#消息线" class="headerlink" title="消息线"></a>消息线</h4><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-&gt;</td><td style="text-align:left">无箭头的实线</td></tr><tr><td style="text-align:left">—&gt;</td><td style="text-align:left">无箭头的虚线</td></tr><tr><td style="text-align:left">-&gt;&gt;</td><td style="text-align:left">有箭头的实线（主动发出消息）</td></tr><tr><td style="text-align:left">–-&gt;&gt;</td><td style="text-align:left">有箭头的虚线（响应）</td></tr><tr><td style="text-align:left">-x</td><td style="text-align:left">末端为叉的实线（表示异步）</td></tr><tr><td style="text-align:left">—x</td><td style="text-align:left">末端为叉的虚线（表示异步）</td></tr></tbody></table></div><h4 id="处理中-激活框"><a href="#处理中-激活框" class="headerlink" title="处理中-激活框"></a>处理中-激活框</h4><p>从消息接收方的时间线上标记一小段时间，表示对消息进行处理的时间间隔。</p><p>在消息线末尾增加 <code>+</code> ，则消息接收者进入当前消息的“处理中”状态；<br>在消息线末尾增加 <code>-</code> ，则消息接收者离开当前消息的“处理中”状态。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="hljs-code">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="hljs-code">    99 -x +seller:给我炸！</span><br><span class="hljs-code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -x +seller:给我炸！    seller --&gt;&gt; -99: 您的炸鸡好了！    </code></pre><h4 id="注解（note）"><a href="#注解（note）" class="headerlink" title="注解（note）"></a>注解（note）</h4><p>语法如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Note 位置表述 参与者: 标注文字<br></code></pre></td></tr></table></figure><p>其中位置表述可以为</p><div class="table-container"><table><thead><tr><th style="text-align:left">表述</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">right of</td><td style="text-align:left">右侧</td></tr><tr><td style="text-align:left">left of</td><td style="text-align:left">左侧</td></tr><tr><td style="text-align:left">over</td><td style="text-align:left">在当中，可以横跨多个参与者</td></tr></tbody></table></div><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    Note over 99,seller : 热爱炸鸡</span><br><span class="hljs-code">    Note left of 99 : 女</span><br><span class="hljs-code">    Note right of seller : 男</span><br><span class="hljs-code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="hljs-code">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="hljs-code">    99 -x +seller : 给我炸！</span><br><span class="hljs-code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br><span class="hljs-code"></span><br><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    Note over 99,seller : 热爱炸鸡    Note left of 99 : 女    Note right of seller : 男    99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -x +seller : 给我炸！    seller --&gt;&gt; -99: 您的炸鸡好了！</code></pre><h4 id="循环（loop）"><a href="#循环（loop）" class="headerlink" title="循环（loop）"></a>循环（loop）</h4><p>在条件满足时，重复发出消息序列。（相当于编程语言中的 while 语句。）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">   </span><br><span class="hljs-code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="hljs-code">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="hljs-code">    99 -&gt;&gt; +seller:给我炸！</span><br><span class="hljs-code">    loop 三分钟一次</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 我的炸鸡好了吗？</span><br><span class="hljs-code">        seller --&gt;&gt; 99 : 正在炸</span><br><span class="hljs-code">    end</span><br><span class="hljs-code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥       99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -&gt;&gt; +seller:给我炸！    loop 三分钟一次        99 -&gt;&gt; seller : 我的炸鸡好了吗？        seller --&gt;&gt; 99 : 正在炸    end    seller --&gt;&gt; -99: 您的炸鸡好了！</code></pre><h4 id="选择（alt）"><a href="#选择（alt）" class="headerlink" title="选择（alt）"></a>选择（alt）</h4><p>在多个条件中作出判断，每个条件将对应不同的消息序列。（相当于 if 及 else if 语句。）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram    <br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？</span><br><span class="hljs-code">    seller --&gt;&gt; 99 : 可卖的炸鸡数</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    alt 可卖的炸鸡数 &gt; 3</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 买三只！</span><br><span class="hljs-code">    else 1 &lt; 可卖的炸鸡数 &lt; 3</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 有多少买多少</span><br><span class="hljs-code">    else 可卖的炸鸡数 &lt; 1</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 那我明天再来</span><br><span class="hljs-code">    end</span><br><span class="hljs-code"></span><br><span class="hljs-code">    seller --&gt;&gt; 99 : 欢迎下次光临</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram        participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？    seller --&gt;&gt; 99 : 可卖的炸鸡数        alt 可卖的炸鸡数 &gt; 3        99 -&gt;&gt; seller : 买三只！    else 1 &lt; 可卖的炸鸡数 &lt; 3        99 -&gt;&gt; seller : 有多少买多少    else 可卖的炸鸡数 &lt; 1        99 -&gt;&gt; seller : 那我明天再来    end    seller --&gt;&gt; 99 : 欢迎下次光临</code></pre><h4 id="可选（opt）"><a href="#可选（opt）" class="headerlink" title="可选（opt）"></a>可选（opt）</h4><p>在某条件满足时执行消息序列，否则不执行。相当于单个分支的 if 语句。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    99 -&gt;&gt; seller : 买炸鸡</span><br><span class="hljs-code">    opt 全都卖完了</span><br><span class="hljs-code">        seller --&gt;&gt; 99 : 下次再来</span><br><span class="hljs-code">    end</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller : 买炸鸡    opt 全都卖完了        seller --&gt;&gt; 99 : 下次再来    end</code></pre><h4 id="并行（Par）"><a href="#并行（Par）" class="headerlink" title="并行（Par）"></a>并行（Par）</h4><p>将消息序列分成多个片段，这些片段并行执行。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br>   participant 99 as 救救<br>   participant seller as 炸鸡店小哥<br>   <br><span class="hljs-code">    99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！</span><br><span class="hljs-code"></span><br><span class="hljs-code">    par 并行执行</span><br><span class="hljs-code">        seller -&gt;&gt; seller : 装可乐</span><br><span class="hljs-code">    and</span><br><span class="hljs-code">        seller -&gt;&gt; seller : 炸炸鸡</span><br><span class="hljs-code">    end</span><br><span class="hljs-code"></span><br><span class="hljs-code">    seller --&gt;&gt; 99 : 您的炸鸡好了！</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram   participant 99 as 救救   participant seller as 炸鸡店小哥       99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！    par 并行执行        seller -&gt;&gt; seller : 装可乐    and        seller -&gt;&gt; seller : 炸炸鸡    end    seller --&gt;&gt; 99 : 您的炸鸡好了！</code></pre><h3 id="饼图（Pie）"><a href="#饼图（Pie）" class="headerlink" title="饼图（Pie）"></a>饼图（Pie）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">pie<br><span class="hljs-code">    title Pie Chart</span><br><span class="hljs-code">    &quot;Dogs&quot; : 386</span><br><span class="hljs-code">    &quot;Cats&quot; : 85</span><br><span class="hljs-code">    &quot;Rats&quot; : 150 </span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">pie    title Pie Chart    &quot;Dogs&quot; : 386    &quot;Cats&quot; : 85    &quot;Rats&quot; : 150     &quot;panda&quot; : 200</code></pre><blockquote><p><a href="http://support.typora.io/Draw-Diagrams-With-Markdown/">Typora支持mermaid的官方链接</a></p></blockquote><h3 id="甘特图（gantt）"><a href="#甘特图（gantt）" class="headerlink" title="甘特图（gantt）"></a>甘特图（gantt）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"> title 标题<br>dateFormat 日期格式<br>section 部分名<br>任务名:参数一, 参数二, 参数三, 参数四，参数五<br><br> //参数一：crit（是否重要，红框框） 或者 不填<br> //参数二：done（已完成）、active（正在进行） 或者 不填(表示为待完成状态)<br> //参数三：取小名 或者 不填<br> //参数四：任务开始时间<br> //参数五：任务结束时间<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://mermaid-js.github.io/mermaid/#/gantt">官方教程</a></p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gantt</span><br>       <span class="hljs-attribute">dateFormat</span>  YYYY-MM-DD<br>       <span class="hljs-attribute">title</span> Adding GANTT diagram functionality to mermaid<br><br>       <span class="hljs-attribute">section</span> A section<br>       <span class="hljs-attribute">Completed</span> task            :done,    des1, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span>,<span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">08</span><br>       <span class="hljs-attribute">Active</span> task               :active,  des2, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">09</span>, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Future</span> task               :         des3, after des2, <span class="hljs-number">5</span>d<br>       <span class="hljs-attribute">Future</span> task2              :         des4, after des3, <span class="hljs-number">5</span>d<br><br>       <span class="hljs-attribute">section</span> Critical tasks<br>       <span class="hljs-attribute">Completed</span> task in the critical line :crit, done, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span>,<span class="hljs-number">24</span>h<br>       <span class="hljs-attribute">Implement</span> parser and jison          :crit, done, after des1, <span class="hljs-number">2</span>d<br>       <span class="hljs-attribute">Create</span> tests for parser             :crit, active, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Future</span> task in critical line        :crit, <span class="hljs-number">5</span>d<br>       <span class="hljs-attribute">Create</span> tests for renderer           :<span class="hljs-number">2</span>d<br>       <span class="hljs-attribute">Add</span> to mermaid                      :<span class="hljs-number">1</span>d<br><br>       <span class="hljs-attribute">section</span> Documentation<br>       <span class="hljs-attribute">Describe</span> gantt syntax               :active, a1, after des1, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Add</span> gantt diagram to demo page      :after a1  , <span class="hljs-number">20</span>h<br>       <span class="hljs-attribute">Add</span> another diagram to demo page    :doc1, after a1  , <span class="hljs-number">48</span>h<br><br>       <span class="hljs-attribute">section</span> Last section<br>       <span class="hljs-attribute">Describe</span> gantt syntax               :after doc1, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Add</span> gantt diagram to demo page      :<span class="hljs-number">20</span>h<br>       <span class="hljs-attribute">Add</span> another diagram to demo page    :<span class="hljs-number">48</span>h<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">gantt       dateFormat  YYYY-MM-DD       title Adding GANTT diagram functionality to mermaid       section A section       Completed task            :done,    des1, 2014-01-06,2014-01-08       Active task               :active,  des2, 2014-01-09, 3d       Future task               :         des3, after des2, 5d       Future task2              :         des4, after des3, 5d       section Critical tasks       Completed task in the critical line :crit, done, 2014-01-06,24h       Implement parser and jison          :crit, done, after des1, 2d       Create tests for parser             :crit, active, 3d       Future task in critical line        :crit, 5d       Create tests for renderer           :2d       Add to mermaid                      :1d       section Documentation       Describe gantt syntax               :active, a1, after des1, 3d       Add gantt diagram to demo page      :after a1  , 20h       Add another diagram to demo page    :doc1, after a1  , 48h       section Last section       Describe gantt syntax               :after doc1, 3d       Add gantt diagram to demo page      :20h       Add another diagram to demo page    :48h</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
