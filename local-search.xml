<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>论文记录</title>
    <link href="/2022/11/04/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/11/04/%E8%AE%BA%E6%96%87%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="故障诊断"><a href="#故障诊断" class="headerlink" title="故障诊断"></a>故障诊断</h2><h3 id="基于卷积神经网络的轴承故障诊断算法研究"><a href="#基于卷积神经网络的轴承故障诊断算法研究" class="headerlink" title="基于卷积神经网络的轴承故障诊断算法研究"></a>基于卷积神经网络的轴承故障诊断算法研究</h3><p>本文主要研究基于卷积神经网络的轴承故障诊断，将卷积神经网络的特征识别直接作用在原始时域信号上，并对设计出的卷积神经网络进行改进，使改进后的网络在噪声环境和工作负载变化情况下，依然可以保持高识别率。主要结构分五部分：</p><p>一、卷积神经网络</p><p>本文中池化层采用的降采样操作为最大值池化。这样做的优点在于<strong>可以获得位置无关的特征</strong>，这一点对于周期性的时域信号很关键。</p><p>该卷网包含两个卷积层，两个池化层，一个全连接隐含层，以及一个Softmax层。</p><p>选用的目标函数为交叉熵函数，因为平方误差函数比较的是每一个类别的大小，故障诊断需要的是衡量两个概率分布的一致性。</p><p>用链式法则从后往前逐层计算目标函数关于W和b的偏导后，要对参数进行优化，因为参数及超参数多的缘故，选用可以自适应且具有鲁棒性的Adam算法。</p><p>数据集增强的方式是重叠采样。</p><p>最后，使用提出的卷积神经网络在CWRU滚动轴承数据集上进行训练，训练好的模型的识别率可以达到99%以上。</p><p>二、模型改进</p><p>为了提高网络性能，本章研究如何加深卷积神经网络的层数，并且减少网络参数个数。</p><p>堆叠式卷积核在一维振动信号领域表现的并不好，因此本文设计出一种WDCNN模型，第一层为大卷积核，目的是为了提取短时特征，快速筛去对诊断没有帮助的特征。</p><p>其余卷积层的卷积核大小均为3×1来增强网络的表达能力，3x1卷积核参数少，有利于加深网络，同时可以抑制过拟合。每层卷积操作之后均进行批量归一化处理BN，主要操作步骤是将卷积层或全连接层的输入先减去所在mini-batch的均值，再除以其标准差，类似于一种标准化操作，因此可以加速训练。但是这样会将输入值限制在一个较窄的区间，降低网络的表达能力。因此，将标准化后的值重新乘以一个缩放量并加上偏执系数，用于增强表达。</p><p><img src="/../img/image-20221104032816510.png" alt="image-20221104032816510" style="zoom:50%;"></p><p>由于振动信号是周期性的，且每一个输入信号的相位值不一定相同。为了让WDCNN的滤波级学习到位移无关的特征，最后一个池化层的神经元在输入信号中的感受野大小，应当大于一个周期，由此结论推导出WDCNN每层网络训练步长的范围。</p><p>最终试验结果得到，WDCNN模型收敛速度快，在大数据训练下，对采样频率为12kHz的凯斯西储大学轴承数据库可以达到100%±0的识别率。</p><p><img src="/../img/image-20221104034028789.png" alt="image-20221104034028789"></p><p>为了深入理解训练数据量对网络训练的影响，通过<strong>t-SNE降维技术</strong>，将测试集在最后一个隐含层的特征降成二维并可视化。上图分别是训练样本个数为90，300，3000以及19800时，测试集D特征可视化图。从图中可以看出，随着训练样本的增加，各类别之间的重叠部分逐渐减少，并且各类别之间的距离也越来越大，即特征的可分性也越来越强、表明WDCNN对测试样本的判别能力逐渐增强。</p><p>三、增加泛化性能</p><p>在实际的工业应用中，工业现场的噪声无法避免，机器工作负载也会随之改变，本章首次将故障诊断中的环境噪声与负载变化造成的信号改变，归结为机器学习中的领域自适应问题，即目标领域（测试样本）的分布与源领域（训练样本）的分布不一致的情况。</p><p>本章采用AdaBN（AdaptiveBatchNormalization）算法提高WDCNN模型的领域自适应能力，AdaBN认为BN层的均值和方差代表了不同域之间的特性，因此在我们用正常情况下的数据集训练出一个模型后，再将拥有噪声或不同工作负载的目标领域的数据输入模型。用目标领域样本在每一个 BN 层的均值和方差替换原来 BN 层所使用的由源领域样本计算出的均值和方差。这样就使源领域与目标领域调整到一个新的分布空间，在此空间内，两者近似一致，从而达到领域自适应的目的。</p><p><img src="/../img/image-20221104035239148.png" alt="image-20221104035239148"></p><p>然后给测试样本添加噪声和在变载情况下测试网络性能，新模型都有很好的性能。得到的经验是，当噪声较大时应选取较大的卷积核，卷积核宽度建议不小于 3 倍步长。最后用tSNE降维表达了最后一个隐含层，可视化了模型的诊断性能。</p><p>四、训练干扰</p><p>上一章的模型虽然好但是需要目标领域样本的均值和方差，这在初期时很难满足的。因此，提出了基于训练干扰的卷积神经网络（TICNN）。</p><p>TICNN模型在WDCNN模型的训练过程中引入了卷积核Dropout和极小mini-batch，并采用集成学习。该模型在没有利用任何目标领域的信息情况下，依然具有很高的抗噪性与负载自适应性。</p><p><a href="https://zhuanlan.zhihu.com/p/77609689">Dropout</a>算法的原理是每次训练都随机让一定神经元停止参与运算，停止神经元的比例就是dropout rate，这样就得到了一堆新的模型（比方说四个）。</p><p>dropout太大就会把重要特征drop掉，会造成欠拟合，而适合的dropout会减轻过拟合，就是因为他drop掉了一些非本质的特征，比如说在人脸识别的时候，把衣服特征drop掉。</p><p>如果第四个模型overfitting了，前三个模型也参与了投票判断，第四个模型overfitting就被弱化了。</p><p><strong>所以，dropout的出现，使得模型稳定性和鲁棒性被大大提高了。</strong></p><p>但是模型在训练的时候会停止训练一些神经元，而测试的时候，整个模型是完整的，不会dropout 任何神经元。所以，在训练的时候，我们会对<strong>没有被dropout的神经元权值做一个rescale</strong>。</p><script type="math/tex; mode=display">rescale rate = 1 / (1 - dropout rate)</script><p>没用dropout的神经网络前向传播计算公式：</p><p><img src="/../img/image-20221104041838983.png" alt="image-20221104041838983" style="zoom:50%;"></p><p>用了dropout 的神经网络前向传播计算公式：</p><p><img src="/../img/image-20221104041912435.png" alt="image-20221104041912435" style="zoom:50%;"></p><p>在使用第一层大卷积核进行卷积时，先对卷积核进行 Dropout 操作，这是 TICNN 模型的第一个训练干扰，目的是给 TICNN 训练时提供不完整的信号，从而强化 TICNN 在信号部分缺失时的诊断能力。</p><p>使用了极小的 mini-batch 来进行批量训练，增大 minibatch 的均值方差变化范围，增强模型对测试集的均值方差于训练集发生的偏移时容忍度。</p><p>为了模拟噪声的多样性与不确定性，TICNN采用变化的 Dropout 率，在每一次进行 mini-batch 训练时，Dropout 率服从 0.1 到 0.9 的均布分布。并且防止TICNN对噪声学习的太好，对正常样本的识别率会降低，五次里只会dropout一次。</p>]]></content>
    
    
    
    <tags>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西瓜书重刷</title>
    <link href="/2022/10/10/%E5%91%A8%E5%BF%97%E5%8D%8E%E9%87%8D%E5%88%B7%E2%80%9C/"/>
    <url>/2022/10/10/%E5%91%A8%E5%BF%97%E5%8D%8E%E9%87%8D%E5%88%B7%E2%80%9C/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h3><p>这章介绍了专用名词和两个原理。</p><p><strong>数据集</strong>里一个<strong>样本</strong>在<strong>属性空间</strong>里被称为一个<strong>特征向量</strong>，每个<strong>特征</strong>对应一个<strong>维度</strong>，维度的总数称为<strong>维数</strong>。</p><p>从数据中学得模型的过程叫做“<strong>学习</strong>”和“<strong>训练</strong>”，学到的潜在规律叫做“<strong>假设</strong>”，训练结果作为<strong>标记</strong>，所有标记的集合叫做“<strong>标记空间</strong>”或者“<strong>输出空间</strong>”。</p><p>预测值为离散变量时称为“<strong>分类</strong>”，预测值为连续变量时称为“<strong>回归</strong>”，将训练集中样本按照某种内在规律分成若干组，每组称为一个“簇”，叫做“<strong>聚类</strong>”。</p><p>通过有标记的训练样本学习叫做“<strong>监督学习</strong>”，通过无标记的训练样本学习叫做“<strong>无监督学习</strong>”。分类和回归属于前者，聚类属于后者。</p><p>假设空间指一个<strong>机器学习算法可以生成的所有函数的集合</strong>。</p><p><u>奥卡姆剃刀原理：若有多个假设和观察一致，选最简单的那个。</u>在曲线中，平滑意味着简单。</p><p><u>没有免费的午餐NFL定理：无论学习算法的“聪明”或“笨拙”与否，它们的期望性能都相同。</u>但这是建立在所有问题机会均等的条件下的，现实中我们肯定只会关心我们需要关心的问题，因此肯定有算法会在某个问题上表现的更好，我们要做的就是找到它。</p><h3 id="二、模型评估与选择"><a href="#二、模型评估与选择" class="headerlink" title="二、模型评估与选择"></a>二、模型评估与选择</h3><p>“模型选择”问题最理想的解决方案是对候选模型的泛化性能进行评估，选择性能最好的那个。泛化性能的评估不仅需要<strong>实验估计方法</strong>，还需要有衡量泛化能力的<strong>评判标准</strong>。</p><h4 id="实验估计方法"><a href="#实验估计方法" class="headerlink" title="实验估计方法"></a>实验估计方法</h4><h5 id="留出法（hold-out）"><a href="#留出法（hold-out）" class="headerlink" title="留出法（hold-out）"></a>留出法（hold-out）</h5><p>将$D$划分为互斥的两部分$S和T$，在$S$上训练出模型后，用$T$来评估测试误差，划分时采用<strong>分层采样</strong>，保证训练集和测试集中正反类的比例一致。</p><p>为了平衡模型的准确性与测试结果的保真性，常见做法是将大约 2/3～ 4/5 的样本用于训练，剩余样本用于测试。</p><h5 id="交叉验证法（cross-validation）"><a href="#交叉验证法（cross-validation）" class="headerlink" title="交叉验证法（cross validation）"></a>交叉验证法（cross validation）</h5><p>将数据集 $D $划分为$k$个互斥子集，即$D=D_1\cup D_2\cup ……\cup D_k$，$D_i\cap D_j=\empty $，每次用$k-1 $个子集的并集作为训练集，余下的那个子集作为测试集；对获得的 $k$组训练/测试集进行 $k$ 次训练和测试，得到这 $k$ 个测试结果的均值。</p><p><img src="/../img/image-20221011194409037.png" alt="image-20221011194409037" style="zoom:50%;"></p><p>交叉验证法的一 个特例：留一法(Leave-One-Out，简称 LOO) </p><p>假定数据集 $D$ 中包含 $m$ 个样本，令 $k=m$ ，即每个子集只包含一个样本。</p><h5 id="自助法（bootstrapping）"><a href="#自助法（bootstrapping）" class="headerlink" title="自助法（bootstrapping）"></a>自助法（bootstrapping）</h5><p>从$D$中随机复制一个样本到$D’$中，复制$m$次，会得到一个拥有$m$个数据样本的$D’$数据集。</p><p>根据平均分布概率计算，大约有36.8%的数据不会被复制到$D’$中，因此$D$覆盖的样本要多于$D’$，把$D’$拿来当训练集，$D$用来当测试集。这样的测试结果，亦称”包外估计” (out-of-bag estimate)。</p><blockquote><p>样本在 $m$ 次采样中始终不被采到的概率是 $(1-\frac{1}{m})^m$， 取极限得到$\lim_{m\to \infty}(1-\frac{1}{m})^m \to \frac{1}{e} \approx. 0.368$</p></blockquote><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>自助法在<strong>数据集较小、难以有效划分训练/测试集时</strong>很有用，另外两个都是采用分层采样的。</p><p>自助法产生的数据集改变了初始数据集的分布，这会引入估计偏差。因此，<u>在初始数据量足够时，留出法和交叉验证法更常用一些。</u></p><p>留出法和交叉验证法由于都把数据集中的一部分用来测试，没有参与训练，因此必然会引入一些因训练样本规模不同而导致的估计偏差，留一法受影响较小，但计算复杂度又太高了。</p><h4 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h4><p>一般参数分两种：一类是算法的参数，亦称“超参数”；一类是模型的参数，如神经网络中每个节点的权重。前者多为人工选择一组候选，后者是让机器自己学习，常用的做法是对每个参数选定一个范围和变化步长，这种做法选出的参数往往不是最佳的，但却是在计算开销与性能估计之间折中的最好结果。</p><p>一般调参过程中，会将训练数据再次划分为训练集和验证集(validation set)，训练集用来训练出模型，验证集用来进行模型评估与选择，对比不同算法的泛化性能。</p><p><u>验证集和测试集有啥区别？</u></p><p>使用验证集是为了快速调参，也就是用验证集选择超参数（网络层数，网络节点数，迭代次数，学习率这些）。另外用验证集还可以监控模型是否异常（过拟合啦什么的），然后决定是不是要提前停止训练。</p><p>验证集的关键在于选择超参数，我们手动调参是为了让模型在验证集上的表现越来越好，如果把测试集作为验证集，调参去拟合测试集，就有点像作弊了。</p><p>而测试集既不参与参数的学习过程，也不参与参数的选择过程，仅仅用于模型评价。</p><p><u>验证集的正确打开方式：</u></p><p>验证集可以看做参与了 “人工调参” 的训练过程。一般训练几个 epoch 就跑一次验证看看效果（大部分网络自带这个功能）。</p><p>这样做的第一个好处是：可以及时发现模型或者参数的问题，比如模型在验证集上发散啦、出现很奇怪的结果啦（Inf）、mAP不增长或者增长很慢啦等等情况，这时可以及时终止训练，重新调参或者调整模型，而不需要等到训练结束。</p><p>另一个好处是验证模型的泛化能力，如果在验证集上的效果比训练集上差很多，就该考虑模型是否过拟合了。同时，还可以通过验证集对比不同的模型。</p><h4 id="评判标准"><a href="#评判标准" class="headerlink" title="评判标准"></a>评判标准</h4><p>模型好坏是相对的，任务不同，使用的性能度量也不同，以下是几种常用的：</p><p>在预测任务中，给定样例集 $D = {(x_1 , y_1) , (x_2 ， y_2)， . . . , (x_m, y_m)} $， 其中 $y_i$ 是示例 $x_i$ 的真实标记。要评估学习器 $f$ 的性能，就要把学习器预测结果 $f(x)$  与真实标记  $y$ 进行比较。</p><h5 id="1-均方误差：回归任务常用"><a href="#1-均方误差：回归任务常用" class="headerlink" title="1.均方误差：回归任务常用"></a>1.均方误差：回归任务常用</h5><p>离散变量：</p><script type="math/tex; mode=display">E(f;D)=\frac{1}{m}\sum_{i=1}^{m}(f(xi)-yi)^2</script><p>连续变量：</p><script type="math/tex; mode=display">E(f;Ð)=\int_{x～Ð}(f(x)-y)^2p(x)dx</script><h5 id="2-错误率与精度：分类任务常用"><a href="#2-错误率与精度：分类任务常用" class="headerlink" title="2.错误率与精度：分类任务常用"></a>2.错误率与精度：分类任务常用</h5><p>离散变量：</p><script type="math/tex; mode=display">错误率：E(f;D)=\frac{1}{m}\sum_{i=1}^{m}\amalg(f(xi)\ne yi)</script><script type="math/tex; mode=display">精度：acc(f;D)=\frac{1}{m}\sum_{i=1}^{m}\amalg(f(xi)= yi)=1-E(f;D)</script><blockquote><p>$\amalg$是指示函数（indicator function），含义是：当输入为True的时候，输出为1，输入为False的时候，输出为0。</p></blockquote><p>连续变量：</p><script type="math/tex; mode=display">错误率：E(f;Ð)=\int_{x～Ð}\amalg(f(x)\ne y)p(x)dx</script><script type="math/tex; mode=display">精度：acc(f;Ð)=\int_{x～Ð}\amalg(f(x)= y)p(x)dx=1-E(f;Ð)</script><h5 id="3-查准率、查全率与-F1"><a href="#3-查准率、查全率与-F1" class="headerlink" title="3.查准率、查全率与$F1$"></a>3.查准率、查全率与$F1$</h5><p>查准率和查全率可以理解为”检索出的信息中有多少比例是用户感兴趣的” 和”用户感兴趣的信息中有多少被检索出来了”。</p><p>查准率 $P $ 与查全率 $R$ 分别定义为：</p><p>$P=\frac{TP}{TP+FP}$  =  真正例 / 预测出的正例</p><p>$R=\frac{TP}{TP+FN}$  =  真正例 / 实际上的正例</p><p>二者通常呈反比。</p><p><img src="/../img/image-20221011214808636.png" alt="image-20221011214808636" style="zoom:33%;"></p><p>在进行比较时，若一个学习器的P-R曲线B把另一个学习器C的曲线完全“包住”，则可断言B的性能优于C。很好理解，查全率一致的情况下，查准率越好的学习器性能越好。因此，ROC曲线越接近左上角，分类效果越好。</p><p>当曲线有相交时，就很难断言两者的优劣。平衡点(Break-Event Point，简称 BEP)是” 查准率=查全率”时的取值，例如图中基于 BEP的比较，可认为学习器 A 优于 B。</p><p>但 BEP 还是过于简化了些，更常用的是 F1 度量，基于查准率与查全率的调和平均 (harinonic mean)定义：</p><script type="math/tex; mode=display">\frac{1}{F1}=\frac{1}{2}.(\frac{1}{P}+\frac{1}{R})</script><p>为了表达出对查准率/查全率的不同偏好，定义了$F1 $度量的一般形式：</p><script type="math/tex; mode=display">F_\beta=\frac{(1+\beta^2)\times P \times R}{(\beta^2 \times P)+R}</script><p>$ß&gt; 1$ 时查全率有更大影响 ; $ß &lt; 1$ 时查准率有更大影响。</p><blockquote><p>混淆矩阵就是TP、TN、FP、FN组成的2x2矩阵。</p></blockquote><p>有多个二分类混淆矩阵的情况，例如：</p><ul><li>进行多次训练/测试，每次得到一个混淆矩阵。</li><li>在多个数据集上进行训练/测试，希望估计算法的”全局” 性能。</li><li>多分类任务每两两类别的组合都对应一个混淆矩阵。</li></ul><p>有两种做法：</p><p>一、在各混淆矩阵上分别计算出查准率和查全率，记为 $(Pn ， Rn)$ ，再计算平均值，这样就得到”宏查准率” ($macro-P$) 、”宏查全率” ($macro-R$) ，以及相应的”宏 $F1$” ($macro-F1$):</p><script type="math/tex; mode=display">macro-P=\frac{1}{n}\sum^n_{i=1}P_i</script><script type="math/tex; mode=display">macro-R=\frac{1}{n}\sum^n_{i=1}R_i</script><script type="math/tex; mode=display">macro-F1=\frac{2\times macro-P \times macro-R}{macro-P+macro-R}</script><p>二、求各混淆矩阵 $TP 、FP 、 TN 、FN$ 的平均值，分别记为 $\overline{TP}、 \overline{FP}、 \overline{TN}、 \overline{FN}$，再基于这些平均值计算出”微查准率 “($micro-P$) 、 “微查全率” ($micro-R$)和”微F1” ($micro-F1$):</p><script type="math/tex; mode=display">micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FP}}</script><script type="math/tex; mode=display">micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FN}}</script><script type="math/tex; mode=display">micro-F1=\frac{2\times micro-P\times micro-R}{micro-P+micro-R}</script><p>以此综合考虑这个模型的查准率、查全率及二者的综合$F_1$。</p><h5 id="4-ROC-与-AUC"><a href="#4-ROC-与-AUC" class="headerlink" title="4.ROC 与 AUC"></a>4.ROC 与 AUC</h5><p>ROC：“受试者工作特征”（receiver operating characteristic）曲线，取用“真正率”（TPR ）作为纵轴，“假正率”（FPR）作为横轴 ，两者分别定义为：</p><script type="math/tex; mode=display">TPR=\frac{TP}{TP+FN},FPR=\frac{FP}{TN+FP}</script><p>学习器得出的预测通常会设置一个阈值来做分类，我们对这些测试样本进行排序，最可能是正类的排在前面，最不可能是正类的排在后面，以某个截断点将这些样本分为两部分，重视准确率就采用靠前的截断点，重视“查全率”就采用靠后的截断点。</p><p>显然，假正率越小越好，真正率越大越好。</p><p>体现在ROC图中就是把样本排序，依次选择它们作为阈值（或称为“截断点”），画出全部的关键点以后，再连接关键点即可最终得到ROC曲线，如下图所示。</p><p><img src="/../img/webp" alt="img" style="zoom: 33%;"></p><p>若要把两个学习器进行比较，简单方法是如果一个学习器A的 ROC 曲线把另一个学习器B的曲线完全”包住”， 则可断言A的性能优于B；较为合理的判据是比较 ROC 曲线下的面积，即 AUC (Area Under ROC Curve) 。</p><script type="math/tex; mode=display">AUC=\frac{1}{2}\sum^{m-1}_{i=1}(x_{i+1}-x_i).(y_i+y_{i+1})</script><p>AUC考虑的是样本预测的排序质量，显然是越大越好。</p><h5 id="5-代价敏感错误率与代价曲线"><a href="#5-代价敏感错误率与代价曲线" class="headerlink" title="5.代价敏感错误率与代价曲线"></a>5.代价敏感错误率与代价曲线</h5><p>现实任务中，不同类型的错误所造成的后果不同，设定一个”代价矩阵” (cost matrix) ，其中 $cost_{ij} $表示将第$ i $类样本预测为第 $j $类样本的代价， $cost_{ii} = 0$​，我们的目标是最小化“总体代价”，以二分类任务为例，期望总体代价为：</p><script type="math/tex; mode=display">E(f;D;cost)=\frac{1}{m}(\sum_{x_i\in D^+}I(f(x_i)\ne y_i)\times cost_{01}+\sum_{x_i\in D^-}I(f(x_i)\ne y_i)\times cost_{10})</script><h5 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6.注意事项"></a>6.注意事项</h5><p>（1）loss函数往往要求有更好的数学性质，比如连续、可导、微分，性能指标常常因为不可微分，无法作为优化的loss函数，因此多采用如cross-entropy, rmse等“距离”可微函数作为优化目标。</p><p>（2）实际中还需要考虑时间开销，存储开销和可解释性等问题。比如DDoS防御中实际上最困难的不是检测到DDoS攻击，而是准确的，高性能的检测DDoS流量，并进行清洗。</p><p>（3）医学，信息检索，web搜索引擎，网络安全等领域都有自己的专用术语，但都与传统的机器学习的名词概念有所重合，只是叫法不同。</p><p>以上指标在sklearn库里基本都有现成的模块可以直接使用，相关API可查阅doc，可参考<a href="https://yq.aliyun.com/articles/623375">https://yq.aliyun.com/articles/623375</a></p><h4 id="比较检验"><a href="#比较检验" class="headerlink" title="比较检验"></a><a href="https://blog.csdn.net/weixin_45666566/article/details/106674542">比较检验</a></h4><p>在测得学习器的性能度量后，如何进行比较比我们想象中的复杂得多，存在着多个问题：</p><ol><li>我们要的是<strong>泛化性能</strong>，但是能用的只是测试性能；</li><li>测试性能和测试集的选择对测试结果有很大影响；</li><li>有的机器学习算法本身也有随机性，对同一测试集的多次测试结果也可能会不同。</li></ol><p>为了解决这些问题，统计假设检验（hypothesis test）为我们提供了重要的依据。<strong>基于假设检验结果，我们可以推断出，若在测试集上观察到模型A优于B，则A的泛化性能是否在统计意义上也优于B，以及做这个结论的把握有多大。</strong></p><p>在数理统计中，假设检验是根据一定条件由样本推断总体的一种方法。</p><p>几个基础概念：</p><ul><li><strong>置信度</strong>：表示有多大的把握认为假设是正确的。</li><li><strong>显著度</strong>：也称“显著性水平”，表示假设出错的概率。显著度越大，假设被拒绝的可能性越大。</li><li><strong>自由度</strong>：不被限制的样本数，也可以理解为能自由取值的样本数，记为 vvv 或 dfdfdf。</li></ul><p>看不懂，不看了。</p><p>参考阅读：</p><p><a href="https://blog.csdn.net/m0_63309778/article/details/124309616">https://blog.csdn.net/m0_63309778/article/details/124309616</a></p><p><a href="https://zhuanlan.zhihu.com/p/57866029">https://zhuanlan.zhihu.com/p/57866029</a></p><p><a href="https://zhuanlan.zhihu.com/p/54178491">https://zhuanlan.zhihu.com/p/54178491</a></p><h4 id="偏差—方差分解"><a href="#偏差—方差分解" class="headerlink" title="偏差—方差分解"></a>偏差—方差分解</h4><p>偏差——方差分解是解释学习算法泛化性能的一种重要工具，同时也对如何在模型的拟合能力和复杂度之间取得一个较好的平衡问题提供了一个很好的分析和指导。</p><p>省略推导过程，偏差——方差分解是对学习算法的期望泛化错误率的分解：</p><p>$E(f;D)=bias^2(x)+var(x)+\varepsilon^2$</p><p>也就是说，泛化误差可分解为偏差、方差与噪声之和，三者共同决定泛化误差。</p><p>这三者的含义是这样的：</p><ul><li><p>偏差：度量学习算法的期望预测与真实结果的偏离程度，代表学习算法本身的拟合能力；</p></li><li><p>方差：度量了训练集变动所导致的学习性能的变化，代表数据扰动所造成的影响；</p></li><li><p>噪声：表达当前任务上任何学习算法所能达到的期望泛化误差的下界，代表学习问题本身的难度；</p></li></ul><p>在给定学习任务的条件下，为了取得好的泛化性能，偏差和方差越小越好。但这两者其实是有冲突的，这称为偏差-方差窘境（bias-variance dilemma）。</p><p>给定学习任务，训练不足时，拟合能力不够强，训练数据的扰动对学习器的影响不大，此时偏差主导了泛化错误率； 随着训练程度的加深，学习器的拟合能力逐渐增强，训练数据发生的扰动渐渐能被学习器学到，方差逐渐主导了泛化错误率； 在训练程度充足后，学习器的拟合能力已非常强，训练数据发生的轻微扰动都会导致学习器发生显著变化，若训练数据自身没什么用的特性也被学习器学到了，则将发生过拟合。</p><p>过拟合的意思就是模型对训练集中所有的样本点都有非常好的预测能力，但是对于非训练集中的新数据预测能力非常差。<strong>为了防止过拟合现象的出现，就要降低决策函数的复杂度，通常的做法是给经验风险后面加一个<u>正则化项</u>（惩罚项）</strong>，这个后面章节有。</p><p>以上是从回归任务中推导得出的公式和结论，告诉我们训练的太过容易发生过拟合。对于分类任务，由于0/1损失函数的跳变性，理论上推导出偏差和方差很困难，但是可以通过实验来估计。</p><h3 id="三、线性模型"><a href="#三、线性模型" class="headerlink" title="三、线性模型"></a>三、线性模型</h3><p>线性模型的本质就是通过训练数据学习出一个通过样本数据的属性的线性组合来进行预测的函数。</p><p>其中参数$w,b$分别代表特征的权重和偏执系数，如果训练样本共有 $d$ 个属性，将描述为：$x=(x_1;x_2;……;x_d)$ 。</p><p>线性模型试图学得$x$的预测函数，即$f(x)=w_1x_1+w_2x_2+……+w_dx_d+b$ ，一般用向量形式写成$f(x)=w^Tx+b$ ，其中$w=(w_1;w_2;…;w_d;b)$ 。</p><p>本章介绍几种经典的线性模型，先从回归任务开始，然后讨论二分类和多分类任务。</p><h4 id="回归任务"><a href="#回归任务" class="headerlink" title="回归任务"></a>回归任务</h4><p>线性回归预测实值不止可以用于连续属性，也可以用于离散属性。</p><p>对离散属性，若属性值间存在”<strong>序</strong>“ (order)关系，可通过连续化将其转化为连续值，例如二值属性”身高”的取值——“高” “矮”可转化为 {1,0}，三值属性”高” “中” “低”可转化为 {1, 0.5, 0}。</p><p>若属性值间不存在序关系，则通常转化为 $k$ 维向量，例如属性”瓜类”的取值”西瓜”、”南瓜”、”黄瓜”可转化为(0,0,1)、(0,1,0)、(1,0,0)。</p><h5 id="最小二乘"><a href="#最小二乘" class="headerlink" title="最小二乘"></a>最小二乘</h5><p>确定W和b的方法通常是用它模型分布的某个参数来构造损失函数，均方误差是回归任务中最常用的衡量参数，也就是我们常说的”欧式距离“和“平方损失”。</p><script type="math/tex; mode=display">(w^*,b^*)=arg\min_{(w,b)}\sum^m_{i=1}(f(x_i)-y_i)^2=arg\min_{(w,b)}\sum^m_{i=1}(y_i-wx_i-b)^2</script><p>这种基于均方误差最小化来求解模型的方法称为“最小二乘法”，可将上式对 $ω $和 $b$ 分别求导，得到</p><script type="math/tex; mode=display">s.t. \frac{\partial{E_{w,b}}}{\partial w}=2(w\sum^m_{i=1}x_i^2-\sum^m_{i=1}x_i(y_i-b))=0</script><script type="math/tex; mode=display">s.t.\frac{\partial{E_{w,b}}}{\partial b}=2(mb-\sum^m_{i=1}(y_i-wx_i))=0</script><p>得到$w$和$b$最优解的闭式(解析)解：</p><script type="math/tex; mode=display">w=\frac{\sum^m_{i=1}y_i(x_i-\overline{x})}{\sum^m_{i=1}x_i^2-\frac{1}{m}(\sum^m_{i=1}x_i)^2}</script><script type="math/tex; mode=display">b=\frac{1}{m}\sum^m_{i=1}(y_i-wx_i)</script><blockquote><p><strong>数值解是在特定条件下通过近似计算得出来的一个数值，而解析解就是给出解的具体函数形式，从解的表达式中就可以算出任何对应值。</strong>eg: $x^2=2$   $\rightarrow x=sqrt(2)$ — <strong>（解析解）</strong></p><p>$\rightarrow x=1.414$ — <strong>（数值解）</strong></p></blockquote><p>上述过程对应的是一个样本只有一个特征的问题，当问题中存在的不止一个特征，我们称之为多元线性回归。</p><p>形式与上述过程类似。把$w,b$吸入向量模式，表示为$\hat{w}=(w;b)$，然后把容量为$m$的数据集$D$表示为一个$m*(d+1)$的大小矩阵，每个样本就是其中的一行$x$，$d$对应属性个数，最后一列元素置为$1$，用来乘偏置系数，即</p><script type="math/tex; mode=display">X=\left|    \begin{matrix}    x_{11} & x_{12} & \cdots & x_{1d} & 1\\    x_{21} & x_{22} & \cdots & x_{2d} & 1\\    \vdots & \vdots & \ddots & \vdots & \vdots\\    x_{m1} & x_{m2} & \cdots & x_{md} & 1 \\    \end{matrix}    \right|=\left|    \begin{matrix}    x_1^T &1\\    x_2^T &1\\    \vdots & \vdots\\    x_m^T &1\\    \end{matrix}    \right|</script><p>再把标记也写成向量形式$y=(y_1;y_2;…;y_m)$，则类似于单变量线性回归模型，有</p><script type="math/tex; mode=display">\hat{w}^*=argmin_{\hat{w}}(y-X\hat{w})^T{}(y-X\hat{w})</script><p>令$E_\hat{w}=(y-X\hat{w})^T{}(y-X\hat{w})$，对$\hat{w}$求导得到：</p><script type="math/tex; mode=display">\frac{\partial E_{\hat{w}}}{ \partial\hat w}=2X^T(X\hat w-y)</script><p>假设$E_\hat{w}$为满秩矩阵或正定矩阵时<script type="math/tex">\hat{w^*}=(X^TX)^{-1}X^Ty</script>，回归模型为<script type="math/tex">f(\hat{x_i})=\hat{x_i}(X^TX)^{-1}X^Ty</script>。 <strong>【注】现实任务中，会遇到大量的变量，甚至会超过样本数，导致列数多于行数，<script type="math/tex">X^TX</script>不满秩，所以会有多个$\hat{w}$，此时结果由算法的学习偏好决定。</strong></p><p><a href="https://zhuanlan.zhihu.com/p/273729929">矩阵求导法则</a></p><p>几个公式：</p><p><img src="/../img/image-20221014152313021.png" alt="image-20221014152313021" style="zoom:50%;"></p><p>其中， a 为常数向量， a=(a1,a2,⋯,an)T 。</p><p><img src="/../img/image-20221014152338461.png" alt="image-20221014152338461" style="zoom:50%;"></p><p><img src="/../img/image-20221014153030829.png" alt="image-20221014153030829" style="zoom:50%;"></p><p><img src="/../img/image-20221014153049266.png" alt="image-20221014153049266" style="zoom:50%;"></p><h5 id="联系函数"><a href="#联系函数" class="headerlink" title="联系函数"></a>联系函数</h5><p>有时候$y$和$x$之间不是线性变化，这就导致$y=w<em>x+b$​不能再表示他们之间的关系，就需要通过一个“<em>*联系函数</em></em>”让他们可以线性表示，考虑单调可微函数$ g(.) $， 令</p><script type="math/tex; mode=display">y=g^{-1}(w^Tx+b)</script><p>$g(.) $连续且充分光滑，这样得到的模型称为”广义线性模型” (generalized linear model) ，其中函数$g(.)$ 就称为”联系函数” (link function)。</p><p>这实际上是一种空间映射，起到了<u>将线性回归模型的预测值与真实标记联系起来的作用</u>。</p><h5 id="对数几率函数sigmoid"><a href="#对数几率函数sigmoid" class="headerlink" title="对数几率函数sigmoid"></a>对数几率函数sigmoid</h5><p>之前讲的是回归学习，训练模型来预测出一个实值，如果要做分类任务的话，就要加一个联系函数把预测值和真实输出标签[0,1]联系起来，最理想的是”单位阶跃函数”。</p><script type="math/tex; mode=display">y=\left\{\begin{array}{c}    0,z<0\\    0.5,z=0\\    1,z>0\end{array}\right.</script><p>但是它并不连续，需要用对数几率函数这种近似单位阶跃函数且单调可微的函数来作为其替代函数。</p><script type="math/tex; mode=display">y=\frac{1}{1+e^{-z}}</script><p>将线性函数代入对数几率函数并写成如下形式：</p><script type="math/tex; mode=display">ln\frac{y}{1-y}=-z=w^Tx+b</script><p>y是正例的概率，1-y就是反例的概率，两者的比值就是“<strong>几率</strong>”，反映了x作为正例的<strong>相对可能性</strong>，对这个几率取的对数就叫做对数几率。</p><p>我们所要做的就是让预测输出，也就是右边部分，尽可能的去逼近真实标签y，由此就用极大似然法得到了目标函数，一个任意阶可导的凸函数，拥有非常好的数学性能。</p><script type="math/tex; mode=display">y=\frac{1}{1+e^{-(w^Tx+b)}}</script><p>求解<script type="math/tex">w,b</script>用了<strong>极大似然法</strong>，最后得到一个关于β的高阶可导连续凸函数</p><script type="math/tex; mode=display">l(β)=\sum_{i=1}^m(-y_iβ^T\hat{x_i}+\ln(1+e^{β^T\hat{x_i}}))</script><p>通过梯度下降法、牛顿法等都可求得这个函数的最优解<script type="math/tex">β^*=argmin_βl(β)</script>，逐步迭代找到最优下降路径。</p><h5 id="线性判别分析（LDA）"><a href="#线性判别分析（LDA）" class="headerlink" title="线性判别分析（LDA）"></a>线性判别分析（LDA）</h5><p>讲正例尽量投在一起，反例投一起，正反例尽可能远离，拿到新样例投上去看更接近哪。</p><p><img src="/../img/image-20221016130515153.png" alt="image-20221016130515153" style="zoom: 33%;"></p><p>椭圆表示数据簇的外轮廓，虚线表示投影， 红色实心园和实心三角形分别表示两类样本投影后的中心点。</p><p>LDA常常用于二分类问题以及多分类的降维处理，举例如图本来一个二维数据投到直线上就变成一个一维数据了，LDA的基本思想就是找到一条这样可以将两类数据分开到两边的直线，并确定一个分界点。</p><p><img src="/../img/image-20221016130906359.png" alt="image-20221016130906359"></p><p>如图，右边天蓝色的分界点就做的很好，左图就做不到。</p><p><a href="https://blog.csdn.net/qq_41876213/article/details/107695663">PCA降维</a></p><p>这里引入协方差矩阵的概念，若要做数据降维，直接简单粗暴的删掉一维数据必然不合理，因此有两种方案：</p><ol><li><p>先看每一维数据的方差，对于分散程度较小的因素而言(极端情况为一个不变的数值)说明分析的价值不大，所以可以舍弃。</p></li><li><p>但是由于各个特征之间可能是充满联系的，比如说空气质量可能会影响上班时间，一些方差小的原因可能不是该因素本身的原因，而是其它因素影响造成的，需要将这些因素之间的影响去除掉，在除掉之前先引进协方差的概念，将各维数据去中心化后得到：</p><p><img src="/../img/image-20221016131555712.png" alt="image-20221016131555712" style="zoom:50%;"></p><p>大于0正相关，等于0不相关，小于0负相关。协方差矩阵对角线位置上的数值表示方差，非对角线位置上的数值表示各因素之间的相关性。</p><p><img src="/../img/image-20221016131717029.png" alt="image-20221016131717029"></p></li></ol><p>为使各个因素之间不相关，需要一种方法对各个因素进行<strong>坐标转换</strong>使协方差矩阵转换为对角矩阵，<strong>这就是我们的求解目标。</strong></p><p>在m维空间中，令$P=[e_1 e_2 … e_m]$，求$x$在$P$组成的m维标准正交基中的坐标公式如下：</p><script type="math/tex; mode=display">[e_1 e_2 ... e_m]^T x=P^Tx</script><p>保留特征值较大的特征向量，不知道降低到多少维合适时一般按照经验判断保留到特征值所在比例为95%左右，有时候为了可视化比例可能远低于这个数值，最终降维之后的坐标为$y_j =P’^Tx_j$。</p><p><strong>二分类线性判别分析</strong></p><p>通过尽量增大两类样本中心点的距离，并尽量减小正类或反类样本各自内部的协方差，得到一个“广义瑞利商”，这就是LDA想要最大化的目标。</p><p>LDA可以从贝叶斯决策论理论的角度来阐述，并可证明，当两类数据同先验、满足高斯分布并且协方差相等时，LDA可达到最优分类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">LDA</span>(<span class="hljs-params">data, target, n_dim</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    :param data: (n_samples, n_features)</span><br><span class="hljs-string">    :param target: data class</span><br><span class="hljs-string">    :param n_dim: target dimension</span><br><span class="hljs-string">    :return: (n_samples, n_dims)</span><br><span class="hljs-string"> &#x27;&#x27;&#x27;</span>   <br>    clusters = np.unique(target)<br><br>    <span class="hljs-keyword">if</span> n_dim &gt; <span class="hljs-built_in">len</span>(clusters)-<span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;K is too much&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;please input again&quot;</span>)<br>        exit(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment">#within_class scatter matrix</span><br>    Sw = np.zeros((data.shape[<span class="hljs-number">1</span>],data.shape[<span class="hljs-number">1</span>]))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> clusters:<br>        datai = data[target == i]<br>        datai = datai-datai.mean(<span class="hljs-number">0</span>)<br>        Swi = np.mat(datai).T*np.mat(datai)<br>        Sw += Swi<br><br>    <span class="hljs-comment">#between_class scatter matrix</span><br>    SB = np.zeros((data.shape[<span class="hljs-number">1</span>],data.shape[<span class="hljs-number">1</span>]))<br>    u = data.mean(<span class="hljs-number">0</span>)  <span class="hljs-comment">#所有样本的平均值</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> clusters:<br>        Ni = data[target == i].shape[<span class="hljs-number">0</span>]<br>        ui = data[target == i].mean(<span class="hljs-number">0</span>)  <span class="hljs-comment">#某个类别的平均值</span><br>        SBi = Ni*np.mat(ui - u).T*np.mat(ui - u)<br>        SB += SBi<br>    S = np.linalg.inv(Sw)*SB<br>    eigVals,eigVects = np.linalg.eig(S)  <span class="hljs-comment">#求特征值，特征向量</span><br>    eigValInd = np.argsort(eigVals)<br>    eigValInd = eigValInd[:(-n_dim-<span class="hljs-number">1</span>):-<span class="hljs-number">1</span>]<br>    w = eigVects[:,eigValInd]<br>    data_ndim = np.dot(data, w)<br>    <span class="hljs-keyword">return</span> data_ndim<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    iris = load_iris()<br>    X = iris.data<br>    Y = iris.target<br>    target_names = iris.target_names<br>    X_r2 = LDA(X, Y, <span class="hljs-number">2</span>)<br>    colors = [<span class="hljs-string">&#x27;navy&#x27;</span>, <span class="hljs-string">&#x27;turquoise&#x27;</span>, <span class="hljs-string">&#x27;darkorange&#x27;</span>]<br>    <span class="hljs-keyword">for</span> color, i, target_name <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(colors, [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], target_names):<br>        plt.scatter(X_r2[Y == i, <span class="hljs-number">0</span>], X_r2[Y == i, <span class="hljs-number">1</span>], alpha=<span class="hljs-number">.8</span>, color=color,<br>                label=target_name)<br>    plt.legend(loc=<span class="hljs-string">&#x27;best&#x27;</span>, shadow=<span class="hljs-literal">False</span>, scatterpoints=<span class="hljs-number">1</span>)<br>    plt.title(<span class="hljs-string">&#x27;LDA of IRIS dataset by Python&#x27;</span>)<br>    plt.show()<br></code></pre></td></tr></table></figure><p>多分类LDA的均值向量仍然是所有样本的均值向量，类内散度矩阵则重定义为每个类别的散度矩阵之和，最后常见的采用的优化目标是最大化</p><p><img src="/../img/image-20221016144004468.png" alt="image-20221016144004468" style="zoom: 50%;"></p><p>看下图，全局均值到类内均值的距离就是$S_b$，类内样本间的距离就是$S_w$，也就是说，尽量增加每一类中心点到全局中心点的距离，尽量缩小每一类内部样本的协方差。</p><p><img src="/../img/image-20221016142851974.png" alt="image-20221016142851974" style="zoom:33%;"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment"># 这是sklearn中实现的LDA，待会我们会比较自己实现的LDA和它的区别</span><br><span class="hljs-keyword">from</span> sklearn.discriminant_analysis <span class="hljs-keyword">import</span> LinearDiscriminantAnalysis<br><br><span class="hljs-comment"># k为目标</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">LDA</span>(<span class="hljs-params">X, y, k</span>):<br>    label_ = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(y))<br>    X_classify = &#123;&#125;<br>    <span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> label_:<br>        X1 = np.array([X[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(X)) <span class="hljs-keyword">if</span> y[i] == label])<br>        X_classify[label] = X1<br><br>    miu = np.mean(X, axis=<span class="hljs-number">0</span>)<br>    miu_classify = &#123;&#125;<br>    <span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> label_:<br>        miu1 = np.mean(X_classify[label], axis=<span class="hljs-number">0</span>)<br>        miu_classify[label] = miu1<br><br>    <span class="hljs-comment"># St = np.dot((X - mju).T, X - mju)</span><br>    <span class="hljs-comment"># 计算类内散度矩阵Sw</span><br>    Sw = np.zeros((<span class="hljs-built_in">len</span>(miu), <span class="hljs-built_in">len</span>(miu)))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> label_:<br>        Sw += np.dot((X_classify[i] - miu_classify[i]).T, X_classify[i] - miu_classify[i])<br><br>    <span class="hljs-comment">#Sb = St-Sw</span><br>    <span class="hljs-comment"># 计算类内散度矩阵Sb</span><br>    Sb = np.zeros((<span class="hljs-built_in">len</span>(miu), <span class="hljs-built_in">len</span>(miu)))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> label_:<br>        Sb += <span class="hljs-built_in">len</span>(X_classify[i]) * np.dot((miu_classify[i] - miu).reshape(<br>            (<span class="hljs-built_in">len</span>(miu), <span class="hljs-number">1</span>)), (miu_classify[i] - miu).reshape((<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(miu))))<br><br>    <span class="hljs-comment"># 计算S_w^&#123;-1&#125;S_b的特征值和特征矩阵</span><br>    eig_vals, eig_vecs = np.linalg.eig(np.linalg.inv(Sw).dot(Sb))<br>    sorted_indices = np.argsort(eig_vals)<br>    <span class="hljs-comment"># 提取前k个特征向量</span><br>    topk_eig_vecs = eig_vecs[:, sorted_indices[:-k - <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]]<br>    <span class="hljs-keyword">return</span> topk_eig_vecs<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    iris = load_iris()<br>    X = iris.data<br>    y = iris.target<br><br>    W = LDA(X, y, <span class="hljs-number">2</span>)<br>    X_new = np.dot(X, W)<br>    plt.scatter(X_new[:, <span class="hljs-number">0</span>], X_new[:, <span class="hljs-number">1</span>], marker=<span class="hljs-string">&#x27;o&#x27;</span>, c=y)<br>    plt.show()<br><br>    <span class="hljs-comment"># 和sklearn的函数对比</span><br>    lda = LinearDiscriminantAnalysis(n_components=<span class="hljs-number">2</span>)<br>    lda.fit(X, y)<br>    X_new = lda.transform(X)<br>    plt.scatter(X_new[:, <span class="hljs-number">0</span>], X_new[:, <span class="hljs-number">1</span>], marker=<span class="hljs-string">&#x27;o&#x27;</span>, c=y)<br>    plt.show()<br>main()<br><br></code></pre></td></tr></table></figure><h4 id="多分类学习"><a href="#多分类学习" class="headerlink" title="多分类学习"></a>多分类学习</h4><p>多分类学习有两个思路。一种是将二分类算法变形之后推广到多分类，比如上一节讲到的LDA。另一种则是利用二分类的学习器来解决多分类问题。下面讨论第二种，即用拆解法将多分类任务拆为若干个二分类任务求解。</p><p><strong>拆解法步骤：</strong></p><ol><li><p>通过拆分策略对问题进行【<strong>拆分】</strong>；</p></li><li><p>为拆分出的每个二分类任务【<strong>训练】</strong>一个分类器；</p></li><li><p>对各个分类器的结果进行【<strong>集成】</strong>，以获得多分类结果。</p></li></ol><p><strong>［1］“一对一”（One vs One，简称OvO）</strong></p><p>OvO将所有类别两两配对，一个作为正类，一个作为反类，从而产生$N(N-1)/2$个二分类任务。把最后得到的每个分类结果进行统计，被预测次数最多的类别作为最终结果。</p><p><strong>［2］“一对其余”（One vs Rest，简称OvR）</strong></p><p>将N个分类中的一个类作为正例，其余均设置为反例，从而【拆分】成N个分类任务；【训练】得到N个分类结果；【集成】的方法是考虑各被判为正例的分类器的置信度，选择置信度大的类别标记作为分类的结果。</p><p><img src="/../img/image-20221016145205366.png" alt="image-20221016145205366" style="zoom:50%;"></p><p>二者对比：OVO的分类器数量很大，存储开销和测试时间开销通常比OvR更大，但是OVO用到的训练样本很少，因此，在类别很多时，OvO的训练时间开销通常比OvR更小。至于预测性能，则取决于具体的数据分布，在多数情形下两者差不多。</p><p><strong>［3］“多对多”（Many vs Many，简称MvM）</strong></p><p>每次将若干个类别作为正类，若干个其它类作为反类。分类方法采用ECOC编码，不想看了。</p><p><a href="https://blog.csdn.net/lafengxiaoyu/article/details/107886065">ECOC编码详解</a></p><h4 id="类别不平衡问题"><a href="#类别不平衡问题" class="headerlink" title="类别不平衡问题"></a>类别不平衡问题</h4><p>目前类别不平衡性学习的一个基本策略是“再缩放”（rescaling），现有技术大体上有以下三种做法：</p><p><strong>［1］欠采样（undersampling）</strong></p><p>哪类样本多，去掉哪一类，让两类样本数目接近。</p><p>代表性算法EasyEnsemble：在反例多的情况下，把反例分给多个学习器，这样每个学习器学到的正反类样本数目就差不多了，而且还不会丢失重要信息。</p><p><strong>［2］过采样（oversampling）</strong></p><p>哪类样本多，增加哪一类，让两类样本数目接近。</p><p>但也不能简单地对初始正例样本进行重复采样，否则会招致严重的过拟合。代表性算法SMOTE是通过对训练集里的正例进行插值来产生额外的正例。</p><p><strong>［3］阈值移动（threshold-moving）</strong></p><p>一般我们认为正反类发生的概率都是0.5，但是在两类样本不平衡的条件下，分类器决策规则为</p><script type="math/tex; mode=display">\frac{ y'} { (1 - y') }= \frac{y} {(1 - y)} \times \frac{m^-}{m^+} > 1</script><p>时，预测为正例——这就是“再缩放”。</p><p>当正类概率大于反类概率时，我们判定结果为正类，也就是：</p><p><img src="/../img/image-20221016154116050.png" alt="image-20221016154116050" style="zoom:50%;"></p><h3 id="四、决策树"><a href="#四、决策树" class="headerlink" title="四、决策树"></a>四、决策树</h3><p>决策树需要分类结果已知的监管学习，决策树在逻辑上以树的形式存在，包含<strong>根节点、内部结点和叶节点</strong>。</p><ul><li>根节点：包含数据集中的所有数据</li><li>内部节点：一个包含符合该判断条件的所有数据的集合。</li><li>叶节点：可以得出最终分类结果的节点。</li></ul><p>一般的原则是，希望通过不断划分节点，使得一个分支节点包含的数据尽可能的属于同一个类别，即“纯度“越来越高，举个例子：</p><p><img src="/../img/image-20221016174520050.png" alt="image-20221016174520050" style="zoom:50%;"></p><p><img src="/../img/image-20221016174536199.png" alt="image-20221016174536199" style="zoom:50%;"></p><p><img src="/../img/image-20221016174557843.png" alt="image-20221016174557843" style="zoom:50%;"></p><p><img src="/../img/image-20221016174620982.png" alt="image-20221016174620982" style="zoom:50%;"></p><p><img src="/../img/image-20221016174637143.png" alt="image-20221016174637143" style="zoom:50%;"></p><p>可知决策树的生成只需要两步：</p><ol><li>节点的分裂：当该节点无法给出最终分类结果，会继续生成判断条件。</li><li>阈值的确定：选择适当的阈值使得分类错误率最小 （Training Error）。</li></ol><p>停止分裂的三种情况：</p><ul><li>没必要分裂：所有样本在当前节点有相同的标签，比如图中分到最后每一类里只有一种类别了。</li><li>没办法分裂：当前分布集合是空的或者所有样本在所有的分布都相同</li><li>没数据分裂：当前节点是空的或者由父节点直接分配了主标签</li></ul><p>决策树学习的关键在于如何选择最好的划分属性，即确定这个阈值，使决策树随着划分过程的进行，使得一个分支节点包含的数据尽可能的属于同一个类别，也就是节点的“纯度”能越来越高。</p><p>常用的最优属性选取方法有三种：</p><ul><li>信息增益：在 ID3 决策树中使用</li><li>信息增益率：在 C4.5 决策树中使用</li><li>基尼系数：在 CART 决策树中使用</li></ul><h4 id="常用划分准则"><a href="#常用划分准则" class="headerlink" title="常用划分准则"></a>常用划分准则</h4><h5 id="信息增益准则"><a href="#信息增益准则" class="headerlink" title="信息增益准则"></a>信息增益准则</h5><p>我们先对一个节点的纯度进行定义，我们将其称之为<strong>信息熵</strong>，代表着一种信息的混乱程度，当它的确定性越大，它的信息熵就越小。</p><p><img src="/../img/image-20221016175531401.png" alt="image-20221016175531401" style="zoom:50%;"></p><p>其中$p_k$代表当前节点D的数据中第k类样本所占的比例，</p><p><img src="/../img/image-20221016181555097.png" alt="image-20221016181555097" style="zoom:50%;"></p><p>蓝线是基尼系数的分布，黑线是熵的分布，这是一个二分类的布局，最小值为0，最大值为各类概率相等时，混乱程度最大。</p><p>定义一个信息增益，$D$代表整个数据集，$D^v$代表第$v$个节点下的数据集。</p><p><img src="/../img/image-20221016220629446.png" alt="image-20221016220629446" style="zoom:50%;"></p><p>光看这个式子可能难以理解，看书上的例子：</p><p><img src="/../img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzU5NTI0ODk3,size_16,color_FFFFFF,t_70.jpeg" alt="img"></p><p>举例以“a=色泽”的情况下，可以分成三个子集合v={绿，白，黑}，分别有{6,6,5}个样本，没个集合中正例和反例的数量分别代入信息熵可得：</p><p><img src="/../img/image-20221017163045713.png" alt="image-20221017163045713" style="zoom: 33%;"></p><p>最后计算总的<strong>色泽</strong>的信息增益：</p><p><img src="/../img/20201123212936414.png" alt="img" style="zoom:67%;"></p><p>然后继续分裂。</p><p>也就是说，对每一个节点信息增益的计算包括：</p><ul><li>对该层正反例进行计数，算出该层节点的信息熵。</li><li>选择下一层的划分属性，对每一个划分属性计算信息熵。</li><li>乘以该属性的样本数量占上一层总样本数量的权重，代入信息增益公式。</li><li>比较每一种划分属性的信息增益大小，选择最大的为该层划分属性。</li></ul><p>观察该过程，可以得到：</p><ol><li>第一项$Ent(D)$是确定的，是整个节点的信息熵，可以当成定值。</li><li>$D^v/D$表示分支节点所占比例的大小，数据集越大的分支节点权重越高。</li><li>分支节点整体纯度越大，分类越好，信息熵越小，后一项就越小，信息增益Gain就变得越大，所以我们的目标是如何<strong>最大化信息增益</strong>。</li></ol><p>由此，我们依据这个，<strong>计算以每个属性进行划分子节点得到的信息增益，选择其中最大的作为选择的属性。</strong></p><h5 id="信息增益率准则"><a href="#信息增益率准则" class="headerlink" title="信息增益率准则"></a>信息增益率准则</h5><p>当分支节点很多时，每个节点的数据量就会变得很小，得到的Gain值就越大，这样会导致<strong>信息熵准则偏爱那些分类数目较多的属性</strong>。</p><p>为了解决该问题，这里引入了信息增益率，定义如下：</p><p><img src="/../img/image-20221016224649861.png" alt="image-20221016224649861" style="zoom:50%;"></p><p>引入修正项IV(a)，它是是分布a的固有属性。属性a的可能取值越多（即V越大），则IV(a)的值通常会越大（以此调整也越大的信息增益），</p><p><img src="/../img/image-20221016224832567.png" alt="image-20221016224832567" style="zoom:50%;"></p><p>需注意，信息增益率对可取值数目较少的属性有所偏好，因此C4.5算法并不是直接根据增益率选择最优划分属性，而是使用了一个启发式：</p><ol><li>先从候选划分属性中选择出信息增益高于平均水平的几个属性</li><li>再从选择出的属性中选择增益率最高的属性作为划分属性</li></ol><p>即C4.5选择的最优划分属性是<strong>信息增益高于平均水平且信息增益率最大</strong>的属性。</p><h5 id="基尼指数-Gini-index"><a href="#基尼指数-Gini-index" class="headerlink" title="基尼指数(Gini index)"></a>基尼指数(Gini index)</h5><p>数据集<em>D</em>的纯度可用基尼值来度量：</p><p><img src="/../img/image-20221017165621389.png" alt="image-20221017165621389" style="zoom: 50%;"></p><p>直观来说，Gini(D)反映了从数据集D中随机抽取两个样本，其类别标记不同的概率。因此，Gini(D)越小，抽到的样例类别相同的概率越大，数据集D的纯度越高。属性<em>a</em>的基尼指数定义为：</p><p><img src="/../img/image-20221017165923354.png" alt="image-20221017165923354" style="zoom:50%;"></p><p>以西瓜集中“a=触感”举例，基尼值为：</p><p><img src="/../img/image-20221017171024738.png" alt="image-20221017171024738" style="zoom:50%;"></p><p>我们在候选属性中选择使得划分后基尼指数最小的属性作为最优划分属性。</p><h4 id="剪枝处理"><a href="#剪枝处理" class="headerlink" title="剪枝处理"></a>剪枝处理</h4><p>过拟合</p><ul><li><p>太多的分支会让数据集在训练集上做的过好，而泛化能力不咋地。</p></li><li><p>过拟合的风险可以通过剪枝来解决。</p></li></ul><p>剪枝策略</p><ul><li>前剪枝(Pre-pruning)，在生成过程就对每个节点进行估计，如果不能提高泛化能力，就提前停止分支的增长。</li><li>后剪枝(Post-pruning)，在生成决策树之后，再自下而上地对子节点进行考察，如果替换成叶节点可以提高泛化能力，那就替换。</li><li>将分支剪除就相当于把它替换成叶节点。</li></ul><p>如何决定要不要剪枝呢？也就是说，如何判断泛化性能是否能提升呢？</p><p>把训练集预留一部分做验证集，这就叫做留出法(hold-out)。具体做法为：</p><ol><li>把数据集分成两部分训练集和测试集</li><li>分层采样(Stratified sampling)，让训练集和测试集有相似的分布</li><li>多次随机采样，用平均分数来评价训练集的泛化指标</li></ol><h5 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h5><p><img src="/../img/5bc728ec80d34.png" alt="8.png"></p><p>这是原决策树，现在用预剪枝看脐部这个属性节点，把下属节点全标记为叶节点，按正反比率分个类，再把验证集带进去。</p><p>对1节点，随便设它为一个分类为正类的叶节点，发现划分正确率仅为42.9%，远没有划分一下正确率高，因此我们还是决定对脐部进行分类。</p><p>对2,3,4节点，看看是之前分的非常细的决策树准确率高还是直接分的准确率高，如果是直接分更高或者差不了多少的话，相当于它之前的活就白干了，直接在这分类就行了。</p><p><img src="/../img/5bc728ec9e330.png" alt="9.png"></p><p>得出的结果是1节点要分，2节点别分了，直接确定为一个“好瓜”的叶节点，3节点也别分，直接确定为一个“好瓜”的叶节点，4节点本来就分到头了，不用再看了。</p><p>最后得到一棵仅有一层划分的决策树，也叫做“决策树桩”。</p><h5 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h5><p><img src="/../img/5bc728ec9d497.png" alt="10.png"></p><p>预剪枝的顺序是1-2-3-4-5，后剪枝则是5-2-3-4-1。</p><p>最终得到的决策树如上图所示，可以看出其保留分支明显多于预剪枝。并且是在生成决策树后再进行剪枝的，因此欠拟合风险很小，泛化性能往往优于预剪枝，但由于其自下而上的进行剪枝，相当于遍历了所有的节点，训练开支要远大于预剪枝。</p><h4 id="连续值与缺失值处理"><a href="#连续值与缺失值处理" class="headerlink" title="连续值与缺失值处理"></a>连续值与缺失值处理</h4><h5 id="连续值处理"><a href="#连续值处理" class="headerlink" title="连续值处理"></a>连续值处理</h5><p>前面用的都是“好瓜”“坏瓜”这样的离散值来生成决策树，但现实任务中常会遇到连续属性。</p><p>最简单的策略是采用二分法，相当于该连续属性是每次都只有两个取值（小于等于 t 和大于 t）的离散属性，以此来划分样本。</p><p>对样本的所有连续值进行排序，依次对连续的两个样本值取中位数，然后对这些候选中位数t选取信息增益最大的一个。</p><p><img src="/../img/20190522235120722.png" alt="在这里插入图片描述"></p><p>需注意，和离散属性只分一次不同，连续属性可多次划分，例如在父节点判断”密度&gt;0.33”之后，子节点还可以判断”密度&gt;0.66”。</p><h5 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h5><p>如何在属性值缺失的情况下进行划分属性选择？</p><p>为了不浪费数据，将总样本分布视为无缺失分布，用无缺失值的样本所占比例 p 来修正计算出的无缺失样本集的信息增益$Gain(\tilde D, a )$ ，以此来近似为全部样本的信息增益$Gain( D , a )$：</p><p><img src="/../img/image-20221017204027501.png" alt="image-20221017204027501" style="zoom:50%;"></p><p>得到该属性的信息增益后就可以进行与其他属性的比较，选择划分属性。</p><p>样本在划分属性上缺失值，如何对样本进行划分？</p><p>将缺值样本划入所有子节点，且以不同的概率划分到子节点中，权重大小由$r_v$决定。</p><h4 id="多变量决策树"><a href="#多变量决策树" class="headerlink" title="多变量决策树"></a>多变量决策树</h4><p>将每个属性视为坐标空间中的一个维度，也就是一个坐标轴，对样本分类就意味着在这个坐标空间中寻找不同类样本的分类边界。</p><p>决策树形成的分类边界由若干个与坐标轴平行的分段组成，这些分类边界使得学习结果有较好的可解释性，因为每一段划分都对应了一个属性的取值的划分，比如：</p><p><img src="/../img/image-20221017214852110.png" alt="image-20221017214852110" style="zoom:50%;"></p><p>但是，当学习任务的真实分类边界比较复杂时，就需要有很多的分段才能有较好的近似，此时的决策树会相当复杂，需进行大量属性测试，时间开销很大。</p><p><img src="/../img/image-20221017221146620.png" alt="image-20221017221146620" style="zoom:50%;"></p><p>多变量决策树正是适合能实现这样的“斜划分”甚至更复杂划分的决策树，从简单的判断属性变成一个$\sum w_ia_i =t$这样的线性分类器。</p><p><img src="/../img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWNoZW5zdXl1,size_16,color_FFFFFF,t_70.png" alt="img"></p><h4 id="阅读材料"><a href="#阅读材料" class="headerlink" title="阅读材料"></a>阅读材料</h4><p>除了信息增益，增益率，基尼指数之外，还有许多其他准则用于决策树划分选择，要注意的是，虽然这些准则对决策树的尺寸有较大影响，但<strong>对泛化性能影响很有限</strong>。</p><p>本质上，各种特征选择方法均可用于决策树的划分属性选择。</p><p>信息增益和基尼指数仅在2%的情况下会有所不同。</p><p><strong>剪枝方法和程度对决策树的泛化性能的影响相当显著</strong>，在数据带有噪声时通过剪枝甚至可将决策树的泛化性能提高25%。</p><p>OC1先贪心地寻找每个属性的最优权值，在局部优化的基础上再对分类边界进行随机扰动以试图找到更好的边界。</p><p>一些多变量决策树算法在决策树的叶结点上嵌入神经网络，以结合这两种学习机制的优势（如感知机树）。</p><h3 id="五、神经网络"><a href="#五、神经网络" class="headerlink" title="五、神经网络"></a>五、神经网络</h3><p>神经网络原理：当神经网络中的某个神经元的电位超过了一个阈值(threshold)，那么它就会被激活，向其他神经元发送化学物质。把许多这样的神经元按一定的层次结构连接起来，就得到了神经网络。</p><p>M-P神经元模型就是从生物神经网络中抽象出来的。</p><h4 id="感知机与多层网络"><a href="#感知机与多层网络" class="headerlink" title="感知机与多层网络"></a>感知机与多层网络</h4><p>感知机(Perception)由两层神经元组成，输入层接受外界输入信号后传递给输出层。学习过程：通过逐个样本输入来更新权重，先初始化权重(一般为随机)，再逐个地输入样本数据，若输出值与真实标记一致则继续输入下一个样本，否则更新权重，再开始重新逐个检验，直到所有的样本的输出值与真实标记一致。</p><p>感知机只拥有一层功能神经元，其学习能力非常有限，只能处理线性可分的问题。</p><blockquote><p>如果用一个线性函数可以将两类样本完全分开，就称这些样本是“线性可分”的。</p></blockquote><ul><li>对于线性可分的问题，感知机的学习过程总能收敛而找到合适的模型参数，即感知机模型总能将训练数据(不是测试数据)的每一个样本都预测正确，但也容易产生过拟合问题。</li><li>对于线性不可分的问题(如异或问题，需要两条平行的分割线)，则需要用多层功能神经元，把原本不可分的数据投射到高维上，可能就变得可分了。</li></ul><p>考虑到现实任务的复杂性，常见的神经网络是层级结构，这样的神经网络结构通常称为“多层前馈神经网络”(multi-layer feedforward neural networks)。</p><p><img src="/../img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWNoZW5zdXl1,size_16,color_FFFFFF,t_70-20221018215403315.png" alt="img"></p><p>神经网络的学习过程就是：根据训练数据来调整神经元之间的连接权和每个功能神经元的阈值，直到每个数据都能够分类正确，或误差在标准之内。</p><h4 id="BP算法"><a href="#BP算法" class="headerlink" title="BP算法"></a>BP算法</h4><p>多层网络比单层的感知机复杂多了，因此需要更强大的学习算法，误差逆传播(error BackPropagation，简称BP)算法是迄今为止最成功的神经网络学习算法。</p><p><img src="/../img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWNoZW5zdXl1,size_16,color_FFFFFF,t_70-20221018215735459.png" alt="img"></p><p>随机初始化模型参数，根据输入预测出实值向量$\hat y_j$后，得到它和实际$y_j$的均方误差，通过最小化这个均方误差来获得最优的模型参数。</p><p>迭代过程选择梯度下降法，找到均方误差函数每一个参数的最速下降方向，用一个0-1之间的学习率$\mu$来乘这个梯度，每次沿着这个梯度下降$\mu$，直到达到停止条件。为达到精细调节的目的，每个参数的$\mu$不一定要相等。</p><p>以下是BP算法的工作流程：</p><p><img src="/../img/image-20221018220608802.png" alt="image-20221018220608802" style="zoom:50%;"></p><p>从repeat循环和for循环可以看出，一旦某个样例$(x_k,y_k)$的预测输出与实际$y$值不一样，使得各参数做出更新，就要开始新一轮迭代，重新从$y_1$开始检验，直到每一个样例的预测输出都符合我们的预期为止。</p><p>具体的数据流过程为：输入示例传给输入层，正向传递到输出层产生一个输出结果，然后计算与实际$y$值的误差(第4-5行)，再将误差反向传播到隐层神经元算出这一步神经元的梯度(第6行)，根据梯度和学习率对模型参数进行调整后(第7行)，再回到第3行。</p><p>这是基于for循环下的单个训练数据的$E_k$而进行的（虽然最终效果还是最小化累积误差），若类似地推导出基于累积误差最小化的更新规则（即在读取整个训练集一遍后才对参数进行更新），就得到了累积误差逆传播算法。但在很多任务中，累积误差下降到一定程度之后，进一步下降会非常缓慢，这时标准BP往往会更快获得较好的解，尤其是在训练集D非常大时更明显。</p><p><a href="https://blog.csdn.net/mynameisgt/article/details/115644410?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-115644410-blog-89704075.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-115644410-blog-89704075.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=8">标准BP和累积BP的区别代码</a></p><p>两种方法的缺点？<strong>标准BP</strong>：震荡；<strong>累积BP</strong>：大样本时下降速度慢。</p><p>多层前馈神经网络有强大的表示能力，已证明只要隐层包含的神经元数量足够多，它就能以任意精度逼近任意复杂度的连续函数。</p><p>但是，如何设置隐层神经元的个数仍是个未决问题，实际应用中通常靠“试错法”(trail-by-error)调整。</p><blockquote><p>试错法：为了追求达到理想目标而通过不断试验和消除误差，探索具有黑箱性质的系统的方法。统称为试错法</p></blockquote><p>BP神经网络过拟合的缓解方法：</p><p>由于多层前馈网络的强大表示能力，经常遇到这样的情况：训练误差持续降低，但测试误差却在上升，这就是BP神经网络经常遭遇的过拟合问题。通常，有以下两种方法缓解BP网络的过拟合：</p><ol><li>“早停(early stopping)”：将数据分成训练集和验证集，训练集用来训练神经网络，验证集用来估计误差。若训练集误差降低但验证集误差升高，则停止训练，同时返回具有最小验证集误差的连接权和阈值。</li><li>“正则化(regularization)”：其基本思想是在误差目标函数中增加一个用于描述网络复杂度的部分，例如连接权与阈值的平方和。</li></ol><p>仍令$E_k$表示第k个训练样例上的误差，则误差目标函数改变为：</p><p><img src="/../img/20190708143448576.png" alt="img" style="zoom:50%;"></p><p>其中$λ ∈ ( 0 , 1 )$用于对经验误差与网络复杂度这两项进行折中，常通过交叉验证法来估计。</p><blockquote><p><strong>将数据划分为n份，依次使用其中一份作为测试集，其他n-1份作为训练集，多次计算模型的精确性来评估模型的平均准确程度</strong>。</p></blockquote><h4 id="全局最小与局部最小"><a href="#全局最小与局部最小" class="headerlink" title="全局最小与局部最小"></a>全局最小与局部最小</h4><p>看这个图就已经非常形象了，梯度下降是最常用的参数寻优方法，在此类方法中，我们从某些初始解出发，迭代寻找最优参数值，每次迭代中，我们先计算误差函数在当前点的梯度，然后根据梯度确定搜索方向。</p><p><img src="/../img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoMTgzMjgwNzE1ODA=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" style="zoom:67%;"></p><p>如果误差函数具有多个局部极小，则不能保证找到的解是全局最小，这显然不是我们所希望的。</p><p>在现实任务中，通常采用以下策略来试图“跳出”局部极小，从而进一步接近全局最小：</p><ol><li>采用多个不同参数值初始化多个神经网络，按标准方法训练后，取其中误差最小的解作为最终参数。</li><li>使用模拟退火技术。模拟退火在每一步都以一定的概率接受比当前解更差的结果，从而有助于“跳出”局部极小。在每步迭代过程中，接受“次优解”的概率要随着时间的推移而逐渐降低，从而保证算法稳定。</li><li>使用随机梯度下降，与标准梯度下降法精确计算梯度不同，随机梯度下降法在计算梯度时加入了随机因素（随机选取训练数据中的特例），相当于是梯度下降的平滑版本，减少了非常多的计算量，并且即便陷入局部极小点，它计算出的梯度仍可能不为零，这样就有机会跳出局部极小继续搜索。</li><li>此外，遗传算法也常用来训练神经网络以更好地逼近全局最小。</li></ol><p>模拟退火具体步骤：设置一个初始高温，当温度越大的时候，分子运动越剧烈，也就是说，x移动的幅度也就越大，在移动一次后，当得到的新的$f(x)$值更好的话，我们要么直接用新的x取代当前位置，要么以一个概率接受原来不怎么好的旧值，打个比方，如果基于贪心的思想，让x永远只接受更好的新位置，那么在下图中，随着迭代次数增多，温度下降，分子运动越微弱，x能移动的距离越小，$x_0$就很容易会陷入左边那个局部最大值，但是如果它没有接受新值，而是在旧的位置上，那么它下一次运动时就有更大的概率可以摇摆到左边那座山上去，找到真正的全局最优值。</p><p><img src="/../img/image-20221019000546114.png" alt="image-20221019000546114" style="zoom:50%;"></p><h4 id="BP算法的改进"><a href="#BP算法的改进" class="headerlink" title="BP算法的改进"></a>BP算法的改进</h4><h5 id="引入动量法"><a href="#引入动量法" class="headerlink" title="引入动量法"></a>引入动量法</h5><p>标准BP算法实质上是一种简单的最速下降静态寻优算法，没有考虑积累的经验，即以前的梯度方向，从而使学习过程振荡，收敛缓慢。</p><p>我们的目的是，假如梯度下降得到的路径一直是沿着一个向右的方向前进着，只不过会在上下方向上来回做没用的震荡，我们会基于前面这些步的经验，考虑在算法上减少上下分量的影响，增加左右方向上的影响，这就是动量法的基本思想。</p><p><img src="/../img/2019070814472366.png" alt="img" style="zoom:67%;"></p><p>$D(k)$为k时刻的梯度，$\alpha$为学习率，$\mu$为动量项因子，通常介于0-1之间。</p><p>所加入的动量项实质上相当于阻尼项，它减小了学习过程的振荡趋势，改善了收敛性，是一种应用比较广泛的改进算法。</p><h5 id="尺度变换法"><a href="#尺度变换法" class="headerlink" title="尺度变换法"></a>尺度变换法</h5><p>标准BP学习算法采用的是一阶梯度法，因而收敛较慢。若采用二阶梯度法，则可以大大提高收敛性。</p><p><img src="/../img/20190708144956306.png" alt="img" style="zoom:80%;"></p><p>虽然二阶梯度法具有较好的收敛性，但是需要计算E对w的 二阶导数，这个计算量很大。所以一般不直接采用二阶梯度法，而常常采用变尺度法或共轭梯度法，它们具有如二阶梯度法收敛较快的优点，又无需直接计算二阶梯度。<br><img src="/../img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoMTgzMjgwNzE1ODA=,size_16,color_FFFFFF,t_70-20221019003334577.png" alt="img" style="zoom:80%;"></p><h5 id="自适应学习率调整法"><a href="#自适应学习率调整法" class="headerlink" title="自适应学习率调整法"></a>自适应学习率调整法</h5><p>在BP算法中，网络权值的调整取决于学习速率和梯度。</p><p><strong>自适应学习率调整准则是</strong>：检查权值的修正是否真正降低了误差函数，当连续两次迭代其梯度方向相同时，表明下降太慢，这时可使步长加倍；当连续两次迭代其梯度方向相反时，表明下降过头，这时可使步长减半。</p><p><img src="/../img/20190708145150247.png" alt="img"></p><h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><p>理论上，参数越多的模型复杂度越高，容量越大，能完成更复杂的任务。但一般情况下，复杂模型的训练效率低，易陷入过拟合。训练效率低可由算力的提升解决，过拟合可由数据规模的增大有所缓解。因此，以深度学习为代表的复杂模型开始受到关注。</p><p>对于神经网络模型，提高容量的一个简单方法就是增加隐层的数量。从增加模型复杂度的角度看，增加隐层的数目显然比增加隐层神经元的数目更有效。因为增加隐层数不仅增加了拥有激活函数的神经元数目，还增加了激活函数嵌套的层数。</p><p>多隐层神经网络难以直接用经典算法（如标准BP算法）进行训练，因为误差在多隐层内逆传播往往会发散而不能收敛。</p><p>无监督逐层训练（unsupervised layer-wise training）是多隐层神经网的训练的有效手段，其基本思想是：</p><p>每次训练一层隐结点，训练时将上一层隐结点的输出作为输入，而本层隐结点的输出又作为下一层隐结点的输入，这称为“预训练”(pre-training)。</p><p>预训练全部完成后，再对整个网络进行微调（fine-tuning）训练，预训练+微调的做法可视为：对每组先找到局部看起来比较好的设置，然后再基于这些局部较优的结果联合起来进行全局寻优。<br>这样就在利用模型大量参数所提供的自由度的同时，有效地节省了训练开销。</p><p>还有一种节省训练开销的策略是权共享(weight sharing)，即让一组神经元使用相同的连接权。这种策略在卷积神经网络（CNN）中发挥了重要作用。</p><h3 id="六、支持向量机"><a href="#六、支持向量机" class="headerlink" title="六、支持向量机"></a>六、支持向量机</h3><p>支持向量机（Support Vector Machine），简称SVM，是一种经典的二分类模型，属于监督学习算法。因为很多损失函数都不是凸优化问题，容易陷入局部最优，SVM把优化目标定为间隔最大化，就转化为了一个凸二次规划求解的问题。</p><h4 id="间隔与支持向量"><a href="#间隔与支持向量" class="headerlink" title="间隔与支持向量"></a>间隔与支持向量</h4><p>对于二分类问题，其基本思想就是基于训练集$D$在样本空间中找到一个用来划分的超平面，将不同类别的样本分开。</p><p>但仅仅是将样本分开的话，可以找到许多个划分超平面。从几何意义易知，粗线对训练样本局部的<strong>扰动的容忍性</strong>最好（考虑到噪声等因素，其他的超平面训练样本很容易越界，分类结果很不稳定），也是最<strong>鲁棒</strong>的（即当新的数据点加入时，超平面对这些点的适应性最强，出错的可能性最小）。于是<strong>同时离两类样本都尽量远</strong>的粗线就是我们想要的最优划分超平面。</p><p><img src="/../img/image-20221019132945679.png" alt="image-20221019132945679" style="zoom:50%;"></p><p><strong>超平面方程</strong>：样本空间中，用来描述超平面的线性方程为：</p><script type="math/tex; mode=display">W^TX+b=0</script><p>其中$W=(w_1;w_2;…;w_d)$为法向量，决定了超平面的方向；$b$为位移项，决定了超平面与原点之间的距离。</p><p><strong>约束条件</strong>：假设超平面$(W，b)$能将训练样本正确分类，即对于$(x_i,y_i)\in D$，若$y_i=+1$，则有$w^Tx_i+b&gt;0$；若$y_i=-1$，则有$w^Tx_i+b&lt;0$​，令</p><script type="math/tex; mode=display">\begin{cases}w^Tx_i+b\geq+1, & y_i=+1\\w^Tx_i+b\leq-1, &  y_i=-1\end{cases}</script><p>为超平面将训练样本正确分类的约束条件，如下图所示，距离超平面最近的三个训练样本使得约束条件中的等号成立，它们就是支持向量，支持向量到超平面的距离就是软间隔。</p><p><img src="/../img/image-20221019134926382.png" alt="image-20221019134926382" style="zoom:50%;"></p><p>我们的目标是最大化这个软间隔，因此只用关注支持向量就可以了，别的点可以都忽略，因为只要支持向量满足约束条件，别的点一定都能满足。</p><p>SVM公式推导</p><p>目标函数：$\max margin(W,b)$，其中$margin$就是所有点中离平面最近的点到平面的距离：</p><script type="math/tex; mode=display">margin(W,b)=\min_ {i=1,2,...,N} \frac{1}{||W||_2}\cdot|W^TX^{(i)}+b|</script><p>点到平面距离公式的推导：</p><p><img src="/../img/image-20221019141221799.png" alt="image-20221019141221799" style="zoom:50%;"></p><p>求$x$到平面$f(x)$的间距，先求$x$到$f(x)$的梯度，单位化之后得到一个单位法向量，再乘$x$到$f(x)$上任意一点的向量，得到在法向量方向上的投影，就是点到平面的距离。</p><p>原理：两向量相乘，二者内积就等于一个是一方对另一方的贡献 。几何意义就是向量a在向量b方向上的投影与向量b的模的乘积。</p><p>以上是软间隔的推导过程，但还需要保证分类也是正确的，即保证Y=+1类f(x)都大于0，Y=-1类f(x)都小于0，即$Y^i(W^TX^i+b)&gt;0$，$(X^i,Y^i)$是样本数据。有了这个约束条件，保证了分类的正确后，还可以把距离$H$更简化，</p><p><img src="/../img/image-20221004160750128-6161181.png" alt="image-20221004160750128" style="zoom: 67%;"></p><p>做出左边最后一行的变形，虽然$H$的结果不变，但是括号内的直线部分却发生了变化，为了缩小我们想要的$H$的范围，我们直接把样本点限定在位于边界的支持向量上，令绝对值里的部分强行等于1，于是就又多了一个约束条件。</p><p>因为有绝对值的存在，所以要加上标签$Y$，这样在分类正确的前提下，若$(W^TX^i+b)&gt;0$属于正类，标签就是+1，若$(W^TX^i+b)&lt;0$属于反类，标签就是-1，标签$Y$就起到了绝对值的作用，保证了函数的连续可微性。</p><p>因此，最后就得到了SVM的目标函数：</p><script type="math/tex; mode=display">min \frac{1}{2}||w||^2\\s.t.\ Y^i(W^TX^i+b)\geq1,\ i=1,2,...,N</script><p>这也是支持向量机的基本形式。</p><h4 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h4><p><a href="https://www.cnblogs.com/90zeng/p/Lagrange_duality.html">具体思想</a></p><p>​     在得到SVM的基本形式之后，因为其带有一个不等式约束，为了方便计算，我们利用拉格朗日乘子法将其转化为无约束问题，再求解$L(w,b,\alpha)$对$w,b$的偏导令其等于0，代回上式，得到SVM的对偶问题：</p><p><img src="/../img/image-20221019171826241.png" alt="image-20221019171826241" style="zoom: 50%;"></p><p>对于上述的转换对偶问题求解过程，需满足KKT(Karush-Kuhn-Tucker)条件，即要求：</p><p><img src="/../img/20190530120814493.png" alt="img" style="zoom:80%;"></p><p>这样才能保证对偶问题可以得到和原问题一样的最优解。</p><p>最后得出支持向量机重要结论：<strong>训练完成后，大部分的训练样本都不需要保留，最终模型仅与支持向量有关。</strong></p><p>如何求解对偶问题？</p><p>我们采用二次规划算法SMO进行求解。我们现在的目标是求解使得对偶问题结果最小的拉格朗日乘子$\alpha$，SMO的基本思想：先固定$α_i$之外的所有参数，然后求$α_i$上的极值，它的思想与坐标上升算法的思想类似。</p><p>坐标上升算法每次通过更新多元函数中的一维，经过多次迭代直到收敛来达到优化函数的目的。简单的讲就是不断地选中一个变量做一维最优化直到函数达到局部最优点。</p><p>例子：</p><p>若我们的优化目标为一个二元函数：$arg\min f(x_1,x_2)=−x_1^2−3x_2^2+2x_1x_2+6$</p><p>我们先给一个$ (x_1,x_2)$ 的初值然后开始迭代。</p><ol><li>先固定 $x_1$ ，把$ f$ 看做$ x_2$ 的一元函数求最优值，可以简单的进行求导获取解析解:<br>$∂f/∂x_1=−2x_1+2x_2=0→x1=x2$</li><li>再固定$x_2$, 把$f$看成$x_1$的一元函数求最优值，得到$x_1$的解析解:<br>$∂f/∂x_2=−6x_2+2x_1→x_2=\frac13x1$</li></ol><p>按照上面两个过程不断交替的优化$ x_1 $和$ x_2 $，直到函数收敛。</p><p>通过下面的图就可以看出，优化的过程，因为每次只优化一个变量，每次迭代的方向都是沿着坐标轴方向的。</p><p><img src="/../img/v2-6a95f54ca97a7f0a87924172794af2d7_r.jpg" alt="img" style="zoom: 33%;"></p><p>SMO的思想类似坐标上升算法，我们需要优化一系列的$α$的值，我们每次选择尽量少的$ α $来优化，不断迭代直到函数收敛到最优值。</p><p>来到SVM的对偶问题上，其中我们需要对$ (α_1,α_2,…,α_N) $进行求解，SMO算法可以高效的求解这个对偶问题，只需要把原始问题的求解 N 个参数二次规划问题分解成多个二次规划问题求解，每个子问题只需要求解两个参数，节省了时间成本和内存需求。</p><blockquote><p>二次规划(QP, Quadratic Programming)定义：目标函数为二次函数，约束条件为线性约束，属于最简单的一种非线性规划。</p></blockquote><p>与坐标上升算法不同的是，我们在SMO算法中每次需要选择<strong>一对</strong>变量$ (α_i,α_j) $，因为在SVM中，$ α $c乘子并不是完全独立的，而是具有约束的：$∑_{i=1}^Nα_iy_i=0$</p><p>因此一个$ α $改变，另一个也要随之变化以满足条件，<a href="https://zhuanlan.zhihu.com/p/29212107">具体推导过程</a>。</p><h4 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h4><p>前两节是在样本在其原始样本空间线性可分的假设下进行讨论的。</p><p>针对原始样本空间线性不可分的问题，基于<strong>有限维原始样本空间一定存在一个高维特征空间使样本线性可分</strong>这一定理，引出了原始空间和特征空间的桥梁——核函数。</p><h3 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h3><p><a href="https://blog.csdn.net/ch18328071580/article/details/95048420">BP神经网络</a></p><p><a href="https://zhuanlan.zhihu.com/p/29212107">SMO算法实现</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Learning</title>
    <link href="/2022/09/30/Machine-Learning/"/>
    <url>/2022/09/30/Machine-Learning/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>机器学习处理的数据通常有categorical特征，我们需要把它转化为数值特征，数值特征的特点是可以比较大小。</p><p><img src="/../img/image-20220930165440724.png" alt="image-20220930165440724"></p><p>举个例子，上面的数据集每一行代表一个人的个人信息。第一列的年龄信息已经是可以比较大小的数值特征，第二列的性别是二元数值，需要转换成0和1，第三列的国籍无法比较大小，所以不能用字典做映射，要用one-hot向量来代表国籍类别，有197个国家，所以每个one-hot向量都是一个197维的向量。并且要保留0向量，用来保存未知或者缺失的国籍。数据库里经常会有缺失国际。举例，下面是两个人的全部信息：</p><p><img src="/../img/image-20221001094116657.png" alt="image-20221001094116657"></p><p>为什么要用one-hot向量，而不是用字典映射？</p><p><img src="/../img/image-20221001094227047.png" alt="image-20221001094227047"></p><p>因此，做机器学习的时候，不能用一个标量来表示categorical feature。 </p><h3 id="文本处理与词嵌入"><a href="#文本处理与词嵌入" class="headerlink" title="文本处理与词嵌入"></a>文本处理与词嵌入</h3><p>在自然语言处理的应用中，数据都是文本，文本可以分割成单词，每个单词都是一个类别，可以作为categorical feature来使用one-hot向量表示。如果有一万个单词，就有一万个类别。</p><p><img src="/../img/image-20221001094540144.png" alt="image-20221001094540144"></p><p><img src="/../img/image-20221001094716842.png" alt="image-20221001094716842"></p><p>完成统计后，对哈希表里的单词做一个排序，按照词频递减的顺序排列，然后把词频换成index，这个表就叫做字典，可以把单词映射成一个数字。字典里单词的个数叫做词汇量(vocabulary)。</p><p>如果词汇量过于庞大，可能有几十w个，通常会按词频只保留1w个，删去低频词汇，减小向量维度，防止计算过慢。</p><p><img src="/../img/image-20221001095416022.png" alt="image-20221001095416022"></p><p>因为低频次在字典里找不到，所以在做one-hot encoding的时候，可以把它直接忽略，也可以编码成0。</p><h4 id="Text-Processing-and-Word-Embedding"><a href="#Text-Processing-and-Word-Embedding" class="headerlink" title="Text Processing and Word Embedding"></a>Text Processing and Word Embedding</h4><p><img src="/../img/image-20221001104029698.png" alt="image-20221001104029698"></p><p>做一个自然语言识别的模型，来判断评论是正面还是负面的，收集了5w条评论，其中2.5w用来训练模型，2.5w用来测试。</p><p>在做文字嵌入和搭机器学习之前，应该先文本处理，把文本变成序列(Text to Sequence)。文本处理的好坏直接影响机器学习的结果。</p><p>文本处理步骤：</p><ol><li><p>Tokenization代号化</p><p>如果把文本分割成单词，则一个token就是一个单词，如果把文本分割成字符，则一个token就是一个字符。这一步看似简单，但是其实有很多坑。<img src="/../img/image-20221001103550038.png" alt="image-20221001103550038"></p></li><li><p>建立字典：把每一个单词对应成一个向量</p></li><li><p>one-hot编码：编码成一个sequence序列</p><p><img src="/../img/image-20221001103744907.png" alt="image-20221001103744907"></p></li></ol><p>每条电影评论都会转换成一个sequence，电影评论有长有短，所以得到的sequence长度也不一样，无法对齐，做机器学习的时候，我们需要把数据存储在矩阵或者张量里，这就需要数据对齐。对其原则是指定一个长度w，超过w的sequence就砍掉前面或者后面的词，不足w的就用0来补齐。<img src="/../img/image-20221001104646834.png" alt="image-20221001104646834"></p><p>Word Embedding：</p><p>指的是将词转化成一种分布式表示，又称词向量。它把高维one-hot向量映射到低维向量，但是one-hot通常可以达到1w多维，这样每层就需要10w多个参数，太过复杂，需要简化它，具体做法是把one-hot向量$e_i$乘到参数矩阵$P^T$上，d是词向量的维度，由用户自己定义，v是字典里单词的数量。矩阵乘法的结果$x_i$就是一个词向量，维度是d。如果$e_i$的第三个元素是1，那么$x_i$的结果就是参数矩阵$P^T$的第三列，可以看出参数矩阵$P^T$的每一列都是一个词向量。</p><p><img src="/../img/image-20221001111331225.png" alt="image-20221001111331225"></p><p><img src="/../img/image-20221001110640912.png" alt="image-20221001110640912"></p><p>同理，这个参数矩阵的每一行都是一个词向量，矩阵的行数是词汇量v，每一行对应一个单词，矩阵的列数d由用户自己决定，会影响模型表现，应该用cross validation选出一个比较好的d。字典里的第一个词是”movie”，那么参数矩阵的第一行就对应”movie”的词向量，以此类推。</p><p>我们的任务是判断评论是正面还是负面的，这个参数矩阵是从训练数据中学习出来的，所以学出来的词向量会带有感情色彩，假如这些词向量都是二维的$(x_1,x_2)$，可以在平面坐标系中标出这些词向量，好词放一块，坏词放一块，并且二者尽量远离，中性词放在中间地带。</p><p><img src="/../img/image-20221001112116783.png" alt="image-20221001112116783"></p><p>代码实现：</p><p><img src="/../img/image-20221001113437985.png" alt="image-20221001113437985"></p><p>参数分别是词汇量=10k，cross validation选出的维数d=8，指定矩阵长度w=20，embedding层的输出是一个20x8的矩阵，每条评论20个单词，每个单词用8维的词向量表示，embedding层的参数数量等于8w，是$P^T$矩阵的行数乘上列数。</p><p>Logistic regression:</p><p>逻辑回归法做二分类，判断电影评价是正面的还是负面的。keras代码如下：</p><p><img src="/../img/image-20221001150240572.png" alt="image-20221001150240572"></p><p>从keras里导入Sequential，把神经网络的层按顺序搭起来。</p><p>设置词向量维度等于8，调用Sequential，返回model对象，然后往model里依次添加各种层，第一层是embedding层，该层输出是一个20x8的矩阵，每条评论中取20个单词，每个单词用8维的词向量来表示。第二层是flatten层，把20x8的矩阵压扁，变成160维的向量和一个偏移量。最后一层是Dense权连接层，输出是一维的，用Sigmoid激活函数，里面全是0-1之间的数，0代表负面，1代表正面。然后用summary打印出模型的概要，显示每一层的名字，输出的形状和参数数量。</p><p>接下来用compile编译model，指定优化算法RMSprop和损失函数，评价标准acc。</p><p><img src="/../img/image-20221001151124355.png" alt="image-20221001151124355"></p><p>为什么选择进行50次迭代？</p><p><img src="/../img/image-20221001151307454.png" alt="image-20221001151307454"></p><p>如果用20次，validation还没有达到最优，如果用1000次，也不会更好，只会浪费时间。</p><p>完成训练后，在测试集上检验model表现。</p><p><img src="/../img/image-20221001151504677.png" alt="image-20221001151504677"></p><p>用x_test作为输入，evaluate模型的准确率，函数会返回一个loss和一个acc。结果acc返回0.75，比随机瞎猜的0.5好上很多，说明模型学到了东西。</p><p>总结：</p><ol><li>Texts to Sequences</li></ol><p><img src="/../img/image-20221001151747291.png" alt="image-20221001151747291"></p><ol><li>Embedding</li></ol><p><img src="/../img/image-20221001152217041.png" alt="image-20221001152217041"></p><h3 id="Simple-RNN模型"><a href="#Simple-RNN模型" class="headerlink" title="Simple RNN模型"></a>Simple RNN模型</h3><p>现在的RNN没有以前流行，尤其是在自然语言处理的方面，RNN已经有些过时了，如果训练数据足够多，RNN的效果不如Transformer模型，但是在小规模的问题上，RNN还是很有用的。</p><p>机器学习中，经常会用到文本，语音等sequential data持续数据，那么怎样对持续数据建模？</p><p>上一节输入一段文字，让model来做二分类，判断正面或者负面，这属于one-to-one模型，一个输入对应一个输出，权连接和卷积神经网络都属于one-to-one模型，但是人脑并不会这样处理数据，而是逐渐积累信息，得到一段话的意思。</p><p>One-to-one模型很适用于图片问题，输入一张图片，输出每一类的概率值，但是不适合文本问题。对于文本问题，输入和输出的长度并不固定，比如中英互译等等，更适用于many-to-one或者many-to-many模型，RNN就是这样的模型，很适用于文本，语音领域。</p><p>RNN和人的阅读习惯比较类似，人每次看一个词，逐渐在大脑里积累信息，RNN每次也看一个词，然后用状态向量h来积累阅读过的信息，并且参数矩阵A只有一个，A随机初始化，然后用训练数据来学习A。</p><p><img src="/../img/image-20221001155448355.png" alt="image-20221001155448355"></p><h5 id="简单循环神经网络Simple-RNN-Model"><a href="#简单循环神经网络Simple-RNN-Model" class="headerlink" title="简单循环神经网络Simple RNN Model"></a>简单循环神经网络Simple RNN Model</h5><p>主要思想：把输入的x结合到状态向量h里，上一个状态记做$h_{t-1}$，新输入的词向量记做$x_t$，二者做兼容，得到一个维数更高的向量，A是RNN的模型参数，相乘得到一个单列的向量，把激活函数tanh用在向量的每一个元素上，这个激活函数是hyperbolic tangent function双曲正切函数，输出在-1到+1之间。因此，新的$h_t$就是新的$x_t$和旧的$h_{t-1}$做A变换后的激活函数。</p><p><img src="/../img/image-20221001172843395.png" alt="image-20221001172843395"></p><p>为什么需要双曲正切函数？</p><p>假设输入的词向量x全都是0，就相当于把蓝色和深蓝色的部分都去掉，因此，第100个状态向量$h_{100}$逐步递推就等于$A^{100}h_0$，假设矩阵A最大的特征值是0.9小于1，0.9的100次方几乎是一个全零的矩阵，那么新的状态$h_{100}$也会是一个全零的向量，假如矩阵A最大的特征值是1.2大于1，100次方后得到的值是八千多万，超级大，状态向量简直blow up。</p><p>因此，没有激活函数的话，计算出的值很可能出问题，要么全等于0，要么爆炸了，数值全是not a number，所以每次更新完状态h后都要做一个normalization，让h恢复到一个合适的区间里。</p><p>Simple RNN有多少个模型参数？</p><p>h的维度加x的维度的向量作为每次迭代的输入，所以A的列数=h的行数+x的行数，A的行数=h的行数，行和列数的乘积就是模型参数的数量。</p><p><img src="/../img/image-20221001174035546.png" alt="image-20221001174035546"></p><p>上节用的是逻辑回归的方法来判断评论是正面还是负面，这节用RNN来解决。</p><p>先搭一个神经网络，最底层是word embedding，把词映射到向量x，词向量维度自己设置，用cross validation来选择最优的维度，这里设置x的维度是32，然后搭一层simple RNN layer，输入的是词向量x，输出的是状态h，h也用cross validation来选择最优的维度，这里设置32。我们可以选择让karas输出所有状态向量，也可以选择只输出最后一个状态向量。因为最后一个状态向量积累了整句话的信息，所以只用最后一个状态向量$h_t$就可以了。$h_t$相当于从文本中提取的特征向量，把$h_t$输入分类器，分类器就会输出一个0-1之间的数值，0代表正面评价，1代表负面评价。</p><p><img src="/../img/image-20221001180125331.png" alt="image-20221001180125331"></p><p><img src="/../img/image-20221001180448482.png" alt="image-20221001180448482"></p><p>Return_sequence参数为true输出全部状态向量，为False只输出最后一个状态向量。</p><p>输出结果：</p><p><img src="/../img/image-20221001183240171.png" alt="image-20221001183240171"></p><p>搭好模型后编译模型，然后用训练数据拟合模型，只让算法运行3个epochs，因为出现了over-fitting，之后validating会变差，提前让算法停止运行(early-stopping)。</p><p><img src="/../img/image-20221001183718987.png" alt="image-20221001183718987"></p><p>最后，用测试data来评价model表现，输出得到：</p><p><img src="/../img/image-20221001183802525.png" alt="image-20221001183802525"></p><p>比上节的逻辑回归高多了。</p><p> 如果让karas返回所有状态向量，RNN的输出就是一个矩阵，矩阵每一行就是一个状态向量h，如果用所有状态，就要加一个flatten层，把状态矩阵变成一个向量，然后把向量作为分类器的输入，输出正面或负面。需要对前面的代码更改两行：</p><p><img src="/../img/image-20221001184204134.png" alt="image-20221001184204134"></p><p>输出网络结构从一个32维的向量变成了一个500x32的矩阵，因为有500个单词，所以有500个状态向量，每个向量状态都是32维的。 </p><p>最后测试结果，用了所有状态向量和只用最后一个状态向量准确率并没有什么提升。</p><p>Simple RNN特点：</p><ol><li><p>擅长Short-term dependence短期依赖，对短句的预测效果很出色。<img src="/../img/image-20221001185108392.png" alt="image-20221001185108392"></p></li><li><p>不擅长Long-term dependence长期依赖，RNN中的h跟之前所有输入的x都有函数依赖关系，但实际上离得越远，相关性越差，俗称读不懂上下文，LSTM就做得好很多。</p></li></ol><p><img src="/../img/image-20221001185425574.png" alt="image-20221001185425574"></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度强化学习</title>
    <link href="/2022/09/28/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/28/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="概率论基础知识"><a href="#概率论基础知识" class="headerlink" title="概率论基础知识"></a>概率论基础知识</h3><h5 id="随机变量：取决于随机事件的结果。"><a href="#随机变量：取决于随机事件的结果。" class="headerlink" title="随机变量：取决于随机事件的结果。"></a>随机变量：取决于随机事件的结果。</h5><p>举个例子，抛硬币就是一个随机事件，X就是随机变量，有两种可能的取值0和1。在随机事件发生前，我们不知道X是什么，但是我们知道概率。</p><p><img src="/../img/image-20220928183006887.png" alt="image-20220928183006887"></p><p>概率统计中，用小写x表示观测值，大写X表示随机变量，x只是一个数而已，并不代表概率，举个例子，扔了四次硬币，结果是：</p><p><img src="/../img/image-20220928183336103.png" alt="image-20220928183336103"></p><h5 id="概率密度函数：意味着随机变量在某个确定的取值点附近的可能性。"><a href="#概率密度函数：意味着随机变量在某个确定的取值点附近的可能性。" class="headerlink" title="概率密度函数：意味着随机变量在某个确定的取值点附近的可能性。"></a>概率密度函数：意味着随机变量在某个确定的取值点附近的可能性。</h5><p>举个例子，高斯函数是一个随机变量的分布函数。它的概率密度函数在0点最大，远离0点的地方值越来越小，说明它在0点附近取值的概率较大。</p><p>把所有可能的取值都算上，它们的概率加和等于1。</p><p><img src="/../img/image-20220928183546028.png" alt="image-20220928183546028"></p><h5 id="期望E-X-如下定义，p-x-是概率密度函数。"><a href="#期望E-X-如下定义，p-x-是概率密度函数。" class="headerlink" title="期望E(X)如下定义，p(x)是概率密度函数。"></a>期望E(X)如下定义，p(x)是概率密度函数。</h5><p><img src="/../img/image-20220928183846442.png" alt="image-20220928183846442"></p><h5 id="随机抽样："><a href="#随机抽样：" class="headerlink" title="随机抽样："></a>随机抽样：</h5><p><img src="/../img/image-20220928184217776.png" alt="image-20220928184217776"></p><h3 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h3><h5 id="state和action："><a href="#state和action：" class="headerlink" title="state和action："></a>state和action：</h5><p>state可以理解为当前场景，action就是智能体(Agent)的动作。举个例子，假设我们在玩超级马里奥，整个画面就是现在的state，马里奥就是智能体，他能做的上下左右运动就是action。</p><p><img src="/../img/image-20220928184404914.png" alt="image-20220928184404914"></p><h5 id="policy："><a href="#policy：" class="headerlink" title="policy："></a>policy：</h5><p>policy可以理解为决策在这个例子中，就是在我们观测到屏幕上这个画面的时候，我们该让Mario做什么动作。在数学上，policy函数这么定义：$\pi(a|s)=P(A=a|S=s)$。它是一个概率密度函数，意思是给定状态s，做出动作a的概率密度。</p><p><img src="/../img/image-20220928193308974.png" alt="image-20220928193308974"></p><p>如果让policy自己完成这个决策，它就会做一个随机抽样，但是向上的概率最大。</p><p>强化学习学的就是这个policy函数，只要有了这个函数，就可以自动操作Mario来自动打游戏了。这个policy函数可以是固定，也可以是随机的，但是在个人博弈的情况下最好还是随机的。举个例子，在玩石头剪刀布时，如果你的出拳顺序是固定的，别人很容易就可以猜到你会出什么，因此最好还是采用概率密度函数作决策函数，随机抽样得到这个动作。</p><p>采用随机策略的目的不仅为了增加随机性，也是为了增加探索性。</p><h5 id="reward-R："><a href="#reward-R：" class="headerlink" title="reward R："></a>reward R：</h5><p>agent做出一个动作，游戏就会给一个奖励，这个奖励通常需要我们自己来定义，这个奖励定义的好坏非常影响强化学习的效果，举个例子：</p><p><img src="/../img/image-20220928202145557.png" alt="image-20220928202145557"></p><p>吃个金币奖励1，但是为了赢下游戏，赢比赛的奖励要定的断层的高，而强化学习的目的就是为了得到更多的奖励。</p><h5 id="state-transition状态转移："><a href="#state-transition状态转移：" class="headerlink" title="state transition状态转移："></a>state transition状态转移：</h5><p>举个例子，当前状态下，Mario跳一下，屏幕就发生改变了，也就是state变了，这个过程就叫状态转移。它可以是确定的，也可以是随机的，通常我们认为是随机的。</p><p><img src="/../img/image-20220928220108934.png" alt="image-20220928220108934"></p><p>状态转移的随机性是从环境里来的，在这个程序里，Mario往上跳一下，确定会吃到金币，但我们不确定的是屎蛋在下个state里会往左还是往右，这就是下个state的随机性。</p><p>可以把状态转移用p函数来表示，意思是已经知道当前状态为s，动作为a，下一个状态变为$s’$的概率。在这个例子中，已知Mario在这个状态里往上跳的条件下，下一个state屎蛋往左的概率是0.8，往右的概率是0.2。但是我们作为玩家，并不知道这个状态转移函数，只有环境自己知道。</p><h5 id="Agent-Environment-Interaction交互："><a href="#Agent-Environment-Interaction交互：" class="headerlink" title="Agent-Environment Interaction交互："></a>Agent-Environment Interaction交互：</h5><p>在这个例子里，Mario是Agent，环境是游戏程序，state就是当前游戏画面，agent做出action后，反馈给环境，环境改变了state，并且给这个动作一个reward。</p><p><img src="/../img/image-20220928221301524.png" alt="image-20220928221301524"></p><p><img src="/../img/image-20220928222649869.png" alt="image-20220928222649869"></p><p><img src="/../img/image-20220928222805359.png" alt="image-20220928222805359"></p><h5 id="强化学习中的随机性来源："><a href="#强化学习中的随机性来源：" class="headerlink" title="强化学习中的随机性来源："></a>强化学习中的随机性来源：</h5><p>一、action产生的随机性：action是根据policy函数策略随机抽样得来的。</p><p><img src="/../img/image-20220928222435691.png" alt="image-20220928222435691"></p><p>二、状态转移产生的随机性：状态概率是环境机制决定的。</p><p><img src="/../img/image-20220928222955204.png" alt="image-20220928222955204"></p><h5 id="怎么样让AI自动打赢游戏？"><a href="#怎么样让AI自动打赢游戏？" class="headerlink" title="怎么样让AI自动打赢游戏？"></a>怎么样让AI自动打赢游戏？</h5><p><img src="/../img/image-20220928223235655.png" alt="image-20220928223235655"></p><p>根据s，a，r的轨迹，找出总计回报最大的轨迹，以此制定策略。</p><h5 id="Return回报："><a href="#Return回报：" class="headerlink" title="Return回报："></a>Return回报：</h5><p>也叫cumulative future reward 未来的累积奖励。</p><p><img src="/../img/image-20220928223924496.png" alt="image-20220928223924496"></p><p>$U_t$代表累积的所有奖励，也就是回报，同时有个问题，对于此刻的你来说，你是更愿意要现在的一百块还是明年的一百块，那肯定是现在。而如果改成今年的八十，和明年的一百，结果可能就是明年，因此得出结论：</p><ul><li>现在的奖励比未来的奖励更有价值。</li><li>未来奖励的权重要比现在的奖励低。</li></ul><p><img src="/../img/image-20220928224403860.png" alt="image-20220928224403860"></p><p>由于这种原因，所以强化学习中普遍使用折扣回报，其中折扣率$\gamma$是一个超参数，介于0和1之间，如果未来的奖励不重要，$\gamma$就小，重要的话$\gamma$就大。这个参数需要我们自己来调，对结果有一定影响。</p><p>如果在游戏还没有结束的时候看$U_t$，那么已经观测到的值就不再是变量，用小写r来表示，如果还未观测到，那就还是个变量，用大写R来表示。</p><p><img src="/../img/image-20220928231508146.png" alt="image-20220928231508146"></p><p><img src="/../img/image-20220928231524670.png" alt="image-20220928231524670"></p><h5 id="回报的随机性来源："><a href="#回报的随机性来源：" class="headerlink" title="回报的随机性来源："></a>回报的随机性来源：</h5><p><img src="/../img/image-20220928230716500.png" alt="image-20220928230716500"></p><p>AI的随机性来源有两个，一是action的随机性，二是状态转移的随机性。</p><p>对于从t时刻起的任意一个时刻，该时刻的奖励都取决于该时刻的状态和该时刻的动作，因此，给定一个t时刻的状态，该时刻的回报$U_t$就取决于所有t时刻往后的动作和状态转移。</p><p>所以回报$U_t$的随机性来源就是未来所有时刻的动作和状态，当没有观测到具体值的时候，它也是一个随机变量。</p><h5 id="价值函数Value-Function"><a href="#价值函数Value-Function" class="headerlink" title="价值函数Value- Function"></a>价值函数Value- Function</h5><p><img src="/../img/image-20220929101346598.png" alt="image-20220929101346598"></p><p>$U_t$是个随机变量，依赖于t时刻之后所有的动作$A_t,A_{t+1},A_{t+2},…$和未来所有的状态$S_t,S_{t+1},S_{t+2},…$，所以我们并不知道t时刻的$U_t$是什么。</p><p>那我们该如何评估当前的形势呢？我们可以对$U_t$求期望，把里面的随机性$A_{t+1},A_{t+2},…,S_{t+1},S_{t+2},…$都用积分积掉，得到的就是一个实数。这样$Q_\pi$就只与当前动作和状态有关，并且积分的时候，还会用到policy函数$\pi$和p。</p><p>动作价值函数的意义就是，如果用policy函数$\pi$，那么在当前状态$s_t$下做动作$a_t$是好还是坏。已知policy函数$\pi$的情况下，$Q_\pi$就会给当前状态下所有的动作打分，然后我们就知道哪个动作好哪个动作不好。因此，有不同的policy函数$\pi$，就会有不同的$Q_\pi$。</p><p>怎么把$Q_\pi$里的$\pi$去掉呢？可以对$Q_\pi$关于$\pi$求最大化，意思是我们有无数种policy函数$\pi$，而我们要求最好的那种，也就是可以让$Q_\pi$最大化的那种。</p><script type="math/tex; mode=display">Q^\star(s_t,a_t)=\max_\pi Q_\pi(s_t,a_t)</script><p>我们把得到的这个最大化的函数称为最优动作价值函数，它的直观意义就是不管用什么样的决策函数，得到的最大期望也就是这。</p><p><img src="/../img/image-20220929104613868.png" alt="image-20220929104613868"></p><p>状态价值函数$V_\pi$，它是动作价值函数的期望，可以把这里的动作A作为随机变量，然后关于动作A求期望，A的概率密度函数为$\pi$，根据期望定义，可以把它写成积分（假设动作是连续的形势，比如汽车驾驶方向盘的角度）或者连加（假设动作是上下左右这种离散的形式）的形式，把A消掉。它的意义是告诉我们当前的形势好不好，举个例子，如果在下围棋，让$V_\pi$看一眼棋盘，它就可以告诉我们当前的胜算有多大。</p><p>总结：$Q_\pi$衡量当前状态下使用$\pi$决策的话a动作的好坏，和$\pi,s,a$都有关，是$U_t$的条件期望。</p><p>$V_\pi$用积分把A去掉，这样就只和s有关，衡量的是使用$\pi$决策的话当前形势s的好坏。它也可以衡量$\pi$决策的好坏，如果policy越好，那么$V_\pi$的均值就越大，即$E_S(V_\pi)$就越大。</p><h3 id="强化学习实践"><a href="#强化学习实践" class="headerlink" title="强化学习实践"></a>强化学习实践</h3><p><img src="/../img/image-20220929110329614.png" alt="image-20220929110329614"></p><p>如何操纵AI打游戏？</p><p>一、学习一个policy函数$\pi(a|s)$，即策略学习</p><p>每观测一个状态$s_t$，就输入策略函数，$\pi$函数会输出每一个动作的概率，将这些动作来做一个随机抽样，得到$a_t$。</p><p>二、学习最优动作价值函数，即价值学习</p><p>每输入一个状态，选择能得分最大的动作。</p><p>这两种方法都可行，所以强化学习的任务就是学习这两个函数之一。</p><p>如果设计出了这种算法，就可以把算法用于各种问题上。</p><p>强化学习最常用的库：OpenAI Gym</p><ol><li>经典控制问题</li><li>小游戏</li><li>连续控制MuJoCo</li></ol><p><img src="/../img/image-20220929110851316.png" alt="image-20220929110851316"></p><p>使用gym测试算法优劣：</p><ol><li>导包</li><li>生成环境</li></ol><p><img src="/../img/image-20220929111106897.png" alt="image-20220929111106897"></p><p>解释代码：</p><ol><li>重置环境，返回初始状态state</li><li>进入循环</li><li>每一轮循环里，先渲染环境，将画面展示给人看</li><li>算出一个action，这里是均匀抽样</li><li>环境做出action，并更新state，给出一个reward，返回done和info</li><li>如果done=1游戏结束，直接结束循环</li></ol><h5 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h5><p>机器学习的核心内容就是把数据喂给一个人工设计的模型，然后让模型自动的“学习”，从而优化模型自身的各种参数，最终使得在某一组参数下该模型能够最佳的匹配该学习任务。</p><p>梯度下降法就是实现该“学习”过程的一种最常见的方式，尤其是在深度学习(神经网络)模型中，BP反向传播方法的核心就是对每层的权重参数不断使用梯度下降来进行优化。</p><p>梯度下降法(gradient descent)是一种常用的一阶(first-order)优化方法，是求解无约束优化问题最简单、最经典的方法之一。我们来考虑一个无约束优化问题 $\min_xf(x) $, 其中 f(x) 为连续可微函数，如果我们能够构造一个序列$ x_0,x_1,x_2,… $，并能够满足：</p><p>$f(x^{t+1})&lt;f(x^t),t=0,1,2,…$</p><p>那么我们就能够不断执行该过程即可收敛到局部极小点，可参考下图。</p><p><img src="/../img/image-20220929150613619.png" alt="image-20220929150613619"></p><p>现在我们随机找了一个初始的点 x1 ，对于一元函数来说，函数值只会随着 x 的变化而变化，那么我们就设计<strong>下一个 $x^{t+1 }$是从上一个$ x^t $沿着某一方向走一小步$ Δx $得到的。此处的关键问题就是：这一小步的方向是朝向哪里？</strong></p><p><img src="/../img/v2-5e43a5099214417029720384e5ac4a17_r.jpg" alt="img"></p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>//返回x的平方<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> np.power(x, <span class="hljs-number">2</span>)<br>//返回2x<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">d_f_1</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2.0</span> * x<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">d_f_2</span>(<span class="hljs-params">f, x, delta=<span class="hljs-number">1e-4</span></span>):<br>//返回x处的斜率<br>    <span class="hljs-keyword">return</span> (f(x+delta) - f(x-delta)) / (<span class="hljs-number">2</span> * delta)<br><br><br><span class="hljs-comment"># plot the function</span><br>//返回一个-<span class="hljs-number">10</span>到<span class="hljs-number">10</span>的数组<br>xs = np.arange(-<span class="hljs-number">10</span>, <span class="hljs-number">11</span>)<br>//画出-<span class="hljs-number">10</span>到<span class="hljs-number">10</span>的x平方的图像<br>plt.plot(xs, f(xs))<br>plt.show()<br><br>learning_rate = <span class="hljs-number">0.1</span><br>max_loop = <span class="hljs-number">30</span><br>//用梯度下降法迭代<span class="hljs-number">30</span>次求f(x)=x^<span class="hljs-number">2</span>的最小值<br>x_init = <span class="hljs-number">10.0</span><br>x = x_init<br>lr = <span class="hljs-number">0.1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_loop):<br>    <span class="hljs-comment"># d_f_x = d_f_1(x)</span><br>    //把x处的斜率付给d_f_x<br>    d_f_x = d_f_2(f, x)<br>    //更新x，减去步长alpha*d_f_x<br>    x = x - learning_rate * d_f_x<br>    <span class="hljs-built_in">print</span>(x)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;initial x =&#x27;</span>, x_init)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;arg min f(x) of x =&#x27;</span>, x)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f(x) =&#x27;</span>, f(x))<br></code></pre></td></tr></table></figure><p>输出内容如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs tex">8.000000000004661<br>6.400000000004837<br>5.120000000003557<br>4.0960000000043095<br>3.276800000005622<br>2.6214400000032967<br>2.097152000001259<br>1.6777216000003392<br>1.3421772800004028<br>1.0737418240003205<br>0.8589934592002546<br>0.6871947673602241<br>0.5497558138881831<br>0.4398046511105336<br>0.35184372088844174<br>0.2814749767107627<br>0.22517998136861533<br>0.18014398509489674<br>0.14411518807592116<br>0.11529215046073862<br>0.09223372036859068<br>0.07378697629487216<br>0.05902958103589708<br>0.047223664828717364<br>0.03777893186297355<br>0.03022314549037856<br>0.024178516392302875<br>0.019342813113842325<br>0.015474250491073885<br>0.012379400392859128<br>initial x = 10.0<br>arg min f(x) of x = 0.012379400392859128<br>f(x) = 0.00015324955408672073<br></code></pre></td></tr></table></figure><p>经过30次迭代 x 从初始点10.0逐步逼近最小点 f(0) .</p><h5 id="无偏估计"><a href="#无偏估计" class="headerlink" title="无偏估计"></a>无偏估计</h5><p>不论总体服从什么分布，样本均值是总体均值的无偏估计量。</p><h5 id="蒙特卡洛近似"><a href="#蒙特卡洛近似" class="headerlink" title="蒙特卡洛近似"></a>蒙特卡洛近似</h5><p>来源：蒙特卡洛模拟是在计算机上模拟项目上实施了成千上万次，每次输入都随机选择输入值。由于每个输入很多时候本身就是一个估计区间，因此计算机模型会随机选取每个输入的该区间内的任意值，通过大量成千上万甚至百万次的模拟次数，最终得出一个<strong>累计概率分布图</strong>，这个就是蒙特卡洛模拟。</p><p>举例：敌人以两门火炮为单位对我方进行干扰，进并经常变换射击地点。经过长期观察发现，我方指挥所对敌方目标的指示有50%是准确的，而我方火力单位在指示正确时，有1/3的射击效果能毁伤敌人1门火炮，有1/6的射击效果能全部消灭敌人。</p><p>解：希望能用某种方法把我方将要对敌人实施的20次打击结果显示出来，确定有效射击的比率及毁伤敌方火炮的平均值。这是一个概率问题，可以通过理论计算得到相应的概率和期望值。但这样只能给出作战行动的最终静态结果，而显示不出作战行动的动态过程。</p><p>为了显示我方20次射击的过程，必须用某种方式模拟出以下两件事：一是观察所对目标的指示正确或不正确；二是当指示正确时，我方火力单位的射击结果。对第一件事进行模拟试验时有两种结果，每一种结果出现的概率都是1/2。因此，可用投掷1枚硬币的方式予以确定。当硬币出现正面时为指示正确，反之为不正确。对第二件事进行模拟试验时有3种结果，毁伤1门火炮的可能为1/3，毁伤2门火炮的可能为1/6，没能毁伤敌火炮的可能为1/2。这时，可用投掷骰子的办法来确定，如果出现的是1、2、3三个点则认为没能击中敌人，如果出现的是4、5点则认为毁伤敌1门火炮，如果出现6点则认为毁伤敌2门火炮。</p><p>通过上面的方式，就可把我方20次射击的过程动态地显现出来。</p><p>使用蒙特卡罗法的基本步骤如下：</p><p>(1)根据作战过程的特点构造模拟模型；</p><p>(2)确定所需要的各项基础数据；</p><p>(3)使用可提高模拟精度和收敛速度的方法；</p><p>(4)估计模拟次数；</p><p>(5)编制程序并在计算机上运行；</p><p>(6)统计处理数据，给出问题的模拟结果及其精度估计。</p><p>在蒙特卡罗法中，对同一个问题或现象可采用多种不同的模拟方法，它们有好有差，精度有高有低，计算量有大有小，收敛速度有快有慢，在方法的选择上有一定的技巧。</p><h3 id="价值学习"><a href="#价值学习" class="headerlink" title="价值学习"></a>价值学习</h3><p>$U_t$是一个随机变量，为了消除它的随机性，求它的积分并取期望得到动作价值函数$Q_\pi$，来反映当前状态下做动作的好坏。动作的随机性是由$\pi$函数随机抽样得到的，状态的随机性是由p函数环境机制随机抽样得到的。</p><p> <img src="/../img/image-20220929144820687.png" alt="image-20220929144820687"></p><h5 id="Deep-Q-Network-DQN-深度神经网络"><a href="#Deep-Q-Network-DQN-深度神经网络" class="headerlink" title="Deep Q-Network(DQN)深度神经网络"></a>Deep Q-Network(DQN)深度神经网络</h5><p>其实就是神经网络用了近似$Q^\star$函数，因为$Q^\star$其实是不存在的，除非存在一个先知，我们只能用神经网络去近似的学习它。</p><p>我们把这个神经网络叫做$Q(s,a;w)$，w是参数，s是输入，输出是对所有可能动作的打分。我们通过奖励来学习神经网络，它的打分会越来越准。</p><p><img src="/../img/image-20220929162821122.png" alt="image-20220929162821122"></p><p>不同问题的DQN结构也可能不一样，举个例子，玩超级玛丽，把显示画面作为输入，用一个Conv卷积层把图片变成特征向量，最后用几个Dense权连接层把特征映射到几个输出向量。</p><p>这个输出向量是对动作的打分，向量的每一个元素对应一个动作。因为向上跳得分最高，所以DQN会操纵Mario向上跳。只要训练好DQN，就可以打赢游戏并且得高分了。</p><p><img src="/../img/image-20220929163610040.png" alt="image-20220929163610040"></p><h5 id="怎么训练DQN？"><a href="#怎么训练DQN？" class="headerlink" title="怎么训练DQN？"></a>怎么训练DQN？</h5><p>最常用的是TD算法。</p><p><img src="/../img/image-20220929163937684.png" alt="image-20220929163937684"></p><p>举个例子，如果想开车从纽约去亚特兰大，模型初步预估是1000分钟。但实际上只用了860分钟，因此就产生了损失Loss，对Loss关于模型参数w求导，得出结果。</p><p>梯度求出来了，就可以用梯度下降法找Loss的最小值，更新模型参数w，指定一个步长，或者说是学习率。在经过这次迭代后，得到$W_{t+1}$，用$W_{t+1}$做预测的话，会准确很多。</p><p>但是这种方法很sb，完成整个旅途也只能对model做一次更新。</p><p>下面是一种新的半场开香槟方法：</p><p><img src="/../img/image-20220929175259409.png" alt="image-20220929175259409"></p><p><img src="/../img/image-20220929174723038.png" alt="image-20220929174723038"></p><p>途径DC的时候看了眼表，发现只用了300min，这时候更新model，判断余下的路程只用600min，这个900也是TD Target，但是比上一种方法来的更准确。得到Loss梯度后更新模型参数，完成一次迭代。</p><p>什么情况下可以用TD算法？答案是右边必须有一项是真实观测到的。</p><p><img src="/../img/image-20220929175417403.png" alt="image-20220929175417403"></p><p>在深度强化学习中也有这个公式，左边是t时刻的估计，这是未来奖励总和的期望，相当于纽约到亚特兰大的总时间。</p><p>等式右边有一项rt，是真实观测到的奖励。等式右边第二项，是DC到亚特兰大的预计时间。</p><p><img src="/../img/image-20220929175827549.png" alt="image-20220929175827549"></p><p>相邻两个折扣回报的关系如上推导，现在要把TD算法用到DQN上：</p><p><img src="/../img/image-20220929180042719.png" alt="image-20220929180042719"></p><p>有了以上两个参数，就可以更新DQN模型的参数了。</p><p><img src="/../img/image-20220929180334200.png" alt="image-20220929180334200"></p><p>已知预测部分和$r_t$，还观测到了新的状态$s_{t+1}$，有了这个状态，就可以根据DQN算出下一个动作$a_{t+1}$了。因此，在t+1时刻，$y_t,s_{t+1},a_{t+1}$都是已知的，就可以得出TD target $y_t$。</p><p>其中，$a_{t+1}$是由$s_{t+1}$下的DQN对各个动作依次打分，得出的那个最高的动作，也就是Q函数关于a求最大化。</p><p>我们希望预测尽量接近TD target，因此定义损失函数得到梯度，然后做梯度下降来更新模型参数。</p><p>总结：</p><p>TD算法的步骤：</p><ol><li>观察t时刻状态和动作。</li><li>输入当前状态，然后对动作进行打分，得到$Q_t(s_t,a_t;w_t)$。</li><li>用反向传播对DQN求导，得到梯度$d_t$。</li><li>执行动作后，环境会更新状态并给出奖励。</li><li>得出TD Target。</li><li>更新模型参数。</li></ol><p>每得到一次r，就可以完成一次迭代，更新一次参数。</p><p><img src="/../img/image-20220929181756642.png" alt="image-20220929181756642"></p><h3 id="策略学习"><a href="#策略学习" class="headerlink" title="策略学习"></a>策略学习</h3><p>我们用一个神经网络来近似这个策略函数，这个神经网络叫做策略网络(Policy-Network)，可以用来控制agent运动，训练这个网络需要用到Policy-gredient算法。</p><p>$\pi(a|s)$函数是一个PDF函数，s作为输入，输出每种动作的可能性。我们可以直接学习这个函数吗？如果s是有限的，我们只需要把所有s列举出来，归纳总结就可以，但是在超级玛丽这个游戏中，s明显是无限的，所以我们需要建立一个策略网络来学习这个策略函数。</p><p>策略网络$\pi(a|s;\theta)$中，$\theta$是策略网络的参数。</p><p><img src="/../img/image-20220930084506357.png" alt="image-20220930084506357"></p><p>因为$\pi$是一个PDF函数，所以必须保证加和等于1，因此需要用一个Softmax函数，来做归一化。</p><h5 id="策略学习主要思想"><a href="#策略学习主要思想" class="headerlink" title="策略学习主要思想"></a>策略学习主要思想</h5><p>用策略网络来近似策略函数，这样状态价值函数就可以写成如下形式，s的形势越好，V就越大，那怎么样让策略网络越变越好？我们可以改进模型参数$\theta$，让$V(s;\theta)$来变大。基于这个想法，我们可以把目标函数定义为V的关于S的期望，把S当作是随机变量，求期望的时候积分掉。这样<script type="math/tex">J(\theta)</script>就是对策略网络的期望，策略网络越好，$J(\theta)$就越大。</p><p>怎么样改进$\theta$呢？我们要用到策略梯度算法。让agent玩游戏，每观测到一个s，就相当于从状态中随机抽样出了一个状态，对V求导得到策略梯度，乘上学习率，用梯度上升的方法来迭代$\theta$。</p><p><img src="/../img/image-20220930100055379.png" alt="image-20220930100055379"> </p><p>为什么是梯度上升不是梯度下降呢？因为这又不是损失函数，我们是想让$J(\theta)$越变越大的。</p><h5 id="怎么计算策略梯度"><a href="#怎么计算策略梯度" class="headerlink" title="怎么计算策略梯度"></a>怎么计算策略梯度</h5><p><img src="/../img/image-20220930101048159.png" alt="image-20220930101048159"></p><p>看以上计算过程，虽然Q显然不能直接做常数处理，因为$\theta$神经网络参数也来源于动作价值函数，但是不管了，直接近似了。将原式作下面的变换，得到一个新的展开式。乘了每一个情况下a的PDF函数，就可以变换成对A的期望了。</p><p><img src="/../img/image-20220930101456099.png" alt="image-20220930101456099"></p><p>由此得到了策略梯度。</p><h5 id="蒙特卡洛近似策略梯度"><a href="#蒙特卡洛近似策略梯度" class="headerlink" title="蒙特卡洛近似策略梯度"></a>蒙特卡洛近似策略梯度</h5><p>如果是离散变量，我们可以直接把每个动作都枚举出来，但实际上通常不是。</p><p><img src="/../img/image-20220930102130793.png" alt="image-20220930102130793"></p><p>如果是连续变量，计算太复杂了，Q是一个神经网络，很难把它积出来，所以我们只好用蒙特卡洛近似QAQ，把这个期望近似算出来。</p><p>步骤：</p><ol><li><p>随机抽样得到一个动作$\hat{a}$，抽样是根据PDF函数$\pi$来抽的。</p></li><li><p>这里把期望公式记做$g(\hat{a},\theta)$，因为这里的$\hat{a}$是一个确定的动作，所以直接算出g的具体值就可以了。</p></li></ol><p><img src="/../img/image-20220930150738529.png" alt="image-20220930150738529"></p><p>根据定义，$g(A,\theta)$关于A求期望，就等于策略梯度。并且由于$\hat{a}$是根据PDF函数$\pi$随机抽出来的，所以$g(\hat{a},\theta)$是关于策略梯度函数的一个无偏估计，因此，可以用它来近似策略梯度，这就是蒙特卡洛近似。</p><p>蒙特卡洛近似就是抽一个或者很多个随机样本，用随机样本来近似期望，更新模型参数的时候，用$g(\hat{a},\theta)$来作为近似的梯度就可以了，不用计算出精确的策略梯度。</p><p>总结</p><ol><li>在第t个时间点，观测到状态$s_t$。</li><li>把策略网络$\pi(*|s_t;\theta_t)$作为概率密度函数，用它随机抽样得到一个动作$a_t$。</li><li>计算价值函数$Q_\pi(s_t,a_t)$的值。</li><li>对策略网络求导，算出$\log\pi$关于参数$\theta$的导数。</li><li>蒙特卡洛近似算出策略梯度。</li><li>用策略梯度来更新策略网络。</li></ol><p><img src="/../img/image-20220930153220538.png" alt="image-20220930153220538"></p><p>如何计算$Q_\pi(s_t,a_t)$？</p><p>方法一：Reinforce</p><p>用策略网络$\pi$来控制agent运动，从一开始一直玩到游戏结束，记录整个游戏的轨迹，就可以计算出整个游戏的$u_t$，而$Q_\pi(s_t,a_t)$又是$U_t$的期望，可以用观测值$u_t$来近似$Q_\pi(s_t,a_t)$。</p><p>所以，该方法就是用观测到的$u_t$来代替$Q_\pi(s_t,a_t)$。</p><p>方法二：用一个神经网络来做近似</p><p>不是已经有了一个神经网络用来近似策略函数了吗，现在再用一个神经网络来近似动作价值函数$Q_\pi$。一个actor演员，一个critic评论员，也叫actor critic算法。</p><p><img src="/../img/image-20220930154240239.png" alt="image-20220930154240239"></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>神经网络</title>
    <link href="/2022/09/28/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/09/28/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<hr><p><a href="https://blog.csdn.net/yawei_liu1688/article/details/113528209">参考：损失函数与期望风险</a></p><p><a href="https://blog.csdn.net/MoreAction_/article/details/106230690">参考：期望、方差和协方差的含义</a></p><h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><h2 id="数据分割"><a href="#数据分割" class="headerlink" title="数据分割"></a>数据分割</h2><p>举个例子，判断北京和郑州的房价，定义房价=价格/面积=x/y，高于0.69的属于北京，低于0.69的属于郑州。并且写成<script type="math/tex">f(x,y)=x-0.69y</script>的形式，当f(x,y)&gt;0时，判定是北京，小于0判定为郑州。</p><p>更现实的情况是，这个能正确区分北京和郑州的阈值并不会恰好是0，打个比方是10，我们仍然可以对函数进行校准，需要写成<script type="math/tex">f(x,y)=x-0.69y-10</script>的形式。</p><p>在这个式子里，x的量纲是1，y的量纲是-0.69，每份y贡献-0.69，每份x贡献1，贡献度正好是x,y的系数。依此类推，当出现更多影响因素时，<script type="math/tex">f(价格，面积，距离，楼层，环境，......)</script>，每个维度都可以看作一个变量，最终决定这个房子值不值得购买。</p><p>写成变量的形式：$f(x_1,x_2,x_3,x_4,x_5,……)=w_1x_1+w_2x_2+w_3x_3+w_4x_4+w_5x_5+…+b=y$$，$其中$w_i$决定$x_i$对y的贡献程度，也叫权重系数，b决定的是阈值的偏移程度，也叫偏置系数。</p><p>在坐标图上看样本点，一条分界线$0.0018x_1-0.0012x_2-1.78=0$将数据分割成上下两部分，在确定分界线后，数据划分也就确定了。所以我们的目标就是找到这条分界线。</p><p><img src="/../img/image-20221002002558453.png" alt="image-20221002002558453"></p><p>神经网络分为两部分：</p><ol><li>决策/预测：在分界线确定之后，对于任意一个新数据，我们都可以根据它在分界线上的位置来判断它属于哪一类。但是机器不会看图，所以就会根据将x代入y后大于或者小于0来分类。f(x)&gt;0则在直线上方，反之在下方。</li><li>训练/学习：这个过程就是如何找到那条分界线，分界线并不唯一，并且事实上根本不存在一条完美的分界线，我们只能从中选择一条还不错的。所以最重要的是找到判断分界线好坏的标准。</li></ol><p><u>看一下下面这几个：</u></p><p>对比学习：有人类做实验的意思了，随机对照实验</p><p>迁移学习：拿了训练好的基础，再基础上继续训练</p><p>强化学习：在给定的基础定义（游戏规则）上，枚举（穷举），统计概率</p><p>强化学习+系统自己随机生成基础定义（游戏规则）就能实现大胆猜想，小心验证的通用智能了。</p><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>分界线标准：在已有的数据样本点上，选出一条能把所有数据完美分割开的分割线是否可行呢？不行，这样只能做到对已知的数据最好，无法保证对未知的数据也是最好的。所以我们选择了一个判断标准之后，这里面就应该包含对未来数据可能情况的一种预测。这在数学逻辑上无法做到，因此引入公设（一种设定，可以有很多种这样的设定）。</p><p>公设一：</p><p>算出离直线最近的点到直线的距离，这个距离越大越好，最小间隔函数如下：</p><script type="math/tex; mode=display">M(W)=\min_{i=1,2,...,N}\frac{1}{||W||_2}|f(X^{(i)}|</script><p>我们要找的是使最小间隔最大的那一组系数<script type="math/tex">W=w_1,w_2,...w_N,b</script>，在不考虑算力的情况下，计算机可以自己完成这样的选择。</p><p>公设二：</p><p><img src="/../img/image-20221002005643117.png" alt="image-20221002005643117"></p><p>等式左边的意思是在给定系数的条件下，取到该数据点的概率是多少，把数据点输入f(x)，通过sigmoid激活函数后，f(x)值越大，输出越接近于1，左边的概率值也就越接近于1。因为f(x)&gt;0时分类为北京，f(x)<0时分类为郑州，所以当f(x)>0大于的越多，该地属于北京的概率就越大，而-f(x)&gt;0大于的越多，就代表该地属于郑州的概率就越大。</0时分类为郑州，所以当f(x)></p><p>因此得到公设：让所有的数据点对应的似然值同时最大的时候最好。因为在这里变动的不是随机变量X，而是条件W，所以不叫概率值，叫似然值。</p><blockquote><p>概率是随机变量的概率，似然是概率分布函数参数的似然。</p><p>有时我们不能在实验前获取随机变量概率分布函数中的具体参数值，这个时候我们通过大量试验收集样本数据，统计样本结果，来推测<strong>参数取值的可能性</strong>，此时这个<strong>可能性大小就是似然值</strong>，这个推测参数取值最大可能性的过程也就是后面我们要讲解的<strong>最大似然估计</strong>。</p></blockquote><p>因为是所有概率值同时最大，所以是一个相乘的关系，列出如下表达式，并用log把连乘变成连加。</p><p><img src="/../img/image-20221002011344066.png" alt="image-20221002011344066"></p><p>公设三：</p><p>假设存在一个可以完美将数据分类的T(x)函数，用图像表示：</p><script type="math/tex; mode=display">T(X)=\begin{cases} 1:X\in\{北京\}\\  0:X\in\{长治\}， \end{cases}</script><p><img src="/../img/image-20221002163443188.png" alt="image-20221002163443188"></p><p>现实中会有噪声存在，对T叠加一个噪声后，就不再是非0即1的情况了，</p><script type="math/tex; mode=display">T(X)+\epsilon=\begin{cases} 1+\epsilon:X\in\{北京\}\\  0+\epsilon:X\in\{长治\}， \end{cases}</script><p>这时候sigmoid函数又可以发挥作用了,</p><script type="math/tex; mode=display">T(X)+\epsilon=sigmoid(f(X))</script><p><img src="/../img/image-20221002164927433.png" alt="image-20221002164927433"></p><p> 对f(X)取值sigmoid后与T(X)的偏差，就是定义的误差项$\epsilon$，我们希望这个误差越小越好，也就是说，方差越小越好。</p><p><img src="/../img/image-20221002165207081.png" alt="image-20221002165207081"></p><p>还有更多的公设，在数学上都可以证明。</p><h3 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h3><p>sigmoid函数：<img src="/../img/image-20221002174627021.png" alt="image-20221002174627021"></p><p> 做指数变形，把$\hat{y}$从实数域投射到$(0,\infty)$ </p><p><img src="/../img/image-20221002174851249.png" alt="image-20221002174851249"></p><p>softmax函数：<img src="/../img/image-20221002175019842.png" alt="image-20221002175019842"></p><p>选择哪一种判断标准，也就是选择哪一种公设，在机器学习上叫做策略。<strong>算法（反向传播——梯度下降法）、策略（输出层）加上模型（隐藏层），就是机器学习的三大要素。</strong></p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>线性方程在坐标图上的表现就是一条直线，增加多次项就相当于增加曲度，只要增加足够的多次项，无论多么奇怪的形状都能够表示出来，举个例子：</p><p><img src="/../img/image-20221002165841885.png" alt="image-20221002165841885"></p><p>可见，随着次数的增加，曲线会越来越复杂，模型的复杂程度也会提高。 </p><p>虽然我们讨论的是分类问题，但是在曲线的拟合方面，和回归在模型上并没有什么本质的区别。当我们拟合出一条回归曲线后，任意给出一个$x_1$的值，我们都可以预测出它对应的$x_2$的数值。这时候完成的就是预测而不是分类。</p><p> 既然直线这么不好用，我们就提高模型的复杂程度来分类，神经网络做的就是这样的工作。</p><p><img src="/../img/image-20221002170454030.png" alt="image-20221002170454030"></p><p>神经网络最左边是输入层，对应的是数据的维度，神经网络里任意一个神经元，都会和上一层，下一层所有的节点相连，所以叫全连接神经网络。</p><p><img src="/../img/image-20221002170733234.png" alt="image-20221002170733234"></p><p>看个最简单的，每一条线就代表一个权重，连起来就是一个线性方程。</p><p><img src="/../img/image-20221002170823104.png" alt="image-20221002170823104"></p><p> 然后它的结果z要经过激活函数后才会传给下一层，激活过程用神经元统一表示。</p><p>以二维输入向量举例，这个过程就是这样的：</p><p><img src="/../img/image-20221002171950200.png" alt="image-20221002171950200"></p><p><img src="/../img/image-20221002171058240.png" alt="image-20221002171058240"></p><p>在经过激活函数前：</p><p><img src="/../img/image-20221002171434650.png" alt="image-20221002171434650"></p><p>经过激活函数后：</p><p><img src="/../img/image-20221002171111001.png" alt="image-20221002171111001"></p><p>再加一层神经元：上一层的输出是下一层的输入：</p><p><img src="/../img/image-20221002171809601.png" alt="image-20221002171809601"></p><p><img src="/../img/image-20221002171623928.png" alt="image-20221002171623928"></p><p>给第一层多加一个神经元：，每层的输出就从单值变成向量了：</p><p><img src="/../img/image-20221002171914583.png" alt="image-20221002171914583"></p><p><img src="/../img/image-20221002172231769.png" alt="image-20221002172231769"></p><p> 依此类推，神经元数量越多，模型越复杂：</p><p><img src="/../img/image-20221002173141748.png" alt="image-20221002173141748"></p><p>只要增加的够多，什么形状都能编出来，这就叫 万能逼近定理。实现这个定理最关键的是一个非线性的激活函数，否则再怎么增加神经元得到的也只是一个多维的平面。</p><blockquote><p>总之，神经网络的复杂性来自于激活函数。</p></blockquote><p>不同的激活函数会拟合出不同的形状，它们可以是这些：</p><p><img src="/../img/image-20221002173432075.png" alt="image-20221002173432075"></p><p>原理：举个例子，加入输入只是一个二维向量，经过矩阵运算后，相当于把它从二维升到了三维，原本不可分的数据，现在即使用更简单的模型也可以把它们分开。</p><p><img src="/../img/image-20221002174123794.png" alt="image-20221002174123794"></p><p>所以我们可以把中间的层看做是对输入的一个升维操作，有多少神经元就会把数据升到多少维。只要维度够高，一定能找到一个超平面，完成对数据的划分。因此，最后一层神经元只需要考虑策略的问题就可以了，该层是否需要激活函数由策略决定。</p><p>但如果只从隐藏层的作用是升维这一角度去理解，通常会发现隐藏层的神经元要少于输入个数，比如：<img src="/../img/image-20221002175255234.png" alt="image-20221002175255234"></p><p>举个例子，在人脸识别中，图片的每个像素都是一个输入，最后对这些输入进行抽象，提取特征，才是我们需要的东西，真实的输入像素反而不是。</p><p><img src="/../img/image-20221002175534642.png" alt="image-20221002175534642"></p><p>再举个例子，在字符识别中，把字符分割成不同大小，分割的最小最具体的一层作为最外层神经元，可复用性最强，个数也最多，越往里分割的部分越抽象，神经元个数也越小，因此隐藏层越深，抽象程度越高。</p><p><img src="/../img/image-20221002175642701.png" alt="image-20221002175642701"></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>在预测的时候，用到的是正向传播$f_W(X)=\hat{Y}$，只不过这个f是一个神经网络，运算特别复杂。在训练的时候，这个关系就会反过来，用来训练的是已知的真实数据X和Y，作为变量需要我们求解的是系数。</p><p><img src="/../img/image-20221002181308051.png" alt="image-20221002181308051"></p><p>这个曲面的最高点就是我们在选择策略后想要达到的目标。但是在初始化时，系数可能出现在任何一个点上，理想情况下，它到最优点的距离就是我们希望求解的目标，但是白想，没有用。</p><p>但是有一点，那就是在这个曲面上任何一点， 我们都可以求出一个向量，这个向量总是指向上升最快的方向，这个向量在参数平面上的投影就叫做梯度。</p><p><img src="/../img/image-20221002182458208.png" alt="image-20221002182458208"></p><p> 梯度下降法：梯度总是指向上升最快的方向，但是有的策略是求最大，有的是求最小，为了统一他们，即便是求最大的问题。也会在函数前面加一个负号，转换成求最小。</p><p><img src="/../img/image-20221002182914297.png" alt="image-20221002182914297"></p><p>这里曲面虽然反了，但是梯度仍然是指向上升最快的方向，所以会先对梯度求反，让他指向下降最快的方法。</p><p><img src="/../img/image-20221002183649863.png" alt="image-20221002183649863"></p><p>通过这个梯度进行反向传播，更新W的参数：</p><p><img src="/../img/image-20221002183846639.png" alt="image-20221002183846639"></p><p>反向传播表达式：</p><p><img src="/../img/image-20221002184116647.png" alt="image-20221002184116647"></p><p><img src="/../img/image-20221002184128040.png" alt="image-20221002184128040"></p><h2 id="支持向量机SVM"><a href="#支持向量机SVM" class="headerlink" title="支持向量机SVM"></a>支持向量机SVM</h2><p>软间隔：</p><p><img src="/../img/image-20221002191511910.png" alt="image-20221002191511910"></p><p>延伸到多维平面：</p><p><img src="/../img/image-20221002191712109.png" alt="image-20221002191712109"></p><p>求x到平面的间距，先求和平面垂直的法向量，也就是下降最快的向量——梯度W，把f(X)对X求导，把X约掉，得到梯度W。</p><p><img src="/../img/image-20221003011038872.png" alt="image-20221003011038872"></p><p>求距离公式=法向量x该点到平面上一点的向量/法向量的二范数。原理：两向量相乘，二者内积就等于一个是一方对另一方的贡献 ，几何意义就是A向量在B向量上的投影再乘上B向量。</p><p>推导过程：</p><p><img src="/../img/image-20221003011103574.png" alt="image-20221003011103574"></p><p>以上，是间隔最大的证明过程，但还需要保证分类也是正确的，即蓝色的点f(X)都要大于0，黄色的点f(X)都要小于0。</p><p><img src="/../img/image-20221003011547492.png" alt="image-20221003011547492"></p><p>推导过程：</p><p><img src="/../img/image-20221003011613894.png" alt="image-20221003011613894"></p><p>整理以上两个条件可得：</p><p><img src="/../img/image-20221003011646310.png" alt="image-20221003011646310"></p><p>$s.t.$约束条件保证分类是正确的，边界计算还可以更简化。</p><p>线性函数中W和b同时增加两倍，直线位置不变，$margin(W,b)$大小也不变。</p><p><img src="/../img/image-20221004160750128.png" alt="image-20221004160750128"></p><p>因此可以做出左边的变形，虽然结果不变，但是括号内的直线部分却发生了变化，为了更确定H的值，另绝对值里的部分强行等于1，于是就又多了一个$s.t.$约束条件，因为左边有个绝对值，所以右边要加上一个标签，可知在分类正确的前提下，加了标签该式就肯定大于0，就相当于加绝对值了。</p><p>合并起来后，可以得到：</p><p><img src="/../img/image-20221004161255962.png" alt="image-20221004161255962" style="zoom:50%;"></p><p>还可以转化成求最小问题：$\min||W||_2$。</p><p>为了方便用<a href="https://www.cnblogs.com/maybe2030/p/4946256.html">拉格朗日乘数法</a>，还可以把它展开成：$\min\frac{1}{2}W^TW$。基本思想就是通过引入拉格朗日乘子来将含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题。</p><p>这里回看对偶问题那一章，晚会看。</p><p>只有在边界上的点，才对边界的大小起作用，才有贡献，因此我们只在乎边界上的点。</p><p><img src="/../img/image-20221004165715184.png" alt="image-20221004165715184" style="zoom:50%;"></p><p>因此，最后决定参数W的只和支持向量有关，SVM就叫做支持向量机。</p><p>将拉格朗日函数转化为损失函数：</p><p><img src="/../img/image-20221004165937256.png" alt="image-20221004165937256" style="zoom:50%;"></p><p>上面这些都是硬间隔，将蓝色和黄色绝对分开。而如果遇到不好分开的情况，我们允许它存在，就叫做软间隔，需要引入一个误差项并做一些改动。正则化是用来减少过拟合的，<u>这个暂时还不会，再看看</u>。</p><p><img src="/../img/image-20221004170227536.png" alt="image-20221004170227536" style="zoom:67%;"></p><p>数学表达：</p><p><img src="/../img/image-20221004170325892.png" alt="image-20221004170325892" style="zoom:50%;"></p><p>$\xi$代表被分错的点到边界的距离，如果分对了，那他就是零，因此还需要这个的总和尽量小，约束条件里也从小于0放宽成了小于$\xi$。两个约束条件写到一起就变成：</p><p><img src="/../img/image-20221004171736009.png" alt="image-20221004171736009" style="zoom:50%;"></p><p>于是损失函数就变成：</p><p><img src="/../img/image-20221004171833056.png" alt="image-20221004171833056" style="zoom:50%;"></p><p>看一眼损失函数里的经验损失项怎么来的：</p><p><img src="/../img/image-20221004172424868.png" alt="image-20221004172424868"></p><p>先看紫线，黄点位于其上方，因此代入线性函数大于0，同时它又是黄点，标签应该为-1，二者相乘是个负数，代入不等式大于1，因此经验损失项也大于1。</p><p>看绿线，在黄点上方，离黄点距离很近，偏差小于1，代入不等式大于0，经验损失项大于0。</p><p>红线也在黄点上方，偏差很大，分类相当正确，代入不等式小于0，没有产生损失，经验损失项为0。</p><p>画出经验损失项的图：</p><p><img src="/../img/image-20221004172919851.png" alt="image-20221004172919851" style="zoom:50%;"></p><p>W，b错的越离谱，损失函数越大，W，b正确的话则不会产生损失。</p><p>机器学习分类问题整理：</p><p><img src="/../img/image-20221004173511340.png" alt="image-20221004173511340"></p><p>现实中我们能做出来的是分类函数T(X)，它能做到的顶多就是在训练集里能完全分类，但我们的目标其实是在所有情况下均可以正确分类，也就是G(X)。</p><p>我们在训练T(X)的过程就是把它拆分成两部分——模型函数和决策函数，用一个模型函数来分割或拟合这些样本点，这样样本点就被转化成了一个具体的数字，再用决策函数对这个数字进行标签化，大于0代表正类，小于0代表反类，因此，只要模型函数确定了，最后标签也就确定了。</p><p>可以说，模型函数就是给全空间的样本点都赋予了一个具体的实数值，f(X)=0既是分界线，也是度量的锚点。</p><p>我们比较T(X)和G(X)，想让他们尽可能一样，只需要比较模型函数即可，决策函数部分不用比较，因为只要他们对应的模型函数是一致的，决策结果一定是一致的。</p><p>因此，这里引入J(X)来比较T(X)和G(X)，这个J(X)就是我们常说的损失函数，学习算法就是用来找到最小损失函数的，这样就把机器学习拆成了两部分：</p><p><img src="/../img/image-20221004174609296.png" alt="image-20221004174609296"></p><p>而损失函数就是为这个度量赋予意义，然后再做适当修正，让修正的结果具有某种现实意义，根据我们对现实意义的理解做出约束，最后在这个现实意义的基础上进行决策。</p><p>可以说，最开始得到的这个度量是没有现实意义的，我们无法根据它猜测这个模型函数和真实情况是否一致，只有在我们给它赋予一些在现实中已经证实的有经验的东西——我们对数据、经验、和世界的理解和归纳。（感觉开始玄学了）</p><p>举个最小二乘法的例子，它给损失函数赋予的意义是一个服从高斯分布的方差，因为根据经验，我们现实中的噪声多数是高斯噪声。</p><p><img src="/../img/image-20221004180202366.png" alt="image-20221004180202366"></p><p>紫色是理想情况，最小二乘法默认方差是服从高斯分布的，因此我们只要找到这些值进行代入就可以了。但是理想情况的函数值只有因果律知道，不过没关系，我们知道训练集的标签，它是已知的，我们可以把训练集的标签当作理想情况的函数值来输入。但是这个标签很固定，只会是-1和1，怎么和我们的模型参数进行比较啊？用双曲正切函数修正它，把它约束到-1和1之间，那这个时候再去求它和标签值的方差，就很合理了。</p><p>再看看别的损失函数的意义：</p><p>最大似然估计法：通过sigmoid得到的值在0-1之间，就可以看作一个概率。在训练集里X和Y已知的情况下，对所有未知参数$\theta$求似然值，当这个似然值最大的时候，我们猜测这个函数和最终目标函数相同。（就相当于，如果在取这个$\theta$的时候，得到现实样本点的概率最大，那它是现实函数的参数的可能性就越大）</p><p>推导过程的最后一步，因为抽样X的概率各个X的概率是一样大的，所以$P(\overline{X})$可以看作是一个常数，在求max的时候直接忽略掉这个常数就可以了。然后就得到了最大似然值的表达式，要注意的是：$y$是真实标签的值，它的值只能是0或1，否则不成立。</p><p><img src="/../img/image-20221004183112819.png" alt="image-20221004183112819"></p><p>并且，再假设：</p><p><img src="/../img/image-20221004183622147.png" alt="image-20221004183622147" style="zoom:50%;"></p><p>这就是最大后验估计。</p><blockquote><p>从原因到结果的论证称为“先验的”，而从结果到原因的论证称为“后验的”。</p></blockquote><p>SVM：在函数模型前乘以一个项，得到它离软间隔的几何距离，有了这个度量后再进行三个约束，默认当约束全部满足时，我们猜的模型和真实模型是一致的。</p><p><img src="/../img/image-20221004184019866.png" alt="image-20221004184019866" style="zoom:80%;"></p><h2 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h2><p>如果是两个同类型的model，比如都是高斯分布，那只用分别比较他们的期望和方差就可以了，但如果不是同一种模型，比如一个是高斯分布，一个是泊松分布，那是否存在一个公度，可以把他们放在一起比较呢？</p><p>答案是熵。</p><p>从信息论的角度可以理解为，从原来的不确定变成确定，它的难度有多大。</p><p>信息量其实是无法计算的，我们只能给出定义。</p><p><img src="/../img/image-20221004202949393.png" alt="image-20221004202949393"></p><p>打个比方，阿根廷夺冠的信息量其实是等于进决赛和赢了决赛加在一起的时候的，因为当我们知道阿根廷进决赛并赢下决赛，就等于知道了阿根廷夺冠。但这在概率论上，相加明显就不成立了。为了保持自洽，信息量的计算公式必须有一个log，并且需要函数是递减的，所以要加个负号。而以2为底，最后得出的单位是bit。</p><p><img src="/../img/image-20221004211131305.png" alt="image-20221004211131305" style="zoom:67%;"></p><p>这时候下面的函数值就等于3。</p><p><img src="/../img/image-20221004211509482.png" alt="image-20221004211509482"></p><p>德国和比利时赢下足球的概率是一半一半，非常难确定谁会赢球，这个系统的熵就很大。但是法国和中国几乎稳稳地就是法国赢球，非常容易确定，因此这个系统的熵就很小。然而简单相加左边这个系统的熵就很小，所以要根据贡献度乘以一个比例才行。</p><p>因此，右边对系统贡献的信息量大概是0.058，</p><p><img src="/../img/image-20221004211951950.png" alt="image-20221004211951950" style="zoom:50%;"></p><p>左边对系统贡献的信息量是1，</p><p><img src="/../img/image-20221004212121257.png" alt="image-20221004212121257" style="zoom:50%;"></p><p>这么一看不就是求期望吗，因此可以把熵定义为：</p><p><img src="/../img/image-20221004212214048.png" alt="image-20221004212214048"></p><p>最后算出来的是一个不确定（混乱）程度。</p><p>相对熵（KL散度）：</p><p><img src="/../img/image-20221004212640747.png" alt="image-20221004212640747"></p><p>P在前，所以是以P系统为基准，熵是恒定的，因此最后得到的式子里，后半部分是恒定的，我们只用看前面部分。当KL散度等于0的时候，P和Q是最接近的。</p><p>根据吉布斯不等式，KL散度是绝对大于等于0的。</p><p>因此，如果我们想让这两个模型尽可能的接近，那就去找交叉熵的最小值就好了，也就是说，交叉熵本身就可以作为损失函数。</p><p>交叉熵的定义：</p><p><img src="/../img/image-20221004213244529.png" alt="image-20221004213244529" style="zoom:50%;"></p><p>这个m是什么呢？如果P，Q的系统里，x也就是发生事件的数量不一样，那么这个x只要选数量大的那个就可以了。</p><p><img src="/../img/image-20221004213649587.png" alt="image-20221004213649587"></p><p>当把图像识别和人脑做交叉熵的时候，p就是人脑，它只肯给出两个可能，要么是猫要么不是，而q就是机器学习要给的它像猫或者不像猫的概率到底是多少，最后展开成上图。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>当我们求梯度的时候，求的就是损失函数的梯度。损失函数就是我们设计出来的函数和我们真正想要的之间的误差，那么损失函数是如何设计出来的呢？</p><p>吴恩达老师给出的公式，可以写成两种形式：</p><p><img src="/../img/image-20221005085901958.png" alt="image-20221005085901958" style="zoom:50%;"></p><p><img src="/../img/image-20221005085918649.png" alt="image-20221005085918649" style="zoom:50%;"></p><h4 id="最小二乘法（最简单）"><a href="#最小二乘法（最简单）" class="headerlink" title="最小二乘法（最简单）"></a>最小二乘法（最简单）</h4><p>以下面这个神经网络为例：</p><p><img src="/../img/image-20221005090133768.png" alt="image-20221005090133768" style="zoom:80%;"></p><p>输入是一个非0即1的标签，代表输入的图片是不是猫，经过神经网络计算后输出一个0-1之间的概率，表示是猫的概率有多少。当x和y相差无几的时候，我们就可以认定机器学习的模型和我们人脑的模型是近似的。</p><p>因此，为了求这个差距，我们可以用$\min|x-y|$来表示，但是绝对值通常不会是全程可导的，因此我们需要对$(x-y)$求平方，这样虽然值发生了变化，但是最小还是最小，不影响。</p><p><img src="/../img/image-20221005090735612.png" alt="image-20221005090735612" style="zoom:50%;"></p><p>因此可以证得吴恩达老师的第一个公式：</p><script type="math/tex; mode=display">L(\hat{y},y)=\frac{1}{2}(\hat{y}-y)^2</script><p>这里的$\hat{y}$就是上面神经网络里的$x_i$，为什么要加一个$\frac{1}{2}$的系数是因为求偏导后会下来一个2，正好可以约掉。</p><p>直接把两个模型结果做差求距离虽然很简单，但是在求梯度下降的时候会非常麻烦，因此不建议选用。</p><h4 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h4><p>是一种概率的反向运用，打个比方：抛硬币的时候，假设我们不知道其实是正反各0.5的概率，但是我们掷了1w次以后，正反差不多各5k次，我们就可以反推它们的概率分布是正反各0.5。</p><p>但如果投了10次硬币，7次正3次反，我们又规定了这样的概率模型，那么这种情况会出现的概率有多大呢？答案很明显是$0.1^7\cdot0.9^3$。</p><p><img src="/../img/image-20221005092107603.png" alt="image-20221005092107603" style="zoom:50%;"></p><p>我们把这个概率值叫做似然值，它虽然也是一种可能性，但是是从真实世界反推回来的。它是在真实的情况已经发生后，我们假设它有很多模型，在某一个概率模型下发生这种真实情况的可能性。</p><p>在训练神经网络的时候，我们输入的图片就像是抛出的那些硬币一样。我们人脑已经知道这些图片是不是猫了，并且告诉了神经网络，现在就要找到一种似然值最大的情况，使神经网络输出的分类也和我们人脑一样，这时的概率模型就应该是最接近真实情况的。</p><p>举个例子：</p><p><img src="/../img/image-20221005093452699.png" alt="image-20221005093452699"></p><p>这世上有各种各样的猫，但是存在一个边界，超出这个边界就不是猫了，这个边界是我们人脑划定的，比如他可能呈高斯分布，那么神经网络就要调整自己的分布，通过调期望和方差来逼近我们人脑的边界线。</p><p>但也可能不是，不过没关系，只要叠加的感知级够多，什么形状都可以逼近出来的，因此我们搭建一个NN神经网络，通过调整W和b来逼近这个人脑模型。</p><p>推导极大似然估计的公式：</p><p><img src="/../img/image-20221005094256500.png" alt="image-20221005094256500" style="zoom:50%;"></p><p>$x_i$放到上面那个判断猫猫的例子里，就是判断的结果0或1，将所有概率连乘后得到第二行的式子，但是每一项的结果不是0就是1，用不了，因此要引入一个$y_i$，它的参数是W和b，输出的是猫猫的概率为多少。</p><p>因为$x$不是0就是1，所以其实是符合伯努利分布的，p代表是猫猫的概率，y就是猫猫的分布，最后展开成：</p><p><img src="/../img/image-20221005095408839.png" alt="image-20221005095408839" style="zoom:50%;"></p><p>连乘不好算，换成连加，log不改变单调性，该极大值还是极大值：</p><p><img src="/../img/image-20221005095629064.png" alt="image-20221005095629064" style="zoom:50%;"></p><p>然后就得到了吴恩达老师的第二个公式：</p><script type="math/tex; mode=display">L(\hat{y},y)=-[y\log\hat{y}+(1-y)\log(1-\hat{y})]</script><p>这里的$\hat{y}$就是我们的$x_i$，因为我们更常算最小值，所以加个负号把max变成了min。</p><p><img src="/../img/image-20221005095753697.png" alt="image-20221005095753697" style="zoom:50%;"></p><h2 id="最大熵"><a href="#最大熵" class="headerlink" title="最大熵"></a>最大熵</h2><p>训练神经网络用梯度下降法，优势是简单好用，劣势是计算量非常大。看看大佬们怎么优化和改进梯度下降法，其中有一种是在隐藏层，把隐藏层感知机的激活函数换掉，从原来的sigmoid换成ReLU函数。</p><p>原因很好理解，因为如果传入的数值恰好在绿框部分的话，这里的梯度是非常小的，如果这个梯度再反向传播，传到前面几层基本上就不剩啥了，这就叫做梯度消失。</p><p><img src="/../img/image-20221005101034990.png" alt="image-20221005101034990"></p><p>如果换成ReLU函数，只要大于0就是一条直线，梯度是一个定值，不会出现梯度消失的问题。但是被ReLU激活过的函数输出是可以无穷大的，怎么转化成概率值需要的0-1之间呢？</p><p><img src="/../img/image-20221005101226575.png" alt="image-20221005101226575" style="zoom:50%;"></p><p>可以在最后一层用sigmoid，把它重新归到0-1之间，这个时候用损失函数就没太大问题了。但是这时候就只能解决一种分类的情况了，因为sigmoid函数只能解决单个感知机归一的问题，比如最后可能会输出两个分类结果，是猫的概率是60%，是狗的概率也是60%，加起来都超过1了。明显不太适合用于这种分类造成的结果互斥情况（是猫就不会是狗），但如果是可以标签重合的情况，就比如这个小动物既可以是可爱的，也可以是吃肉的，等等等等，这些要一起分类的话，softmax反而不合适了，反而要回去用sigmoid。</p><p>输出层只有单个感知机的情况：</p><p><img src="/../img/image-20221005103127031.png" alt="image-20221005103127031"></p><p>输出层有多个感知机的情况，z，y，a就变成了一个向量：</p><p><img src="/../img/image-20221005103222720.png" alt="image-20221005103222720"></p><p>a作为最后输出的结果：</p><p><img src="/../img/image-20221005103326143.png" alt="image-20221005103326143" style="zoom:50%;"></p><p>首先是一个向量，其次每一项都是一个概率，所以大于等于0肯定，然后任何一个图片或数据输入给神经网络，都应该有一个分类，把每一个分类的概率都加起来，那它就应该是百分百会发生的事，所以元素之和等于1，用e为底，将z作为e的指数，就可以做到值域绝对大于0，再除以所有分子的总和，做归一化处理，得到的就是softmax函数。</p><p><img src="/../img/image-20221005150321481.png" alt="image-20221005150321481" style="zoom:50%;"></p><p>通过比较softmax和sigmoid函数发现，sigmoid函数其实就是只有一种分类情况下的softmax，$t_2$是不会变化的。</p><p>之前章节里，我们学到的都是无论这个神经网络有多么复杂，只要似然值最大并且交叉熵最小，就可以认为这个模型已经逼近了人脑，但其实还存在一个隐藏的前提假设，只要激活函数选择了sigmoid或者softmax，这个前提条件就默认被勾选了，它就是最大熵原理。</p><p>举个例子，比如说你对一个概率问题完全没有什么额外的信息，我们去猜概率的话只能挨个猜，相当于每个事件的概率都是相等的，当然也可以猜第一个是50%，第二个是25%，第三个是5%这样。这样计算出来第二种的熵明显比第一种要小，而第一种熵是所有猜测里最大的。</p><p>在已知一部分概率的条件下，未知的信息都要符合最大熵原理。这样得到的模型既能满足已知的信息，又能让未知的信息熵最大。因此，问题可以被拆成两部分，第一个部分是解决相同的问题，第二个部分是解决最大熵的问题。</p><p>前面提到过的交叉熵，KL散度，可以用来比较两个概率模型之间的差别，但前提是两个概率模型是已知的，而现在两个里我们只知道半个，首先目标概率模型是不到的，已知的只是一堆样本数据，还要从中归纳出背后的概率模型。</p><p>那咋办呢？数学家提出了一个概念，是概率论里的矩。</p><p>先看一眼正态分布：</p><p><img src="/../img/image-20221006092037858.png" alt="image-20221006092037858"></p><p>不论什么样的正态分布，只要确定了期望和方差，都可以没有任何信息损失的把它的概率分布描绘出来，它的期望和方差表达式如上，期望就是平均分布，方差就是一个二次减一次的平方。但就凭这个还是无法归纳出背后的规律，现在对正态分布做一定量的偏移，得到：</p><p><img src="/../img/image-20221006092517835.png" alt="image-20221006092517835"></p><p>多了一个三次项，而$\mu$和$\sigma$在前面都已经知道了，那是不是可以猜想，概率分布和这些多次项有关呢？然后数学家证明了，真的有，而且还起了名字。</p><p><img src="/../img/image-20221006092915969.png" alt="image-20221006092915969"></p><p>得到的归纳结果是，如果是一个正态分布，只用一阶矩和二阶矩就能描述出来，更复杂一点，需要三阶矩，再复杂的话就通过四阶矩、五阶矩、六阶矩等等，也能给描述出来。</p><p>也就是说，任何一个概率分布，它的特征都可以用这样一个向量来表现：</p><p><img src="/../img/image-20221006093434038.png" alt="image-20221006093434038" style="zoom:50%;"></p><p>数学家们定义了一个特征函数，$e^{itx}$是一个复数，求这个复数的期望，任何一个概率分布都可以用特征函数来表示出来，而且一个概率分布就对应一个特征函数，把这个特征函数在$x=0$处<a href="https://zhuanlan.zhihu.com/p/404446570#:~:text=%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%80%BC%E8%BF%91%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%BD%8E%E6%AC%A1%E5%88%B0%E9%AB%98%E6%AC%A1%E7%9A%84%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%B4%AF%E5%8A%A0%E6%9D%A5%E6%8B%9F%E5%90%88%E5%87%BD%E6%95%B0%20f%20%28x%29%20%E5%9C%A8%E6%9F%90%E4%B8%AA%E7%82%B9%E9%82%BB%E5%9F%9F%E7%9A%84%E5%87%BD%E6%95%B0%E5%80%BC%E3%80%82%20%E6%AF%94%E5%A6%82%E5%9C%A8%E7%89%A9%E7%90%86%E4%B8%8A%EF%BC%8C%20text%20%7Bsin%7D%20%28x%29,x%20%E6%9D%A5%E9%80%BC%E8%BF%91%20text%20%7Bsin%7D%20%28x%29%20%E5%9C%A8%20x%3D0%20%E9%99%84%E8%BF%91%E7%9A%84%E5%87%BD%E6%95%B0%E5%80%BC%E3%80%82">泰勒展开</a>，得到上面的式子。</p><blockquote><p><strong>泰勒展开的实质是找一个各阶导数都和原函数在展开点处的导数相等的多项式，来达到拟合的效果。</strong></p></blockquote><p>这个式子其实就是上面那个向量的线性关系。</p><p>也就是说，如果有两组数据，想知道它们的概率分布是否一样，只需要去比较它们的一阶矩，二阶矩，三阶矩……是否相同，如果相同，不需要去计算他们的概率分布具体表达式，就可以确定是一样的。</p><p>因此，我们在做神经网络拟合现实模型的时候，只需要保证：</p><p><img src="/../img/image-20221006100355037.png" alt="image-20221006100355037" style="zoom:50%;"></p><p>现在我们知道拿到两个概率模型之后，就算我们不知道它们具体是什么，也知道应该比什么了。具体到机器学习和训练集，这个情况是什么样的呢？</p><blockquote><p>$\tilde{P}$代表经验概率，即从数据中直接归纳出的概率。</p></blockquote><p><img src="/../img/image-20221006100815684.png" alt="image-20221006100815684"></p><p>在图片识别应用中：</p><p><img src="/../img/image-20221006102106310.png" alt="image-20221006102106310"></p><p>训练集内有N个图片，每个照片都可以用$(x,y)$来表达，其中x表示照片，y表示标签，它是一个向量，每个分量代表一个分类，因为神经网络的输出层有四个，所以是一个四维的向量，代表它属于哪一个分类。</p><p>但是这里给出的照片不可能有两个完全一样的照片，所以若按像素输入的话概率值只可能等于1/N，这样就没有意义了，无法区分开不同的照片。 </p><p>但不看输入层，看隐藏层，尤其是输出层前一层的隐藏层，感知机就没有那么多了，可以把这一层的感知机看作一个一个的特征，将特征作为x输入，这时候概率值就不是1/N了。</p><p><img src="/../img/image-20221006104908439.png" alt="image-20221006104908439"></p><p>$\tilde{P}(x,y)$和$\tilde{P}(x)$都是已知的，我们的目标是求在输入x图片的情况下，y——即分类概率是多少，$P(y|x)$中包含了一部分已知的，又包含了一部分未知的，已知的部分要完全相等，未知的部分要用最大熵，这就是我们接下来求解问题的方针。</p><p>用贝叶斯公式把目标概率展开得：</p><p><img src="/../img/image-20221006105744859.png" alt="image-20221006105744859" style="zoom:50%;"></p><p>$P(x,y)$按理说是不知道的，但是前面有经验概率，我们若想利用这个经验概率，需要保证$P(x)\cdot P(y|x)$和这个经验概率相等，$P(x)$仍然可以用经验概率，未知部分要用最大熵来确定，因此，要保证：</p><p><img src="/../img/image-20221006110648640.png" alt="image-20221006110648640" style="zoom:50%;"></p><p>第三个式子虽然也可以用，但是求偏导不太方便，所以不建议，我们不用。</p><p>在前面通过数数的方式得到了$\tilde{P}$，但是只知道概率是无法求期望的，期望的公式是概率乘以随机变量的累加或积分，在这里只有概率，没有随机变量，所以我们还需要在设计一个x和y的随机变量。</p><p>举个例子：</p><p>当确定了事件A以后，只要不符合其中的一个特征，比如“尖脸，是鸭”，就不属于这个事件那么X就等于0。</p><p><img src="/../img/image-20221006164639901.png" alt="image-20221006164639901" style="zoom:50%;"></p><p>这样满足A和不满足A这两个事件就构成了二项伯努利分布非0即1的条件，最后得到X的期望结果就是$\tilde{P}$，就是满足A的概率本身。</p><p>以上是只有一个条件，当一共有m个条件，把样本空间里面所有可能的事件都覆盖掉，那么对$X_1,X_2,…,X_3$求期望，得到的就是对应事件的概率。这部分的函数在很多论文里叫特征函数，其实英文直译应该是指示函数。</p><p><img src="/../img/image-20221006171520590.png" alt="image-20221006171520590" style="zoom:50%;"></p><p>这时候再去完成让两个模型分布相等的目标，只需要把f设计成所有事件的一阶矩，因为只要一阶矩相等，这两个概率分布就一定是相等的。因为对于伯努利分布来说，决定它的形状的只有一阶矩。</p><p>因此，之前那个需要考虑很多阶矩的复杂问题就只用考虑一阶矩了，只要将样本空间里所有的可能事件都列举出来就可以了。</p><p>这时候，下面这个问题其实就已经解决了：</p><p><img src="/../img/image-20221006172021361.png" alt="image-20221006172021361" style="zoom:50%;"></p><p>在设计了这些$X_m$事件后，就相当于在原来的样本空间$(x^(k),y^(k))$上，重新设计了一个样本空间，原样本空间的维度非常高，现在变成了只有一维的情况，这个一维就是事件。</p><p><img src="/../img/image-20221006172434773.png" alt="image-20221006172434773"></p><p>也就是把原来很多维的输入，都投射到一维的事件上，在一维上进行比较。</p><h3 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h3><p>我们之前的目标有两个，第一个已经达成了，还有第二个求条件概率的最大熵。要求$P(y|x)$的熵，需要把每一个事件下y的熵都求出来，并对它们求期望，所以前面再乘以一个概率，然后求和。</p><p><img src="/../img/image-20221006174155241.png" alt="image-20221006174155241"></p><p>得到右边条件熵的公式$H(Y|X)$，代表X发生之后Y的概率，求和符号下的$x,y$代表x和y的任意一种组合情况，我们可以把它看作X取一个具体值时的熵，然后再对这个熵求期望。</p><p>我们要求它的最大值，还需要满足别的条件。</p><blockquote><p>sigmoid和softmax函数的本质其实就是最大熵。</p></blockquote><p>因为概率经验$\tilde{P}$是可以直接从训练样本里数出来的，所以这里把它看作常数$\Delta$。</p><p><img src="/../img/image-20221006181845123.png" alt="image-20221006181845123"></p><p>在同时满足上面两个条件的同时，用拉格朗日乘数法来求极小值，推导过程如下：</p><p><img src="/../img/image-20221006182040984.png" alt="image-20221006182040984"></p><p>拉格朗日乘数法求极值有一个基础，原本的问题是求当$P,\lambda$等于多少的时候，L的值为最小值，具体过程是，先把$\lambda$当作需要调整的参数，P当作一个参数，找到L的最大值，然后再在最大值的情况下，再去调整P，找到L的最小值。对偶问题则是先把P当作参数，再把$\lambda$当作参数。二者结果是一样的，具体求解如下：</p><p><img src="/../img/image-20221006183112036.png" alt="image-20221006183112036"></p><p>因为$\lambda$项没有$\tilde{P}(x)$系数，为了把$\tilde{P}(x)$提出来，乘上一个它的加和，易知是等于1。这时候就需要偏导等于0来求极值，因为后半部分始终同号，所以求和所有项都是同号，要求和为0，所以要每项都为0。因为L对所有的$P(y_j|x_i)$的偏导都要为0才能保证是可能的极值点。这块的实质是变分，<u>不知道是啥，再看看。</u></p><p><img src="/../img/image-20221006183804353.png" alt="image-20221006183804353"></p><p>把结果化简成感知机进行线性运算的形式，因为$\lambda_0$是归一化条件的系数，所以条件概率最后是归一的，并且样本空间所有样本概率求和结果为1，因此分子分母应该相等。</p><p><img src="https://gitee.com/labulavish/blog/raw/master/img/202210061841725.png" alt="image-20221006184118190" style="zoom:50%;"></p><p>回到softmax函数，可以闭环了。</p><p><img src="/../img/image-20221006184557423.png" alt="image-20221006184557423"></p><p>这里softmax以e为底，不只是为了保证结果大于0，而且是因为在求最大熵偏导的过程中引入了$\log$，反函数用到了e，因此，只要在输出层用到了sigmoid或者softmax函数，就保留了最大熵原理的应用。</p><p>前面只确定了最大熵P的形式，还没有确定参数。</p><p><img src="/../img/image-20221006185111870.png" alt="image-20221006185111870" style="zoom:50%;"></p><p>我们在做机器学习的时候，我们已知的是训练集，但我们希望可以把模型应用到训练集的延长线上，我们扩大的是什么？</p><p><img src="/../img/image-20221006185301603.png" alt="image-20221006185301603"></p><p>如果x和y都在训练集上，那么条件概率就等于经验概率，如果x和y有一个不在训练集上，那么条件概率就是未知的，未知的话就可以用到最大熵原理，因此，这就是机器学习的前提：</p><p><img src="/../img/image-20221006185450171.png" alt="image-20221006185450171" style="zoom:50%;"></p><p>通过$\min L(P,\lambda)$确定出$P(y|x)$的形式，他逃不出指数族的形式。</p><p><img src="/../img/image-20221006191000121.png" alt="image-20221006191000121"></p><p>确定形式后代回原式来求$\lambda$的具体值，这个$\lambda$是一个向量，维数非常多，仅凭计算是求不出来的，常用方法是构建一个损失函数，用梯度下降法训练得到。</p><p><img src="/../img/image-20221006191420978.png" alt="image-20221006191420978"></p><p>整理思路：1、设定样本的概率模型与目标概率模型一致（两个模型特性函数一致）建立服从伯努利分布的变量（此处需要理解样本空间及变量的关系）对两个模型进行降维（降维后两个概率模型依旧一致），由于降维后的两个概率模型只有一阶矩不为零，可以产生一个条件用于后面的计算：降维后样本模型与目标模型的一阶矩相等；2、在满足第一个条件后（降维后样本模型与目标模型的一阶矩相等），可大胆的地将目标概率模型的条件熵转换公式用样本概率模型的经验概率替换，然后计算目标概率模型的条件熵最大值（即满足最大熵原理），计算过程使用了拉格朗日乘数法以及概率论的基本知识。</p><p>只能说为了水论文看这个不合适，想要自己设计算法，知道谁是谁的爹谁和谁有血缘关系太重要了。</p><p>我觉得他们最终归一其实就是为了解决机器学习，但针对不同工程问题而设计出来的算法，极大似然和交叉熵这种计算简单，可以用在直观数据的机器学习，而softmax这种适合更加复杂的问题，比如图片。</p><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>正向传播：把数据输入神经网络，通过参数W，b和无数感知机，得到一个在误差范围内的最终结果。</p><p>反向传播：把偏差的信息传递到各个参数上，根据这些参数对偏差贡献的大小，来相应的承担修改的责任。</p><p>凭直觉来设计一种分配偏差的方式：</p><p><img src="/../img/image-20221007085853363.png" alt="image-20221007085853363"></p><p>绿色的球代表偏差，能对它产生影响的可以分为三层——偏置系数b、权重系数W和上一层神经网络的输出$a^{[2]}$。根据该层每一个感知机的贡献度反向传递对应的偏差，调整参数W和把，上一层输出的调整则要反向传递到上上一层来进行处理。通过这样一层层的向上传播、分配，最终神经网络里每一个W和b都会被分配到对应的份额，并且根据对偏差的贡献相应地调整自己。</p><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><p>梯度=$\nabla f(x,y)$，以下是一个展示梯度的示意图：</p><p><img src="/../img/image-20221007090756143.png" alt="image-20221007090756143"></p><p>红色的曲面代表$f(x,y)$的曲面，选定一个点做一个切面，并做一个向量，它在xy平面上的投影如左图所示，分解得到：</p><p><img src="/../img/image-20221007091404287.png" alt="image-20221007091404287"></p><p>梯度是增大最快的那个方向，如果把它取反，就是减小最快的方向向量。我们要求的就是$(W_i,b_i)$空间中的梯度。在这样一个神经网络中进行反向传播：</p><p><img src="/../img/image-20221007091849342.png" alt="image-20221007091849342"></p><p>梯度的数学表达：</p><p><img src="/../img/image-20221007094155934.png" alt="image-20221007094155934" style="zoom: 25%;"></p><p>方便的理解：梯度就是对不同的方向各自求偏导。</p><p>看下图，P点处的切线是红线，绿线是过曲线的一条直线，当$\Delta x \rightarrow 0$时，绿线会和红线重合。</p><p><img src="/../img/image-20221007094315358.png" alt="image-20221007094315358"></p><p>拓展到高维：</p><p><img src="/../img/image-20221007101241894.png" alt="image-20221007101241894"></p><p>高维平面无法确定，因此引入偏导：</p><p><img src="/../img/image-20221007101407873.png" alt="image-20221007101407873"></p><p>把y当作常数，对应的就是绿色的平面，这个平面和$f(x,y)$的曲面相交，得到曲线$f_y(x)$，对它求偏导就相当于是求在这个曲线上的切线，把x当作常数同理，得到两条相交的直线，可以唯一确定一个平面，这个平面恰好就是这个曲面的切平面。</p><p>继续简化，从z轴向下俯视：</p><p><img src="/../img/image-20221007102302062.png" alt="image-20221007102302062"></p><p>这个点x轴的切向量和y轴的切向量加起来恰好是梯度，因此，梯度就是一个向量，向量的分量就是那些偏导。因此可以引申到全微分：</p><p><img src="/../img/image-20221007102627206.png" alt="image-20221007102627206"></p><p>本来是当作面积来理解的，但是这里两个偏微分组成的一个梯度分别乘上x和y方向上的单位投影，加起来就相当于在梯度方向上移动了一个单位。</p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>这里要区分$\alpha,\beta,\gamma$，$\alpha$和$\gamma$直接可以修改，但是$\beta$需要反向传递，直至传递到第一层，最终体现在W和b上</p><p><img src="/../img/image-20221007092028475.png" alt="image-20221007092028475"></p><p>想让J沿着变化最快的方向进行变化，之前看到的是分别把$x,y,z$减去对应系数的倍数，把这个过程照搬过来，乘一个$\eta$倍数，而$a^{[2]}$是依赖于前面的输入的，所以还需要继续向前传递，因此变形成：</p><p><img src="/../img/image-20221007093228796.png" alt="image-20221007093228796" style="zoom:50%;"></p><p>第一个$a^{[2]}$是原来的，第二个$a^{[2]}$是我们梯度下降后的目标，相减得到一个“单位向量”，再一层层的传递，传递到最上面那一层，遍布每一个W和b之后乘$\eta$，结果是一样的。这样就和损失函数“原输出-目标输出”的形式一致了，于是我们做一个额外的假设：</p><p><img src="/../img/image-20221007093825763.png" alt="image-20221007093825763"></p><p>这样就可以把第二层的损失函数继续展开成第二行的样子，就可以继续迭代，进入下一轮，直到把所有参数都分配一遍。</p><p>引入前面梯度就是求偏导的概念，得到：</p><p><img src="/../img/image-20221007103010507.png" alt="image-20221007103010507" style="zoom:50%;"></p><p>下一轮更新：</p><p><img src="/../img/image-20221007103141209.png" alt="image-20221007103141209" style="zoom:50%;"></p><p>由于a的偏差数值不止有一个感知机确定，是由上一层所有感知机确定，所以把他们加起来，然后求一个平均（为了求导之后可以抵消）。</p><p>到了$a^{[0]}$输入层，它就是一个输入的常量了，前面没有层了，因此就只有W和b需要修改了。</p><p>拿出一个感知机，对它放大后得到：</p><p><img src="/../img/image-20221007104106527.png" alt="image-20221007104106527"></p><p>$l$代表的是第$l$层，$i$代表的是第$i$个，算出的$z$值进行激活函数运算后，可以解决非线性问题，得到一个值$a^{[l]}_i$，也就是这个感知机向外输出的值。再强调一下，每一个感知机的输入都是上一层所有感知机的输出。</p><p>抽象解决了表述的复杂性，每个数学家都有潜在的编程天赋，展开成矩阵形式，紫色表示$l-1$层第一个感知机对$l$层所有感知机的作用：</p><p><img src="/../img/image-20221007152657608.png" alt="image-20221007152657608" style="zoom:50%;"></p><p>上面是隐藏层，接下来看输出层。最后得出一个$a^{[l]}$要通过损失函数的计算，计算出一个偏差值，这个损失函数除了依赖$a^{[l]}$，还要依赖y，y就是标签。</p><p>上标代表的是有m组数据，下标代表的是在一组数据有j个特征。</p><p><img src="/../img/image-20221007153826926.png" alt="image-20221007153826926"></p><p>反向传播：</p><p><img src="/../img/image-20221007153944578.png" alt="image-20221007153944578"></p><p>可以把输出层看作第$l+1$层：</p><p><img src="/../img/image-20221007154031476.png" alt="image-20221007154031476"></p><p>得到：</p><p><img src="/../img/image-20221007154345236.png" alt="image-20221007154345236" style="zoom:50%;"></p><p>已知：</p><p><img src="/../img/image-20221007154408181.png" alt="image-20221007154408181" style="zoom:50%;"></p><p>用链式求导法则：</p><p><img src="/../img/image-20221007154420979.png" alt="image-20221007154420979"></p><p>把第一项展开，就是之前求的梯度：</p><p><img src="/../img/image-20221007154640396.png" alt="image-20221007154640396"></p><p>反向传播之后参数的修改值：</p><p><img src="/../img/image-20221007154918337.png" alt="image-20221007154918337"></p><p><img src="/../img/image-20221007155154457.png" alt="image-20221007155154457"></p><p>正常训练的话不需要理解这么多，就知道梯度是根据损失函数调参就可以，参数那么多，网络层那么多，这个微分只有计算机能做，所以不用纠结自己会不会计算。</p><h3 id="mini-batch"><a href="#mini-batch" class="headerlink" title="mini-batch"></a>mini-batch</h3><p>什么是mini-batch？</p><p>我们已知在梯度下降中，先训练一个模型，然后对所有样本进行分类，通过最小化损失函数来对参数进行一次调整。</p><p>也就是说，需要把所有样本处理一遍后才能往前走一步，此时样本规模特别大的话效率就会比较低。例如有500万，甚至5000万个样本(在我们的业务场景中，一般有几千万行，有些大数据有10亿行)的话走一轮迭代就非常的耗时，别说整个训练过程了。这个时候的梯度下降叫做full batch。</p><p> 所以为了提高效率，我们可以把样本分成等量的子集，例如我们把100万样本分成1000份， 每份1000个样本， 这些子集就称为mini-batch。我们对每一个子集做一次梯度下降。 然后更新参数W和b的值。接着到下一个子集中继续进行梯度下降。 这样在遍历完所有的mini-batch之后我们相当于在梯度下降中做了1000次迭代。 我们将遍历一次所有样本的行为叫做一个 epoch，也就是一个世代。 在mini-batch下的梯度下降中做的事情其实跟full batch一样，只不过我们训练的数据不再是所有的样本，而是一个个的子集。 这样在mini batch我们在一个epoch中就能进行1000次的梯度下降，而在full batch中只有一次。 这样就大大的提高了我们算法的运行速度。</p><p><strong>mini batch的效果</strong></p><p>左边是full batch的梯度下降效果。 可以看到每一次迭代成本函数都呈现下降趋势，这是好的现象，说明我们w和b的设定一直再减少误差。 这样一直迭代下去我们就可以找到最优解。 右边是mini batch的梯度下降效果，可以看到它是上下波动的，成本函数的值有时高有时低，但总体还是呈现下降的趋势。 这个也是正常的，因为我们每一次梯度下降都是在mini-batch上跑的而不是在整个数据集上。 数据的差异可能会导致这样的效果(可能某段数据效果特别好，某段数据效果不好)。但没关系，因为他整体的是呈下降趋势的。</p><p><img src="/../img/format,png.png" alt="img"></p><p>由于mini batch一个epoch就走了5000步，而full batch一个epoch只有一步。所以虽然mini batch走了弯路但还是会快很多。</p><p><strong>经验公式</strong></p><p>既然有了mini batch那就会有一个batch size的超参数，也就是块大小。代表着每一个mini batch中有多少个样本。 我们一般设置为2的n次方。 例如64，128，512，1024.。一般不会超过这个范围。不能太大，因为太大了会无限接近full batch的行为，速度会慢。 也不能太小，太小了以后可能算法永远不会收敛。 当然如果我们的数据比较小， 但也用不着mini batch了。 full batch的效果是最好的。</p><h2 id="优化梯度下降算法"><a href="#优化梯度下降算法" class="headerlink" title="优化梯度下降算法"></a>优化梯度下降算法</h2><p>梯度下降法计算太过复杂，计算机也难以做到，因此需要将梯度下降法进行优化，有两个思路，分别是减少每次计算的计算量和优化下降路径，用更少的步数，更快的到达极值点。</p><h3 id="优化每次计算量"><a href="#优化每次计算量" class="headerlink" title="优化每次计算量"></a>优化每次计算量</h3><h4 id="随机梯度法"><a href="#随机梯度法" class="headerlink" title="随机梯度法"></a>随机梯度法</h4><p>该方法旨在减少每次计算的计算量。</p><p>期望的意义是，可以摆脱开样本的具体数据，又能代表整个样本的均值。如果从期望或者说平均值这个角度来考虑的话，那计算的时候用了多少样本数据，是否覆盖了整个样本空间，就不再是一个关键性要素了。</p><p>简单说就是，样本反映整体，机器学习本质上都是统计学。</p><p>按照这个思路，随机梯度法被提出来了。</p><p>原来是把每一个数据都计算一遍然后求和，现在是随机挑一个数据，用这个数据计算，最后修改参数值，下一次再随机挑一个数据，再训练一次，最后也能达到训练的效果。</p><p>题外话：随机梯度下降法是一次一个样本，只是现在多将小批量随机梯度下降法简称为随机梯度下降法了，很多人也将他叫做mini-batch方法。</p><p>下面需要证明的是，样本越大均值的方差也越小，我们这样选样本最后真的可以收敛到我们想要的极值点吗？</p><p>证明结果是在凸问题中，最后结果是：</p><p><img src="/../img/image-20221007161011189.png" alt="image-20221007161011189" style="zoom:50%;"></p><p>$k$代表迭代次数，$f^\star$代表极值点，$o$代表时间复杂度的渐进符。</p><p>意思是，经过k次训练后，随机梯度下降法能达到的误差，是$\frac{1}{\sqrt{k}}$这个量级的。如果是强凸问题的话，它的收敛还会更快：</p><p><img src="/../img/image-20221007161352579.png" alt="image-20221007161352579" style="zoom:50%;"></p><p>也就是说，除非迭代很多次，否则误差还是这么大，收益不是很理想，再看看别的方法。</p><h3 id="优化步长"><a href="#优化步长" class="headerlink" title="优化步长"></a>优化步长</h3><p>即使梯度已经指向了下降最快的方向，但还是有一定优化空间的，因为求的是每一个点的梯度，如果我们将步长设置为无限小的话，就等于找到了一条完美的最优路径，但是这种计算量是目前计算机无法达到的。因此，每次迭代要确定的步长就为优化带来了可能性。</p><p>打个比方，如图，在A点求梯度后，延长到了B点，B点的梯度已经不和A点的重合了，但是由于设置步长过长的缘故，还是把B点的梯度设置为和A点一样的，这就和最优路径产生了偏差。</p><p><img src="/../img/image-20221007162141113.png" alt="image-20221007162141113" style="zoom:50%;"></p><p>但是减小步长就意味着增加了步数，也就是计算量。</p><h4 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h4><p>不用直线当路径了，用曲线。如图，绿色抛物线在一定范围内，效果是优于橙色直线的，但是超过一定范围，效果比直线还差。也就是说，如果以抛物线的方式进行学习的话，步长在$\Delta x$范围内，它的学习效果最好，远远优于直线。可以得到：</p><ol><li>固定学习率，即需要在参数空间的附近的等距面上寻找最小值。</li><li>在当前位置做泰勒展开，取阶数越多，寻找的最小值位置越精确。</li><li>学习率无限小时，一阶即完全精确，学习率有限时，二阶比一阶精确。</li><li>下一步走到哪取决于学习率多大。</li></ol><p><img src="/../img/image-20221007165007749.png" alt="image-20221007165007749"></p><p>拓展到高维平面，如图是损失函数的等高线：</p><p><img src="/../img/image-20221007165336607.png" alt="image-20221007165336607"></p><p>橙线是梯度下降法的优化路径，绿线是牛顿法的优化路径，明显更接近最优路径，数学表达就是左边对参数W进行迭代，计算量依旧很大。</p><p>牛顿法本质是把下降路径的所有维度放到一起，统一考虑，看看能不能找到一个更好的路径，现在我们把下降路径的维度拆分开，看看有没有更好的思路。</p><p>这是一种常见的求梯度下降的时候会遇到的情况，梯度方向反复震荡折叠趋近于极值点，我们看到造成它来回震荡的原因是纵轴上的分量，横轴始终指向正确的方向。</p><p><img src="/../img/image-20221007170043059.png" alt="image-20221007170043059"></p><p>我们也许能找到一种方法，使他在横轴上加速，让它可以在横轴的分量上更快的到达极值点。</p><p><img src="/../img/image-20221007170342354.png" alt="image-20221007170342354"></p><p>比如说在某一个点，它计算的梯度在纵轴的分量是一个向上的纵向向量，再去看它的历史向量，与它方向相反，是向下的，那它就会减少这个维度上的量。再看横轴，现在是向前的，之前也是向前的，和自己一样，那就增加这个维度上的量。</p><p>通过这个方法减少纵轴上的震动，增加横轴上的变化速度，这就是利用历史数据来修正分量。具体计算如下：</p><p><img src="/../img/image-20221007174235832.png" alt="image-20221007174235832"></p><p>新一步的参数=上一步的参数-学习率x梯度，对应到每一个分量上，就是第二列的样子。</p><p>为了表达方便再引入一个变量，$\Delta W$代表了W系数在$i$维度下应该调整多少，在标准的梯度下降法下，它调整的幅度应该是梯度的分量，写出来就是它下面那个式子。</p><p><img src="/../img/image-20221007181926093.png" alt="image-20221007181926093"></p><p>再把历史数据也考虑进来：本来有了$\Delta W$之后，直接用在参数上进行学习，现在增加一个中间过程，一个迭代出的量$V(t)$，它其实代表了历史上前面所有步的$\Delta W$的和，最后把它作为参数修改的量放进来，然后进行学习，<u>这里可以参考卡尔曼滤波。</u></p><p>只是简单相加的话，就相当于把前面所有历史数据都一视同仁的全部考虑，不是很合适，所以会用一下<u>指数加权移动平均</u>。</p><p><img src="/../img/image-20221007182950802.png" alt="image-20221007182950802"></p><p>假设$\beta$取0.9的话，把这个式子展开：</p><p><img src="/../img/image-20221007183159392.png" alt="image-20221007183159392"></p><p>可以看到越往前的量越不重要，也说明了以前的改变是有惯性的，要想发生改变必须先讲它们抵消，然后才能发生变化。</p><p>这样的方法就叫动量法，或者叫冲量法。</p><p>橙色是梯度方向，绿色是历史冲量方向，通过前面的铺垫知道，实际优化的下降路径介于这二者之间，然后我们发现它绕路了。于是提出假设：如果它有预知未来的能力，知道第二步会落在那个点上，它第一步修正的幅度就不是这么小了，怎么做到超前呢？引入Nesterov算法。</p><p><img src="/../img/image-20221007184507900.png" alt="image-20221007184507900" style="zoom:50%;"></p><h4 id="Nesterov算法-动量法"><a href="#Nesterov算法-动量法" class="headerlink" title="Nesterov算法+动量法"></a>Nesterov算法+动量法</h4><p>在上一节点把当前的梯度纳入历史，所以每一个节点都比之前多考虑一步。移动到新的一点的梯度方向，和下一级的v合成新的方向。</p><p><img src="/../img/image-20221007184831378.png" alt="image-20221007184831378" style="zoom:50%;"></p><p>将第t-1步的$\Delta W$做一个修正，本质上是让点进行移动，相当于让点移到第t-1步的$V(t-1)$的位置，也就是绿色向量的终点——红点的位置。也就是说，求的已经不是原点的偏导了，而是红点处的偏导$\overrightarrow{g}$，求出红点的偏导方向后再拿进来放到原点，去计算冲量。</p><p><img src="/../img/image-20221007202254214.png" alt="image-20221007202254214"></p><p>得到的效果就相当于把红点处的偏导$\overrightarrow{g}$平移到原点处，也就是图上的紫色向量，它就是t时刻的$\Delta W$，而$V(t-1)$是绿色向量，它们之和就是新的冲量方向。</p><p>相当于在训练和学习的时候，对参数的变化量增加了一个0次项的修正，我们是否也可以对一次项，也就是步长也进行一定修正呢？可以理解为0次项修正是在修正路径方向，1次项修正是在修正步长。</p><p><img src="/../img/image-20221007202423959.png" alt="image-20221007202423959" style="zoom:50%;"></p><p>学习率不应该是一个确定的值，否则在极值点附近很可能就无法收敛，比如说下面的情况，模型直接跨过了极值点。</p><p><img src="/../img/image-20221007202619106.png" alt="image-20221007202619106" style="zoom:50%;"></p><p>接下来的过程中，由于步长一定，A点无法恰好到达极值点，就只会在极值点附近来回震荡无法停止。</p><p><img src="/../img/image-20221007202742713.png" alt="image-20221007202742713" style="zoom:50%;"></p><p>最简单的方法是，每一步减少一个固定的值，当减少到0的时候，迭代停止。那么能否让学习率自动调整呢？那得看Adagrad方法了。</p><h4 id="Adagrad方法"><a href="#Adagrad方法" class="headerlink" title="Adagrad方法"></a>Adagrad方法</h4><p>靠前面的历史数据来让学习率实现自适应。</p><p><img src="/../img/image-20221007203006949.png" alt="image-20221007203006949" style="zoom:50%;"></p><p>相当于是在学习率$\eta$下面除以一个数值，是历史上每一个梯度的内积开方，学习到的梯度是真实梯度除以梯度内积的开方。adagrad本质是解决各方向导数数值量级的不一致而将梯度数值归一化。再增加一个$\epsilon$极小量避免分母为0。</p><p>最后得到的结果是：在相对平坦梯度较小时，始终保持较大学习率；一旦产生较大梯度，学习率将维持在较低水平。</p><p>总之，动量法修正的是0次项，adagrad修正的是一次项，适合稀疏数据，二者不可替代，也为二者结合提供了可能性。</p><p>虽然我们输入神经网络一开始的是一个照片，但经过一层层的隐藏层之后，到了最后一层隐藏层上的感知机，其实已经变成了一个个的特征。我们说的向量上的维度就是这些特征，如果某一个特征的学习率较大，就意味着接下来的学习中，对这个特征的调整比较大，如果某一个特征的学习率较小，就意味着接下来的学习中，对这个特征的调整比较小。</p><p>稀疏数据是指，训练集里的两个数据，它们之间的不同，更多的是体现在了特征的不同上，而不是某个具体特征上的程度不一样。举例来说：给两张照片，一个人一个猴子，要想去分开只要看有毛还是无毛，有尾巴还是没尾巴，不用看毛的多少或者尾巴的长短。</p><p><img src="/../img/image-20221007204448895.png" alt="image-20221007204448895"></p><p>再给两只猫，一只英短，一只波斯，区分起来就要看毛的长短，就不是稀疏数据。</p><p><img src="/../img/image-20221007204636556.png" alt="image-20221007204636556"></p><p>在稀疏数据的情况下，意味着某些数据的缺失，梯度下降法会产生振荡，而使用adagrad算法优势就比较明显了，因为它就是为了减少震荡的。</p><p>维度灾难：随着维度的增加，数据会越来越稀疏的，选择adagrad算法会更有效果。</p><p>优化方法1：加一个指数加权，变成RMSprop方法。</p><p><img src="/../img/image-20221007205300980.png" alt="image-20221007205300980"></p><p>优化方法 2 : 将动量法和RMSprop方法结合起来，变成Adam算法。</p><p><img src="/../img/image-20221007205401792.png" alt="image-20221007205401792"></p><p>优化方法 3:  和Nesterov方法结合，变成Nadam算法。</p><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><p><img src="/../img/image-20221030223602834.png" alt="image-20221030223602834"></p><p>回看全联接神经网络，输入层是我们的数据，隐藏层是对输入的数据提取特征，或是对已经提取出来的特征进行线性组合，输出层是根据特征对输入进行线性划分。</p><p><img src="/../img/image-20221030223838275.png" alt="image-20221030223838275"></p><p>图片作为输入，一个像素点代表一个维度，每个像素点都是同质的，它的意义就是该像素点的灰度值或RGB值。</p><p>而上面的神经网络中，播放量、点赞数这些数据的维度是异质的，完全可以作为最后可以作为判断的特征，神经网络只要对他们做线性组合就可以进行判断了。即使他们还可以组合成更抽象的特征，比如将点赞数和投币数抽象为视频质量等，但是不能否认，最开始的这些数据已经可以看成抽象程度比较低的特征了。</p><p>而在看图片输入，我们很难说一个像素或几个像素就是一个特征，打个比方，把一个像素平移8个单位，像素点完全变了，但内容完全没变，所以像素不是特征。毕竟对图片识别起到作用的不是某个像素点具体的RGB值，而是一个像素点和周围其他像素点的相对关系。</p><p>因此，我们再将图片数据输入时，可以对其作预处理，不是每个点具体的数值，而是一个它和周围像素点存在着什么关系的特征值，这样神经网络就可以直接对特征进行各种组合，然后进行判断了，而不是还要通过全联接层，把像素点和像素点之间关系的特征计算一遍。</p><p>因为在我们直接把图片信息输入神经网络时，它提供的每个像素的信息和位置通常是绑定的，很难被复用。就比如这个数字8，我们可以看出它上下两个圆圈具有的特征是相同的，但是神经网络却不能对他们进行复用，只能把它们分别看作是不同的特征。但如果我们把输入变为每个像素点和周围像素点的位置关系，而不是它本身的RGB数值，就可以避免这一点。</p><p>打个比方，在识别图例8时，有下面几个模式，我们可以看到图例8最符合的是模式1，有0.9的相似度，别的模式相似度仅有0.01。我们把这些预设的模式作为特征，将输入转化为这些特征值，特征值即为原始数据里面具有这些特征的强弱。</p><p><img src="/../img/image-20221030234240073.png" alt="image-20221030234240073"></p><p>这个模式，或者说特征，用数据的方式呈现出来，就是卷积核，这些特征值就是卷积核和图像计算后的结果。</p><p>这些模式之间是无法公度的，那么我们要如何把它们呢集合成一个数据，保存到一个像素点中呢？还是用加权求和的方法。</p><p><img src="/../img/image-20221031010817052.png" alt="image-20221031010817052"></p><p>基于这样加工后的数据再输入到神经网络里，神经网络用来判断的依据就不再是像素点的绝对位置，而是相对位置了，目标达成。</p><p>而且加工后的数据与RGB数值形式上无本质区别，因此就可以对已经处理过的数据反复进行同样的操作，这样就像神经网络增加了更多隐藏层一样，让相对位置的模式抽象程度可以更高，让一个像素点的数据可以体现更大范围的特征。</p><p>现在要做的就是把这个模式和特征值通过计算机能实现的方式来表达和计算出来。</p><h3 id="傅立叶变换"><a href="#傅立叶变换" class="headerlink" title="傅立叶变换"></a>傅立叶变换</h3><p>信号里常见的概念——时域和频域，假如左边是一个电脉冲信号，纵轴是电压的高低，横轴是时间，用频域表达成右边这样，横轴就是频率，纵轴是对应频率信号的强弱，这个转换关系就是把F(t)信号变成如下形式：</p><script type="math/tex; mode=display">F(w)=\int^{+\infty }_{-\infty}f(t)\cdot e^{-iwt}dt</script><p><img src="/../img/image-20221031011558817.png" alt="image-20221031011558817"></p><p>我们可以把图片看作一个静态的信号，但可以把像素点的位置看成是这个空间里的坐标轴，而且是一个2维的，像素点间的距离是x，y轴组成的平面，像素点的RGB数值是第三根坐标轴，这样这个信号的周期就不是用时间来表示了，而是像素点之间的距离，此时时域就是空间域，频域就是变换域。</p><p><img src="/../img/image-20221031013032998.png" alt="image-20221031013032998" style="zoom:50%;"></p><p>我们希望的是把一个像素点和周围其他像素点的关系浓缩到一点上，而傅立叶变换中，变换域里的一个点对应一个F(w)的取值，映射到空间域就是把空间域从正无穷到负无穷全部都考虑了进来，也就是一个变换域的点把空间域的全域信息进行了浓缩。</p><p>具体来讲，就是在频域中不同角速度w的取值在整个信号阶段的强弱，把它对应到模式中，就是w取不同模式时像素点的特征值，只不过这里的F(w)是一个复变函数，它的具体取值是一个复数，把F(w)换成复数表达形式如下，而复数会提供两个信息，一个是复数的模长——不同模式下正弦余弦曲线的振幅，另一个则是幅角——对应不同模式下正弦余弦曲线的相位。当我们变换空间域信号的时候，信号的振幅已经和位置无关了，只会对幅角产生影响，达到了我们想要提取特征值的效果。</p><script type="math/tex; mode=display">F(w)=|F(w)|\cdot e^{i\varphi}</script><script type="math/tex; mode=display">\varphi=arctan \frac{Im[F(w)]}{Re[F(w)]}</script><p><img src="/../img/image-20221031014110911.png" alt="image-20221031014110911" style="zoom:50%;"></p><p>用信号的角度看模式和特征值，二者相乘就代表这个模式在原信号中的强弱，我们只需要把所有特征值和对应模式相乘再相加，应该就能把原信号给还原出来了，这就是傅立叶逆变换。</p><script type="math/tex; mode=display">f(t)=\frac{1}{2 \pi} \int^{+\infty }_{-\infty}F(w)\cdot e^{iwt}dw</script><p>我们目前已经做到把空间域中一个模式的全局情况浓缩到一个点上，但我们希望的是局部情况，这就是加窗（短时）傅立叶变换。</p><p>对空间域做一个升维，升到无穷维。在空间是二维的时候，我们可以把空间中任何一个点在x和y数轴上的投影看作是坐标，用两个数字就可以把这个点描述出来，同样，在无穷维的时候，就相当于是有无穷个坐标轴，每个点在无穷个维上都可以做投影。我们把这些维度一一对应到一个实数数轴上，纵轴就代表在这些维度上的取值，于是在无穷维空间中的一个点，就被投射成了一个二维空间中的一条曲线。</p><p><img src="/../img/image-20221031163942538.png" alt="image-20221031163942538"></p><p>现在这个绿色曲线是乱画的，但如果它是下图这样，不就是空间域里信号所代表的曲线嘛。也就是说，二维时域空间里用一条曲线描述的问题，到无穷空间只需要一个点就可以。</p><p><img src="/../img/image-20221031164032094.png" alt="image-20221031164032094"></p><p>通俗来讲，一个实数函数就是无穷维空间的一个点！！无穷维空间的点也可以和二维空间中的曲线一一对应。</p><p>这样我们把空间升到无穷维的好处就体现出来了，我们可以让二维空间的曲线降维成一个点，并且因为变换后的空间是无穷维的，就算是二维平面，三维立体，只要图像的维度是有限的，都可以被降维到一点。</p><p>降维成一个点的好处真正体现的还是一个空间的点可以用向量来等价表示，当我们把原来的f(t)函数看作是一个无穷维空间中的向量之后，就可以进行别的操作了，就比如下图所示的坐标系变换，它的坐标向量推导公式如下，最终凑出了一个f向量和坐标轴向量的内积乘上坐标轴向量的单位向量。</p><p><img src="/../img/image-20221031164959659.png" alt="image-20221031164959659"></p><p>一个是无穷维，又有内积的空间，就被称作是希尔伯特空间，它其实是欧几里得空间的扩展。在欧几里得空间中，向量内积如第一个公式所示，希尔伯特空间和它类似，只不过向量的坐标值可以用函数来表示，于是最后内积就写成了下面的形式。</p><p><img src="/../img/image-20221031165338747.png" alt="image-20221031165338747"></p><p>于是坐标变换公式就等于内积的定积分乘以对应坐标向量的单位向量$\hat d_n$，这个坐标轴的单位向量$\hat d_n$就可以看成我们前面的模式，不同坐标轴代表着不同的维度，也就是不同的模式，前面的定积分也就是在这个模式下的特征值。</p><p><img src="/../img/image-20221031165847437.png" alt="image-20221031165847437" style="zoom:50%;"></p><p>综上，从时域到频域其实就是在希尔伯特空间做了一次坐标变化，频域里的函数就是坐标变换后特征值的表达式，这个特征值F(n)代表的就是向量f在新坐标系下各个坐标轴上分量的大小，因此它和坐标轴的单位向量相乘再求和，就是f向量本身，因此又得到了这个变化的逆过程。</p><p><img src="/../img/image-20221031171010244.png" alt="image-20221031171010244" style="zoom:50%;"></p><p>注意：我们能做坐标变化的前提是要保证这些坐标轴$\hat d_n$要是两两正交的，如果模式不正交的话就需要先把模式进行简化为正交系，在数学上面就是求矩阵的满秩矩阵，或者看ds洗数据的本事，数值分析函数拟合有讲，如果不正交需要求解希尔伯特线性方程组。</p><p><img src="/../img/image-20221031173415628.png" alt="image-20221031173415628" style="zoom:50%;"></p><p> 而傅立叶变换就是把希尔伯特空间坐标变换里的坐标基变为$e^{-iwt}$，这组基一定是正交的。这组基本身也是向量，它在时域中的样子是一个全局的正弦余弦曲线。我们需要的加窗傅立叶变换需要对这组基做一些改变，使它不再考虑全局的情况，就需要对这个正弦余弦曲线做一个约束，让它只在一个小窗口里进行波动，其他情况全等于0。于是这个窗口的特征就成了衡量信号的新锚点，坐标轴需要考虑的情况就增加了一个维度。</p><p>窗口开在不同的位置就是不同的坐标轴，窗口里面信号的频率不同也是不同的坐标轴，这个有窗口范围的基就可以这样表示，其中变量s就是窗口的位置，$(s-1,s+1)$就是窗口的大小。</p><p><img src="/../img/image-20221031180105954.png" alt="image-20221031180105954"></p><p>但在实际计算时，这种分段函数不是处处可微的，于是我们可以用高斯分布来做g函数，在这里a就是方差，决定了窗口的大小，s是期望，决定了窗口的位置，窗口画出来就长这样：</p><p><img src="/../img/image-20221031182426495.png" alt="image-20221031182426495" style="zoom:50%;"></p><p><img src="/../img/image-20221031182446980.png" alt="image-20221031182446980" style="zoom:50%;"></p><p>这个用高斯分布做g分布其实就是Gabor变换，经过变换后的特征函数有两个变量，一个是n控制w，也就是不同的模式，另一个就是s，控制窗口的位置，窗口大小只是一个参数而非变量。</p><p><img src="/../img/image-20221031182822562.png" alt="image-20221031182822562" style="zoom:50%;"></p><p>这个g函数为傅立叶变换增加了很多可能性，如果g是指数函数，其实就是拉普拉斯变换，它会让正弦余弦曲线不断衰减。</p><p><img src="/../img/image-20221031183049530.png" alt="image-20221031183049530" style="zoom:50%;"></p><p>如果这个窗口大小不再是固定的，而是也可以作为变量，可以根据w动态的变化，那么这就是一个小波变化。</p><p><img src="/../img/image-20221031183309106.png" alt="image-20221031183309106" style="zoom:50%;"></p><p>并且正弦余弦曲线也不是固定的，也是可以被其他的波形代替的，但本质上都是在希尔伯特空间选择一组不同的基进行变换。</p><p>现在我们已经通过傅立叶变换实现了让特征和位置无关，不论这个特征出现在什么位置，反映到变换域中都应该是相同的特征值。现在我们要通过Garbo变换来实现当图像的不同位置出现了相同的两个特征，那么反映到变换域里，它们的特征值也应该是相同的。</p><p>左边是时域空间，因为gabor变换对应的特征值f函数有了两个变量，所以他就需要用三维画面来展示了。如果是这样的一个波形，在其他地方增加一个同样的波形，那么我们在变换域上就会相应的增加了一个形状相同的鼓包，这里的变量n代表不同的w取值，或者说是不同的模式，而变量S则是位置信息，它的取值对应到时域里面就是不同的窗口位置，只有把窗口开在相应的波形的位置上，在变换域上才会被明显的体现出来。</p><p><img src="/../img/image-20221031184840290.png" alt="image-20221031184840290" style="zoom:50%;"></p><p>那么要如何把Gabor变换对应到卷积上呢，我们来一一对应一下。</p><p><img src="/../img/image-20221031185832483.png" alt="image-20221031185832483" style="zoom:50%;"></p><p>在把图片输入到全联接神经网络之前，先对图片$f(t)$进行$F(n,S)$变换，左边绿色像素点周围的特征就会被储存到右边相应位置的点阵中，</p><p>把这个点阵中的绿色像素点展开，就是各种不同卷积核计算的结果，不同的卷积核代表的是不同的模式n，卷积核下面具体的特征值就是$F(n,S)$的取值，卷积核的中心对准的就是变换结果里的位置S，所以卷积核的大小就是窗口的大小3x3，也就是参数a。而模式或者说卷积核中的具体数值，也就是窗口里面具体的波形是什么，最终是由黄框里的函数来决定的，也是由卷积神经网络自己学习出来的。因为用卷积核进行计算本质上也是一种线性计算，所以一个卷积核里面它的参数具体是多少，通过梯度下降法就能学习到。</p><p><img src="/../img/image-20221031190853629.png" alt="image-20221031190853629" style="zoom:50%;"></p><p>严格地说，这里已经不是Gabor变换了，Gabor变换一般特指窗口函数是高斯分布，对应的波形也得是正弦余弦曲线，但在卷积神经网络里，具体学到的卷积核是什么样子就不一定了，只是作为一个理解的切入点。</p><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>CNN的卷积其实是互相关，实际上加入进行卷积，还需要对过滤器进行两次镜面反转。</p><p>卷积公式：</p><p><img src="/../img/image-20221009220304188.png" alt="image-20221009220304188" style="zoom:50%;"></p><p>如何理解卷积，打个比方，一个人特别喜欢吃东西，不止一日三餐吃，零食也不断，总之就是24h都在吃，如果画下来就是这样。</p><p><img src="/../img/image-20221031192207176.png" alt="image-20221031192207176" style="zoom:50%;"></p><p>g就表示某一刻进食后该食物随着时间变化剩余量的比例。</p><p><img src="/../img/image-20221031192404328.png" alt="image-20221031192404328" style="zoom:50%;"></p><p>把进食多少用f函数表示，消化多少用g函数表示，带进卷积公式后就能计算出这个人在某个时间胃里还剩多少食物，以下午两点进行举例，只看它进食不考虑消化的话只要求一个积分就行，但是他还要消化。如果在12点吃了一碗米饭，在14点时就要讲2h消化的比率代入g函数，看米饭在14点还剩多少。</p><p><img src="/../img/image-20221031193039444.png" alt="image-20221031193039444" style="zoom:50%;"></p><p>更一般的可以写成如下形式，</p><p><img src="/../img/image-20221031193144915.png" alt="image-20221031193144915"></p><p>将这对x和t-x用f和g联系起来就是：</p><p><img src="/../img/image-20221031193338930.png" alt="image-20221031193338930" style="zoom:50%;"></p><p>总结一下就是存在一个系统，他的输入是不稳定的，输出是稳定的，那么我们就可以用卷积来求系统的存量。上面这张图看着很别扭，但是我们只要把它翻转一下，就很明朗了。</p><p><img src="/../img/image-20221031193601047.png" alt="image-20221031193601047" style="zoom:50%;"></p><p>CNN主要应用在图片输入，它在把图片输入神经网络之前，会对图像进行一个卷积操作。</p><p>什么是卷积操作？其实就是用一个3x3的点阵，和图像进行一个操作，这个3x3的点阵就叫做卷积核。操作的过程就是把卷积核扣在图像的点阵上，然后对应的两个各自相乘，3x3点阵也就是9个数，把这九个结果相加保存到一起，就相当于得到了一个新的像素点。</p><p><img src="/../img/image-20221031194441478.png" alt="image-20221031194441478" style="zoom:50%;"></p><p>然后用这个卷积核把整个图像都扫一遍，得到一个新的点阵，这样处理得到的图片会少了最外面一圈，我们只需要在处理之前给图像外面加一圈都是0的像素就可以了，</p><p><img src="/../img/image-20221031194648579.png" alt="image-20221031194648579" style="zoom:50%;"></p><p><img src="/../img/image-20221031194820757.png" alt="image-20221031194820757" style="zoom:50%;"></p><p>在这里，图像就是函数f，卷积核就是函数g，因为图像里的像素点总在不停的变化，对应了系统中那个不稳定的输入，卷积核不变，对应的是稳定的输出。把刚刚吃饭的那个一维的例子扩展到二维，画出来就是一个平面波，这个F(X,Y)就是图像，g函数是一个随着距离t的变化对x的影响。可以说，就是把之前的事件的影响按距离的权重方程累加起来</p><p><img src="/../img/image-20221102154417085.png" alt="image-20221102154417085" style="zoom:50%;"></p><p>比如这样一个卷积核，本质上就是找了一个像素点，把它周围的像素点全加起来，然后求平均，这样处理完图像就会变得更平滑，更朦胧，所以叫做平滑卷积操作。</p><p><img src="/../img/image-20221102163132560.png" alt="image-20221102163132560" style="zoom:50%;"></p><p><img src="/../img/image-20221102163437083.png" alt="image-20221102163437083" style="zoom:50%;"></p><p>也就是说，卷积核就是规定了周围的3x3像素点是如何对当前的像素点产生影响的，当然也存在5x5或者7x7这种两圈甚至三圈像素点对当前像素点产生的影响，甚至是无穷圈，但是考虑计算机计算时的性价比，如果一圈能搞定的话就不会再往多圈考虑。</p><p>f和g之间的星号代表卷积操作，像素点不是连续的，因此展开不是积分，而是连加。x和m-x相加之后消掉x只剩m，同理消掉y只剩n。</p><p><img src="/../img/image-20221102190652020.png" alt="image-20221102190652020" style="zoom:50%;"></p><p>如果我们考虑左下角像素对中间像素的影响，就相当于把中间像素当作t时刻，左下角像素当作x时刻，则影响因子g(t-x)代入计算就是g(1,1)。如果把所有周围的和他自己对该像素产生的影响，就是以下形式：</p><p><img src="/../img/image-20221102191041854.png" alt="image-20221102191041854" style="zoom:50%;"></p><p>这里表现的g函数并不是卷积核，它要旋转180度之后才是卷积核。如果用了下面这两种卷积核的话，上面这个只把垂直方向的边界给挑出来了，忽略了横向的边界，下面这个只把左右方向的边界挑出来。这个时候虽然还是进行的卷积操作，但其实是把图片里的一些特征给挑了出来，所以说卷积核还有个功能，就是如果选择的合适，还可以把图片的某些特征给挑出来，而其他的特征就被过滤掉了，这样的卷积核也叫过滤器，比如下图这两个就叫做垂直边界过滤器和水平边界过滤器。</p><p><img src="/../img/image-20221102192426626.png" alt="image-20221102192426626" style="zoom:50%;"></p><p>而且，这个卷积先相乘再相加的操作可以看作是对周围像素点的试探，而卷积核就是试探的模版，当你不想考虑某个位置的时候，就把这个位置的卷积核设为0，想考虑的时候就把它设置为一个较高的数值。给人的感觉这个像素在主动的试探和选择周围的像素点，通过卷积核把周围有用的特征给保留了下来。</p><p>举个例子，假如我们想识别“X”这个字母，利用以下三个特征就可以把所有的X都识别出来。 </p><p><img src="/../img/image-20221102205255736.png" alt="image-20221102205255736" style="zoom:50%;"></p><p>比如说第一种情况，卷积核计算出来等于1，完美匹配。</p><p><img src="/../img/image-20221102205409463.png" alt="image-20221102205409463" style="zoom:50%;"></p><p>而用以下这个卷积核虽然也能匹配上，但不是完美匹配，最后计算出的结果就是0.55。</p><p><img src="/../img/image-20221102205619995.png" alt="image-20221102205619995" style="zoom:50%;"></p><p>将整个图像和卷积核匹配后，就得到了与这个特征匹配的全部信息。</p><p><img src="/../img/image-20221102210038004.png" alt="image-20221102210038004" style="zoom:50%;"></p><p>然后分别用三个卷积核进行操作，用不同的卷积核去对同一个图像做卷积，相当于是三个通道了所以输出也是三个不同的特征图，然后就要输入神经网络开始干活了，后面还有池化反向传播等等等等。</p><p><img src="/../img/image-20221102210105602.png" alt="image-20221102210105602" style="zoom:50%;"></p><h3 id="池化层的作用"><a href="#池化层的作用" class="headerlink" title="池化层的作用"></a>池化层的作用</h3><p>在卷积神经网络中通常会在相邻的卷积层之间加入一个池化层，池化层可以有效的缩小参数矩阵的尺寸，从而减少最后连接层的中的参数数量。所以加入池化层可以加快计算速度和防止过拟合的作用。</p><p>池化的原理或者是过程：pooling是在不同的通道上分开执行的（就是池化操作不改变通道数），且不需要参数控制。然后根据窗口大小进行相应的操作。 一般有max pooling、average pooling等。</p><p><strong>主要的作用</strong></p><p>（1）首要作用，下采样（downsamping）</p><p>（2）降维、去除冗余信息、对特征进行压缩、简化网络复杂度、减小计算量、减小内存消耗等等。各种说辞吧，总的理解就是减少参数量。</p><p>（3）实现非线性（这个可以想一下，relu函数，是不是有点类似的感觉？）。</p><p>（4）可以扩大感知野。</p><p>（5）可以实现不变性，其中不变形性包括，平移不变性、旋转不变性和尺度不变性。</p><p><strong>池化主要有哪几种</strong></p><p>（1）一般池化（General Pooling）：其中最常见的池化操作有平均池化、最大池化：</p><ul><li><p>​    平均池化（average pooling）：计算图像区域的平均值作为该区域池化后的值。</p></li><li><p>​    最大池化（max pooling）：选图像区域的最大值作为该区域池化后的值。</p></li></ul><p>（2）重叠池化（OverlappingPooling）：重叠池化就是，相邻池化窗口之间有重叠区域，此时一般sizeX &gt; stride。</p><p>（3）空金字塔池化（Spatial Pyramid Pooling）：空间金字塔池化可以把任意尺度的图像的卷积特征转化成相同维度，这不仅可以让CNN处理任意尺度的图像，还能避免cropping和warping操作，导致一些信息的丢失，具有非常重要的意义。</p><p><strong>堆叠式卷积核</strong></p><p>用图说明，从下往上看。</p><p><img src="/../img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F5aGFpbGw=,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom:50%;"></p><ol><li>保证具有相同感受野的条件下，提升了网络的深度，在一定程度上提升了网络效果（从这点来说，也说明了ResNet的巨大作用）</li><li>保证具有相同感受野的条件下，减少了计算量和参数量</li></ol><p>两个3x3的可以代替一个5x5的，四个3x3的可以代替一个7x7的，以此类推。</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>我们想知道机器是怎么模仿人类学习的，先要知道人类是怎么学习的。首先，学习的意义就是预判，举一反三，见过同类型的题以后，变一变还能做出来。那么这个预判能力怎么来的呢？大概有三个方式：演绎、归纳和演化。而实现人工智能的三大流派分别是：符号主义、连接主义和行为主义，正好可以和上面一一对应。</p><p>演绎意味着绝对理性，单纯从数据中找到真理。归纳则是理性和非理性结合，从数据中萃取出可能需要的特征，再去寻找特征之间的关系，归纳出一定的规律。通过演绎推导出的结论一般是不会错的，而归纳可能因为数据量不够或者提取的特征不恰当等等原因推导出一个不恰当的规律。</p><p>而归纳可能会出错的特点，也意味着它更能容忍模糊和不精确，打个比方，在语义翻译领域，绝对精确演绎出的结果根本没法用，因为语言并不是绝对理性的，它还掺杂着情感。归纳则将理性降格，因为它承认这个世界理性与混乱共存。SVM的本质就是将数据两两比较，寻找差异最小的一种划分方法，也是一种归纳的方法。</p><p>演化则是利用一代又一代的经历和反馈，上一代全部是已知，下一代则还未知，比如遗传算法。和归纳的区别是，归纳虽然承认混乱和理性并存，但是还是会利用理性从已有的数据中去总结规律，它相信万事万物背后<u>都会有一个具有一致性的规律</u>，只是会被各种各样的因素污染，反映到数学上就是，<u>所有事物都可以被用一个函数表达出来</u>，而不确定的污染元素可以把它们看作是噪声。但是演化对规律并不执着，它是靠死记硬背把以前经历的事物中好的因素保留，不好的因素筛去，最后编织成一个巨大的DNA序列，它可以用来作神经网络的参数选择。</p><p>我们现在的机器学习主要还是归纳，也就是说，机器学习其实就是机器归纳。归纳的过程分为两步，从已知的数据中总结规律，再把规律应用到未知的领域中。难点是，随便应用到未知的领域，结果能靠谱吗？打个比方，有下面几个蓝点，要想用线把它们串起来，并且未来的点还会出现在这条线上，人脑会怎么穿呢？</p><p><img src="/../img/image-20221011102205004.png" alt="image-20221011102205004" style="zoom:50%;"></p><p>这就用到了大数定律，比如一个罐子中黄豆和绿豆各占多少，不需要把它们全都倒出来，只需要随机抽样，利用抽样结果的比例来确定即可，抽样数量越多，这个比例和真实的比例就越接近，这个比例其实就是期望。</p><p><img src="/../img/image-20221011102412119.png" alt="image-20221011102412119" style="zoom:50%;"></p><p>除了大数定律，数学家还没找出别的能用于归纳的好办法。大数定律需要的变量只有期望和方差，而我们归纳出的其实是一个函数$f(x)$，把$f(x)$变成期望的过程会出很多差错。</p><h3 id="VC维"><a href="#VC维" class="headerlink" title="VC维"></a>VC维</h3><p>线性模型的VC维度等于数据空间的维度+1，</p><p>归纳方法认为，所有事物都会存在一个具有一致性的规律，用函数表达出来就是目标函数G，它是一个我们默认的理想规律，因此分类结果总是正确的。</p><p><img src="/../img/image-20221011104454733.png" alt="image-20221011104454733" style="zoom:50%;"></p><p>虽然G很好，但是我们不知道，只能假设一个$h(x)$去猜：</p><p><img src="/../img/image-20221011104604368.png" alt="image-20221011104604368" style="zoom:50%;"></p><p>做损失函数，把返回值最小的那个$h(x)$挑出来，就是我们学习到的规律，但是现实中我们无法对这两个函数比较，只能用大数定律。</p><p><img src="/../img/image-20221011105147709.png" alt="image-20221011105147709" style="zoom:50%;"></p><p>辛钦大数定律从理论上指出：用算术平均值来近似实际真值是合理的，只要样本容量$N$够大，$\infty$现实中无法到达，而霍尔夫不等式有说明，当阈值$\epsilon$确定之后，我们无法接受的情况发生的概率是有一个上限的，并且不会超过不等式右边那个数字。</p><p>也就是说，我们可以接受的情况发生的概率不会小于$1-\delta$，$\delta$越小情况越好，这就给了判断$h(x)$好坏的一个方法，上界$1-\delta$越大$h(x)$越好，这样就把大数定律里极限和无穷的问题规避掉了。</p><p>下面的问题就是怎么求大数定律里面的参数$v,\mu$平均数和均值，最简单的方法是把假设函数h在样本D中的函数值的平均值带进去，但实际上这样做毫无意义，因为红色的是全样本的期望，绿色是训练样本中的均值，只求了h的均值和期望，完全没有体现h和G的差距。</p><p><img src="/../img/image-20221011115929445.png" alt="image-20221011115929445" style="zoom:50%;"></p><p>正确的方式是将h和G之间的差别作为考虑因素，把这个差别作为平均值和期望。这样输入就不只有x了，而是x和y组成一组，x是输入数据(图片、语音等数据)，y是分类标签。</p><p><img src="/../img/image-20221011121256787.png" alt="image-20221011121256787" style="zoom:50%;"></p><p>$E_{in}$算出在样本数据里h和G不相等的时候，这个平均值是多少，$E_{out}$算出在全样本中h和G不相等的那个期望值。通过霍尔夫不等式可得，二者差距超过阈值$\epsilon$的概率不会超过$\delta$。因此，只要尽力拉低$E_{in}$，$E_{out}$自然会被降低。</p><p>这就得到了PAC（概率近似正确）机器学习理论框架，双重不确定得出的是一个肯定的结论。</p><p>横轴是h取值不同时候的值，纵轴是误差量，两条曲线不重合，中间阴影代表它们的差值，而$E_{out}$曲线的最低点就是G，因为只有当假设函数和目标函数相等的时候，$E_{out}$才能完全等于0。数据集也是影响$E_{in}$曲线的一个因素，但是不会对$E_{out}$造成影响，因为$E_{out}$和数据集没有关系，他是整体的全样本的一个数值。</p><p><img src="/../img/image-20221011145211273.png" alt="image-20221011145211273"></p><p>有了这个关系后，就能得到两条曲线的差值了，就是竖条的大小。</p><p><img src="/../img/image-20221011145302431.png" alt="image-20221011145302431"></p><p>再回到上边的不等式，其中的概率代表的是什么的概率呢？</p><p><img src="/../img/image-20221011145603637.png" alt="image-20221011145603637" style="zoom:50%;"></p><p>影响随机变量的有两个因素，一个是h一个是数据集，那么所有情况是指所有h，也就是所有竖线，还是指所有数据集，就又回到随机变量的概念问题上。</p><p>随机变量是样本的函数，对于这个问题，它的样本是什么，它的样本就是数据集。大数定律所描述的问题就是抽样很多次数据以后，它们之间的期望差值是趋于一致的。也就是说，这里的随机变量来源就是数据集，而h只是他的一个隐性的参数，是先要把h确定，然后通过D这个数据集的不同，去看不等式中的概率是什么样子的。</p><p>总结，这里的所有情况就是在同一个h的情况下，所有不同的数据集代表的情况。大数定律的核心是对抽样分布的理解，本质是总体期望与样本期望的差异。</p><p><img src="/../img/image-20221011150551600.png" alt="image-20221011150551600" style="zoom:50%;"></p><p>以上是确定h，将不同数据集作为变量的情况下，$E_{in}$和$E_{out}$满足的不等式关系，现在要考虑不同的假设函数会带来什么样的影响。</p><p><img src="/../img/image-20221011151335713.png" alt="image-20221011151335713" style="zoom:50%;"></p><p>打个比方，$f(h)$长这样，只有当h等于G的时候，才能保证随意抽样一个数据集，$E_{in}$和$E_{out}$都是等于0的。当$f(h)$越小，大于$\epsilon$的坏情况发生的可能性就越小，取值越大，坏情况发生的可能性就越大。</p><p><img src="/../img/image-20221011152438122.png" alt="image-20221011152438122"></p><p>理想情况是我们知道了h在所有数据集中的f(h)大小，越小效果越好，现实是我们只知道这个上限，并且这个上限还只和样本容量大小有关。</p><p>举个例子，在给定数据集的情况下，两条$E_{in}$的最优$h^*$明显$D_N^2$的更好一点，因为离G更近，但是这是在开了上帝视角的情况下看到的，现实中我们只知道它们的上界都一样，哪个好是不知道的。</p><p><img src="/../img/image-20221011153329494.png" alt="image-20221011153329494"></p><p>所以怎么做h之间的横向对比，只能多氪数据，氪得够多就能靠近$E_{out}$了。</p><p>其实也不是没有别的办法。</p><p>上图中我们的做法是在所有的h里去挑一个最好的$h^*$，现在直接挑一堆出来，如下图，$H_1,H_2,H_3$分别代表三个假设函数的集合，我们来比较这三个集合的好坏，把比较好的$H_2$挑出来，再从$H_2$里挑选一个确定的假设函数。</p><blockquote><p>令A和B是任意两个集合，若序偶的第一个成员是A的元素，第二个成员是B的元素，所有这样的序偶集合，称为集合A和B的笛卡尔乘积或直积，记做A X B</p></blockquote><p>这个概率的随机变量只和数据集D有关，和h无关，为了让h也成为影响随机变量的一个因素，把随机变量看作$\Delta$，原来的函数是将h作为一个参数，将数据集D带进去，来得到随机变量，样本空间就是$D$。现在把h也作为变量，拿到括号里面，这样原来的样本就变了，从单纯的$D_N$变成了$<D,h>$，样本空间也就变成了D和H的笛卡尔乘积。</D,h></p><p><img src="/../img/image-20221011155835598.png" alt="image-20221011155835598" style="zoom:50%;"></p><p>再继续进行化简，增加一行，当一个数据集中，一旦出现了一个坏情况，就把这一列记做❌，因此最后一行的坏情况个数肯定是所有行中最多的，由此得到一个上界。</p><p><img src="/../img/image-20221011160402535.png" alt="image-20221011160402535" style="zoom:50%;"></p><p>笛卡尔乘积中H是可以约掉的，把会出现坏情况的数据集集中起来，然后计算每个数据集下每个h的的表现，最后就等于每个h下会出现坏情况的概率的加和。</p><p><img src="/../img/image-20221011162209527.png" alt="image-20221011162209527" style="zoom: 67%;"></p><p>坏的H组，会让很多的数据集都坏，好的H组只会让少量的数据集表现得坏。因此单个h虽然无法比较，但是比较群体H就不一样了。</p><p>现在终于让$P_H$和H建立联系了，虽然只是上界。但只是和群体的数量有关，H的总体数量也不一定是有限的。</p><p><u>太难证了，不想看了，用到再看吧。</u></p><h3 id="拉格朗日乘数法"><a href="#拉格朗日乘数法" class="headerlink" title="拉格朗日乘数法"></a>拉格朗日乘数法</h3><p>凸优化的核心就是拉格朗日，避免过拟合的L1和L2正则化本质也是拉格朗日函数。</p><p>以前学的拉格朗日方法总结一下就是帮助我们求最值的，让函数的导数或梯度等于0，得到一堆极值点，然后在里面去挑极大值或极小值。</p><p>拉格朗日乘数法加了一个约束空间，函数的变量只能在我们规定的范围内取值，在这个范围内找到极值。打个比方，以前是从A地到B地怎么快怎么走，现在加了一个路费100块，就只能挑选在这个价格范围内合适的路线了。</p><p>这样的话，有可能会发生在规定范围内根本没有我们想要的梯度等于0的点，这个时候就可以用拉格朗日乘数法，把原来的函数和约束条件写到一个式子里，对这个式子又可以继续用求导求梯度的方法来求最值了。</p><p>这时候原来问题的函数就叫做目标函数，目标函数在约束条件下自变量的取值范围叫做可行域，写成拉格朗日乘数法形式就是下图，其中$\lambda$是一个待定的系数，我们把它叫做拉格朗日乘子。</p><p><img src="/../img/image-20221012211851188.png" alt="image-20221012211851188" style="zoom:50%;"></p><p>注：拉格朗日函数和拉格朗日方程是两个东西。</p><h4 id="互补松弛条件"><a href="#互补松弛条件" class="headerlink" title="互补松弛条件"></a>互补松弛条件</h4><p>拉格朗日函数求出的最值和目标函数求出的最值是一样的，两个问题是等价的，都和梯度有关，举个例子：图中圆圈是$f(x,y)$的等高线，中心位置的值最小，越往外值越大，黄线是约束条件的等高线，等高线的法线就是梯度方向，只有在黄线和等高线相切的位置，目标函数的梯度方向和约束条件的梯度方向一致。</p><blockquote><p>等高线就是等值线，就是函数值取相同值时的那些输入$(x,y)$</p></blockquote><p>只有方向一致，它们相加才有可能为0，然后再通过拉格朗日乘子去调整两个梯度的长短，让它们两个可以大小相等，方向相反，这样子的话梯度就等于0，极值点就找到了。除了相切的这一点，其他任何地方都没有办法实现这一点。</p><p><img src="/../img/image-20221012215652662.png" alt="image-20221012215652662" style="zoom:50%;"></p><p>以上是只有一个约束条件的情况，如果有多个约束条件，比如下图有5个约束条件，则要找到所有约束条件的梯度的一个线性组合，这个线性组合为原目标函数的梯度的等长反向向量。</p><p><img src="/../img/image-20221013111625956.png" alt="image-20221013111625956"></p><p>反映在图形上就是围成的橙色区域，真正起到约束作用的只有$g_\alpha(x)$和$g_\beta(x)$两条直线，只考虑它们两个的梯度，在线性组合代入拉格朗日函数后应该能正好和$f(x)$抵消，因此$\lambda$是不能等于0的。</p><p>再看剩下三个没起到约束条件的直线，区域内的任何点反映在它们那里都是小于0的，因为区域内的每一个点都是五个边界条件同时&lt;0的范围，某条边界上的点对这个约束条件=0，对其他约束条件&lt;0。（线的两侧图形的内外侧分别是大于0和小于0）为了让它们的梯度对整体梯度不要造成影响，所以让它们的$\lambda$都等于0。</p><blockquote><p>alpha和beta的线性组合要能够和目标函数的梯度共面，而其他的三个方向的向量，引入任何一个，都会破坏共面的条件（三个非零向量共面行列式要为0）。</p></blockquote><p><img src="/../img/image-20221013122657881.png" alt="image-20221013122657881"></p><blockquote><p>考研数学的话，区域内的点是去掉约束条件，直接求是否有极值点（就是原目标函数的极值点），然后与边界比较。</p></blockquote><p>上面这个就叫做互补松弛条件，当极值点就在橙色区域内的话，这个时候就相当于是所有的约束条件都是松弛的，直接就是目标函数的极值点。</p><p><img src="/../img/image-20221013123045477.png" alt="image-20221013123045477" style="zoom:50%;"></p><p>虽然但是，这样求出的极值点或者鞍点可能并不是最值点，但如果是凸问题的话，就可以认为它就是最值点了。</p><blockquote><p>凸问题要求目标函数和可行域都是凸的，第一个图里那个曲里拐弯的线明显不是凸的。</p></blockquote><p>因此，在一个凸函数上求最小值或者在一个凹函数上求最大值都是简单的，所以遇到凹函数一般都会在前面加个负号变成凸函数，然后再求最小值。举个例子，熵函数就是个凹函数，因此我们经常去掉它的负号，把它变成一个凸函数。</p><p><img src="/../img/image-20221013124003283.png" alt="image-20221013124003283" style="zoom: 25%;"></p><blockquote><p>为什么我们这么喜欢用墒函数就是因为很多熵本身就是一个凸问题，求最值非常容易，比如交叉熵和最大熵。</p><p>但是放到神经网络里可能就不一定了。</p></blockquote><p>那么非凸问题的最值怎么求解？看拉格朗日的对偶问题。</p><p>先把x当作常数，$\lambda$和$\mu$这两个拉格朗日乘子当作变量，去求拉格朗日函数的最大值。然后再把x当作变量，去求拉格朗日函数的最小值。</p><p>因为约束条件都是小于等于零的，而且乘子是非负的，要求最小，那就要减掉一个最大的数。</p><p>说的简单点是这样，但其实不是先后求，是循环的过程。</p><h4 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h4><p><img src="/../img/image-20221013175308351.png" alt="image-20221013175308351"></p><p>当x不在可行域内的时候，不满足约束条件，所以后两项是大于0的，要求拉格朗日函数的最大值，后两项可以达到无穷。</p><p>当x在可行域内，满足约束条件，后两项是小于0的，为了使拉格朗日函数最大，就要让乘子等于0，于是得到的函数的最大值形式如右边所示，其实是和最上面的式子是等价的，令$f_i(x)$小于0得到一个凸问题，约束条件等于0保证函数取得最大值。</p><p>拉格朗日对偶函数是拉格朗日函数在x处取得的下界，而拉格朗日对偶问题是拉格朗日对偶函数如何取最大值的问题。</p><p><img src="/../img/image-20221014000940530.png" alt="image-20221014000940530"></p><p>对偶函数相当于把原函数中先求x再求乘子的操作颠倒了一下，先把乘子看作常数，求变量x，再在对偶函数上求参数。</p><p>看求函数最小值的部分，相当于是把这部分的x当作变量求梯度，梯度等于0的时候就是函数的最小值。</p><p><img src="/../img/image-20221014002430811.png" alt="image-20221014002430811" style="zoom:50%;"></p><p>不论原问题是什么，只要变成对偶问题，就都是凸问题。</p><h4 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h4><p>凸集简单地说，可以想象成一种形状，其中任何连接2点的线都不会超出凸集。</p><p><img src="/../img/image-20221012124524306.png" alt="image-20221012124524306" style="zoom:50%;"></p><p>用数学表达一个凸集 C ：</p><p><img src="/../img/image-20221014002740515.png" alt="image-20221014002740515" style="zoom:50%;"></p><p>去掉$\theta$的约束条件后，线段就变成了一条直线，如果是多维的话，那线段就成了一个超平面，这时候的C就是仿射集，仿射集一定是一个凸集。</p><p><img src="/../img/image-20221014003039652.png" alt="image-20221014003039652" style="zoom:50%;"></p><p>这里把上图的线性关系写成了这样的形式，我们看着就更熟悉了。</p><blockquote><p>如果$C_1,C_2,C_3$都是仿射集，那么三者相交仍然是凸集。</p></blockquote><p>如果规定一个直线，把某个空间切割了一半，那一半的空间也是凸集，半空间相交的部分也是凸集。</p><p><img src="/../img/image-20221014003521184.png" alt="image-20221014003521184" style="zoom:50%;"></p><p>epigraph 是在函数中或其上的所有点，$f(x)$的epigraph如下：</p><p><img src="/../img/image-20221012130232456.png" alt="image-20221012130232456" style="zoom:50%;"></p><p>如果一个函数 f 的 epigraph 是凸集（如左下方绿色图所示)），则称该函数为凸函数。这意味着在这个 <em>epigraph</em> 上画的每个两点间线段<strong>总是</strong>等于或高于函数图。</p><p><img src="/../img/image-20221012135304781.png" alt="image-20221012135304781" style="zoom:50%;"></p><p>凸性检验：在神经网络中，大多数的成本函数是非凸的。因此，如果想优化学习器的话，必须先测试一下函数的凸性。</p><blockquote><p>只有一个样本时叫损失函数，对于m个样本，叫成本函数。</p></blockquote><p>如果函数 f 的二阶导数$f’’(x)$大于或等于0，则称该函数为凸函数。如果$ -f(x) $是一个凸函数，那么函数 f 称为凹函数。</p><p>凸函数在神经网络里的作用：</p><p>一个凸函数意味着没有局部极小值，只有全局极小值。因此，梯度下降法将会收敛到全局极小值。</p><p>如果不是凸函数，可以看到梯度下降法将停止在局部极小值，而不是收敛到全局极小值。因为这一点的梯度已经到零了，而且还是附近区域的极小值，解决这个问题的一个方法是使用动量。</p><p><img src="/../img/image-20221012145230982.png" alt="image-20221012145230982" style="zoom:50%;"></p><p>原问题本身和约束条件都是凸函数组成的问题才是凸优化问题。</p><p>因此，在对偶问题中，将x看作一个常数的话，$g(\lambda,v)$就相当于是一条直线，直线既是凸问题，又是凹问题，而约束条件$\lambda&gt;0$相当于是一个半空间，半空间是仿射集中的一个凸集，因此，对偶问题本身和其约束条件都是凸的，所以它一定是一个凸优化问题。</p><p><img src="/../img/image-20221019163620244.png" alt="image-20221019163620244" style="zoom:50%;"></p><p>因此，不论是什么问题，只要化成对偶问题，就都是凸问题。但是这一切的前提条件是原问题和对偶问题必须是等价的。</p><p><img src="/../img/image-20221019164321590.png" alt="image-20221019164321590" style="zoom:50%;"></p><p>将原问题和对偶问题做第一步变换后，一个可以看成是x的函数，另一个可以看成是$\lambda,v$的函数，并且左边是恒大于等于右边的，由此可以得出的结论是原问题的解一定是大于对偶问题的。我们的期望是二者相等，因此就引入了KKT条件，只要一个问题是强对偶的，那么就一定符合KKT条件，反过来不一定。这有点像用求导的方式求最值，导数等于0的点不一定就是最值点，KKT条件也一样，找到了最优值的点，这个点一定是满足KKT条件的，满足KKT条件的点，不一定是最优值的点，</p><p>但是当问题为凸规划时，在约束规范下，KKT条件可以直接作为全局最优解的充要条件。</p><p><img src="/../img/image-20221019170717481.png" alt="image-20221019170717481"></p><p>前两个条件为原问题的约束条件，三四为对偶问题的约束条件，互补松弛条件参考右下两幅图，上面是$\lambda&gt;0$，最优点位于边界上，条件是紧致的，下面的图代表$\lambda=0$，最优点位于范围内，条件是松弛的。</p><h2 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h2><p>在机器学习的有监督学习算法中，我们的目标是学习出一个稳定的且在各个方面表现都较好的模型，但实际情况往往不这么理想，有时我们只能得到多个有偏好的模型（弱监督模型，在某些方面表现的比较好）。集成学习就是组合这里的多个弱监督模型以期得到一个更好更全面的强监督模型，集成学习潜在的思想是即便某一个弱分类器得到了错误的预测，其他的弱分类器也可以将错误纠正回来。</p><p>集成学习在各个规模的数据集上都有很好的策略。</p><ul><li>数据集大：划分成多个小数据集，学习多个模型进行组合。</li><li>数据集小：利用Bootstrap方法进行抽样，得到多个数据集，分别训练多个模型再进行组合。</li></ul><p>这篇博客介绍一下集成学习的几类：Bagging，Boosting以及Stacking。</p><p><strong>Bootstrap</strong></p><p>Bootstrap是一类非参数Monte Carlo方法，实质是对观测信息进行再抽样，进而对总体的分布特性进行统计推断。</p><p>步骤：</p><ol><li><p>使用这个方法的前提是每个抽样的样本集大小和原数据集大小一样，并且数据集大小要非常大，而不是像本文这样设置成固定的100个。</p></li><li><p>在已有的样本通过重抽样抽取一定数量（比如100）的新样本，重抽样（Re-sample）的意思就是有放回的抽取，即一个数据有可以被重复抽取超过一次。</p></li><li><p>根据我们抽取的样本，计算我们需要估计的统计量。</p></li><li><p>重复上述步骤n次（一般是n&gt;1000次）。通过n次（假设n=1000），我们就可以得到1000个$α_i$计算出统计量的置信区间。</p></li></ol><h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><p>在Bagging方法中，利用bootstrap方法从整体数据集中重抽样出得到N个数据集，在每个数据集上学习出一个模型，最后的预测结果利用N个模型的输出得到，具体地：分类问题采用N个模型预测投票的方式，回归问题采用N个模型预测平均的方式。</p><p>例如<strong>随机森林（Random Forest）</strong>就属于Bagging。</p><p>随机森林简单地来说就是用随机的方式建立一个森林，森林由很多的决策树组成，随机森林的每一棵决策树之间是没有关联的。</p><p>在我们学习每一棵决策树的时候就需要用到Bootstrap方法。在随机森林中，有两个随机采样的过程：对输入数据的数量与数据的特征都进行采样。对于输入数据采用重采样，这样在训练的时候每一棵树都不是全部的样本，相对而言不容易出现overfitting；接着进行特征采样，从M个特征中选择出m个，进行决策树的学习。</p><p>预测的时候，随机森林中的每一棵树都对输入进行预测，最后进行投票，哪个类别多，输入样本就属于哪个类别。这就相当于前面说的，每一个分类器（每一棵树）都比较弱，但组合到一起（投票）就比较强了。</p><h3 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h3><p>提升方法（Boosting）是一种可以用来减小监督学习中偏差的机器学习算法。主要也是学习一系列弱分类器，并将其组合为一个强分类器。Boosting中有代表性的是<strong>AdaBoost（Adaptive boosting）算法</strong>：刚开始训练时对每一个训练例赋相等的权重，然后用该算法对训练集训练t轮，每次训练后，对训练失败的训练例赋以较大的权重，也就是让学习算法在每次学习以后更注意学错的样本，从而得到多个预测函数。</p><p><strong>GBDT（Gradient Boost Decision Tree)</strong>就是一种Boosting的方法，与AdaBoost不同，GBDT每一次的计算是为了减少上一次的残差，GBDT在残差减少（负梯度）的方向上建立一个新的模型。</p><h3 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h3><p>Stacking方法是指训练一个模型用于组合其他各个模型。首先我们先训练多个不同的模型，然后把之前训练的各个模型的输出为输入来训练一个模型，以得到一个最终的输出。理论上，Stacking可以表示上面提到的两种Ensemble方法，只要我们采用合适的模型组合策略即可。但在实际中，我们通常使用logistic回归作为组合策略。</p><p>如下图，先在整个训练数据集上通过bootstrap抽样得到各个训练集合，得到一系列分类模型，称之为Tier 1分类器（可以采用交叉验证的方式学习），然后将输出用于训练Tier 2 分类器。</p><p><img src="/../img/v2-bc3b2612dd0ff778c53db4165bc35449_r.jpg" alt="img" style="zoom:75%;"></p><h3 id="Bagging与Boosting"><a href="#Bagging与Boosting" class="headerlink" title="Bagging与Boosting"></a>Bagging与Boosting</h3><p>Bagging和Boosting采用的都是<strong>采样-学习-组合</strong>的方式，但在细节上有一些不同，如</p><ul><li><strong>Bagging中每个训练集互不相关，也就是每个基分类器互不相关，而Boosting中训练集要在上一轮的结果上进行调整，也使得其不能并行计算</strong></li><li><strong>Bagging中预测函数是均匀平等的，但在Boosting中预测函数是加权的</strong></li></ul><p>在算法学习的时候，通常在bias和variance之间要有一个权衡。bias与variance的关系如下图，因而模型要想达到最优的效果，必须要兼顾bias和variance，也就是要采取策略使得两者比较平衡。</p><p><img src="/../img/v2-9000c0e50e1a97d0d12e85dc93affa5f_1440w.png" alt="img"></p><p>从算法来看，Bagging关注的是多个基模型的投票组合，保证了模型的稳定，因而每一个基模型就要相对复杂一些以降低偏差（比如每一棵决策树都很深）；而Boosting采用的策略是在每一次学习中都减少上一轮的偏差，因而在保证了偏差的基础上就要将每一个基分类器简化使得方差更小。</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3.x 动画篇</title>
    <link href="/2022/09/21/vue3-x-%E5%8A%A8%E7%94%BB%E7%AF%87/"/>
    <url>/2022/09/21/vue3-x-%E5%8A%A8%E7%94%BB%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="Vue3-x-动画和过渡篇"><a href="#Vue3-x-动画和过渡篇" class="headerlink" title="Vue3.x 动画和过渡篇"></a>Vue3.x 动画和过渡篇</h1><h3 id="01-CSS样式中的动画效果"><a href="#01-CSS样式中的动画效果" class="headerlink" title="01.CSS样式中的动画效果"></a>01.CSS样式中的动画效果</h3><p><a href="https://jspang.com/article/71#toc32">动画和过渡的区别</a></p><blockquote><p>动画：一个DOM元素，从一个地方移到另一个地方，这种效果叫做动画。比如一个层从浏览器的左侧移动到右侧，这就是动画。</p><p>过渡：是DOM元素中的一个属性，缓慢的变成另一个属性，这种效果叫做过渡效果。比如一个层从红色慢慢变成黄色，这种就是过渡。</p></blockquote><p>在开发中两者经常混合使用，也就是说动画的过程中伴随着过渡，所以很多小伙伴搞不清楚两者的概念。这节先来看一下CSS动画的写法。</p><p><a href="https://jspang.com/article/71#toc34">编写CSS动画效果</a></p><p>现在要作的效果是，一个<code>div</code>从左侧，往右移25像素，再移50像素，然后再回来，整个动画持续3秒钟。</p><p>在<code>VSCode</code>中，创建一个CSS区域，然后编写样式。这时候我们要使用CSS中的<code>animation</code>属性，然后再使用关键帧<code>keyframes</code>指定详细的动画过程。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;style&gt;<br>    .<span class="hljs-property">animation</span> &#123;<br>        <span class="hljs-attr">animation</span>: leftToRight 3s;<br>    &#125;<br><br>    @keyframes leftToRight &#123;<br>        <span class="hljs-number">0</span>% &#123;<br>            <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translateX</span>(0px);<br>        &#125;<br><br>        <span class="hljs-number">25</span>% &#123;<br>            <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translateX</span>(25px);<br>        &#125;<br><br>        <span class="hljs-number">50</span>% &#123;<br>            <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translateX</span>(50px);<br>        &#125;<br><br>        <span class="hljs-number">75</span>% &#123;<br>            <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translateX</span>(25px);<br>        &#125;<br><br>        <span class="hljs-number">100</span>% &#123;<br>            <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translateX</span>(0px);<br>        &#125;<br><br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>写完CSS样式，可以在要使用样式的部分加入这个样式，我这里直接加入到Vue模板中的div里。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`  &lt;div class=&quot;animation&quot;&gt;技术胖讲程序&lt;/div&gt;`</span><br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/71#toc35">写一个按钮控制动画效果</a></p><p>这时候我们就可以用按钮控制动画是否起作用了。但是注意，到目前位置我们都是以前学的知识，没有涉及到Vue3的动画。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/body&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">isAnimate</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                    <span class="hljs-attr">animation</span>: <span class="hljs-literal">false</span></span></span><br><span class="language-javascript"><span class="language-xml">                &#125;</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAnimate</span>.<span class="hljs-property">animation</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">isAnimate</span>.<span class="hljs-property">animation</span></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">template</span>: <span class="hljs-string">`  </span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">            &lt;div :class=&quot;isAnimate&quot;&gt;技术胖讲程序&lt;/div&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">            &lt;div&gt;&lt;button @click=&quot;handleClick&quot;&gt;启动/关闭&lt;/button&gt;&lt;/div&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">        `</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> vm = app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="02-CSS制作过渡效果用Vue进行控制"><a href="#02-CSS制作过渡效果用Vue进行控制" class="headerlink" title="02.CSS制作过渡效果用Vue进行控制"></a>02.CSS制作过渡效果用Vue进行控制</h3><p><a href="https://jspang.com/article/71#toc37">编写CSS样式 实现基本过渡样式</a></p><p>如果背景颜色<code>background-color</code>有变化时，我们要在3秒种完成过渡（变化），并且效果是由慢到快进行的，此部分的关键词是<code>ease</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;style&gt;<br>        .<span class="hljs-property">transition</span> &#123;<br>            <span class="hljs-attr">transition</span>: 3s background-color ease;<br>        &#125;<br><br>        .<span class="hljs-property">red</span> &#123;<br>            background-<span class="hljs-attr">color</span>: red;<br>        &#125;<br><br>        .<span class="hljs-property">yellow</span> &#123;<br>            background-<span class="hljs-attr">color</span>: yellow;<br>        &#125;<br>    &lt;/style&gt;<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/71#toc38">Vue控制过渡效果</a></p><p>声明数据项，因为一切都是数据驱动的，所以有数据才能实现控制。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">css</span>: &#123;<br>            <span class="hljs-attr">transition</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">red</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">yellow</span>: <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>有了数据后，在模板中进行绑定数据。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div  :<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;css&quot;</span> &gt;技术胖讲程序&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>绑定成功后，这时候到浏览器预览应该<code>div</code>的背景色是红色的。现在点击按钮后，还没有对应的响应事件，所以我们需要编写一个响应事件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">hanldClick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">css</span>.<span class="hljs-property">red</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">css</span>.<span class="hljs-property">red</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">css</span>.<span class="hljs-property">yellow</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">css</span>.<span class="hljs-property">yellow</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>响应事件名字为<code>hanldClick</code>，然后我们对颜色属性进行取反，就完成了这种过渡效果。</p><h3 id="03-Vue3制作动画效果"><a href="#03-Vue3制作动画效果" class="headerlink" title="03.Vue3制作动画效果"></a>03.Vue3制作动画效果</h3><p><a href="https://jspang.com/article/71#toc310">制作一个显示隐藏的切换效果</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/body&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-attr">isShow</span>:<span class="hljs-literal">false</span></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">methods</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-title function_">hanldClick</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">isShow</span>= !<span class="hljs-variable language_">this</span>.<span class="hljs-property">isShow</span></span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">template</span>: <span class="hljs-string">`</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">            &lt;div v-if=&quot;isShow&quot;&gt;技术胖讲程序&lt;/div&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">            &lt;div&gt;&lt;button @click=&quot;hanldClick&quot;&gt;切换动画&lt;/button&gt;&lt;/div&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">        `</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> vm = app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>点击按钮实现文字的显示和隐藏。</p><p><a href="https://jspang.com/article/71#toc311">编写CSS样式和制作进入动画</a></p><p>先来写一个关键帧动画, 这个关键帧动画作了从左侧位移到屏幕中的效果，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;style&gt;<br>    @keyframes comein&#123;<br>        <span class="hljs-number">0</span>%&#123;<br>            <span class="hljs-attr">transform</span>:<span class="hljs-title function_">translateX</span>(-100px)<br>        &#125;<br>        <span class="hljs-number">100</span>%&#123;<br>            <span class="hljs-attr">transform</span>:<span class="hljs-title function_">translateX</span>(50px)<br>        &#125;<br>    &#125;<br>  .<span class="hljs-property">v</span>-enter-active&#123;<br>        <span class="hljs-attr">animation</span>: comein 1s;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><code>v-enter-active</code>是一个固定的CSS样式写法，意思是以何种动画方式进入，我们直接用<code>animation</code>调用这个动画就可以了。</p><p>现在还是没有动画效果的，你还需要给动画的DOM元素加上<code>&lt;transition&gt;</code>标签。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;transition&gt;</span><br><span class="hljs-string">        &lt;div v-if=&quot;isShow&quot;&gt;技术胖讲程序&lt;/div&gt;</span><br><span class="hljs-string">    &lt;/transition&gt;</span><br><span class="hljs-string">    &lt;div&gt;&lt;button @click=&quot;hanldClick&quot;&gt;切换动画&lt;/button&gt;&lt;/div&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/71#toc312">编写退出动画</a></p><p>已经有了元素进入动画，下面是退出动画：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">@keyframes comeout&#123;<br>    <span class="hljs-number">0</span>%&#123;<br>        <span class="hljs-attr">transform</span>:<span class="hljs-title function_">translateX</span>(50px)<br>    &#125;<br>    <span class="hljs-number">100</span>%&#123;<br>        <span class="hljs-attr">transform</span>:<span class="hljs-title function_">translateX</span>(-100px)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了<code>comeout</code>的关键帧CSS，然后又是一个固定写法<code>v-leave-active</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">.<span class="hljs-property">v</span>-leave-active&#123;<br>    animation : comeout 1s;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候再点击按钮，就有了退出动画。</p><p>本节课我们学习了Vue3中的单个元素进入动画效果的制作，下节课我们再学习一下单个元素过渡效果的制作。</p><h3 id="04-Vue3制作过渡效果"><a href="#04-Vue3制作过渡效果" class="headerlink" title="04.Vue3制作过渡效果"></a>04.Vue3制作过渡效果</h3><p><a href="https://jspang.com/article/71#toc314">准备基础文件</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo04&lt;/title&gt;<br>    &lt;style&gt;<br>        .v-enter-active&#123;<br><br>        &#125;<br>        .v-leave-active&#123;<br><br>        &#125;<br>    &lt;/style&gt;<br>    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/3.0.2/vue.global.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app = Vue.createApp(&#123;<br>        data()&#123;<br>            return &#123;<br>                isShow:false<br>            &#125;<br>        &#125;,<br>        methods:&#123;<br>            hanldClick()&#123;<br>                this.isShow = ! this.isShow<br>            &#125;<br>        &#125;,<br>        template: `  <br>        &lt;transition&gt;<br>            &lt;div v-if=&quot;isShow&quot;&gt;技术胖讲程序&lt;/div&gt;<br>        &lt;/transition&gt;<br>        &lt;button @click=&quot;hanldClick&quot;&gt;切换动画&lt;/button&gt;<br><br>        `<br>    &#125;)<br>    const vm = app.mount(&quot;#app&quot;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>这时候的代码是没有任何过渡效果的，但是依然可以切换显示与隐藏效果。</p><p><a href="https://jspang.com/article/71#toc315">增加过渡效果</a></p><p>虽然<code>v-enter-active</code>和<code>v-leave-active</code>都是固定写法，但是我们需要告诉它执行的过渡效果是什么样子的。</p><p>我们还需要再写两个固定的css样式<code>v-enter-from</code>和<code>v-enter-to</code>。分别控制进入前DOM的样式和进入完成后DOM的样子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;style&gt;<br>    .<span class="hljs-property">v</span>-enter-<span class="hljs-keyword">from</span>&#123;<br>        <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>;<br>    &#125;<br>    .<span class="hljs-property">v</span>-enter-to&#123;<br>        <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>;<br>    &#125;<br>    .<span class="hljs-property">v</span>-enter-active&#123;<br>        <span class="hljs-attr">transition</span>: opacity 3s ease-out;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>预览一下，就有了进入时的透明度过渡效果。隐藏效果同理，也是两个固定的CSS选择器<code>v-leave-from</code>和<code>v-leave-to</code>，然后再编写离开时的执行效果<code>v-leave-active</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;style&gt;<br>    .<span class="hljs-property">v</span>-leave-active&#123;<br>        <span class="hljs-attr">transition</span>: opacity 3s ease-out;<br>    &#125;<br>    .<span class="hljs-property">v</span>-leave-<span class="hljs-keyword">from</span>&#123;<br>        <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>;<br>    &#125;<br>    .<span class="hljs-property">v</span>-leave-to&#123;<br>        <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>目前这段CSS代码还是比较冗余的，可以简化一下。简化的原则就是把一样的值的选择器合并到一期：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;style&gt;<br>    .<span class="hljs-property">v</span>-enter-<span class="hljs-keyword">from</span> , .<span class="hljs-property">v</span>-leave-to&#123;<br>        <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>;<br>    &#125;<br>    .<span class="hljs-property">v</span>-enter-to , .<span class="hljs-property">v</span>-leave-<span class="hljs-keyword">from</span>&#123;<br>        <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>;<br>    &#125;<br>    .<span class="hljs-property">v</span>-enter-active , .<span class="hljs-property">v</span>-leave-active&#123;<br>        <span class="hljs-attr">transition</span>: opacity 3s ease-out;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>Vue动画和过渡效果的套路就是利用固定的选择器，然后配合<code>&lt;transition&gt;</code>标签来现实。</p><h3 id="05-第三方动画库Animate使用"><a href="#05-第三方动画库Animate使用" class="headerlink" title="05.第三方动画库Animate使用"></a>05.第三方动画库Animate使用</h3><p>这节课学习如何在Vue中使用第三方动画库<code>Animate.css</code>。它里边有很多已经写好的动画，可以给开发带来极大的方便。</p><p><a href="https://jspang.com/article/71#toc317">自定义动画选择</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo05&lt;/title&gt;<br>    &lt;style&gt;<br>        @keyframes comein&#123;<br>            0%&#123;<br>                transform :translateX(-120px)<br>            &#125;<br>            100%&#123;<br>                transform :translateX(0px)<br>            &#125;<br>        &#125;<br>        @keyframes comeout&#123;<br>            0%&#123;<br>                transform :translateX(0px)<br>            &#125;<br>            100%&#123;<br>                transform :translateX(-120px)<br>            &#125;<br>        &#125;<br>        .v-enter-active&#123;<br>            animation: comein 1s;<br>        &#125;<br>        .v-leave-active&#123;<br>            animation: comeout 1s;<br>        &#125;<br><br>    &lt;/style&gt;<br>    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/3.0.2/vue.global.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app = Vue.createApp(&#123;<br>        data()&#123;<br>            return &#123;<br>                isShow:false<br>            &#125;<br>        &#125;,<br>        methods:&#123;<br>            hanldClick()&#123;<br>                this.isShow = ! this.isShow<br>            &#125;<br>        &#125;,<br>        template: `  <br>        &lt;transition&gt;<br>            &lt;div v-if=&quot;isShow&quot;&gt;技术胖讲程序&lt;/div&gt;<br>        &lt;/transition&gt;<br>        &lt;button @click=&quot;hanldClick&quot;&gt;切换动画&lt;/button&gt;<br><br>        `<br>    &#125;)<br>    const vm = app.mount(&quot;#app&quot;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>代码中使用了<code>v-enter-active</code>和<code>v-leave-active</code>，这些CSS中固定选择器的类名又臭又长，这里有两个自定义类名的方法，你们可以根据需要自行选择。</p><p><strong>方法一：给<code>transition</code>标签一个name</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`  </span><br><span class="hljs-string">    &lt;transition name=&quot;jspang&quot;&gt;</span><br><span class="hljs-string">        &lt;div v-if=&quot;isShow&quot;&gt;技术胖讲程序&lt;/div&gt;</span><br><span class="hljs-string">    &lt;/transition&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这时候去浏览器中预览，发现所有的动画已经不能使用了。需要把CSS选择器以<code>v-</code>打头的类名改为<code>jspang</code>打头的<code>.jspang-enter-active</code>和<code>.jspang-leave-active</code>。此时的CSS代码如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">.<span class="hljs-property">jspang</span>-enter-active&#123;<br>    <span class="hljs-attr">animation</span>: comein 1s;<br>&#125;<br>.<span class="hljs-property">jspang</span>-leave-active&#123;<br>    <span class="hljs-attr">animation</span>: comeout 1s;<br>&#125;<br></code></pre></td></tr></table></figure><p>在一个页面中有多个动画时，经常使用。</p><p><strong>方法二：在<code>&lt;transition&gt;</code>标签中直接指定一个CSS样式</strong></p><p>现在新写一个CSS样式，叫做<code>come</code>和<code>go</code>，代码跟<code>v-enter-active</code>和<code>v-leave-active</code>的CSS代码一样。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">.<span class="hljs-property">come</span>&#123;<br>    <span class="hljs-attr">animation</span>: comein 1s;<br>&#125;<br>.<span class="hljs-property">go</span>&#123;<br>    <span class="hljs-attr">animation</span>: comeout 1s;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在<code>template</code>代码中，加入<code>enter-active-class</code>和<code>leave-active-class</code>属性，并指定名称。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`  </span><br><span class="hljs-string">    &lt;transition </span><br><span class="hljs-string">        enter-active-class=&quot;come&quot;</span><br><span class="hljs-string">        leave-active-class=&quot;go&quot;</span><br><span class="hljs-string">    &gt;</span><br><span class="hljs-string">        &lt;div v-if=&quot;isShow&quot;&gt;技术胖讲程序&lt;/div&gt;</span><br><span class="hljs-string">    &lt;/transition&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>使用自定义名称可以定义一些比较复杂的动画，也可以使用第三方动画库，比如<code>Animate.css</code>动画库。</p><p><a href="https://jspang.com/article/71#toc318">使用第三方动画库</a></p><p>当我们会了这种自定义方法后，就可以使用<code>Animate.css</code>这样的动画库了。</p><p>这里先给出动画库的网址：</p><ul><li><p><a href="http://www.animate.net.cn/">http://www.animate.net.cn/</a></p></li><li><p>下载库：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ npm install animate<span class="hljs-selector-class">.css</span> <span class="hljs-attr">--save</span><br></code></pre></td></tr></table></figure></li><li><p>直接在HTML页面中引入CDN地址。</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;link<br>    rel=<span class="hljs-string">&quot;stylesheet&quot;</span><br>    href=<br>  <span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css&quot;</span><br>  /&gt;<br></code></pre></td></tr></table></figure><ul><li>在动画标签加上<code>animate__animated</code> 和指定的动画效果，比如<code>animate__bounce</code> （跳动的动画）。就可以实现一个酷炫的CSS动画效果了。在网站上查看所有动画效果：<a href="https://animate.style/#attention_seekers">https://animate.style/#attention_seekers</a></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;h1 <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;animate__animated animate__bounce&quot;</span>&gt;<span class="hljs-title class_">An</span> animated element&lt;/h1&gt;<br></code></pre></td></tr></table></figure><ul><li><p>使用<code>@keyframes</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx">.<span class="hljs-property">my</span>-element &#123;<br>  <span class="hljs-attr">display</span>: inline-block;<br>  <span class="hljs-attr">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0.</span>5rem;<br><br>  <span class="hljs-attr">animation</span>: bounce; <span class="hljs-comment">/* referring directly to the animation&#x27;s @keyframe declaration */</span><br>  animation-<span class="hljs-attr">duration</span>: 2s; <span class="hljs-comment">/* don&#x27;t forget to set a duration! */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>更改css配置</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">/* This only changes this particular animation duration */</span><br>.<span class="hljs-property">animate__animated</span>.<span class="hljs-property">animate__bounce</span> &#123;<br>  --animate-<span class="hljs-attr">duration</span>: 2s;<br>&#125;<br><br><span class="hljs-comment">/* This changes all the animations globally */</span><br>:root &#123;<br>  --animate-<span class="hljs-attr">duration</span>: 800ms;<br>  --animate-<span class="hljs-attr">delay</span>: <span class="hljs-number">0.</span>9s;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="06-过渡和动画并用小技巧"><a href="#06-过渡和动画并用小技巧" class="headerlink" title="06.过渡和动画并用小技巧"></a>06.过渡和动画并用小技巧</h3><p><a href="https://jspang.com/article/71#toc320">构建一个过渡和动画并用的代码</a></p><p>复制后修改CSS样式，最终实现页面既有动画，又有过渡效果。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo06&lt;/title&gt;<br>    &lt;style&gt;<br>        @keyframes comein &#123;<br>            0% &#123;<br>                transform: translateX(-120px)<br>            &#125;<br><br>            100% &#123;<br>                transform: translateX(0px)<br>            &#125;<br>        &#125;<br><br>        @keyframes comeout &#123;<br>            0% &#123;<br>                transform: translateX(0px)<br>            &#125;<br><br>            100% &#123;<br>                transform: translateX(-120px)<br>            &#125;<br>        &#125;<br><br>        .v-enter-from,<br>        .v-leave-to &#123;<br>            opacity: 0;<br>        &#125;<br><br>        .v-enter-to,<br>        .v-leave-from &#123;<br>            opacity: 1;<br>        &#125;<br><br>        .v-enter-active &#123;<br>            animation: comein 3s;<br>            transition: opacity 3s ease-out;<br>        &#125;<br><br>        .v-leave-active &#123;<br>            animation: comeout 3s;<br>            transition: opacity 3s ease-out;<br>        &#125;<br>    &lt;/style&gt;<br>    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/3.0.2/vue.global.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app = Vue.createApp(&#123;<br>        data() &#123;<br>            return &#123;<br>                isShow: false<br>            &#125;<br>        &#125;,<br>        methods: &#123;<br>            hanldClick() &#123;<br>                this.isShow = !this.isShow<br>            &#125;<br>        &#125;,<br>        template: `  <br>        &lt;transition&gt;<br>            &lt;div v-if=&quot;isShow&quot;&gt;技术胖讲程序&lt;/div&gt;<br>        &lt;/transition&gt;<br>        &lt;button @click=&quot;hanldClick&quot;&gt;切换动画&lt;/button&gt;<br><br>        `<br>    &#125;)<br>    const vm = app.mount(&quot;#app&quot;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>为了查看方便，把过渡和动画的时间都变成3秒。然后到浏览器中进行查看，可以看到这时候过渡和动画都非常正常。</p><p><a href="https://jspang.com/article/71#toc321">过渡和动画时长不一致的处理</a></p><p>有些时候<code>transition</code>过渡和<code>animation</code>动画时长并不是一致的，比如过渡时间是7秒，动画时间还是3秒。在进场动画时，你可能还感觉不到Bug，但在出场动画时，就会有严重的问题。动画结束后，为了显示过渡效果，元素又回到了页面上，直到过渡结束，才消失。</p><p>看不懂，大概意思是过渡时间&gt;动画世间的时候加吧。</p><p>为了解决这个问题，可以在<code>&lt;transition&gt;</code>标签上加入<code>type=&#39;animation&#39;</code>属性，意思是不管过渡时长是多少，动画结束，整个过程结束。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`  </span><br><span class="hljs-string">    &lt;transition type=&quot;animation&quot;&gt;</span><br><span class="hljs-string">        &lt;div v-if=&quot;isShow&quot;&gt;技术胖讲程序&lt;/div&gt;</span><br><span class="hljs-string">    &lt;/transition&gt;</span><br><span class="hljs-string">    &lt;button @click=&quot;hanldClick&quot;&gt;切换动画&lt;/button&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p><code>type=&#39;transition&#39;</code>以过渡时长为准，过渡结束，动画结束，过渡时间&lt;动画世间的时候加。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx">.<span class="hljs-property">v</span>-enter-active &#123;<br>    <span class="hljs-attr">animation</span>: comein 7s;<br>    <span class="hljs-attr">transition</span>: opacity 3s ease-out;<br>&#125;<br><br>.<span class="hljs-property">v</span>-leave-active &#123;<br>    <span class="hljs-attr">animation</span>: comeout 7s;<br>    <span class="hljs-attr">transition</span>: opacity 3s ease-out;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板部分修改如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`  </span><br><span class="hljs-string">    &lt;transition type=&quot;transition&quot;&gt;</span><br><span class="hljs-string">        &lt;div v-if=&quot;isShow&quot;&gt;技术胖讲程序&lt;/div&gt;</span><br><span class="hljs-string">    &lt;/transition&gt;</span><br><span class="hljs-string">    &lt;button @click=&quot;hanldClick&quot;&gt;切换动画&lt;/button&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/71#toc322">属性控制动画和过渡时长</a></p><p>绑定属性<code>&lt;transition :duration=&quot;1000&quot;&gt;</code> 可以直接控制时长，意思是1秒后，结束动画和过渡。注意这里的1000是毫米的意思，也就是1秒。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`  </span><br><span class="hljs-string">    &lt;transition :duration=&quot;1000&quot;&gt;</span><br><span class="hljs-string">        &lt;div v-if=&quot;isShow&quot;&gt;技术胖讲程序&lt;/div&gt;</span><br><span class="hljs-string">    &lt;/transition&gt;</span><br><span class="hljs-string">    &lt;button @click=&quot;hanldClick&quot;&gt;切换动画&lt;/button&gt;</span><br></code></pre></td></tr></table></figure><p>这时候再到浏览器中查看，可以看到1秒种过渡和动画虽没有完成，但是还是停止了。</p><p>duration除了能写一个数字之外，还可以写对象进去，比如入场的时候1秒种，出厂的时候3秒钟，就可以这样写。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;transition :duration=<span class="hljs-string">&quot;&#123;enter:1000,leave:3000&#125;&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="07-JS-Vue3制作动画和钩子函数"><a href="#07-JS-Vue3制作动画和钩子函数" class="headerlink" title="07.JS+Vue3制作动画和钩子函数"></a>07.JS+Vue3制作动画和钩子函数</h3><p>有时候我们不使用CSS制作动画，而使用JS来制作动画。虽然CSS的动画比JS的效率要高，但JS在操作DOM和时间控制上有着优势。所以这节我们就来学习一下如何使用JavaScript+Vue3来制作动画。</p><p><a href="https://jspang.com/article/71#toc324">指定不使用CSS动画</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo07&lt;/title&gt;<br>    &lt;style&gt;<br>        @keyframes comein&#123;<br>            0%&#123;<br>                transform :translateX(-120px)<br>            &#125;<br>            100%&#123;<br>                transform :translateX(0px)<br>            &#125;<br>        &#125;<br>        @keyframes comeout&#123;<br>            0%&#123;<br>                transform :translateX(0px)<br>            &#125;<br>            100%&#123;<br>                transform :translateX(-120px)<br>            &#125;<br>        &#125;<br>        .v-enter-active&#123;<br>            animation: comein 1s;<br>        &#125;<br>        .v-leave-active&#123;<br>            animation: comeout 1s;<br>        &#125;<br><br>    &lt;/style&gt;<br>    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/3.0.2/vue.global.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app = Vue.createApp(&#123;<br>        data()&#123;<br>            return &#123;<br>                isShow:false<br>            &#125;<br>        &#125;,<br>        methods:&#123;<br>            hanldClick()&#123;<br>                this.isShow = ! this.isShow<br>            &#125;<br>        &#125;,<br>        template: `  <br>        &lt;transition&gt;<br>            &lt;div v-if=&quot;isShow&quot;&gt;技术胖讲程序&lt;/div&gt;<br>        &lt;/transition&gt;<br>        &lt;button @click=&quot;hanldClick&quot;&gt;切换动画&lt;/button&gt;<br><br>        `<br>    &#125;)<br>    const vm = app.mount(&quot;#app&quot;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>如果不使用CSS动画，需要在<code>&lt;transition&gt;</code>标签上加入<code>:css=&quot;false&quot;</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;transition :css=<span class="hljs-string">&quot;false&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>加上这个绑定属性的意思就是，我不再使用CSS作为动画了。</p><p>此时CSS的动画没有用处了，你可以进行删除。</p><p><a href="https://jspang.com/article/71#toc325">使用JS编写动画效果</a></p><p>Vue为了能让我们使用JS动画效果，为我们提供了一些钩子函数。所谓钩子函数 ，就是在某一时刻会被自动调用的函数。</p><p><strong>before-enter钩子函数</strong></p><p>先来看第一个钩子函数<code>before-enter</code>，在动画开始前执行的函数。我们给这个钩子，绑定一个方法，比如这个方法叫做<code>handleBeforeEnter</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;transition <br>    :css=<span class="hljs-string">&quot;false&quot;</span> <br>    @before-enter=<span class="hljs-string">&quot;handleBeforeEnter&quot;</span><br>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span>技术胖讲程序<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure><p>写好钩子函数后，再编写对应的方法<code>handleBeforeEnter</code>.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">handleBeforeEnter</span>(<span class="hljs-params">element</span>)&#123;<br>    element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span>=<span class="hljs-string">&quot;red&quot;</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>注意，这个方法接收一个参数<code>element</code>,这个参数就是动画的DOM元素，有了它你就可以操作动画了。现在程序的意思是在动画开始前，把字体颜色变为红色。</p><p><strong>enter钩子函数</strong></p><p>当动画进入时，可以使用钩子函数<code>enter</code>。这里我们作一个如果字体是红色，就变成绿色；如果是绿色就变成红色的效果，并且是半秒钟变化一次。</p><p>在template的<code>&lt;transition&gt;</code>标签里加入<code>enter</code>钩子函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;transition <br>    :css=<span class="hljs-string">&quot;false&quot;</span> <br>    @before-enter=<span class="hljs-string">&quot;handleBeforeEnter&quot;</span><br>    @enter=<span class="hljs-string">&quot;handleEnterActive&quot;</span><br>&gt;<br></code></pre></td></tr></table></figure><p>编写钩子函数的业务逻辑。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">handleEnterActive</span>(<span class="hljs-params">element,done</span>)&#123;<br>    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">const</span> color=element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span>;<br>        <span class="hljs-keyword">if</span>(color==<span class="hljs-string">&#x27;red&#x27;</span>)&#123;<br>            element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> =<span class="hljs-string">&quot;green&quot;</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span>=<span class="hljs-string">&quot;red&quot;</span><br>        &#125;<br>    &#125;,<span class="hljs-number">500</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>但现在如何让这个动画停下来那？其实这个还是比较麻烦的。需要先为<code>setInterval</code>指定一个变量<code>animation</code>，然后使用<code>setTimeout</code>在1500毫秒后停止这个动画。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">handleEnterActive</span>(<span class="hljs-params">element,done</span>)&#123;<br>    <span class="hljs-keyword">const</span> animation=<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">const</span> color=element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span>;<br>        <span class="hljs-keyword">if</span>(color==<span class="hljs-string">&#x27;red&#x27;</span>)&#123;<br>            element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> =<span class="hljs-string">&quot;green&quot;</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span>=<span class="hljs-string">&quot;red&quot;</span><br>        &#125;<br>    &#125;,<span class="hljs-number">500</span>)<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">clearInterval</span>(animation)<br>    &#125;,<span class="hljs-number">1500</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>此时在到浏览器中进行预览就可以看到，动画停止了。</p><p>那我们再来说说<code>done</code>参数的作用，其实done相当于得知动画执行结束后通知执行下一个钩子函数<code>after-enter</code>,如果不通知无法进入下一个钩子函数。</p><p><strong>after-enter钩子函数</strong></p><p>这个钩子函数是当动画结束时执行的。比如我们想在动画结束后弹出一个alter对象，就可以先写一个after-enter钩子函数，然后利用enter钩子中的done进行通知它动画执行结束。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;transition <br>    :css=<span class="hljs-string">&quot;false&quot;</span> <br>    @before-enter=<span class="hljs-string">&quot;handleBeforeEnter&quot;</span><br>    @enter=<span class="hljs-string">&quot;handleEnterActive&quot;</span><br>    @after-enter=<span class="hljs-string">&quot;handleEnterEnd&quot;</span><br>&gt;<br></code></pre></td></tr></table></figure><p>然后在<code>handleEnterActive</code>的<code>clearInterval</code>后面使用<code>done( )</code>进行通知。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-built_in">clearInterval</span>(animation)<br>    <span class="hljs-title function_">done</span>()<br>&#125;,<span class="hljs-number">1500</span>)<br></code></pre></td></tr></table></figure><p>这时候才会执行<code>handleEnterEnd</code>里边的方法，弹出对话框。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">handleEnterEnd</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;JSPang.com&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们只学了入场动画的钩子函数，当然还有三个出场动画的钩子函数。</p><ul><li>before-leave :离场动画执行之前</li><li>leave：开始执行离场动画</li><li>leave-after: 离场动画执行结束</li></ul><p>离场动画我们就不讲了，你可以自己试一下就可以了。</p><h3 id="08-双DOM元素动画的实现"><a href="#08-双DOM元素动画的实现" class="headerlink" title="08.双DOM元素动画的实现"></a>08.双DOM元素动画的实现</h3><p>这节课学习的内容是双DOM元素的动画切换，意思就是一个动画<code>&lt;transtion&gt;</code>标签里有两个DOM，然后一个出现时，另一个消失。</p><p><a href="https://jspang.com/article/71#toc327">双元素交替切换效果制作</a></p><p>下面是当前的代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo08&lt;/title&gt;<br>    &lt;style&gt;<br><br><br>    &lt;/style&gt;<br>    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/3.0.2/vue.global.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app = Vue.createApp(&#123;<br>        data()&#123;<br>            return &#123;<br>                isShow:false<br>            &#125;<br>        &#125;,<br>        methods:&#123;<br>            hanldClick()&#123;<br>                this.isShow = ! this.isShow<br>            &#125;<br>        &#125;,<br>        template: `  <br>        &lt;transition&gt;<br>            &lt;div v-if=&quot;isShow&quot;&gt;大脚进入了试衣间&lt;/div&gt;<br>            &lt;div v-else&gt;晓红进入了试衣间&lt;/div&gt;<br>        &lt;/transition&gt;<br>        &lt;button @click=&quot;hanldClick&quot;&gt;切换动画&lt;/button&gt;<br><br>        `<br>    &#125;)<br>    const vm = app.mount(&quot;#app&quot;)<br>&lt;/script&gt;`<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/71#toc328">增加动画效果</a></p><p>先写进入时的过渡样式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;style&gt;<br>    .<span class="hljs-property">v</span>-enter-<span class="hljs-keyword">from</span>&#123;<br>        <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>;<br>    &#125;<br>    .<span class="hljs-property">v</span>-enter-to &#123;<br>        <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>;<br>    &#125;<br>    .<span class="hljs-property">v</span>-enter-active&#123;<br>        <span class="hljs-attr">transition</span>: opacity 2s ease-<span class="hljs-keyword">in</span>;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>有了进场的过多效果，直接加入出场的选择器就可以实现同时拥有入场和出场动画了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;style&gt;<br>    .<span class="hljs-property">v</span>-enter-<span class="hljs-keyword">from</span>,<br>    .<span class="hljs-property">v</span>-leave-to &#123;<br>        <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>;<br>    &#125;<br><br>    .<span class="hljs-property">v</span>-enter-to,<br>    .<span class="hljs-property">v</span>-leave-<span class="hljs-keyword">from</span> &#123;<br>        <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>;<br>    &#125;<br><br>    .<span class="hljs-property">v</span>-enter-active,<br>    .<span class="hljs-property">v</span>-leave-active &#123;<br>        <span class="hljs-attr">transition</span>: opacity 2s ease-<span class="hljs-keyword">in</span>;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>这时再到浏览器中查看效果，虽然都有了动画。但这时候的动画时同时发生的，并不是我们想要的效果。</p><p><a href="https://jspang.com/article/71#toc329">mode模式讲解</a></p><p>为了解决这个问题，可以在模板中<code>&lt;transition&gt;</code>标签上加入<code>mode</code>属性。mode属性专门用来控制是先显示离场和入场动画的顺序的。比如现在想让离场动画先显示（从实体到透明）然后再显示入场动画。就可以使用<code>mode=&quot;out-in&quot;</code>.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`  </span><br><span class="hljs-string">    &lt;transition mode=&quot;out-in&quot;&gt;</span><br><span class="hljs-string">        &lt;div v-if=&quot;isShow&quot;&gt;大脚进入了试衣间&lt;/div&gt;</span><br><span class="hljs-string">        &lt;div v-else&gt;晓红进入了试衣间&lt;/div&gt;</span><br><span class="hljs-string">    &lt;/transition&gt;</span><br><span class="hljs-string">    &lt;button @click=&quot;hanldClick&quot;&gt;切换动画&lt;/button&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>当然你也可以用<code>mode=&quot;in-out&quot;</code>先显示入场动画，再显示出场动画。只不过这并不是我们想要的方式。</p><p>但这时候还是有一个小问题的，就是刚进入页面时，显示的DOM元素（<code>晓红进入了试衣间</code>）是没有动画效果的。如果想让进入页面，开始就产生动画效果，可以在<code>&lt;transition&gt;</code>标签上加上<code>appear</code>属性就可以实现。</p><p><code>appear</code>属性的意思是初次对某一个元素进行默认显示的时候也进行动画显示。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`  </span><br><span class="hljs-string">    &lt;transition mode=&quot;out-in&quot; appear&gt;</span><br><span class="hljs-string">        &lt;div v-if=&quot;isShow&quot;&gt;大脚进入了试衣间&lt;/div&gt;</span><br><span class="hljs-string">        &lt;div v-else&gt;晓红进入了试衣间&lt;/div&gt;</span><br><span class="hljs-string">    &lt;/transition&gt;</span><br><span class="hljs-string">    &lt;button @click=&quot;hanldClick&quot;&gt;切换动画&lt;/button&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><h3 id="09-双组件切换动画的实现"><a href="#09-双组件切换动画的实现" class="headerlink" title="09.双组件切换动画的实现"></a>09.双组件切换动画的实现</h3><p><a href="https://jspang.com/article/71#toc331">双组件切换动画</a></p><p>我们先来编写两个组件，这里可以写两个最简单的局部组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">DaJiao</span> = &#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;大脚进入了试衣间&lt;/div&gt;`</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">XiaoHong</span> = &#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;晓红进入了试衣间&lt;/div&gt;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>要想使用局部组件，需要先用<code>components</code>进行注册,这里换成小写加横线的形式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">components</span>: &#123;<br>    <span class="hljs-string">&#x27;da-jiao&#x27;</span>: <span class="hljs-title class_">DaJiao</span>,<br>    <span class="hljs-string">&#x27;xiao-hong&#x27;</span>: <span class="hljs-title class_">XiaoHong</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>然后修改模板中的<code>&lt;transition&gt;</code>部分，使用局部组件，实现动画。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`  </span><br><span class="hljs-string">    &lt;transition mode=&quot;out-in&quot; appear&gt;</span><br><span class="hljs-string">        &lt;da-jiao v-if=&quot;isShow&quot; /&gt;</span><br><span class="hljs-string">        &lt;xiao-hong v-else /&gt;</span><br><span class="hljs-string">    &lt;/transition&gt;</span><br><span class="hljs-string">    &lt;button @click=&quot;hanldClick&quot;&gt;切换动画&lt;/button&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/71#toc332">动态组件切换效果</a></p><p>我们还可以使用动态组件的形式进行切换，也就是在业务逻辑层面修改绑定属性，然后在模板中用<code>:is</code>来进行绑定。</p><p>先声明一个数据项，叫做<code>component</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;da-jiao&#x27;</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后在<code>handleClick</code>方法里修改这个组件的绑定，这里可以使用一个三元运算符。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">hanldClick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">component</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">component</span> === <span class="hljs-string">&#x27;da-jiao&#x27;</span> ? <span class="hljs-string">&#x27;xiao-hong&#x27;</span> : <span class="hljs-string">&#x27;da-jiao&#x27;</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>最后修改模板中的绑定方式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;transition mode=<span class="hljs-string">&quot;out-in&quot;</span> appear&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;component&quot;</span> /&gt;</span></span><br>&lt;/transition&gt;<br></code></pre></td></tr></table></figure><p>这时候到浏览器中查看效果，仍然可以得到我们想要的效果。</p><p>这里为了方便你学习，我给出所有代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo08&lt;/title&gt;<br>    &lt;style&gt;<br>        .v-enter-from,<br>        .v-leave-to &#123;<br>            opacity: 0;<br>        &#125;<br><br>        .v-enter-to,<br>        .v-leave-from &#123;<br>            opacity: 1;<br>        &#125;<br><br>        .v-enter-active,<br>        .v-leave-active &#123;<br>            transition: opacity 2s ease-in;<br>        &#125;<br>    &lt;/style&gt;<br>    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/3.0.2/vue.global.js&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const DaJiao = &#123;<br>        template: `&lt;div&gt;大脚进入了试衣间&lt;/div&gt;`<br>    &#125;<br>    const XiaoHong = &#123;<br>        template: `&lt;div&gt;晓红进入了试衣间&lt;/div&gt;`<br>    &#125;<br>    const app = Vue.createApp(&#123;<br>        data() &#123;<br>            return &#123;<br>                component: &#x27;da-jiao&#x27;<br>            &#125;<br>        &#125;,<br>        methods: &#123;<br>            hanldClick() &#123;<br>                this.component = this.component === &#x27;da-jiao&#x27; ? &#x27;xiao-hong&#x27; : &#x27;da-jiao&#x27;<br>            &#125;<br>        &#125;,<br>        components: &#123;<br>            &#x27;da-jiao&#x27;: DaJiao,<br>            &#x27;xiao-hong&#x27;: XiaoHong<br>        &#125;,<br>        template: `  <br>            &lt;transition mode=&quot;out-in&quot; appear&gt;<br>                &lt;component :is=&quot;component&quot; /&gt;<br>            &lt;/transition&gt;<br>            &lt;button @click=&quot;hanldClick&quot;&gt;切换动画&lt;/button&gt;<br><br>        `<br>    &#125;)<br>    const vm = app.mount(&quot;#app&quot;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Day05</title>
    <link href="/2022/09/13/Python-Day05/"/>
    <url>/2022/09/13/Python-Day05/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="一、下载数据"><a href="#一、下载数据" class="headerlink" title="一、下载数据"></a>一、下载数据</h2><p>本章将访问并可视化的数据以两种常见格式存储：CSV和 JSON。</p><h3 id="案例一、全球温度图表csv"><a href="#案例一、全球温度图表csv" class="headerlink" title="案例一、全球温度图表csv"></a>案例一、全球温度图表csv</h3><p><strong>CSV文件格式</strong></p><p>要在文本文件中存储数据，一个简单方式是将数据作为一系列以逗号分隔的值 （comma-separated values）写入文件。这样的文件称 为CSV 文件。例如，下面是一行CSV格式的天气数据：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-string">&quot;USW00025333&quot;</span>,<span class="hljs-string">&quot;SITKA AIRPORT, AK US&quot;</span>,<span class="hljs-string">&quot;2018-01-01&quot;</span>,<span class="hljs-string">&quot;0.45&quot;</span>,,<span class="hljs-string">&quot;48&quot;</span>,<span class="hljs-string">&quot;38&quot;</span><br></code></pre></td></tr></table></figure><p>CSV文件对人来说阅读起来比较麻烦，但程序可轻松提取并处理其中的值，有助于加快数据分析过程。</p><p><strong>分析CSV文件头</strong></p><p>csv 模块包含在Python标准库中，可用于分析CSV文件中的数据行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br>filename=<span class="hljs-string">&#x27;../sitka_weather_07-2018_simple.csv&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span>  f:<br>    reader=csv.reader(f)<br>    header_row=<span class="hljs-built_in">next</span>(reader)<br>    <span class="hljs-built_in">print</span>(header_row)<br></code></pre></td></tr></table></figure><p>调用<code>csv.reader()</code>创建一个与该文件相关联的阅读器对象，调用next()传入阅读器对象时，它将返 回文件中的下一行。在上述代码中，只调用了next() 一次，没有把每次循环的数据传入列表，因此得到的是文件的第一行，其中包含文件头。</p><p>reader 处理文件中以逗号分隔的第一行数据，并将每项数据都作为一个元素存储在列表中。</p><p><strong>打印文件头及其位置</strong></p><p>为了让文件头数据更容易理解，将列表中的每个文件头及其位置打印出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br>filename=<span class="hljs-string">&#x27;../sitka_weather_07-2018_simple.csv&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span>  f:<br>    reader=csv.reader(f)<br>    header_row=<span class="hljs-built_in">next</span>(reader)<br>    <span class="hljs-keyword">for</span> index, column_header <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(header_row):<br>        <span class="hljs-built_in">print</span>(index, column_header)<br></code></pre></td></tr></table></figure><p>在循环中，对列表调用了<code>enumerate()</code> 来获取每个元素的索引及其值。</p><p><strong>提取并读取数据</strong></p><p>知道需要哪些列中的数据后，我们来读取一些数据。首先，读取每天的最高温度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br>filename=<span class="hljs-string">&#x27;../sitka_weather_07-2018_simple.csv&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span>  f:<br>    reader=csv.reader(f)<br>    header_row=<span class="hljs-built_in">next</span>(reader)<br>    highs=[]<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:<br>      <span class="hljs-comment">#第五列为温度数据</span><br>        high=<span class="hljs-built_in">int</span>(row[<span class="hljs-number">5</span>])<br>        highs.append(high)<br><span class="hljs-built_in">print</span>(highs)<br></code></pre></td></tr></table></figure><p><strong>绘制温度图表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>filename=<span class="hljs-string">&#x27;../sitka_weather_07-2018_simple.csv&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span>  f:<br>    reader=csv.reader(f)<br>    header_row=<span class="hljs-built_in">next</span>(reader)<br>    highs=[]<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:<br>        high=<span class="hljs-built_in">int</span>(row[<span class="hljs-number">5</span>])<br>        highs.append(high)<br>plt.style.use(<span class="hljs-string">&#x27;seaborn&#x27;</span>)<br>fig,ax=plt.subplots()<br>ax.plot(highs,c=<span class="hljs-string">&#x27;pink&#x27;</span>)<br>ax.set_title(<span class="hljs-string">&quot;2018年7月每日最高温度&quot;</span>, fontsize=<span class="hljs-number">24</span>)<br>ax.set_xlabel(<span class="hljs-string">&#x27;&#x27;</span>, fontsize=<span class="hljs-number">16</span>)<br>ax.set_ylabel(<span class="hljs-string">&quot;温度 (F)&quot;</span>, fontsize=<span class="hljs-number">16</span>)<br>ax.tick_params(axis=<span class="hljs-string">&#x27;both&#x27;</span>, which=<span class="hljs-string">&#x27;major&#x27;</span>, labelsize=<span class="hljs-number">16</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><strong>模块datetime</strong></p><p>导入模块datetime 中的datetime 类，再调用方法<code>strptime()</code>，并将包含所需日期的字符串作为第一个实参。第二个实参告诉Python如何设置日期的格式。</p><div class="table-container"><table><thead><tr><th>实参</th><th>含义</th></tr></thead><tbody><tr><td>%A</td><td>星期几，如Monday</td></tr><tr><td>%B</td><td>月份名，如January</td></tr><tr><td>%m</td><td>用数表示的月份（01～12）</td></tr><tr><td>%d</td><td>用数表示的月份中的一天（01～31）</td></tr><tr><td>%Y</td><td>四位的年份，如2019</td></tr><tr><td>%y</td><td>两位的年份，如19</td></tr><tr><td>%H</td><td>24小时制的小时数（00～23）</td></tr><tr><td>%I</td><td>12小时制的小时数（01～12）</td></tr><tr><td>%p</td><td>am或pm</td></tr><tr><td>%M</td><td>分钟数（00～59）</td></tr><tr><td>%S</td><td>秒数（00～61）</td></tr></tbody></table></div><p><strong>在图表中添加日期</strong></p><p>可以通过提取日期和最高温度并将其传递给plot() ，对温度图形进行改进</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>filename=<span class="hljs-string">&#x27;../sitka_weather_07-2018_simple.csv&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span>  f:<br>    reader=csv.reader(f)<br>    header_row=<span class="hljs-built_in">next</span>(reader)<br>    dates=[]<br>    highs=[]<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:<br>      <span class="hljs-comment">#将包含日期信息的数据（row[2]）转换为datetime 对象</span><br>        current_date = datetime.strptime(row[<span class="hljs-number">2</span>],<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)<br>        high=<span class="hljs-built_in">int</span>(row[<span class="hljs-number">5</span>])<br>        dates.append(current_date)<br>        highs.append(high)<br>plt.style.use(<span class="hljs-string">&#x27;seaborn&#x27;</span>)<br>fig,ax=plt.subplots()<br>ax.plot(dates,highs,c=<span class="hljs-string">&#x27;pink&#x27;</span>)<br>ax.set_title(<span class="hljs-string">&quot;2018年7月每日最高温度&quot;</span>, fontsize=<span class="hljs-number">24</span>)<br>ax.set_xlabel(<span class="hljs-string">&#x27;&#x27;</span>, fontsize=<span class="hljs-number">16</span>)<br><span class="hljs-comment">#绘制倾斜的日期标签，以免其彼此重叠</span><br>fig.autofmt_xdate()<br>ax.set_ylabel(<span class="hljs-string">&quot;温度 (F)&quot;</span>, fontsize=<span class="hljs-number">16</span>)<br>ax.tick_params(axis=<span class="hljs-string">&#x27;both&#x27;</span>, which=<span class="hljs-string">&#x27;major&#x27;</span>, labelsize=<span class="hljs-number">16</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><strong>给图表区域着色</strong></p><p>使用方法<code>fill_between()</code> 。它接受一个x值系列和两个y值系列，并填充两个y值系列之间的空间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:<br>        current_date = datetime.strptime(row[<span class="hljs-number">2</span>],<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)<br>        high=<span class="hljs-built_in">int</span>(row[<span class="hljs-number">5</span>])<br>        low=<span class="hljs-built_in">int</span>(row[<span class="hljs-number">6</span>])<br>        dates.append(current_date)<br>        highs.append(high)<br>        lows.append(low)<br>plt.style.use(<span class="hljs-string">&#x27;seaborn&#x27;</span>)<br>fig,ax=plt.subplots()<br>ax.plot(dates,highs,c=<span class="hljs-string">&#x27;pink&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>ax.plot(dates,lows,c=<span class="hljs-string">&#x27;yellow&#x27;</span>,alpha=<span class="hljs-number">0.5</span>)<br>ax.fill_between(dates,highs,lows,facecolor=<span class="hljs-string">&#x27;blue&#x27;</span>,alpha=<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure><p>alpha 指定颜色的透明度。alpha 值为0表示完全透明，为1（默认）表示完全不透明。实参facecolor指定填充区域的颜色</p><p><img src="/../img/image-20220917195455887.png" alt="image-20220917195455887" style="zoom:50%;"></p><h3 id="案例二、全球地震散点图json"><a href="#案例二、全球地震散点图json" class="headerlink" title="案例二、全球地震散点图json"></a>案例二、全球地震散点图json</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>fn=<span class="hljs-string">&#x27;./eq_data_1_day_m1.json&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(fn) <span class="hljs-keyword">as</span> f:<br>    data=json.load(f)<br>reader_file=<span class="hljs-string">&#x27;readable_eq_data.json&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(reader_file,<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(data,f,indent=<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>函数json.load() 将数据转换为 Python能够处理的格式，这里是一个庞大的字典。参数indent=4 让dump() 使用与数据结构匹配的缩进量来设置数据的格式。</p><p><strong>创建地震列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>fn=<span class="hljs-string">&#x27;./eq_data_1_day_m1.json&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(fn) <span class="hljs-keyword">as</span> f:<br>    data=json.load(f)<br>dics=data[<span class="hljs-string">&#x27;features&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(dics))<br></code></pre></td></tr></table></figure><p>提取与键 ‘features’ 相关联的数据,记录了158次地震</p><p>每次地震的震级都存储在相应字典 的’properties’ 部分的’mag’ 键下，依次将地震震级赋给变量mag ，再将这个变量附加到列表mags 末尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>fn=<span class="hljs-string">&#x27;./eq_data_1_day_m1.json&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(fn) <span class="hljs-keyword">as</span> f:<br>    data=json.load(f)<br>dics=data[<span class="hljs-string">&#x27;features&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(dics))<br>mags=[]<br><span class="hljs-keyword">for</span> eq_dict <span class="hljs-keyword">in</span> data:<br>    mag=eq_dict[<span class="hljs-string">&#x27;properties&#x27;</span>][<span class="hljs-string">&#x27;mag&#x27;</span>]<br>    mags.append(mag)<br><span class="hljs-built_in">print</span>((mag[:<span class="hljs-number">10</span>]))<br></code></pre></td></tr></table></figure><p><strong>绘制震级散点图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px<br>fig = px.scatter( x=lons, y=lats,<br>labels=&#123;<span class="hljs-string">&quot;x&quot;</span>: <span class="hljs-string">&quot;经度&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>: <span class="hljs-string">&quot;纬度&quot;</span>&#125;,<br>range_x=[-<span class="hljs-number">200</span>, <span class="hljs-number">200</span>], range_y=[-<span class="hljs-number">90</span>, <span class="hljs-number">90</span>], <br>  width=<span class="hljs-number">800</span>, height=<span class="hljs-number">800</span>,<br>title=<span class="hljs-string">&quot;全球地震散点图&quot;</span>,)<br>fig.write_html(<span class="hljs-string">&quot;global_earthquakes.html&quot;</span>) <br>fig.show()<br></code></pre></td></tr></table></figure><p>调用px.scatter 函数配置参数创建一个fig 实例，分别设置x轴为经度［范围是[-200, 200]］、y 轴为纬度［范围是[-90, 90] ］，设置散点图显示的宽度和高度均为800像素，并设置标题为“全球地震散点图”。</p><p>散点图配置完成，返回一个fig 对象。fig.write_html 方法可以将可视化图保存为html文件。</p><p><strong>另一种指定图表数据的方式</strong></p><p>使用pandas数据分析工具，创建一个DataFrame ，将需要的数据封装起来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>data = pd.DataFrame( data=<span class="hljs-built_in">zip</span>(lons, lats, titles, mags), <br>columns=[<span class="hljs-string">&quot;经度&quot;</span>, <span class="hljs-string">&quot;纬度&quot;</span>, <span class="hljs-string">&quot;位置&quot;</span>, <span class="hljs-string">&quot;震级&quot;</span>] ) <br>data.head()<br></code></pre></td></tr></table></figure><p>在这种方式中，所有有关数据的信息都以键值对的形式放在一个字 典中。如果在eq_plot.py中使用这些代码，生成的图表是一样的。 相比于前一种格式，这种格式让我们能够无缝衔接数据分析，并且更轻松地进行定制。</p><p><strong>渐变</strong></p><p>Plotly Express有大量的渐变可供选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px<br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> px.colors.named_colorscales():<br><span class="hljs-built_in">print</span>(key)<br></code></pre></td></tr></table></figure><p>使用px.colors.diverging.RdYlGn[::-1] 可以将对应颜色的配色列表反转。</p><p><strong>添加鼠标指向时显示的文本</strong></p><p>Plotly Express的操作非常简单，只需要将hover_name 参数配置为data 的”位置” 字段即可。</p><h2 id="二、使用API"><a href="#二、使用API" class="headerlink" title="二、使用API"></a>二、使用API</h2><p>使用Web应用程序编程接口（API）自动请求网站的特定信息而不是整个网页，再对这些信息进行可视化。由于这样编写的程序始终使用最新的数据进行可视化，即便数据瞬息万变，它呈现的信息也是最新的。</p><p><strong>使用Web API</strong></p><p>Web API是网站的一部分，用于与使用具体URL请求特定信息的程序交互。这种请求称为API调用。请求的数据将以易于处理的格式（如JSON或CSV）返回。</p><p><strong>使用API调用请求数据</strong></p><p>GitHub的API让你能够通过API调用来请求各种信息。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">https://api.github.<span class="hljs-keyword">com</span>/<span class="hljs-built_in">search</span>/repositories?q=<span class="hljs-keyword">language</span>:<span class="hljs-keyword">python</span>&amp;<span class="hljs-keyword">sort</span>=<span class="hljs-keyword">star</span><br></code></pre></td></tr></table></figure><p>这个调用返回GitHub当前托管了多少个Python项目，以及有关最受欢迎的Python仓库的信息。下面来仔细研究这个调用。开头的 <a href="https://api.github.com/">https://api.github.com/</a> 将请求发送到GitHub网站中响应API 调用的部分，接下来的search/repositories 让API搜索GitHub 上的所有仓库。</p><p>repositories 后面的问号指出需要传递一个实参。q 表示查询，而等号（=）让我们能够开始指定查询。我们使用language:python指出只想获取主要语言为Python的仓库的信息。最后的&amp;sort=stars指定将项目按星级排序。</p><p><strong>安装Requests</strong></p><p>Requests包让Python程序能够轻松地向网站请求信息并检查返回的响应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 执行API调用并存储响应。</span><br>url=<span class="hljs-string">&#x27;https://api.github.com/search/repositories?q=language:python&amp;sort=star&#x27;</span><br>headers=&#123;<span class="hljs-string">&#x27;Accept&#x27;</span>: <span class="hljs-string">&#x27;application/vnd.github.v3+json&#x27;</span>&#125;<br>r=requests.get(url,headers=headers)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Status code:<span class="hljs-subst">&#123;r.status_code&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 将API响应赋给一个变量。</span><br>response_dict=r.json()<br><span class="hljs-built_in">print</span>(response_dict.keys())<br></code></pre></td></tr></table></figure><p>url存储API调用的URL，最新的GitHub API版本为第3版，因此通过指定headers 显式地要求使用这个版本的API，再使用requests 调用API。响应对象包含一个名为status_code 的属性，指出了请求是否成功 （状态码200表示请求成功）。</p><p>这个API返回JSON格式的信息，因此使用方法json() 将这些信息转换为一个Python字典，最后，打印response_dict 中的键，输出如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Status <span class="hljs-selector-tag">code</span>: <span class="hljs-number">200</span> <br><span class="hljs-function"><span class="hljs-title">dict_keys</span><span class="hljs-params">([<span class="hljs-string">&#x27;total_count&#x27;</span>, <span class="hljs-string">&#x27;incomplete_results&#x27;</span>, <span class="hljs-string">&#x27;items&#x27;</span>])</span></span><br></code></pre></td></tr></table></figure><p><strong>处理响应字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 执行API调用并存储响应。</span><br>url=<span class="hljs-string">&#x27;https://api.github.com/search/repositories?q=language:python&amp;sort=star&#x27;</span><br>headers=&#123;<span class="hljs-string">&#x27;Accept&#x27;</span>: <span class="hljs-string">&#x27;application/vnd.github.v3+json&#x27;</span>&#125;<br>r=requests.get(url,headers=headers)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Status code:<span class="hljs-subst">&#123;r.status_code&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 将API响应赋给一个变量。</span><br>response_dict=r.json()<br><span class="hljs-comment">#打印与&#x27;total_count&#x27; 相关联的值，它指出了GitHub总 共包含多少个Python仓库。</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Total repositories: <span class="hljs-subst">&#123;response_dict[<span class="hljs-string">&#x27;total_count&#x27;</span>]&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 探索有关仓库的信息。</span><br>repo_dicts=response_dict[<span class="hljs-string">&#x27;item&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Repositories returned: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(repo_dicts)&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 研究第一个仓库。</span><br>repo_dict=repo_dicts[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\nKeys: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(repo_dict)&#125;</span>&quot;</span>)<br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(repo_dict.keys()):<br>    <span class="hljs-built_in">print</span>(key)<br></code></pre></td></tr></table></figure><p>GitHub的API返回有关仓库的大量信息：repo_dict 包含73个键。通过仔细查看这些键，可大致知道可提取有关项目的哪些信息。</p><p>要准确地获悉API将返回哪些信息，要么阅读文档，要么像这里一样使用代码来查看。</p><p><strong>监视API的速率限制</strong></p><p>大多数API存在速率限制，也就是说，在特定时间内可执行的请求数存在限制。</p><p>要获悉是否接近了GitHub的限制，请在浏览器中输入 <a href="https://api.github.com/rate_limit">https://api.github.com/rate_limit</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;limit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>配额极限为每分钟10个请求，用完配额后，你将收到一条简单的响应，由此知道已到达API极限。到达极限后，必须等待配额重置。</p><p><strong>使用Plotly可视化仓库</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests <br><span class="hljs-keyword">from</span> plotly.graph_objs <span class="hljs-keyword">import</span> Bar <br><span class="hljs-keyword">from</span> plotly <span class="hljs-keyword">import</span> offline<br><br> <span class="hljs-comment"># 执行API调用并存储响应。 </span><br> url = <span class="hljs-string">&#x27;https://api.github.com/search/repositories?q=language:python&amp;sort=stars&#x27;</span><br> headers = &#123;<span class="hljs-string">&#x27;Accept&#x27;</span>: <span class="hljs-string">&#x27;application/vnd.github.v3+json&#x27;</span>&#125;<br> r = requests.get(url, headers=headers) <br> <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Status code: <span class="hljs-subst">&#123;r.status_code&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 处理结果。 </span><br> response_dict = r.json()<br> repo_dicts = response_dict[<span class="hljs-string">&#x27;items&#x27;</span>]<br> repo_names, stars = [], []<br> <span class="hljs-keyword">for</span> repo_dict <span class="hljs-keyword">in</span> repo_dicts:<br> repo_names.append(repo_dict[<span class="hljs-string">&#x27;name&#x27;</span>])<br>    stars.append(repo_dict[<span class="hljs-string">&#x27;stargazers_count&#x27;</span>])<br><span class="hljs-comment"># 可视化。</span><br>data = [&#123; <br><span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;bar&#x27;</span>, <br><span class="hljs-string">&#x27;x&#x27;</span>: repo_names, <br><span class="hljs-string">&#x27;y&#x27;</span>: stars, <br>  <span class="hljs-comment">#给条形指定了颜色和边框，给条形指定了一种自定义的蓝色，加上了宽1.5像素的深灰色轮廓，还将条形的不透明度设置为0.6，</span><br><span class="hljs-string">&#x27;marker&#x27;</span>: &#123; <br><span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;rgb(60, 100, 150)&#x27;</span>, <br><span class="hljs-string">&#x27;line&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1.5</span>, <span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;rgb(25, 25, 25)&#x27;</span>&#125; <br>&#125;, <br><span class="hljs-string">&#x27;opacity&#x27;</span>: <span class="hljs-number">0.6</span>,<br>&#125;]<br>my_layout = &#123; <br><span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;GitHub上最受欢迎的Python项目&#x27;</span>, <br><span class="hljs-string">&#x27;xaxis&#x27;</span>: &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;Repository&#x27;</span>&#125;, <br><span class="hljs-string">&#x27;yaxis&#x27;</span>: &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;Stars&#x27;</span>&#125;, <br>&#125;<br>fig = &#123;<span class="hljs-string">&#x27;data&#x27;</span>: data, <span class="hljs-string">&#x27;layout&#x27;</span>: my_layout&#125; <br>offline.plot(fig, filename=<span class="hljs-string">&#x27;python_repos.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在data 和 my_layout 中以键值对的形式指定各种样式。</p><p><strong>添加自定义工具提示</strong></p><p>在列表data 包含的字典中，添加了键’hovertext’ ，并将与之关联的值指定为刚创建的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">label=<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;owner&#125;</span>&lt;br/&gt;<span class="hljs-subst">&#123;description&#125;</span>&quot;</span><br>labels.append(label)<br>data = [&#123;<br><span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;bar&#x27;</span>, <br><span class="hljs-string">&#x27;x&#x27;</span>: repo_names, <br><span class="hljs-string">&#x27;y&#x27;</span>: stars, <br><span class="hljs-string">&#x27;hovertext&#x27;</span>: labels, <br>&#125;]<br></code></pre></td></tr></table></figure><p>在观察者将鼠标指向条形时，显示label标签中的内容。</p><p><strong>在图表中添加可单击的链接</strong></p><p>将x轴标签作为链接，让观察者能够访问项目在 GitHub上的主页。为此，需要提取URL并用其生成x 轴标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> repo_dict <span class="hljs-keyword">in</span> repo_dicts:<br>repo_name = repo_dict[<span class="hljs-string">&#x27;name&#x27;</span>]<br>  <span class="hljs-comment">#从repo_dict 中提取项目的URL</span><br>repo_url = repo_dict[<span class="hljs-string">&#x27;html_url&#x27;</span>]<br>  <span class="hljs-comment">#创建一个指向项目的链接</span><br>repo_link = <span class="hljs-string">f&quot;&lt;a href=&#x27;<span class="hljs-subst">&#123;repo_url&#125;</span>&#x27;&gt;<span class="hljs-subst">&#123;repo_name&#125;</span>&lt;/a&gt;&quot;</span><br>  <span class="hljs-comment">#将链接附加到列表repo_links 末尾。</span><br>repo_links.append(repo_link)<br> data = [&#123;<br><span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;bar&#x27;</span>, <br>   <span class="hljs-string">&#x27;x&#x27;</span>: repo_links, <br>   <span class="hljs-string">&#x27;y&#x27;</span>: stars,<br>--snip-<br> &#125;]<br></code></pre></td></tr></table></figure><p>将这个列表用作图表的x值。生成的图表与前面相同，但可单击图表底端的项目名，以访问项目在GitHub上的主页。</p><p><strong>深入了解Plotly和GitHub API</strong></p><p><a href="https://www.geeksforgeeks.org/python-plotly-tutorial/">Plotly自助文档</a></p><p><a href="https://plotly.com/python/reference/layout/">可视化所有设置</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python项目练习</title>
    <link href="/2022/09/09/Python%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/"/>
    <url>/2022/09/09/Python%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="项目一：外星人入侵"><a href="#项目一：外星人入侵" class="headerlink" title="项目一：外星人入侵"></a>项目一：外星人入侵</h3><p>本项目将使用Pygame模块，用于管理图形、动画乃至声音，让你能够更轻松地开发复杂的游戏。</p><p><strong>阶段一</strong></p><p>创建一艘飞船，可以左右移动，并且能在用户按空格键时开火。设置好这种行为后，就可以创建外星人并提高游戏的可玩性了。</p><p>先来安装Pygame，可使用pip 模块来帮助下载并安装 Python包。要安装Pygame，在终端提示符下执行如下命令：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">python3 -m pip install --user pygame<br>python3<br>import pygame<br></code></pre></td></tr></table></figure><p><strong>开始游戏项目</strong></p><p>首先创建一个空的Pygame窗口，并让这个游戏响应用户输入，设置背景色，以及加载飞船图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlienInvasion</span>:<br>  <span class="hljs-comment">#访问Pygame检测到的事件</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>      <span class="hljs-comment">#初始化游戏并创建游戏资源</span><br>        pygame.init()<br>        self.screen=pygame.display.set_mode((<span class="hljs-number">1200</span>,<span class="hljs-number">800</span>))<br>        pygame.display.set_caption(<span class="hljs-string">&quot;Alien Invasion&quot;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>      <span class="hljs-comment">#开始游戏的主循环</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>          <span class="hljs-comment">#监视键盘和鼠标事件</span><br>            <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>                <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span>==pygame.QUIT:<br>                    sys.exit()<br>            <span class="hljs-comment">#让最近绘制的屏幕可见</span><br>            pygame.display.flip()<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>  <span class="hljs-comment">#创建游戏实例并运行游戏</span><br>    ai=AlienInvasion()<br>    ai.run_game()<br></code></pre></td></tr></table></figure><p>a. 导入模块</p><p>首先，导入模块sys和pygame 。模块pygame 包含开发游戏所需的功能，模块sys中的工具用来退出游戏。</p><p>b. 初始化显示窗口</p><p><code>pygame.init()</code>初始化背景设置，<code>pygame.display.set_mode()</code>创建一个显示窗口，游戏的所有图形元素都将在其中绘制。实参(1200, 800) 是一个元组，指定了游戏窗口的尺寸——宽1200像素、高800 像素。将这个显示窗口赋给属性<code>self.screen</code> ，让这个类中的所有方法都能够使用它。</p><p>c. surface元素</p><p>在这个游戏中，每个元素（如外星人或飞船）都是一个surface。<code>display.set_mode()</code>返回的surface表示整个游戏窗口。激活游戏的动画循环后，每经过一次循环都将自动重绘这个surface。</p><p>d. 运行游戏</p><p>方法<code>run_game()</code> 有无限循环的 while 循环，循环内用来放监听事件和事件响应。</p><p>c. 响应事件</p><p><code>pygame.event.get()</code>用于访问Pygame检测到的事件，这个函数返回一个事件列表，所有键盘和鼠标事件都将导致这个for 循环运行。</p><p>d. 换帧</p><p><code>pygame.display.flip()</code> 函数命令Pygame显示最近绘制的屏幕。在这个程序里，它每次执行while 循环时都会绘制一个空屏幕，并擦去旧屏幕。我们移动游戏元素时，<code>pygame.display.flip()</code>将不断更新屏幕，以显示元素的新位置，并且在原来的位置隐藏元素，从而营造平滑移动的效果。</p><p>e. 创建实例</p><p>创建一个游戏实例并调用<code>run_game()</code> 。如果此时运行alien_invasion.py，将看到一个空的Pygame窗口。</p><p><strong>设置背景色</strong></p><p>在Pygame中，颜色是以RGB值指定的，我们自定义一个元祖赋给self.bg_color作为RGB参数。并在while循环内调用方法<code>fill()</code> 用背景色填充屏幕，方法<code>fill()</code>用于处理surface，接受一个RGB实参，在每次循环时都用该背景色重绘屏幕。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlienInvasion</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        pygame.init()<br>        self.screen=pygame.display.set_mode((<span class="hljs-number">1200</span>,<span class="hljs-number">800</span>))<br>        pygame.display.set_caption(<span class="hljs-string">&quot;Alien Invasion&quot;</span>)<br>        self.bg_color=(<span class="hljs-number">227</span>, <span class="hljs-number">234</span>, <span class="hljs-number">255</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>                <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span>==pygame.QUIT:<br>                    sys.exit()<br>            self.screen.fill((self.bg_color))<br>            pygame.display.flip()<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ai=AlienInvasion()<br>    ai.run_game()<br></code></pre></td></tr></table></figure><p><strong>创建设置类</strong></p><p>每次给游戏添加新功能时，都要引入一些新设置。下面来编写一个settings模块，用于将所有设置都存储在一个地方，以免在代码中到处添加设置。</p><p>在文件夹alien_invasion中，新建一个名为settings.py的文件，并在其中添加如下Settings 类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Settings</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.screen_width=<span class="hljs-number">1200</span><br>        self.screen_height=<span class="hljs-number">800</span><br>        self.bg_color=(<span class="hljs-number">227</span>, <span class="hljs-number">234</span>, <span class="hljs-number">255</span>)<br></code></pre></td></tr></table></figure><p>并将 alien_invasion.py修改成下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">from</span> settings <span class="hljs-keyword">import</span> Settings<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlienInvasion</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        pygame.init()<br>        self.settings=Settings()       <br>     self.screen=pygame.display.set_mode((self.settings.screen_width,<br>                                             self.settings.screen_height))<br>        pygame.display.set_caption(<span class="hljs-string">&quot;Alien Invasion&quot;</span>)<span class="hljs-comment">#设置窗口标题</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>                <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span>==pygame.QUIT:<br>                    sys.exit()<br>            self.screen.fill((self.settings.bg_color))<br>            pygame.display.flip()<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ai=AlienInvasion()<br>    ai.run_game()<br></code></pre></td></tr></table></figure><p>创建的Settings类被赋给<code>self.settings</code>，接下来就可以作为AlienInvasion示例本身的属性来调用了。</p><p><strong>添加飞船图像</strong></p><p>为了在屏幕上绘制玩家的飞船，我们将加 载一幅图像，再使用Pygame方法blit() 绘制它。在游戏中几乎可以使用任何类型的图像文件，但使用位图（.bmp） 文件最为简单，因为Pygame默认加载位图，可使用Photoshop、 GIMP和Paint等工具将其转换为位图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,ai_game</span>):<br>        self.screen=ai_game.screen<br>        self.screen_rect=ai_game.screen.get_rect()<br>        <span class="hljs-comment"># 加载飞船图像并获取其外接矩形。</span><br>        self.proto=pygame.image.load(<span class="hljs-string">&#x27;airsvg.svg&#x27;</span>)<br>        self.image=pygame.transform.scale(self.proto,(<span class="hljs-number">200</span>,<span class="hljs-number">100</span>))<br>        self.rect = self.image.get_rect()<br>        <span class="hljs-comment"># 对于每艘新飞船，都将其放在屏幕底部的中央。</span><br>        self.rect.midbottom = self.screen_rect.midbottom<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">blitme</span>(<span class="hljs-params">self</span>):<br>      <span class="hljs-comment">#在指定位置绘制飞船。</span><br>        self.screen.blit(self.image, self.rect)<br>        <span class="hljs-comment">#pygame.transform.scale(Surface, (width, height), DestSurface = None) </span><br>        <span class="hljs-comment">#转化大小</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">from</span> ship <span class="hljs-keyword">import</span> Ship<br><span class="hljs-keyword">from</span> settings <span class="hljs-keyword">import</span> Settings<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlienInvasion</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        pygame.init()<br>        self.settings=Settings()<br>        self.screen=pygame.display.set_mode(<br>          (self.settings.screen_width,<br>           self.settings.screen_height))<br>        pygame.display.set_caption(<span class="hljs-string">&quot;Alien Invasion&quot;</span>)<br>        self.ship = Ship(self)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>                <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span>==pygame.QUIT:<br>                    sys.exit()<br>            self.screen.fill((self.settings.bg_color))<br>            self.ship.blitme()<br>            pygame.display.flip()<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ai=AlienInvasion()<br>    ai.run_game()<br></code></pre></td></tr></table></figure><p>Pygame之所以高效，是因为它让你能够像处理矩形（rect 对象） 一样处理所有的游戏元素。</p><p>Ship传进去一个当前AlienInvasion 实例的引用来访问AlienInvasion中定义的所有游戏资源。<code>get_rect()</code>函数的作用是将我们的图片的位置用代码的形式告诉我们。</p><p><img src="/../img/image-20220913202941197.png" alt="image-20220913202941197"></p><p>调用<code>pygame.image.load()</code>加载图像，并将飞船图像的位置传递给它。该函数返回一个表示飞船的surface，将这个 surface赋给了self.image 。加载图像后，使用get_rect() 获取相应surface的属性rect ，以便后面能够把图片的位置和外框的底部中央对齐起来。</p><ul><li>处理rect 对象时，可通过设置它的属性值来指定矩形的位置。</li><li>让游戏元素居中，可设置相应 rect 对象的属性center 、centerx 或centery ；</li><li>让游戏元素与屏幕边缘对齐，可使用属性top 、bottom 、left 或right 。</li><li>还有一些组合属性，可同时设置两个方向，如midbottom 、midtop 、midleft 和 midright 。</li><li>要调整游戏元素的水平或垂直位置，可使用属性x和y ，分别是相应矩形左上角的坐标和坐标。</li></ul><p><strong><code>pygame.surface.blit()</code>方法</strong></p><p>假设有两个surface对象，简称为图，函数<code>B.blit(A,dest)</code>的功能就是把图A粘贴到图B上，这意味着B上的图将被A上的图覆盖，且永久不能恢复。</p><p><code>blit（）</code>的原型是<code>blit（source, dest, area=None, special_flags = 0）</code>，返回值为rect对象，返回被改变的画面区域，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">screen=pygame.display.set_mode(<span class="hljs-number">200</span>,<span class="hljs-number">200</span>)<span class="hljs-comment">#screen是Surface实例，宽高各为200</span><br>screen.blit(image,(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>))<span class="hljs-comment">#image是某图像，(10,10)是screen坐标</span><br></code></pre></td></tr></table></figure><p>先创建一个surface实例B，再把图A粘贴到图B的某一位置上。第二个参数为一个坐标标识，可以是一个（x，y）元组。也可以是一个（x，y，height，width）元组，也可以是一个Rect对象，Rect对象可以理解为有位置有大小的矩形。</p><p>pygame的坐标体系中以左上角为原点，向右向下两个方向作x轴y轴，构成坐标（x，y），注意是被画的B对象的左上角，如果这个对象是屏幕，那就是屏幕的左上角了。如果传入一个Rect对象给dest，那么blit()会使用传入Rect对象的左上角坐标，而忽略Rect的宽和高。例如：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crystal">screen = pygame.display.set_mode(<span class="hljs-number">200</span>,<span class="hljs-number">200</span>)<br>rect=image.get_rect()<br>rect.x=<span class="hljs-number">10</span><br>rect.y=<span class="hljs-number">10</span><br>screen.blit(image, rect)<span class="hljs-comment">#效果同上边代码</span><br></code></pre></td></tr></table></figure><p>blit方法的第3和第4个参数都有默认值，实际使用中可以不使用这两个参数。可选参数area是一个Rect对象，表示从source的area区域取出图像绘制到screen上。</p><p><strong>重构</strong></p><p>在大型项目中，经常需要在添加新代码前重构既有代码。重构旨在简化代码结构，把一大段代码分割成多个不同的函数，易于扩展和管理。本节将把越来越长的方法 run_game() 拆分成两个辅助方法（helper method）。辅助方法在 类中执行任务，但并非是通过实例调用的。在Python中，辅助方法的名称以单个下划线打头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">from</span> ship <span class="hljs-keyword">import</span> Ship<br><span class="hljs-keyword">from</span> settings <span class="hljs-keyword">import</span> Settings<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlienInvasion</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        pygame.init()<br>        self.settings=Settings()<br>        self.screen=pygame.display.set_mode((self.settings.screen_width,self.settings.screen_height))<br>        pygame.display.set_caption(<span class="hljs-string">&quot;Alien Invasion&quot;</span>)<br>        self.ship = Ship(self)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            self._check_events()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_events</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>            <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>                sys.exit()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_screen</span>(<span class="hljs-params">self</span>):<br>        self.screen.fill((self.settings.bg_color))<br>        self.ship.blitme()<br>        pygame.display.flip()<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ai=AlienInvasion()<br>    ai.run_game()<br></code></pre></td></tr></table></figure><p><strong>驾驶飞船</strong></p><p>下面来编写代码，在用户按左或右箭头键时做出响应。</p><p>a. 响应按键</p><p>每当用户执行动作时，都会在Pygame中注册一个事件，事件都是通过方法pygame.event.get() 获取的，因此需要在方法 _check_events() 中指定要检查哪些类型的事件。每次按键都被注册为一个KEYDOWN 事件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_events</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            sys.exit()<br>        <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span>==pygame.KEYDOWN:<br>            <span class="hljs-keyword">if</span> event.key==pygame.K_RIGHT:<br>                self.ship.rect.x+=<span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> event.key==pygame.K_LEFT:<br>                self.ship.rect.x-=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>b. 允许持续移动</p><p>玩家按住右键不放时，我们希望飞船不断向右移动，直到玩家松开为止。我们将让游戏检测<code>pygame.KEYUP</code>事件，以便知道玩家何时松开右键。然后，结合使用<code>KEYDOWN</code>和<code>KEYUP</code>事件以及一个名为<code>moving_right</code> 和<code>moving_left</code>的标志来实现持续移动。</p><p>当标志为False 时，飞船不会移动。玩家按下右键时，我们将该标志设置为True ，在玩家松开时将该标志重新设置为False 。</p><p>飞船的属性都由Ship 类控制，因此要给这个类添加一个名为<code>moving_right</code> 和<code>moving_left</code>的属性以及一个名为<code>update()</code> 的方法。方法<code>update()</code>检查标志的状态，在while 循环中调用这个方法，以调整飞船的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_events</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            sys.exit()<br>        <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span>==pygame.KEYDOWN:<br>            <span class="hljs-keyword">if</span> event.key==pygame.K_RIGHT:<br>                self.ship.moving_right=<span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span> event.key==pygame.K_LEFT:<br>                self.ship.moving_left=<span class="hljs-literal">True</span><br>        <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span>==pygame.KEYUP:<br>            self.ship.moving_left=<span class="hljs-literal">False</span><br>            self.ship.moving_right=<span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>如果在keyup时让左右键标志都置为False的话，当同时按下左右键，只要松开其中一个飞机就停止动作了，这种游戏机制太严格了，还是分别检测吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_events</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            sys.exit()<br>        <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span>==pygame.KEYDOWN:<br>            <span class="hljs-keyword">if</span> event.key==pygame.K_RIGHT:<br>                self.ship.moving_right=<span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span> event.key==pygame.K_LEFT:<br>                self.ship.moving_left=<span class="hljs-literal">True</span><br>        <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span>==pygame.KEYUP:<br>            <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>                self.ship.moving_right = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">elif</span> event.key == pygame.K_LEFT:<br>                self.ship.moving_left = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>Ship类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,ai_game</span>):<br>        self.screen=ai_game.screen<br>        self.screen_rect=ai_game.screen.get_rect()<br>        self.proto=pygame.image.load(<span class="hljs-string">&#x27;airsvg.svg&#x27;</span>)<br>        self.image=pygame.transform.scale(self.proto,(<span class="hljs-number">200</span>,<span class="hljs-number">100</span>))<br>        self.rect = self.image.get_rect()<br>        self.rect.midbottom = self.screen_rect.midbottom<br>        self.moving_right=<span class="hljs-literal">False</span><br>        self.moving_left=<span class="hljs-literal">False</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">blitme</span>(<span class="hljs-params">self</span>):<br>        self.screen.blit(self.image, self.rect)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.moving_right:<br>            self.rect.x+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> self.moving_left:<br>            self.rect.x-=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>调整飞船的速度</strong></p><p>当前，每次执行while 循环时，飞船最多移动1像素，但可 在Settings 类中添加属性ship_speed ，用于控制飞船的速度。使用函数float() 将速度的值转换为小数，才能准确进行运算 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Settings</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.screen_width=<span class="hljs-number">1200</span><br>        self.screen_height=<span class="hljs-number">800</span><br>        self.bg_color=(<span class="hljs-number">230</span>, <span class="hljs-number">230</span>, <span class="hljs-number">230</span>)<br>        self.ship_speed=<span class="hljs-number">1.5</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,ai_game</span>):<br>        self.screen=ai_game.screen<br>        self.screen_rect=ai_game.screen.get_rect()<br>        self.proto=pygame.image.load(<span class="hljs-string">&#x27;airsvg.svg&#x27;</span>)<br>        self.image=pygame.transform.scale(self.proto,(<span class="hljs-number">200</span>,<span class="hljs-number">100</span>))<br>        self.rect = self.image.get_rect()<br>        self.rect.midbottom = self.screen_rect.midbottom<br>        self.moving_right=<span class="hljs-literal">False</span><br>        self.moving_left=<span class="hljs-literal">False</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">blitme</span>(<span class="hljs-params">self</span>):<br>        self.screen.blit(self.image, self.rect)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self,speed</span>):<br>        <span class="hljs-keyword">if</span> self.moving_right:<br>            self.rect.x+=<span class="hljs-built_in">float</span>(speed)<br>        <span class="hljs-keyword">elif</span> self.moving_left:<br>            self.rect.x-=<span class="hljs-built_in">float</span>(speed)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">from</span> ship <span class="hljs-keyword">import</span> Ship<br><span class="hljs-keyword">from</span> settings <span class="hljs-keyword">import</span> Settings<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlienInvasion</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        pygame.init()<br>        self.settings=Settings()<br>        self.screen=pygame.display.set_mode((self.settings.screen_width,self.settings.screen_height))<br>        pygame.display.set_caption(<span class="hljs-string">&quot;Alien Invasion&quot;</span>)<br>        self.ship = Ship(self)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            self._check_events()<br>            self.ship.update(self.settings.ship_speed)<br>            self._update_screen()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_events</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>            <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>                sys.exit()<br>            <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span>==pygame.KEYDOWN:<br>                <span class="hljs-keyword">if</span> event.key==pygame.K_RIGHT:<br>                    self.ship.moving_right=<span class="hljs-literal">True</span><br>                <span class="hljs-keyword">elif</span> event.key==pygame.K_LEFT:<br>                    self.ship.moving_left=<span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span>==pygame.KEYUP:<br>                <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>                    self.ship.moving_right = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">elif</span> event.key == pygame.K_LEFT:<br>                    self.ship.moving_left = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_screen</span>(<span class="hljs-params">self</span>):<br>        self.screen.fill((self.settings.bg_color))<br>        self.ship.blitme()<br>        pygame.display.flip()<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ai=AlienInvasion()<br>    ai.run_game()<br></code></pre></td></tr></table></figure><p><strong>限制飞船的活动范围</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self,speed</span>):<br>    <span class="hljs-keyword">if</span> self.moving_right <span class="hljs-keyword">and</span> self.rect.right&lt;<span class="hljs-number">1200</span>:<br>        self.rect.x+=<span class="hljs-built_in">float</span>(speed)<br>    <span class="hljs-keyword">elif</span> self.moving_left <span class="hljs-keyword">and</span> self.rect.left&gt;<span class="hljs-number">0</span>:<br>        self.rect.x-=<span class="hljs-built_in">float</span>(speed)<br></code></pre></td></tr></table></figure><p>随着游戏的开发，方法_check_events() 将越来越长。因此将其部分代码放在两个方法中，其中一个处理KEYDOWN 事件，另一个处理KEYUP 事件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_events</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            sys.exit()<br>        <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span>==pygame.KEYDOWN:<br>            self._check_keydown_events(event)<br>        <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span>==pygame.KEYUP:<br>            self._check_keyup_events(event)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_keydown_events</span>(<span class="hljs-params">self, event</span>):<br>    <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>        self.ship.moving_right = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">elif</span> event.key == pygame.K_LEFT:<br>        self.ship.moving_left = <span class="hljs-literal">True</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_keyup_events</span>(<span class="hljs-params">self, event</span>):<br>    <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>        self.ship.moving_right = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">elif</span> event.key == pygame.K_LEFT:<br>        self.ship.moving_left = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><strong>全屏模式</strong></p><p>要在全屏模式下运行该游戏，可在<code>__init()__</code>中做如下修改：</p><p>创建屏幕时传入尺寸(0, 0) 以及参数<code>pygame.FULLSCREEN</code>。这让Pygame生成一个覆盖整个显示器的屏幕。由于无法预先知道屏幕的宽度和高度，要在创建屏幕后更新这些设置：使用屏幕的rect 的属性width 和height 来更新对象settings 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    pygame.init()<br>    self.settings=Settings()<br>    self.screen=pygame.display.set_mode((<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),pygame.FULLSCREEN)<br>    self.settings.screen_width=self.screen.get_rect().width<br>    self.settings.screen_height=self.screen.get_rect().height<br>    pygame.display.set_caption(<span class="hljs-string">&quot;Alien Invasion&quot;</span>)<br>    self.ship = Ship(self)<br></code></pre></td></tr></table></figure><p>注意：在全屏模式下运行这款游戏之前，请确认能够按Q键退出，因为Pygame默认不提供在全屏模式下退出游戏的方式。</p><p><strong>射击</strong></p><p>我们将编写在玩家按空格键时发射子弹的代码，子弹将在屏幕中向上飞行，抵达屏幕上边缘 后消失。</p><p>a. 添加子弹设置</p><p>首先，更新settings.py，存储新类Bullet 所需的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>--snip-<br><span class="hljs-comment"># 子弹设置 </span><br>self.bullet_speed = <span class="hljs-number">1.0</span> <br>self.bullet_width = <span class="hljs-number">3</span> <br>self.bullet_height = <span class="hljs-number">15</span> <br>self.bullet_color = (<span class="hljs-number">60</span>, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>)<br></code></pre></td></tr></table></figure><p>b. 创建Bullet 类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame <br><span class="hljs-keyword">from</span> pygame.sprite <span class="hljs-keyword">import</span> Sprite<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bullet</span>(<span class="hljs-title class_ inherited__">Sprite</span>):<br><span class="hljs-string">&quot;&quot;&quot;管理飞船所发射子弹的类&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, ai_game</span>):<br><span class="hljs-string">&quot;&quot;&quot;在飞船当前位置创建一个子弹对象。&quot;&quot;&quot;</span> <br><span class="hljs-built_in">super</span>().__init__() <br>self.screen = ai_game.screen <br>self.settings = ai_game.settings <br>self.color = self.settings.bullet_color<br><span class="hljs-comment">#在(0,0)处创建一个表示子弹的矩形，再设置正确的位置。 </span><br>self.rect = pygame.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <br>self.settings.bullet_width, <br>self.settings.bullet_height) <br>self.rect.midtop = ai_game.ship.rect.midtop<br><span class="hljs-comment"># 存储用小数表示的子弹位置。 </span><br>self.y = <span class="hljs-built_in">float</span>(self.rect.y)<br></code></pre></td></tr></table></figure><p>Bullet 类继承了Sprite 类。通过使用精灵（sprite），可将游戏中相关的元素编组，进而同时用for循环操作编组中的所有元素。<code>pygame.sprite.group</code>中的一个值得注意的method是<code>draw(surface)</code>，可以直接将group里面的每一个sprite对象在surface上通过<code>surface.blit()</code>操作进行绘制，见下例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建一个sprite类实例aliens</span><br>aliens.draw(screen)<br><span class="hljs-keyword">for</span> alien <span class="hljs-keyword">in</span> aliens.sprites():<br>    screen.blit(alien.image, alien.rect)<br></code></pre></td></tr></table></figure><p>本例中，先调用super() 来继承Sprite，再创建子弹属性的rect</p><p>因为子弹并非基于图像，所以必须使用pygame.Rect() 类从头开始创建一个矩形。创建这个类的实例 时，必须提供矩形左上角的x坐标和y坐标，以及矩形的宽度和高度。我们在(0, 0)处创建这个矩形，但下一行代码就将其移到了正确的位置，因为子弹的初始位置取决于飞船当前的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bullet</span>(<span class="hljs-title class_ inherited__">Sprite</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,ai_game</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.screen=ai_game.screen<br>        self.settings=ai_game.settings<br>        self.color = self.settings.bullet_color<br>        self.rect = pygame.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, self.settings.bullet_width, self.settings.bullet_height)<br>        self.rect.midtop = ai_game.ship.rect.midtop<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self</span>):<br>        self.rect.y-=self.settings.bullet_speed<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_bullet</span>(<span class="hljs-params">self</span>):<br>        pygame.draw.ellipse(self.screen, self.color, self.rect)<br></code></pre></td></tr></table></figure><p>c. 将子弹存储到编组中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>--snip-<br>self.ship = Ship(self)<br>self.bullets = pygame.sprite.Group()<br></code></pre></td></tr></table></figure><p>然后在while 循环中更新子弹的位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        self._check_events()<br>        self.ship.update(self.settings.ship_speed,self.settings.screen_width)<br>        self.bullets.update()<br>        self._update_screen()<br></code></pre></td></tr></table></figure><p>d. Fire</p><p>e. 删除屏幕外的子弹</p><p>使用for循环遍历Pygame编组时，Python要求该列表的长度在整个循环中保持不变。因此不能从for 循环遍历的列表或编组中删除元素，所以必须遍历编组的副本。</p><p>我们使用方法copy() 来设置for 循环，从而能够在循环中修改bullets 。</p><p>f. 限制子弹数量</p><p>将未消失的子弹数限制为三颗，在创建新子弹前检查未消失的子弹数是否小于该设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_fire_bullet</span>(<span class="hljs-params">self</span>):<br><span class="hljs-string">&quot;&quot;&quot;创建新子弹并将其加入编组bullets中。&quot;&quot;&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.bullets) &lt; self.settings.bullets_allowed:<br>new_bullet = Bullet(self) self.bullets.add(new_bullet)<br></code></pre></td></tr></table></figure><p>g. 让主循环包含尽可能少的代码</p><p>把run_game() 中while 循环里带模块的代码都写到单独的函数里</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">from</span> ship <span class="hljs-keyword">import</span> Ship<br><span class="hljs-keyword">from</span> settings <span class="hljs-keyword">import</span> Settings<br><span class="hljs-keyword">from</span> settings <span class="hljs-keyword">import</span> Bullet<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlienInvasion</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        pygame.init()<br>        self.settings=Settings()<br>        <span class="hljs-comment">#self.screen=pygame.display.set_mode((self.settings.screen_width,self.settings.screen_height))</span><br>        self.screen=pygame.display.set_mode((<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),pygame.FULLSCREEN)<br>        self.settings.screen_width=self.screen.get_rect().width<br>        self.settings.screen_height=self.screen.get_rect().height<br>        pygame.display.set_caption(<span class="hljs-string">&quot;Alien Invasion&quot;</span>)<br>        self.ship = Ship(self)<br>        self.bullets=pygame.sprite.Group()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            self._check_events()<br>            self.ship.update(self.settings.ship_speed,self.settings.screen_width)<br>            self.bullets.update()<br>            self._update_bullets()<br>            self._update_screen()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_events</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>            <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>                sys.exit()<br>            <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span>==pygame.KEYDOWN:<br>                self._check_keydown_events(event)<br>            <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span>==pygame.KEYUP:<br>                self._check_keyup_events(event)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_keydown_events</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>            self.ship.moving_right = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">elif</span> event.key == pygame.K_LEFT:<br>            self.ship.moving_left = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">elif</span> event.key==pygame.K_q:<br>            sys.exit()<br>        <span class="hljs-keyword">elif</span> event.key==pygame.K_SPACE:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.bullets)&lt;self.settings.bullets_allowed:<br>                self._fire_bullet()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_keyup_events</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>            self.ship.moving_right = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">elif</span> event.key == pygame.K_LEFT:<br>            self.ship.moving_left = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_fire_bullet</span>(<span class="hljs-params">self</span>):<br>        new_bullet=Bullet(self)<br>        self.bullets.add((new_bullet))<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_screen</span>(<span class="hljs-params">self</span>):<br>        self.screen.fill((self.settings.bg_color))<br>        self.ship.blitme()<br>        <span class="hljs-keyword">for</span> bullet <span class="hljs-keyword">in</span> self.bullets.sprites():<br>            bullet.draw_bullet()<br>        pygame.display.flip()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_bullets</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> bullet <span class="hljs-keyword">in</span> self.bullets.copy():<br>            <span class="hljs-keyword">if</span> bullet.rect.bottom &lt; <span class="hljs-number">0</span>:<br>                self.bullets.remove(bullet)<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ai=AlienInvasion()<br>    ai.run_game()<br></code></pre></td></tr></table></figure><h3 id="项目二：外星人生成"><a href="#项目二：外星人生成" class="headerlink" title="项目二：外星人生成"></a>项目二：外星人生成</h3><p>目标：</p><ol><li>首先在屏幕上边缘附近添加一个外星人，再生成一群外星人。</li><li>让这群外星人向两边和下面移动，并删除被子弹击中的外星人。</li><li>显示玩家拥有的飞船数量，并在玩家的飞船用完后结束游戏。</li></ol><p><strong>创建Alien类</strong></p><p>将每个外星人的左边距都设置为外星 人的宽度，并将上边距设置为外星人的高度。我们主要关心的是外星人的水平速度，因此精确地记录了每个外星人的水平位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Alien</span>(<span class="hljs-title class_ inherited__">Sprite</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,ai_game</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.screen=ai_game.screen<br>        self.image=pygame.image.load(<span class="hljs-string">&#x27;images/alien.bmp&#x27;</span>)<br>        pygame.transform.scale(self.image,(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>))<br>        <span class="hljs-comment"># 每个外星人最初都在屏幕左上角附近。</span><br>        self.rect=self.image.get_rect()<br>        self.rect.x=self.rect.width<br>        self.rect.y=self.rect.height<br>        <span class="hljs-comment"># 存储外星人的精确水平位置。</span><br>        self.x=<span class="hljs-built_in">float</span>(self.rect.x)<br></code></pre></td></tr></table></figure><p><strong>创建Alien实例</strong></p><p>我们最终会创建一群外星人，涉及的工作量不少，因此要新建一个名为_create_fleet() 的辅助方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>--snip-<br>self.ship = Ship(self) <br>self.bullets = pygame.sprite.Group() <br>self.aliens = pygame.sprite.Group()<br>self._create_fleet()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_create_fleet</span>(<span class="hljs-params">self</span>):<br><span class="hljs-string">&quot;&quot;&quot;创建外星人群。&quot;&quot;&quot;</span> <br><span class="hljs-comment"># 创建一个外星人。 </span><br>alien = Alien(self) <br>self.aliens.add(alien)<br></code></pre></td></tr></table></figure><p>要让外星人现身，需要在_update_screen() 中对外星人编组调用方法draw() ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.aliens.draw(self.screen)<br></code></pre></td></tr></table></figure><p>对编组调用<code>draw()</code>时，Pygame将把编组中的每个元素绘制到属性rect 指定的位置。方法draw() 接受一个参数，这个参数指定了 要将编组中的元素绘制到哪个surface上。</p><p><strong>创建一群外星人</strong></p><p>计算可用于放置外星人的水平空间，还需要在外星人之间留出一定的空间，定为外星人的宽度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">available_space_x = settings.screen_width – (<span class="hljs-number">2</span> * alien_width)<br>number_aliens_x = available_space_x // (<span class="hljs-number">2</span> * alien_width)<br></code></pre></td></tr></table></figure><p>Work：找一幅星星图像，并在屏幕上显示一系列随机排列的星星。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> pygame.sprite <span class="hljs-keyword">import</span> Sprite<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Star</span>(<span class="hljs-title class_ inherited__">Sprite</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,ai_game</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.screen=ai_game.screen<br>        self.proto=pygame.image.load(<span class="hljs-string">&#x27;star.svg&#x27;</span>)<br>        self.image=pygame.transform.scale(self.proto,(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>))<br>        self.rect=self.image.get_rect()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sky</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        pygame.init()<br>        self.screen = pygame.display.set_mode((<span class="hljs-number">1200</span>,<span class="hljs-number">800</span>))<br>        pygame.display.set_caption(<span class="hljs-string">&quot;Stars&quot;</span>)<br>        self.bg_color=(<span class="hljs-number">255</span>, <span class="hljs-number">127</span>, <span class="hljs-number">80</span>)<br>        self.stars=pygame.sprite.Group()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            self.update_screen()<br>            self.check()<br>            self.create()<br>        pygame.display.flip()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_screen</span>(<span class="hljs-params">self</span>):<br>        self.screen.fill(self.bg_color)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>            <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span>==pygame.QUIT:<br>                sys.exit()<br>            <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span>==pygame.KEYDOWN:<br>                <span class="hljs-keyword">if</span> event.key==pygame.K_q:<br>                    sys.exit()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">self</span>):<br>        num_x=random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">20</span>)<br>        num_y=random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)<br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_y):<br>            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_x):<br>                new_star=Star(self)<br>                self.stars.add(new_star)<br>                new_star.rect.x=<span class="hljs-number">100</span>+<span class="hljs-number">50</span>*num_x<br>                new_star.rect.y=<span class="hljs-number">100</span>+<span class="hljs-number">50</span>*num_y<br>        self.stars.draw(self.screen)<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    sky=Sky()<br>    sky.run_game()<br></code></pre></td></tr></table></figure><p>要实现设置fleet_direction ，可将其设置为文本值，如’left’ 或’right’ ，但这样就必须编写if-elif 语句来检查外星人群的移 动方向。鉴于只有两个可能的方向，我们使用值1和-1来表示，并 在外星人群改变方向时在这两个值之间切换。</p><p><strong>检查外星人是否撞到了屏幕边缘</strong></p><p>如果外星人的rect 的属性right 大于或等于屏幕的rect 的right 属性，就说明外星人位于屏幕右边缘；如果外星人的rect 的left 属性小于或等于0，就说明外星人位于屏幕左边缘</p><p><strong>检测子弹与外星人的碰撞</strong></p><p>函数sprite.groupcollide() 将一个编组中每个元素的rect 同另一个编组中每个元素的rect 进行比较。在这里，是将每颗子弹 的rect 同每个外星人的rect 进行比较，并返回一个字典，其中包含发生了碰撞的子弹和外星人。在这个字典中，每个键都是一颗子 弹，而关联的值是被该子弹击中的外星人。</p><p>第一个参数为键，第二个参数为值，第三个参数为碰撞后值是否消失，第三个参数为碰撞后键是否消失。</p><p><strong>生成新的外星人群</strong></p><p>要在一群外星人被消灭后再显示一群外星人，先检查编组 aliens 是否为空。如果编组aliens 为空， 就使用方法empty() 删除bullets编组中余下的所有精灵，并新建一群外星人</p><p><strong>结束游戏</strong></p><p>检查外星人和飞船之间的碰撞，函数spritecollideany() 接受两个实参：一个精灵和一个编组。 它检查编组是否有成员与精灵发生了碰撞，并在找到与精灵发生碰撞的成员后停止遍历编组。在这里，它遍历编组aliens ，并返回找到的第一个与飞船发生碰撞的外星人。</p><p><u>不想看了，真的会有人用python做游戏吗</u></p><h4 id="项目二-数据可视化"><a href="#项目二-数据可视化" class="headerlink" title="项目二 数据可视化"></a>项目二 数据可视化</h4><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>Matplotlib是一个数学绘图库，是一款优秀的可视化和分析工具，本章将使用Plotly包，它生成的图表非常适合在数字设备上显示。Plotly生成的图表可根据显示设备的尺寸自动调整大小，还具备众多交互特性，如在用户将鼠标指向图表的不同部分时突出数据集的特定方面。本章将使用Plotly来分析掷骰子的结果。</p><div class="table-container"><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>Bar</td><td>绘制条形图</td></tr><tr><td>Barh</td><td>绘制水平条形图</td></tr><tr><td>Boxplot</td><td>绘制箱型图</td></tr><tr><td>Hist</td><td>绘制直方图</td></tr><tr><td>his2d</td><td>绘制2D直方图</td></tr><tr><td>Pie</td><td>绘制饼状图</td></tr><tr><td>Plot</td><td>在坐标轴上画线或者标记</td></tr><tr><td>Polar</td><td>绘制极坐标图</td></tr><tr><td>Scatter</td><td>绘制x与y的散点图</td></tr><tr><td>Stackplot</td><td>绘制堆叠图</td></tr><tr><td>Stem</td><td>用来绘制二维离散数据绘制（又称为“火柴图”）</td></tr><tr><td>Step</td><td>绘制阶梯图</td></tr><tr><td>Quiver</td><td>绘制一个二维按箭头</td></tr><tr><td>Imread</td><td>从文件中读取图像的数据并形成数组。</td></tr><tr><td>Imsave</td><td>将数组另存为图像文件。</td></tr><tr><td>Imshow</td><td>在数轴区域内显示图像。</td></tr><tr><td>Axes</td><td>在画布(Figure)中添加轴</td></tr><tr><td>Text</td><td>向轴添加文本</td></tr><tr><td>Title</td><td>设置当前轴的标题</td></tr><tr><td>Xlabel</td><td>设置x轴标签</td></tr><tr><td>Xlim</td><td>获取或者设置x轴区间大小</td></tr><tr><td>Xscale</td><td>设置x轴缩放比例</td></tr><tr><td>Xticks</td><td>获取或设置x轴刻标和相应标签</td></tr><tr><td>Ylabel</td><td>设置y轴的标签</td></tr><tr><td>Ylim</td><td>获取或设置y轴的区间大小</td></tr><tr><td>Yscale</td><td>设置y轴的缩放比例</td></tr><tr><td>Yticks</td><td>获取或设置y轴的刻标和相应标签</td></tr><tr><td>Figtext</td><td>在画布上添加文本</td></tr><tr><td>Figure</td><td>创建一个新画布</td></tr><tr><td>Show</td><td>显示数字</td></tr><tr><td>Savefig</td><td>保存当前画布</td></tr><tr><td>Close</td><td>关闭画布窗口</td></tr></tbody></table></div><p><strong>绘制简单的折线图</strong></p><p>使用平方数序列1、4、 9、16和25来绘制这个图表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>squares=[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">25</span>]<br>fig,ax=plt.subplots()<br>ax.plot(squares)<br>plt.show()<br></code></pre></td></tr></table></figure><p>创建一个名为squares 的列表，存储要用来制作图表的数据。</p><p>调用函数<code>subplots()</code>， 创建一个包含子图区域的画布fig，并创建一个 figure 图形对象ax。</p><p><code>subplots()</code> 的函数格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fig , ax = plt.subplots(nrows, ncols)<br></code></pre></td></tr></table></figure><p>nrows 与 ncols 表示两个整数参数，它们指定子图所占的行数、列数。</p><p>函数的返回值是一个元组，包括一个图形对象和所有的 axes 对象。其中 axes 对象的数量等于 nrows * ncols，且每个 axes 对象均可通过索引值访问（从1开始），坐标原点位于左上角。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>fig,a =  plt.subplots(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x = np.arange(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)<br><span class="hljs-comment">#绘制平方函数</span><br>a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].plot(x,x*x)<br>a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].set_title(<span class="hljs-string">&#x27;square&#x27;</span>)<br><span class="hljs-comment">#绘制平方根图像</span><br>a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>].plot(x,np.sqrt(x))<br>a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>].set_title(<span class="hljs-string">&#x27;square root&#x27;</span>)<br><span class="hljs-comment">#绘制指数函数</span><br>a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>].plot(x,np.exp(x))<br>a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>].set_title(<span class="hljs-string">&#x27;exp&#x27;</span>)<br><span class="hljs-comment">#绘制对数函数</span><br>a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>].plot(x,np.log10(x))<br>a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>].set_title(<span class="hljs-string">&#x27;log&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../img/image-20220917121348668.png" alt="image-20220917121348668"></p><p>方法<code>plot()</code>，它尝试根据给定的数据以有意义的方式绘制图表。函数<code>plt.show()</code>打开Matplotlib查看器并显示绘制的图表。在查看器中，可以缩放和导航图形，还可单击磁盘图标将图表保存起来。</p><p><strong>修改标签文字和线条粗细</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib<br>matplotlib.rc(<span class="hljs-string">&quot;font&quot;</span>,family=<span class="hljs-string">&#x27;Adobe Heiti Std&#x27;</span>)<br>squares=[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">25</span>]<br>fig,ax=plt.subplots()<br>ax.plot(squares,linewidth=<span class="hljs-number">3</span>)<br>ax.set_title(<span class="hljs-string">&#x27;sqrt&#x27;</span>,fontsize=<span class="hljs-number">24</span>)<br>ax.set_xlabel(<span class="hljs-string">&#x27;value&#x27;</span>,fontsize=<span class="hljs-number">14</span>)<br>ax.set_ylabel(<span class="hljs-string">&#x27;value.sqrt&#x27;</span>,fontsize=<span class="hljs-number">14</span>)<br>ax.tick_params(axis=<span class="hljs-string">&#x27;both&#x27;</span>,labelsize=<span class="hljs-number">14</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>⌃+左键可以查看源代码，<code>set_title()</code>给图表指定标题，方法<code>set_xlabel()</code>和<code>set_ylabel()</code>让你能够为每条轴设置标题，方法<code>tick_params()</code>设置刻度的样式，指定的实参将影响x轴和y轴上的刻度（<code>axes=&#39;both&#39;</code>为x和y轴都有刻度）。</p><p><strong>校正图形</strong></p><p>图形更容易看清后，我们发现没有正确地绘制数据：折线图的终点指出4.0的平方为25！下面来修复这个问题。向plot() 提供一系列数时，它假设第一个数据点对应的 坐标值 为0，但这里第一个点对应的值为1。为改变这种默认行为，可向plot() 同时提供输入值和输出值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>input_values=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>squares=[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">25</span>]<br>fig,ax=plt.subplots()<br>ax.plot(input_values,squares,linewidth=<span class="hljs-number">3</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>现在plot() 将正确地绘制数据，因为同时提供了输入值和输出值，plot() 无须对输出值的生成方式做出假设，直接一一对应即可。</p><p><strong>使用内置样式</strong></p><p>打印全部内置样式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> style<br><span class="hljs-built_in">print</span>(plt.style.available)<br></code></pre></td></tr></table></figure><p>‘bmh’, ‘classic’, ‘dark_background’, ‘fast’, ‘fivethirtyeight’, ‘ggplot’, ‘grayscale’, ‘seaborn-bright’, ‘seaborn-muted’, ‘seaborn-notebook’, ‘seaborn-paper’, ‘seaborn-pastel’, ‘seaborn-poster’, ‘seaborn-talk’, ‘seaborn-ticks’, ‘seaborn-white’, ‘seaborn-whitegrid’, ‘seaborn’, ‘Solarize_Light2’, ‘tableau-colorblind10’, ‘_classic_test’</p><p>使用方法：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">plt.style.use(<span class="hljs-string">&#x27;seaborn&#x27;</span>)<br></code></pre></td></tr></table></figure><p>背景有格线可以用：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">plt.grid(True, linestyle=<span class="hljs-string">&#x27;-.&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/../img/image-20220917140815396.png" alt="image-20220917140815396" style="zoom:50%;"></p><p><strong>使用scatter() 绘制散点图并设置样式</strong></p><p>绘制散点图，你可能想以一种颜色显示较小的值，用另一种颜色显示较大的值。绘制大型数据集时，还可对每个点都设置同样的样式，再使用不同的样式选项重新绘制某些点以示突出。</p><p>要绘制单个点，可使用方法scatter() 。向它传递一对<code>(x,y)</code>坐标，它将在指定位置绘制一个点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.style.use(<span class="hljs-string">&#x27;seaborn&#x27;</span>) <br>fig, ax = plt.subplots() <br>ax.scatter(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment"># 设置x和y轴刻度标记的大小，并且刻度聚焦在点的附近，并设置刻度字体的大小</span><br>ax.tick_params(axis=<span class="hljs-string">&#x27;both&#x27;</span>, which=<span class="hljs-string">&#x27;major&#x27;</span>, labelsize=<span class="hljs-number">14</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><strong>使用scatter() 绘制一系列点</strong></p><p>要绘制一系列的点，可向<code>scatter()</code>传递两个分别包含x值和y值的列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>vxs=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>vys=[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">16</span>,<span class="hljs-number">25</span>]<br>plt.style.use(<span class="hljs-string">&#x27;seaborn&#x27;</span>)<br>fig, ax = plt.subplots()<br><span class="hljs-comment">#s=100设置点的大小</span><br>ax.scatter(vxs,vys,s=<span class="hljs-number">100</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><strong>自动计算数据</strong></p><p>手工计算列表效率低下，我们可以用Python循环来完成。</p><p>下面是绘制1000个点的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>vxs=<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1001</span>)<br>vys=[x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> vxs]<br>plt.style.use(<span class="hljs-string">&#x27;seaborn&#x27;</span>)<br>fig, ax = plt.subplots()<br>ax.scatter(vxs,vys,s=<span class="hljs-number">10</span>)<br><span class="hljs-comment">#axis()设置坐标范围</span><br>ax.axis([<span class="hljs-number">0</span>,<span class="hljs-number">1100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1100000</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p>方法axis() 指定了每个坐标轴的取值范围，含4个参数：x和y轴的最小值和最大值。这里将x坐标轴的取值范围设置为0～1100，并将y坐标轴的取值范围设置为 0～1 100 000。</p><p><strong>自定义颜色</strong></p><p>要修改数据点的颜色，可向<code>scatter()</code> 传递参数c</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ax.scatter(vxs,vys,c=<span class="hljs-string">&#x27;yellow&#x27;</span>,s=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>要指定自定义颜色，可传递参 数c ，并将其设置为一个元组，其中包含三个0～1的小数值，分别 表示红色、绿色和蓝色的分量。值越接近0，指定的颜色越深；值越接近1，指定的颜色越浅。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ax.scatter(vxs,vys,c=(<span class="hljs-number">0</span>,<span class="hljs-number">0.58</span>,<span class="hljs-number">0.49</span>),s=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p><strong>使用颜色渐变</strong></p><p>用于突出数据的规律。例如，可以用较浅的颜色来显示较小的值，并使用较深的颜色来显示较大的值。以下代码将值较小的点显示为浅蓝色，并将值较大的点显示为深蓝色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>vxs=<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1001</span>)<br>vys=[x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> vxs]<br>plt.style.use(<span class="hljs-string">&#x27;seaborn&#x27;</span>)<br>fig, ax = plt.subplots()<br><span class="hljs-comment">#将参数c设置成一个值列表，并使用参数cmap 告诉 pyplot 使用哪个颜色映射</span><br>ax.scatter(vxs,vys,c=vys,cmap=plt.cm.Blues,s=<span class="hljs-number">10</span>)<br>ax.axis([<span class="hljs-number">0</span>,<span class="hljs-number">1100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1100000</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/../img/image-20220917160441549.png" alt="image-20220917160441549" style="zoom:50%;"></p><p>注意：要了解pyplot 中所有的颜色映射，请访问Matplotlib网站主页，单击Examples，向下滚动到Color，再单击Colormaps reference。</p><p><strong>自动保存图表</strong></p><p>要让程序自动将图表保存到文件中，可将调用<code>plt.show()</code> 替换为调用<code>plt.savefig()</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.savefig(<span class="hljs-string">&#x27;squares_plot.png&#x27;</span>, bbox_inches=<span class="hljs-string">&#x27;tight&#x27;</span>)<br></code></pre></td></tr></table></figure><p>第一个实参指定要以什么文件名保存图表，这个文件将存储到当前程序目录下。</p><p>第二个实参指定将图表多余的空白区域裁剪掉。如果要保留图表周围多余的空白区域，只需省略这个实参即可。</p><h4 id="随机漫步"><a href="#随机漫步" class="headerlink" title="随机漫步"></a>随机漫步</h4><p>每次行走都是完全随机的、没有明确的方向，结果是由一系列随机决策决定的。</p><p><strong>创建RandomWalk 类</strong></p><p>这个类需要三个属性：一个是存储漫步次数的变量，其他两个是列表，分别存储漫步经过的每个点的 x坐标和y坐标，让每次漫步都从点(0, 0)出发。</p><p>RandomWalk 类只包含两个方法：方法<code>__init___()</code>和 <code>fill_walk()</code>，后者计算随机漫步经过的所有点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomWalk</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,num_points=<span class="hljs-number">5000</span></span>):<br>        self.num_points=num_points<br>        self.x_values=[<span class="hljs-number">0</span>]<br>        self.y_values=[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fill_walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(self.x_values)&lt;self.num_points:<br>            <span class="hljs-comment">#随机返回1或-1,决定上下左右</span><br>            x_dir=choice([<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>])<br>            x_dis=choice([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>            x_step=x_dis*x_dir<br>            y_dir = choice([<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>])<br>            y_dis = choice([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br>            y_step = y_dis * y_dir<br>            <span class="hljs-comment">#拒绝原地踏步</span><br>            <span class="hljs-keyword">if</span> x_step==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> y_step == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-comment"># 计算下一个点的x值和y值，从最后一个点的坐标加上这一步走的距离中决定</span><br>            x = self.x_values[-<span class="hljs-number">1</span>] + x_step<br>            y = self.y_values[-<span class="hljs-number">1</span>] + y_step<br>            self.x_values.append(x)<br>            self.y_values.append(y)<br><br></code></pre></td></tr></table></figure><p><strong>绘制随机漫步图</strong></p><p>rw_visual.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> random_walk <span class="hljs-keyword">import</span> RandomWalk<br>rw=RandomWalk(<span class="hljs-number">100</span>)<br>rw.fill_walk()<br>plt.style.use(<span class="hljs-string">&#x27;classic&#x27;</span>)<br>fig,ax=plt.subplots()<br>ax.scatter(rw.x_values,rw.y_values,c=(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),s=<span class="hljs-number">5</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><strong>模拟多次随机漫步</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> random_walk <span class="hljs-keyword">import</span> RandomWalk<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    rw=RandomWalk(<span class="hljs-number">1000</span>)<br>    rw.fill_walk()<br>    plt.style.use(<span class="hljs-string">&#x27;classic&#x27;</span>)<br>    fig,ax=plt.subplots() <br>    ax.scatter(rw.x_values,rw.y_values,c=(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),s=<span class="hljs-number">5</span>)<br>    plt.show()<br>    keep_running = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Make another walk? (y/n): &quot;</span>)<br>    <span class="hljs-keyword">if</span> keep_running == <span class="hljs-string">&#x27;n&#x27;</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p><strong>设置随机漫步图的样式</strong></p><p>本节将定制图表，以突出每次漫步的重要特征。为此，我们确定要突出的元素，如漫步的起点、 终点和经过的路径。</p><p>a. 给点着色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> random_walk <span class="hljs-keyword">import</span> RandomWalk<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    rw=RandomWalk()<br>    rw.fill_walk()<br>    plt.style.use(<span class="hljs-string">&#x27;classic&#x27;</span>)<br>    fig,ax=plt.subplots()<br>    point_num=<span class="hljs-built_in">range</span>(rw.num_points)<br>    ax.scatter(rw.x_values,rw.y_values,<br>               c=point_num,cmap=plt.cm.Blues,<br>               edgecolors=<span class="hljs-string">&#x27;none&#x27;</span>, s=<span class="hljs-number">15</span>)<br>    plt.show()<br>    keep_running = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Make another walk? (y/n): &quot;</span>)<br>    <span class="hljs-keyword">if</span> keep_running == <span class="hljs-string">&#x27;n&#x27;</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>使用range() 生成了一个数字列表，其中包含的数与漫步包含的点数量相同。将参数c设置为point_numbers ，指定使用颜色映射Blues ，并传递实参edgecolors=’none’ 以删除每个点的轮廓。最终的随机漫步图从浅蓝色渐变为深蓝色。</p><p>至于为什么不直接用rw.y_values给c，因为他在一直append，直接赋不太好。</p><p><img src="/../img/image-20220917164443554.png" alt="image-20220917164443554" style="zoom:50%;"></p><p>b. 重新绘制起点和终点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">ax.scatter(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, c=<span class="hljs-string">&#x27;green&#x27;</span>, edgecolors=<span class="hljs-string">&#x27;none&#x27;</span>, s=<span class="hljs-number">100</span>)<br>   <br>ax.scatter(rw.x_values[-<span class="hljs-number">1</span>], rw.y_values[-<span class="hljs-number">1</span>],<br>           c=<span class="hljs-string">&#x27;red&#x27;</span>, edgecolors=<span class="hljs-string">&#x27;none&#x27;</span>,s=<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>c. 隐藏坐标轴</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ax.get_xaxis().set_visible(<span class="hljs-literal">False</span>) <br>ax.get_yaxis().set_visible(<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>d. 调整尺寸以适合屏幕</p><p>创建图表时，可传递参数figsize 以指定生成的图形的尺寸。 需要给参数figsize 指定一个元组，向Matplotlib指出绘图窗口的尺寸，单位为英寸，如果知道当前系统 的分辨率，可通过参数dpi 向plt.subplots() 传递该分辨 率，以有效利用可用的屏幕空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fig, ax = plt.subplots(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">9</span>), dpi=<span class="hljs-number">128</span>)<br></code></pre></td></tr></table></figure><h4 id="使用Plotly模拟掷骰子"><a href="#使用Plotly模拟掷骰子" class="headerlink" title="使用Plotly模拟掷骰子"></a>使用Plotly模拟掷骰子</h4><p>Plotly生成的图表还是交互式的：用户将鼠标指向特定元素时，将突出显示有关该元素的信息。</p><p><strong>创建Die 类</strong></p><p>创建一个n面骰子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Die</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,num_sides=<span class="hljs-number">6</span></span>):<br>        self.num_sides=num_sides<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">roll</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> randint(<span class="hljs-number">1</span>,self.num_sides)<br></code></pre></td></tr></table></figure><p><strong>掷骰子</strong></p><p>计算每个点数出现的次数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> die <span class="hljs-keyword">import</span> Die<br>die=Die()<br>results=[]<br><span class="hljs-keyword">for</span> rn <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    result=die.roll()<br>    results.append(result)<br>freq=[]<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,die.num_sides+<span class="hljs-number">1</span>):<br>    fre=results.count(value)<br>    freq.append(fre)<br><span class="hljs-built_in">print</span>(freq)<br></code></pre></td></tr></table></figure><p><strong>绘制直方图</strong></p><p>绘制一个条形图，指出各种结果出现的频率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> die <span class="hljs-keyword">import</span> Die<br><span class="hljs-keyword">from</span> plotly.graph_objs <span class="hljs-keyword">import</span> Bar, Layout<br><span class="hljs-keyword">from</span> plotly <span class="hljs-keyword">import</span> offline<br>die=Die()<br>results=[]<br><span class="hljs-keyword">for</span> rn <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    result=die.roll()<br>    results.append(result)<br>freq=[]<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,die.num_sides+<span class="hljs-number">1</span>):<br>    fre=results.count(value)<br>    freq.append(fre)<br><span class="hljs-comment">#Plotly不能直接接受函数range() 的结果，因此需要使用函数list() 将其转换为列表。</span><br>x_values = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, die.num_sides+<span class="hljs-number">1</span>))<br><span class="hljs-comment">#Plotly类Bar() 表示用于绘制条形图的数据集,需要一个存储x值的列表和一个存储y值的列表。</span><br>data = [Bar(x=x_values, y=freq)]<br><span class="hljs-comment">#每个坐标轴都能以不同的方式进行配置,而每个配置选项都是一个字典元素,这里只设置了坐标轴标签</span><br>x_axis_config = &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;结果&#x27;</span>&#125;<br>y_axis_config = &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;结果的频率&#x27;</span>&#125;<br><span class="hljs-comment">#类Layout() 返回一个指定图表布局和配置的对象</span><br>my_layout = Layout(title=<span class="hljs-string">&#x27;掷一个D6 1000次的结果&#x27;</span>, xaxis=x_axis_config, yaxis=y_axis_config)<br><span class="hljs-comment">#为生成图表，我们调用了函数offline.plot()</span><br><span class="hljs-comment">#这个函数需要一个包含数据和布局对象的字典，还接受一个文件名</span><br>offline.plot(&#123;<span class="hljs-string">&#x27;data&#x27;</span>: data, <span class="hljs-string">&#x27;layout&#x27;</span>: my_layout&#125;, filename=<span class="hljs-string">&#x27;d6.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p>注意：Plotly让这个图表具有交互性，将鼠标指向其中的任意条形，就能看到与之相关联的数据。另外，注意到右上角有一些图标，让你能够平移和缩放图表以及将其保存为图像。</p><p><strong>同时掷两个骰子</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> die <span class="hljs-keyword">import</span> Die<br><span class="hljs-keyword">from</span> plotly.graph_objs <span class="hljs-keyword">import</span> Bar, Layout<br><span class="hljs-keyword">from</span> plotly <span class="hljs-keyword">import</span> offline<br>die1=Die()<br>die2=Die()<br>results=[]<br><span class="hljs-keyword">for</span> rn <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    result1=die1.roll()<br>    result2=die2.roll()<br>    results.append(result1+result2)<br>freq=[]<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,(die1.num_sides+<span class="hljs-number">1</span>)*<span class="hljs-number">2</span>):<br>    fre=results.count(value)<br>    freq.append(fre)<br>x_values = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, (die1.num_sides+<span class="hljs-number">1</span>)*<span class="hljs-number">2</span>))<br>data = [Bar(x=x_values, y=freq)]<br>x_axis_config = &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;结果&#x27;</span>,<span class="hljs-string">&#x27;dtick&#x27;</span>: <span class="hljs-number">1</span>&#125;<br>y_axis_config = &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;结果的频率&#x27;</span>&#125;<br>my_layout = Layout(title=<span class="hljs-string">&#x27;掷一个D6 1000次的结果&#x27;</span>, xaxis=x_axis_config, yaxis=y_axis_config)<br>offline.plot(&#123;<span class="hljs-string">&#x27;data&#x27;</span>: data, <span class="hljs-string">&#x27;layout&#x27;</span>: my_layout&#125;, filename=<span class="hljs-string">&#x27;d6.html&#x27;</span>)<br></code></pre></td></tr></table></figure><p>创建图表时，在字典x_axis_config 中使设置’dtick’: 1，让Plotly显示每个刻度值。</p><p><strong>同时掷两个面数不同的骰子</strong></p><p>下面来创建一个6面骰子和一个10面骰子，看看同时掷这两个骰子 50 000次的结果如何：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> die <span class="hljs-keyword">import</span> Die<br><span class="hljs-keyword">from</span> plotly.graph_objs <span class="hljs-keyword">import</span> Bar, Layout<br><span class="hljs-keyword">from</span> plotly <span class="hljs-keyword">import</span> offline<br>die1=Die(<span class="hljs-number">6</span>)<br>die2=Die(<span class="hljs-number">10</span>)<br>results=[]<br><span class="hljs-keyword">for</span> rn <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50_000</span>):<br>    result=die1.roll()+die2.roll()<br>    results.append(result)<br>freq=[]<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,die1.num_sides+die2.num_sides+<span class="hljs-number">1</span>):<br>    fre=results.count(value)<br>    freq.append(fre)<br>x_values = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, die1.num_sides+die2.num_sides+<span class="hljs-number">1</span>))<br>data = [Bar(x=x_values, y=freq)]<br>x_axis_config = &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;结果&#x27;</span>,<span class="hljs-string">&#x27;dtick&#x27;</span>: <span class="hljs-number">1</span>&#125;<br>y_axis_config = &#123;<span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;结果的频率&#x27;</span>&#125;<br>my_layout = Layout(title=<span class="hljs-string">&#x27;掷一个D6 1000次的结果&#x27;</span>, xaxis=x_axis_config, yaxis=y_axis_config)<br>offline.plot(&#123;<span class="hljs-string">&#x27;data&#x27;</span>: data, <span class="hljs-string">&#x27;layout&#x27;</span>: my_layout&#125;, filename=<span class="hljs-string">&#x27;d6.html&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Day03</title>
    <link href="/2022/09/08/Python-Day03/"/>
    <url>/2022/09/08/Python-Day03/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h3><p><strong>创建和使用类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name,age</span>):<br>self.name=name<br>self.age=age<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sit</span>(<span class="hljs-params">self</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> is now sitting.&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">roll</span>(<span class="hljs-params">self</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> rolled over.&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>方法<code>_init_()_</code></strong></p><p>类中的函数称为方法 。</p><p><code>_init_()</code>是一个特殊方法，每当你根据Dog 类创建新实例时，Python都会自动运行它。在这个方法的名称中，开头和末尾各有两个下划线，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突。</p><p>该方法中的三个形参：self 、name 和 age 。其中形参self 是一个指向实例本身的引用，必须位于其他形参的前面。以self 为前缀的变量可供类中的所有方法使用，可以通过类的任何实例来访问，像这样可通过实例访问的变量称为属性 。</p><blockquote><p>因为 Python调用这个方法来创建Dog 实例时，将自动传入实参self ，所以必须位于所有参数的前面。</p><p>而self 会自动传递，因此可以缺省。每当根据Dog 类创建实例时，都只需给最后别的形参提供值。</p></blockquote><p><strong>普通方法</strong></p><p>本例中<code>sit()</code>和<code>roll()</code>方法执行时不需要额外的信息，因此只有一个形参self 。</p><p><strong>根据类创建实例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">doggie=Dog(<span class="hljs-string">&#x27;Leo&#x27;</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;dog name:<span class="hljs-subst">&#123;doggie.name&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;dog age:<span class="hljs-subst">&#123;doggie.age&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>通常将类的首字母大写，创建的实例首字母小写</p><p>a. 访问属性</p><p>要访问实例的属性，可使用句点表示法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">doggie.name<br></code></pre></td></tr></table></figure><p>b. 调用方法</p><p>使用句点表示法来调用Dog 类中定义的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">doggie.sit()<br>doggie.roll()<br></code></pre></td></tr></table></figure><p><strong>给属性指定默认值</strong></p><p>在初始化函数中添加一个名为odometer_reading 的属性，其初始值总是为 0。并添加一个名为read_odometer() 的方法，用于读取汽车的里程表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make,model,year</span>):<br>self.make=make<br>self.model=model<br>self.year=year<br>self.odometer_reading = <span class="hljs-number">0</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_des</span>(<span class="hljs-params">self</span>):<br>fn=<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.year&#125;</span> <span class="hljs-subst">&#123;self.make&#125;</span> <span class="hljs-subst">&#123;self.model&#125;</span>&quot;</span><br><span class="hljs-keyword">return</span> fn.title()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_odometer</span>(<span class="hljs-params">self</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;This car has <span class="hljs-subst">&#123;self.odometer_reading&#125;</span> miles on it.&quot;</span>)<br>my_car=Car(<span class="hljs-string">&#x27;audi&#x27;</span>,<span class="hljs-string">&#x27;a4&#x27;</span>,<span class="hljs-number">2019</span>)<br><span class="hljs-built_in">print</span>(my_car.get_des())<br>my_car.read_odometer()<br></code></pre></td></tr></table></figure><p><strong>修改属性的值</strong></p><p>a. 直接修改属性的值</p><p>要修改属性的值，最简单的方式是通过实例直接访问它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_car.odometer_reading=<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p>b. 通过方法修改属性的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">Class Car:<br>...<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self,mile</span>):<br>self.odometer_reading=mile<br>my_car=Car(<span class="hljs-string">&#x27;audi&#x27;</span>,<span class="hljs-string">&#x27;a4&#x27;</span>,<span class="hljs-number">2019</span>)<br>my_car.update(<span class="hljs-number">23_400</span>)<br></code></pre></td></tr></table></figure><p>c. 通过方法对属性的值进行递增</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">Class Car:<br>...<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">inc</span>(<span class="hljs-params">self,miles</span>):<br>self.odometer_reading+=miles<br>my_car=Car(<span class="hljs-string">&#x27;audi&#x27;</span>,<span class="hljs-string">&#x27;a4&#x27;</span>,<span class="hljs-number">2019</span>)<br>my_car.inc(<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p><strong>继承</strong></p><p>在父类的基础上编写子类时，通常要调用父类的方法 <code>__init__()</code>，子类会包含这些属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make,model,year</span>):<br>self.make=make<br>self.model=model<br>self.year=year<br>self.odometer_reading = <span class="hljs-number">0</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_des</span>(<span class="hljs-params">self</span>):<br>fn=<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.year&#125;</span> <span class="hljs-subst">&#123;self.make&#125;</span> <span class="hljs-subst">&#123;self.model&#125;</span>&quot;</span><br><span class="hljs-keyword">return</span> fn.title()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_odometer</span>(<span class="hljs-params">self</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;This car has <span class="hljs-subst">&#123;self.odometer_reading&#125;</span> miles on it.&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self,mile</span>):<br>self.odometer_reading=mile<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">inc</span>(<span class="hljs-params">self,miles</span>):<br>self.odometer_reading+=miles<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Elecar</span>(<span class="hljs-title class_ inherited__">Car</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,make,model,year</span>):<br><span class="hljs-built_in">super</span>().__init__(make,model,year)<br>my_tesla=Elecar(<span class="hljs-string">&#x27;tesla&#x27;</span>,<span class="hljs-string">&#x27;model-X&#x27;</span>,<span class="hljs-number">2019</span>)<br><span class="hljs-built_in">print</span>(my_tesla.get_des())<br></code></pre></td></tr></table></figure><ul><li>创建子类时，父类必须包含在当前 文件中，且位于子类前面。</li><li>定义子类时，必须在圆括号内指定父类的名称。</li><li>super() 是一个特殊函数，让你能够调用父类的方法。</li></ul><p><strong>给子类定义属性和方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>--snip--<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElectricCar</span>(<span class="hljs-title class_ inherited__">Car</span>):<br><span class="hljs-string">&quot;&quot;&quot;电动汽车的独特之处。&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make, model, year</span>):<br><span class="hljs-string">&quot;&quot;&quot; 初始化父类的属性。 再初始化电动汽车特有的属性。 &quot;&quot;&quot;</span> <br><span class="hljs-built_in">super</span>().__init__(make, model, year) <br>self.battery_size = <span class="hljs-number">75</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">describe_battery</span>(<span class="hljs-params">self</span>):<br><span class="hljs-string">&quot;&quot;&quot;打印一条描述电瓶容量的消息。&quot;&quot;&quot;</span> <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;This car has a <span class="hljs-subst">&#123;self.battery_size&#125;</span>-kWh battery.&quot;</span>)<br>my_tesla = ElectricCar(<span class="hljs-string">&#x27;tesla&#x27;</span>, <span class="hljs-string">&#x27;model s&#x27;</span>, <span class="hljs-number">2019</span>)<br><span class="hljs-built_in">print</span>(my_tesla.get_descriptive_name()) <br>my_tesla.describe_battery()<br></code></pre></td></tr></table></figure><p>添加新属性self.battery_size ，并设置初始值。</p><p><strong>重写父类的方法</strong></p><p>在子类中定义与父类方法同名的方法，这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。</p><p><strong>将实例用作属性</strong></p><p>使用代码模拟实物时，你可能会发现自己给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分提取出来，作为一个独立的类。可以将大型类拆分成多个协同工作的小类。</p><p>例如，不断给ElectricCar 类添加细节时，我们可能发现其中包 含很多专门针对汽车电瓶的属性和方法。在这种情况下，可将这些属性和方法提取出来，放到一个名为Battery 的类中，并将一 个Battery 实例作为ElectricCar 类的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>--snip--<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Battery</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, battery_size=<span class="hljs-number">75</span></span>):<br>self.battery_size = battery_size<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Electric</span>(<span class="hljs-title class_ inherited__">Car</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,make,model,year</span>):<br><span class="hljs-built_in">super</span>().__init__(make,model,year)<br>self.battery=Battery()<br>my_tesla = ElectricCar(<span class="hljs-string">&#x27;tesla&#x27;</span>, <span class="hljs-string">&#x27;model s&#x27;</span>, <span class="hljs-number">2019</span>)<br><span class="hljs-built_in">print</span>(my_tesla.get_descriptive_name()) <br>my_tesla.battery.describe_battery()<br></code></pre></td></tr></table></figure><p>在ElectricCar 类中，添加了一个名为self.battery 的属性。这行代码让Python创建一个新的Battery 实例，并将该实例赋给新属性self.battery 。</p><p>这行代码让Python在实例my_tesla 中查找属性battery ，并对存 储在该属性中的Battery 实例调用方法describe_battery() 。</p><p><strong>导入类</strong></p><p>随着不断给类添加功能，文件可能变得很长，即便妥善地使用了继承亦如此。为遵循Python的总体理念，应让文件尽可能整洁。 Python在这方面提供了帮助，允许将类存储在模块中，然后在主程 序中导入所需的模块。</p><p>a. 导入单个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#有一个Car类存在car.py文件中</span><br><span class="hljs-keyword">from</span> car <span class="hljs-keyword">import</span> Car<br>my_new_car = Car(<span class="hljs-string">&#x27;audi&#x27;</span>, <span class="hljs-string">&#x27;a4&#x27;</span>, <span class="hljs-number">2019</span>)<br><span class="hljs-built_in">print</span>(my_new_car.get_descriptive_name())<br>my_new_car.odometer_reading = <span class="hljs-number">23</span> <br>my_new_car.read_odometer()<br></code></pre></td></tr></table></figure><p>b. 从一个模块中导入多个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> car <span class="hljs-keyword">import</span> Car, ElectricCar<br></code></pre></td></tr></table></figure><p>c. 导入整个模块</p><p>导入整个模块，再使用句点表示法访问需要的类。这种导入方式很简单，代码也易于阅读。因为创建类实例的代码都包含模块名，所以不会与当前文件使用的任何名称发生冲突。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> car<br>my_beetle = car.Car(<span class="hljs-string">&#x27;volkswagen&#x27;</span>, <span class="hljs-string">&#x27;beetle&#x27;</span>, <span class="hljs-number">2019</span>) <br><span class="hljs-built_in">print</span>(my_beetle.get_descriptive_name())<br></code></pre></td></tr></table></figure><p>d. 导入模块中的所有类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> module_name <span class="hljs-keyword">import</span> *<br></code></pre></td></tr></table></figure><p>不推荐使用这种导入方式</p><p>e. 在一个模块中导入另一个模块</p><p>将类存储在多个模块中时，你可能会发现一个模块中的类依赖于另一个模块中的类。在这种情况下，可在前一 个模块中导入必要的类。</p><p>将Car类存储在一个模块中，并将ElectricCar 类和Battery 类存储在另一个模块中。将第二个模块命名为electric_car.py（这将 覆盖前面创建的文件electric_car.py），并将Battery 类和 ElectricCar 类复制到这个模块中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> car <span class="hljs-keyword">import</span> Car <span class="hljs-keyword">from</span> electric_car <span class="hljs-keyword">import</span> ElectricCar<br>my_beetle = Car(<span class="hljs-string">&#x27;volkswagen&#x27;</span>, <span class="hljs-string">&#x27;beetle&#x27;</span>, <span class="hljs-number">2019</span>)<br><span class="hljs-built_in">print</span>(my_beetle.get_descriptive_name())<br>my_tesla = ElectricCar(<span class="hljs-string">&#x27;tesla&#x27;</span>, <span class="hljs-string">&#x27;roadster&#x27;</span>, <span class="hljs-number">2019</span>)<br><span class="hljs-built_in">print</span>(my_tesla.get_descriptive_name())<br></code></pre></td></tr></table></figure><p>f. 使用别名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> electric_car <span class="hljs-keyword">import</span> ElectricCar <span class="hljs-keyword">as</span> EC<br>my_tesla = EC(<span class="hljs-string">&#x27;tesla&#x27;</span>, <span class="hljs-string">&#x27;roadster&#x27;</span>, <span class="hljs-number">2019</span>)<br></code></pre></td></tr></table></figure><h3 id="2-文件和异常"><a href="#2-文件和异常" class="headerlink" title="2. 文件和异常"></a>2. 文件和异常</h3><p>　 本章中，你将学习处理文件，让程序能够快速地分析大量数 据；你将学习错误处理，避免程序在面对意外情形时崩溃；你 将学习异常 ，它们是Python创建的特殊对象，用于管理程序运 行时出现的错误；你还将学习模块json ，它让你能够保存用户数据，以免在程序停止运行后丢失。</p><p><strong>从文件中读取数据</strong></p><p>要使用文本文件中的信息，首先需要将信息读取到内存中。为此，你可以一次性读取文件的全部内容，也可以以每次一行的方式逐步读取。</p><p>a. 读取整个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;pi.txt&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br>    contents = file_object.read() <br><span class="hljs-built_in">print</span>(contents)<br></code></pre></td></tr></table></figure><p>​    在这个程序中，函数<code>open()</code>先打开文件，这样我们才能访问它。参数填入要打开的文件的名称，返回一个表示文件的对象，Python将该对象赋给file_object 供以后使用。关键字with在不再需要访问文件后将其关闭。</p><p>b. 为什么不用<code>close()</code>关闭文件？</p><p>​    用<code>close()</code>关闭文件时，如果程序存在bug导致方法close() 未执行，文件将不会关闭。这看似微不足道，但未妥善关闭文件可能导致数据丢失或受损。如果在程序中过早调用close() ，你会发现需要使用文件时它已关闭 （这将导致文件无法访问），这会导致更多的错误。并非在任何情况下都能准确的确定关闭文件的恰当时机，但通过使用前面所示的结构，可让Python去确定：你只管打开文件，并在需要时使用它，Python自会在合适的时 候自动将其关闭。</p><p>c. <code>read()</code>读取内容</p><p>​    有了表示pi_digits.txt的文件对象后，使用方法<code>read()</code>读取这个文件的全部内容，并将其作为一个长长的字符 串赋给变量contents 。这样，通过打印contents 的值，就可将这个文本文件的全部内容显示出来：</p><p>d. 读取内容末尾多出来一个空行</p><p>​    相比于原始文件，该输出唯一不同的地方是末尾多了一个空行。因为<code>read()</code>到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除多出来的空行，可在函数调用print() 中使用rstrip() ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;pi_digits.txt&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br>contents = file_object.read()<br><span class="hljs-built_in">print</span>(contents.rstrip())<br></code></pre></td></tr></table></figure><p><strong>文件路径</strong></p><p>不写文件路径时，Python将只在当前目录中查找，不会在子文件夹或上级文件夹中查找。</p><p>相对文件路径：相对于当前程序所在目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;text_files/filename.txt&#x27;</span>) <span class="hljs-keyword">as</span> file_object:<br></code></pre></td></tr></table></figure><p>这行代码让Python到当前文件目录的子文件夹text_files中去查找指定的.txt文件。</p><p>注意：显示文件路径时，Windows系统使用反斜杠<code>\</code>而不是斜杠<code>/</code>，但在代码中依然可以使用斜杠。如果在文件路径中直接使用反斜杠，将引发错误，因为反斜杠用于对字符串中的字符进行转义。</p><p>绝对路径：可读取系统中任何地方的文件。</p><p><strong>逐行读取</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">filename=<span class="hljs-string">&#x27;pi.txt&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> fo:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> fo:<br>        <span class="hljs-built_in">print</span>(line)<br></code></pre></td></tr></table></figure><p>打印每一行时，发现空白行更多了：</p><p>每行末尾都有两个换行符：一个来自文件，另一个来自函数调用print() 。要消除这些多余的空白行，可在函数调用print() 中使用rstrip() 。</p><p><strong>创建一个包含文件各行内容的列表</strong></p><p>使用关键字with时，open() 返回的文件对象只在with 代码块内可用。如果要在with代码块外访问文件的内容，可在with代码块内将文件的各行存储在一个外部列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">filename=<span class="hljs-string">&#x27;pi.txt&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> fo:<br>    lines=fo.readlines()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> lines:<br>    <span class="hljs-built_in">print</span>(i.rstrip())<br></code></pre></td></tr></table></figure><p><strong>使用文件的内容</strong></p><p>将文件读取到内存中后，就能以任何方式使用这些数据了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">filename=<span class="hljs-string">&#x27;pi.txt&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> fo:<br>    lines=fo.readlines()<br>pi_str=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> lines:<br>    pi_str+=i.rstrip()<br><span class="hljs-built_in">print</span>(pi_str)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(pi_str))<br></code></pre></td></tr></table></figure><p>注意：读取文本文件时，Python将其中的所有文本都解读为字符串。如果读取的是数，并要将其作为数值使用，就必须使用函数int() 将其转换为整数或使用函数float() 将其转换为浮点数。</p><p><strong>写文件</strong></p><p>要将文本写入文件，需要在调用open() 时提供另一个实参为：读取模式<code>&#39;r&#39;</code>、写入模式 <code>&#39;w&#39;</code>、附加模式<code>&#39;a&#39;</code>或读写模式<code>&#39;r+&#39;</code>。如果省略了模式实参，Python将默认用只读模式打开文件。</p><p>如果要写入的文件不存在，函数open() 将自动创建它。然而，以<code>&#39;w&#39;</code>模式打开文件时千万要小心，因为如果指定的文件已经存在，Python将清空该文件，不想这样的话可以用<code>&#39;a&#39;</code>模式。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">filename=<span class="hljs-string">&#x27;pi.txt&#x27;</span><br>with <span class="hljs-keyword">open</span>(<span class="hljs-string">&#x27;pi.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">fo</span>:<br>    <span class="hljs-keyword">fo</span>.<span class="hljs-keyword">write</span>(<span class="hljs-string">&#x27;love U!&#x27;</span>)<br></code></pre></td></tr></table></figure><p>注意：Python只能写入字符串格式。如果要写入数据，必须先使用函数<code>str()</code>将其转换为字符串格 式。</p><p><strong>异常</strong></p><p>异常使用<code>try-except</code> 代码块处理，让 Python在出现异常时执行指定的操作，让程序在出现异常时也可以继续运行。</p><p>a. 处理异常</p><p>ZeroDivisionError为用数除以0时触发的异常，处理起来可以这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>/<span class="hljs-number">0</span>)<br><span class="hljs-keyword">except</span> ZeroDivisionError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;you can\&#x27;t do this&#x27;</span>)<br></code></pre></td></tr></table></figure><p>把可能会触发异常的代码放到try模块里，except里为异常处理程序。</p><p>b. 使用异常避免崩溃</p><p>程序崩溃让用户看到traceback并不好，不懂技术的用户会被搞糊涂，怀有恶意的用户还会通过traceback获悉你不想他知道的信息。</p><p>例如，他将知道你的程序文件的名称，还将看到部分不能正确运行的代码。有时候，训练有素的攻击者可根据这些信息判断出可对你的代码发起什么样的攻击。</p><p>c. else 代码块</p><p>try-except-else 代码块的工作原理大致如下。Python先执行try代码块中的代码，只有可能引发异常的代码才需要放在try 语句中，有时候下面的代码需要用到try中的语句，放到try- except内部会导致程序冗余，放到外部会触发别的异常，因此Python有一个else代码块，专门用来放置这部分代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    fir=<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;plz input the first num:&#x27;</span>)<br>    sec=<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;plz input the second num:&#x27;</span>)<br>    <span class="hljs-keyword">if</span> sec==<span class="hljs-string">&#x27;q&#x27;</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">try</span>:<br>        ans=<span class="hljs-built_in">int</span>(fir)/<span class="hljs-built_in">int</span>(sec)<br>    <span class="hljs-keyword">except</span> ZeroDivisionError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;the second num can\&#x27;t be 0&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><p><strong>处理FileNotFoundError 异常</strong></p><p>使用文件时，一种常见的问题是找不到文件：查找的文件可能在其他地方，文件名可能不正确，或者这个文件根本就不存在。对于这些情形，都可使用try-except 代码块以直观的方式处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;i.txt&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fo:<br>        contents=fo.read()<br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;file not found&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(contents.rstrip())<br></code></pre></td></tr></table></figure><p>参数encoding 在系统的默认编码与要读取文件使用的编码不一致时，必须要赋值。</p><p>方法<code>split()</code>以空格为分隔符将字符串分拆成单个的单词，并将这些单词都存储到一个列表中，但是有些单词可能包含标点。</p><p><strong>静默失败</strong></p><p>有时候我们希望程序在发生异常时保持沉默就可以了，就像什么都没有发生一样继续运行。Python有一个pass 语句，可用于让Python在 代码块中什么都不要做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;i.txt&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fo:<br>            contents=fo.read()<br>    <span class="hljs-keyword">except</span> FileNotFoundError:<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(contents.rstrip())<br></code></pre></td></tr></table></figure><p><strong>存储数据</strong></p><p>模块json可以简单的把Python数据结构转储到文件中，并在程序再次运行时加载该文件中的数据。你还可以使用json 在 Python程序之间分享数据。更重要的是，JSON数据格式并非Python专用的，这可以让JSON格式存储的数据与使用其他编程语言的人分享。是一种轻便而有用的格式，也易于学习。</p><p>注意：JSON（JavaScript Object Notation）格式最初是为 JavaScript开发的，但随后成了一种常见格式，被包括Python在 内的众多语言采用。</p><p>a. 使用json.dump() 和json.load()</p><p>我们来编写一个使用json.dump() 存储一组数的程序，再使用json.load()将这些数读取到内存中的程序 。</p><p>函数json.dump() 接受两个实参：要存储的数据，以及可用于存储数据的文件对象（没有则创建）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>nums=[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>]<br>fname=<span class="hljs-string">&#x27;num.json&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(fname,<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> fo:<br>    json.dump(nums,fo)<br></code></pre></td></tr></table></figure><p>打开文件numbers.json可以看到：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[2, 4, 6, 2, 6, 3]</span><br></code></pre></td></tr></table></figure><p>下面再编写一个程序，使用json.load() 将列表读取到内存中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>fn=<span class="hljs-string">&#x27;num.json&#x27;</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(fn) <span class="hljs-keyword">as</span> fo:<br>    nums=json.load(fo)<br><span class="hljs-built_in">print</span>(nums)<br></code></pre></td></tr></table></figure><p>这是一种在程序之间共享数据的简单方式。</p><p>示例：保存和读取用户生成的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>fn=<span class="hljs-string">&#x27;user.json&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(fn) <span class="hljs-keyword">as</span> f:<br>        user=json.load(f)<br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    user=<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;your name?\n&#x27;</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(fn,<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        json.dump(user,f)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;We&#x27;ll remember you when you come back, <span class="hljs-subst">&#123;user&#125;</span>!&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Welcome back, <span class="hljs-subst">&#123;user&#125;</span>!&quot;</span>)<br></code></pre></td></tr></table></figure><p>在try模块中打开文件，如果是第一次打开文件则跳到异常处理模块中创建该文件，并将数据进行存储，如果文件已存在，就直接读取并打印。</p><h3 id="3-测试代码"><a href="#3-测试代码" class="headerlink" title="3. 测试代码"></a>3. 测试代码</h3><p>　编写函数或类时，还可为其编写测试。通过测试，可确定代码面对各种输入都能够按要求的那样工作。</p><p><strong>测试方法</strong></p><p>要为函数编写测试用例，可先导入模块unittest 和要测试的函数，再创建一个继承unittest.TestCase 的类，并编写一系列方法对函数行为的不同方面进行测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#four.py的待测试代码</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_name</span>(<span class="hljs-params">first,last</span>):<br>    fname=<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;first,last&#125;</span>&#x27;</span><br>    <span class="hljs-keyword">return</span> fname.title()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">from</span> four <span class="hljs-keyword">import</span> get_name<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NamaCase</span>(unittest.TestCase):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_first_last_name</span>(<span class="hljs-params">self</span>):<br>        fname=get_name(<span class="hljs-string">&#x27;v&#x27;</span>,<span class="hljs-string">&#x27;leo&#x27;</span>)<br>        self.assertEqual(fname,<span class="hljs-string">&#x27;V Leo&#x27;</span>)<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><p>创建了一个名为NamaCase的类，用于包含一系列针对待测试类的单元测试。这个类可以随意命名，但必须继承<code>unittest.TestCase</code> 类，这样Python才知道如何运行你编写的测试。</p><p>NamaCase只包含一个方法，命名为<code>test_first_last_name()</code>，运行脚本时，所有以<code>test_</code>打头的方法都将自动运行。在这个方法中，调用了要测试的函数<code>get_name()</code>。</p><p><code>assertEqual()</code>是unittest 类最有用的功能之一：断言方法，用来核实得到的结果是否与期望的结果一致，将得到的测试值与我们的期望值进行比较，如果相等的话就很nice，如果不相等的话就会输出Failed。</p><p><code>&#39;__main__&#39;</code> 是顶层代码执行的作用域的名称。模块的 <code>__name__</code>在通过标准输入、脚本文件或是交互式命令读入的时候会等于 <code>&#39;__main__&#39;</code>。</p><p>模块可以通过检查自己的 <code>__name__</code> 来得知是否运行在 main 作用域中，这使得模块可以在作为脚本或是通过 <code>python -m</code> 运行时条件性地执行一些代码，<strong>而在被 import 时不会执行</strong>。</p><p>简单的说，这就是一个用于在被导入时不执行，只有作为主程序时才执行的一个标志。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># execute only if run as a script</span><br>    main()<br></code></pre></td></tr></table></figure><p>对软件包来说，通过加入 <code>__main__.py</code> 模块可以达到同样的效果，当使用 <code>-m</code> 运行模块时，其中的代码会被执行。</p><p><strong>测试类</strong></p><p>断言方法：检查你认为应该满足的条件是否确实满足。</p><p>表11-1　unittest模块中的断言方法</p><div class="table-container"><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>assertEqual(a, b)</td><td>核实a == b</td></tr><tr><td>assertNotEqual(a, b)</td><td>核实a != b</td></tr><tr><td>assertTrue(x)</td><td>核实x 为True</td></tr><tr><td>assertFalse(x)</td><td>核实x 为False</td></tr><tr><td>assertIn(item , list )</td><td>核实 item 在 list 中</td></tr><tr><td>assertNotIn(item , list )</td><td>核实 item 不在 list 中</td></tr></tbody></table></div><p>测试AnonymousSurvey 类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnonymousSurvey</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,ques</span>) :<br>self.ques=ques<br>self.resp=[]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">self</span>):<br><span class="hljs-built_in">print</span>(self.ques)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">store</span>(<span class="hljs-params">self ,new</span>):<br>self.resp.append(new)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">results</span>(<span class="hljs-params">self</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Results:&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.resp:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;-<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>下面来编写一个测试，对AnonymousSurvey 类的行为的一个方面进行验证：如果用户面对调查问题只提供一个答案，这个答案也能被妥善地存储。为此，我们将在这个答案被存储后，使用方法 assertIn() 来核实它确实在答案列表中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest <span class="hljs-keyword">from</span> survey <span class="hljs-keyword">import</span> AnonymousSurvey<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAnonymousSurvey</span>(unittest.TestCase):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_store_single_response</span>(<span class="hljs-params">self</span>):<br>question = <span class="hljs-string">&quot;What language did you first learn to speak?&quot;</span> <br>my_survey = AnonymousSurvey(question) <br>my_survey.store_response(<span class="hljs-string">&#x27;English&#x27;</span>) <br>self.assertIn(<span class="hljs-string">&#x27;English&#x27;</span>, my_survey.responses)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>unittest.main()<br></code></pre></td></tr></table></figure><p><strong>方法setUp()</strong></p><p>在前面的测试中，我们在每个测试方法里都创建了一个AnonymousSurvey 实例，并在每个方法中都创建了答 案。unittest.TestCase 类包含的方法setUp() 让我们只需创建这些对象一次，就能在每个测试方法中使用。</p><p>如果在Test类中包含了方法setUp() ，Python将先运行它，再运行各个以test_ 打头的方法。这样，在你编写的每个测试方法中，都可使用在方法 setUp() 中创建的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">from</span> four <span class="hljs-keyword">import</span> AnonymousSurvey<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAnnony</span>(unittest.TestCase):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUp</span>(<span class="hljs-params">self</span>):<br>        ques=<span class="hljs-string">&quot;What language did you first learn to speak?&quot;</span><br>        self.my_sur=AnonymousSurvey(ques)<br>        self.resp=[<span class="hljs-string">&#x27;English&#x27;</span>,<span class="hljs-string">&#x27;Spanish&#x27;</span>,<span class="hljs-string">&#x27;Mandarin&#x27;</span>]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_one</span>(<span class="hljs-params">self</span>):<br>        self.my_sur.store(self.resp[<span class="hljs-number">0</span>])<br>        self.assertIn(self.resp[<span class="hljs-number">0</span>],self.my_sur.resp[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><p>方法setUp() 做了两件事情：创建一个测试用的调查对象，以及创建一个测试用答案列表。存储这两样东西的变量名包含前缀self （即存储在属性中），因此可在这个类的任何地方使用。这让两个测试方法都更简单，因为它们都不用创建调查对象和答案了。只用看测试类的答案和答案列表是否相符即可。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python Day02</title>
    <link href="/2022/09/07/Python-Week02/"/>
    <url>/2022/09/07/Python-Week02/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="1-元组"><a href="#1-元组" class="headerlink" title="1. 元组"></a>1. 元组</h3><p><strong>不可变的列表被称为元组</strong> </p><p>元组使用圆括号而非中括号来标识，可使用索引来访问其元素。</p><p>例如，如果有一个大小不应改变的矩形，可将其长度和宽度存储在 一个元组中，从而确保它们是不能修改的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dimens=(<span class="hljs-number">200</span>,<span class="hljs-number">50</span>)<br><span class="hljs-built_in">print</span>(dimens[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(dimens[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>修改元素的值，会触发错误消息。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">TypeError</span>: <span class="hljs-string">&#x27;tuple&#x27;</span> <span class="hljs-keyword">object</span> does not support item assignment<br></code></pre></td></tr></table></figure><p>注意：严格地说，元组是由逗号标识的，如果你要定义只包含一个元素的元组，必须在这个元素后面加上逗号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_t = (<span class="hljs-number">3</span>,)<br></code></pre></td></tr></table></figure><p>遍历元组和列表一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dimens=(<span class="hljs-number">200</span>,<span class="hljs-number">50</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dimens:<br><span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>虽然不能修改元组的元素，但可以重新定义整个元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dimens=(<span class="hljs-number">200</span>,<span class="hljs-number">50</span>)<br>dimens=(<span class="hljs-number">300</span>,<span class="hljs-number">20</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dimens:<br><span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>相比于列表，元组是更简单的数据结构。如果需要存储的一组值在程序的整个生命周期内都不变，可以使用元组。</p><h3 id="2-if-语句"><a href="#2-if-语句" class="headerlink" title="2. if 语句"></a>2. if 语句</h3><p><strong>区分大小写：</strong></p><p>在Python中检查是否相等时区分大小写，两个大小写不同的值被视为不相等。</p><p>如果大小写很重要，这种行为有其优点。但如果大小写无关紧要， 只想检查变量的值，可将变量的值转换为小写，再进行比较。</p><p><strong>数值比较：</strong></p><p>条件语句中可包含各种数学比较，如小于、小于等于、大于、大于等于、等于、不等于：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">&gt;= &lt; &lt;= == !=</span><br></code></pre></td></tr></table></figure><p><strong>检查多个条件：</strong></p><p>a. 使用and 检查多个条件</p><p>b. 使用or检查多个条件</p><p><strong>检查特定值是否包含在列表中：</strong></p><p>要判断特定的值是否已包含在列表中，可使用关键字<code>in</code></p><p>不包含在列表中，使用<code>not in</code></p><p><strong>布尔表达式</strong> </p><p>布尔值通常用于记录条件，如游戏是否正在运行，或者用户是否可以编辑网站的特定内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">game_active = <span class="hljs-literal">True</span> <br><br>can_edit = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>在跟踪程序状态或程序中重要的条件方面，布尔值提供了一种高效的方式。</p><p><strong>if语句结构：</strong></p><ul><li>if</li><li>If-else</li><li>If-elif-else：else可以省略</li></ul><p><strong>验证列表是否为空：</strong></p><p>Python将在列表至少包含一个元素时返回True ， 并在列表为空时返回False 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">lists=[]<br><span class="hljs-keyword">if</span> lists:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;yes&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;no&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="3-字典"><a href="#3-字典" class="headerlink" title="3. 字典"></a>3. 字典</h3><p>字典类似于列表，但是是是一系列键值对，让你能够将不同的信息关联起来，用中括号表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">alien=&#123;<span class="hljs-string">&#x27;color&#x27;</span>:<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;points&#x27;</span>:<span class="hljs-number">5</span>&#125;<br><span class="hljs-built_in">print</span>(alien[<span class="hljs-string">&#x27;color&#x27;</span>])<br><span class="hljs-built_in">print</span>(alien[<span class="hljs-string">&#x27;points&#x27;</span>])<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">green</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>每个键都与一个值相关联， 你可使用键来访问相关联的值。与键相关联的值可以是数、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。</p><p><strong>添加键值对：</strong></p><p>字典是一种动态结构，可随时在其中添加键值对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">alien=&#123;<span class="hljs-string">&#x27;color&#x27;</span>:<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;points&#x27;</span>:<span class="hljs-number">5</span>&#125;<br><span class="hljs-built_in">print</span>(alien)<br>alien[<span class="hljs-string">&#x27;xpos&#x27;</span>]=<span class="hljs-number">100</span><br>alien[<span class="hljs-string">&#x27;ypos&#x27;</span>]=<span class="hljs-number">50</span><br><span class="hljs-built_in">print</span>(alien)<br></code></pre></td></tr></table></figure><p>注意：字典中元素的排列顺序与定义时相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">alien_0 = &#123;<span class="hljs-string">&#x27;x_position&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;y_position&#x27;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;medium&#x27;</span>&#125; <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Original position: <span class="hljs-subst">&#123;alien_0[<span class="hljs-string">&#x27;x_position&#x27;</span>]&#125;</span>&quot;</span>)<br><span class="hljs-keyword">if</span> alien_0[<span class="hljs-string">&#x27;speed&#x27;</span>]==<span class="hljs-string">&#x27;slow&#x27;</span>:<br>x_inc=<span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> alien_0[<span class="hljs-string">&#x27;speed&#x27;</span>]==<span class="hljs-string">&#x27;medium&#x27;</span>:<br>x_inc=<span class="hljs-number">2</span><br><span class="hljs-keyword">else</span>:<br>x_inc=<span class="hljs-number">3</span><br>alien_0[<span class="hljs-string">&#x27;x_position&#x27;</span>]+=x_inc<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;New position:<span class="hljs-subst">&#123;alien_0[<span class="hljs-string">&#x27;x_position&#x27;</span>]&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>删除键值对</strong></p><p>使用del 语句，必须指定字典名和要删除的键。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">alien_0 = &#123;<span class="hljs-string">&#x27;x_position&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;y_position&#x27;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;medium&#x27;</span>&#125; <br><span class="hljs-keyword">del</span> alien_0[<span class="hljs-string">&#x27;speed&#x27;</span>]<br><span class="hljs-built_in">print</span>(alien_0)<br></code></pre></td></tr></table></figure><p>注意 　删除的键值对会永远消失。</p><p><strong>使用get() 来访问值</strong> </p><p>用键搜索时，可能会引发问题：如果指定的键不存在就会出错。</p><p>但就字典而言，可使用方法get() 在指定的键不存在时返回一个默认值，从而避免这样的错误。</p><p>方法get() 的第一个参数用于指定键；第二个参数指定键不存在时要返回的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">alien_0 = &#123;<span class="hljs-string">&#x27;x_position&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;y_position&#x27;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;medium&#x27;</span>&#125; <br>msg=alien_0.get(<span class="hljs-string">&#x27;dgg&#x27;</span>,<span class="hljs-string">&#x27;no such value&#x27;</span>)<br><span class="hljs-built_in">print</span>(msg)<br></code></pre></td></tr></table></figure><p>注意：调用get() 时，如果没有指定第二个参数，Python将返回值None 。</p><p><strong>遍历字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">alien_0 = &#123;<span class="hljs-string">&#x27;x_position&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;y_position&#x27;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;medium&#x27;</span>&#125; <br><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> alien_0.items():<br><span class="hljs-built_in">print</span>(i)<br><span class="hljs-built_in">print</span>(j)<br></code></pre></td></tr></table></figure><p><strong>遍历字典中的所有键</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">alien_0 = &#123;<span class="hljs-string">&#x27;x_position&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;y_position&#x27;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;medium&#x27;</span>&#125; <br><span class="hljs-built_in">print</span>(alien_0.keys())<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> alien_0.keys():<br><span class="hljs-built_in">print</span>(x)<br></code></pre></td></tr></table></figure><p>Keys()返回一个列表，因此可以用<code>sort()</code>等方法进行排序。</p><p><strong>遍历字典中的所有值</strong></p><p>方法values() 可以返回一 个值列表，不包含任何键。这种做法提取字典中所有的值，而没有考虑是否重复。为剔除重复项，可使用集合<code>set()</code>，集合中的每个元素都必须是独一无二的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">favorite_languages = &#123; <span class="hljs-string">&#x27;jen&#x27;</span>: <span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;sarah&#x27;</span>: <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;edward&#x27;</span>: <span class="hljs-string">&#x27;ruby&#x27;</span>, <span class="hljs-string">&#x27;phil&#x27;</span>: <span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;sdf&#x27;</span>: <span class="hljs-string">&#x27;python&#x27;</span>,&#125;<br><span class="hljs-keyword">for</span> lang <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span>(favorite_languages.values()):<br><span class="hljs-built_in">print</span>(lang)<br></code></pre></td></tr></table></figure><p>集合和字典很容易混淆，因为它们都是用一对花括号定义的。 当花括号内没有键值对时，定义的很可能是集合。不同于列表 和字典，集合不会以特定的顺序存储元素。</p><p><strong>在列表中存储字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">alien_0 = &#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">5</span>&#125; <br>alien_1 = &#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">10</span>&#125; <br>alien_2 = &#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">15</span>&#125;<br>aliens = [alien_0, alien_1, alien_2]<br><span class="hljs-keyword">for</span> alien <span class="hljs-keyword">in</span> aliens: <br>  <span class="hljs-built_in">print</span>(alien)<br></code></pre></td></tr></table></figure><p><strong>在字典中存储列表</strong></p><p>每当需要在字典中将一个键关联到多个值时，都可以在字典中嵌套 一个列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">favorite_languages = &#123;<br><span class="hljs-string">&#x27;jen&#x27;</span>: [<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;ruby&#x27;</span>], <br><span class="hljs-string">&#x27;sarah&#x27;</span>: [<span class="hljs-string">&#x27;c&#x27;</span>],<br><span class="hljs-string">&#x27;edward&#x27;</span>: [<span class="hljs-string">&#x27;ruby&#x27;</span>, <span class="hljs-string">&#x27;go&#x27;</span>], <br><span class="hljs-string">&#x27;phil&#x27;</span>: [<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;haskell&#x27;</span>], &#125;<br><span class="hljs-keyword">for</span> name, languages <span class="hljs-keyword">in</span> favorite_languages.items():<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n<span class="hljs-subst">&#123;name.title()&#125;</span>&#x27;s favorite languages are:&quot;</span>) <br><span class="hljs-keyword">for</span> language <span class="hljs-keyword">in</span> languages: <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\t<span class="hljs-subst">&#123;language.title()&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>注意 　列表和字典的嵌套层级不应太多。如果嵌套层级比前 面的示例多得多，很可能有更简单的解决方案。</p><p><strong>在字典中存储字典</strong></p><p>可在字典中嵌套字典，但这样做时，代码可能很快复杂起来。</p><p>最好储存的每项字典都具有相同的结构。虽然Python并没 有这样的要求，但这使得嵌套的字典处理起来更容易。倘若表示每个字典都包含不同的键，for 循环内部的代码将更复杂。</p><h3 id="3-input和while循环"><a href="#3-input和while循环" class="headerlink" title="3. input和while循环"></a>3. input和while循环</h3><p><strong><code>input()</code>工作原理</strong></p><p>函数<code>input()</code>让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其赋给一个变量，以方便后面使用。</p><p>函数<code>input()</code>的参数为要向用户显示的提示 （prompt） 或说明，让用户知道该如何做。</p><p>注意：Sublime Text等众多编辑器不能运行用户输入程序，必须从终端运行它们。</p><p><strong>将用户输入转化为数值<code>int()</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">msg=<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;plz give a num:\t&#x27;</span>)<br>num=<span class="hljs-built_in">int</span>(msg)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(num))<br><span class="hljs-keyword">if</span> num&gt;=<span class="hljs-number">10</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;You are big&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;You are small&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>while循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">num=<span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> num&lt;=<span class="hljs-number">5</span>:<br><span class="hljs-built_in">print</span>(num)<br>num+=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>while 循环运行，直到指定的条件<strong>不满足</strong>为止</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">prompt = <span class="hljs-string">&quot;\nTell me something, and I will repeat it back to you:&quot;</span><br>prompt += <span class="hljs-string">&quot;\nEnter &#x27;quit&#x27; to end the program. &quot;</span> <br>message = <span class="hljs-string">&quot;&quot;</span> <br><span class="hljs-keyword">while</span> message != <span class="hljs-string">&#x27;quit&#x27;</span>:<br>message = <span class="hljs-built_in">input</span>(prompt)<br><span class="hljs-built_in">print</span>(message)<br></code></pre></td></tr></table></figure><p><strong>使用标志作为条件</strong></p><p>在要求很多条件都满足的程序中，在一条while 语句中检查所有这些条件，将既复杂又困难。</p><p>因此可定义一个变量，用于判断整个程序是否处于活动状态。这个变量称为标志 （flag）。这样，在while 语句中就只需检查一个条件，从而让程序更整洁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">prompt = <span class="hljs-string">&quot;\nTell me something, and I will repeat it back to you:&quot;</span><br>prompt += <span class="hljs-string">&quot;\nEnter &#x27;quit&#x27; to end the program. &quot;</span> <br>active=<span class="hljs-literal">True</span><br><span class="hljs-keyword">while</span> active:<br>message = <span class="hljs-built_in">input</span>(prompt)<br><span class="hljs-keyword">if</span> message==<span class="hljs-string">&#x27;quit&#x27;</span>:<br>active=<span class="hljs-literal">False</span><br><span class="hljs-keyword">else</span>:<br><span class="hljs-built_in">print</span>(message)<br></code></pre></td></tr></table></figure><p><strong>使用while 循环处理列表和字典</strong></p><p>for 循环是一种遍历列表的有效方式，但不应在for 循环中修改列表，否则将导致Python难以跟踪其中的元素。要在遍历列表的同时对其进行修改，可使用while 循环。通过将while 循环同列表和字典结合起来使用，可收集、存储并组织大量输入，供以后查看和显示。</p><p>(1) 列表间通过while移动元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">unconfirmed_users = [<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;brian&#x27;</span>, <span class="hljs-string">&#x27;candace&#x27;</span>] <br>confirmed_users = []<br><span class="hljs-keyword">while</span> unconfirmed_users:<br>cur_user=unconfirmed_users.pop()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Verifying user:<span class="hljs-subst">&#123;cur_user&#125;</span>&quot;</span>)<br>confirmed_users.append(cur_user)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\nThe following users have been confirmed:&quot;</span>)<br><span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> confirmed_users:<br><span class="hljs-built_in">print</span>(user)<br></code></pre></td></tr></table></figure><p>(2) 删除特定值的所有列表元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">pets = [<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;goldfish&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;rabbit&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>]<br><span class="hljs-built_in">print</span>(pets)<br><span class="hljs-keyword">while</span> <span class="hljs-string">&#x27;cat&#x27;</span> <span class="hljs-keyword">in</span> pets:<br>pets.remove(<span class="hljs-string">&#x27;cat&#x27;</span>)<br><span class="hljs-built_in">print</span>(pets)<br></code></pre></td></tr></table></figure><p>(3) 使用用户输入来填充字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">responses=&#123;&#125;<br>active=<span class="hljs-literal">True</span><br><span class="hljs-keyword">while</span> active:<br>name=<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;what is your name?&#x27;</span>)<br>response=<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Which mountain would you like to climb someday?&quot;</span>)<br>responses[name]=response<br>repeate=<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Continue?(Y/N)&#x27;</span>)<br><span class="hljs-keyword">if</span> repeate==<span class="hljs-string">&#x27;N&#x27;</span>:<br>active=<span class="hljs-literal">False</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;------result------&#x27;</span>)<br><span class="hljs-keyword">for</span> name,response <span class="hljs-keyword">in</span> responses.items():<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span> would like to climb <span class="hljs-subst">&#123;response&#125;</span>.&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h3><p><strong>定义函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet_user</span>():<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br>greet_user()<br></code></pre></td></tr></table></figure><p><strong>含参函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet_user</span>(<span class="hljs-params">name</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;hello,<span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br>greet_user(<span class="hljs-string">&#x27;xmm&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>位置实参</strong></p><p>调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。为此，最简单的关联方式是基于实参的顺序。这种关联方式称为位置实参 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">describe_pet</span>(<span class="hljs-params">animal_type, pet_name</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\nI have a <span class="hljs-subst">&#123;animal_type&#125;</span>.&quot;</span>) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My <span class="hljs-subst">&#123;animal_type&#125;</span>&#x27;s name is <span class="hljs-subst">&#123;pet_name.title()&#125;</span>.&quot;</span>)<br>describe_pet(<span class="hljs-string">&#x27;hamster&#x27;</span>, <span class="hljs-string">&#x27;harry&#x27;</span>)<br></code></pre></td></tr></table></figure><p>位置实参的顺序很重要，如果实参的顺序不正确，结果可能出乎意料。</p><p><strong>关键字实参</strong></p><p>关键字实参让你无须考虑函数调用 中的实参顺序，还清楚地指出了函数调用中各个值的用途</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">describe_pet</span>(<span class="hljs-params">animal_type, pet_name</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\nI have a <span class="hljs-subst">&#123;animal_type&#125;</span>.&quot;</span>) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My <span class="hljs-subst">&#123;animal_type&#125;</span>&#x27;s name is <span class="hljs-subst">&#123;pet_name.title()&#125;</span>.&quot;</span>)<br>describe_pet(pet_name=<span class="hljs-string">&#x27;lego&#x27;</span>, animal_type=<span class="hljs-string">&#x27;cat&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>默认值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">describe_pet</span>(<span class="hljs-params"> pet_name,animal_type=<span class="hljs-string">&#x27;dog&#x27;</span></span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\nI have a <span class="hljs-subst">&#123;animal_type&#125;</span>.&quot;</span>) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My <span class="hljs-subst">&#123;animal_type&#125;</span>&#x27;s name is <span class="hljs-subst">&#123;pet_name.title()&#125;</span>.&quot;</span>)<br>describe_pet(pet_name=<span class="hljs-string">&#x27;lego&#x27;</span>)<br></code></pre></td></tr></table></figure><p>注意：使用默认值时，必须先写没有默认值的形参，再写有默认值的实参，顺序不对会报错。</p><p><strong>返回值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">eat_food</span>(<span class="hljs-params">food,num</span>):<br>msg=<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;num&#125;</span> <span class="hljs-subst">&#123;food&#125;</span>s&quot;</span><br><span class="hljs-keyword">return</span> msg<br>word=eat_food(<span class="hljs-string">&#x27;burger&#x27;</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Eat <span class="hljs-subst">&#123;word&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>让实参变成可选的</strong></p><p>并非所有实参都需要提供，但不提供的话就不能正确运行。因此可以指定一个空的默认值，并将其移到形参列表的末尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">eat_food</span>(<span class="hljs-params">food,num,name=<span class="hljs-string">&#x27;&#x27;</span></span>):<br>msg=<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span> Eats <span class="hljs-subst">&#123;num&#125;</span> <span class="hljs-subst">&#123;food&#125;</span>s&quot;</span><br><span class="hljs-keyword">return</span> msg<br><span class="hljs-built_in">print</span>(eat_food(<span class="hljs-string">&#x27;egg&#x27;</span>,<span class="hljs-number">6</span>))<br></code></pre></td></tr></table></figure><p><strong>返回字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">full_name</span>(<span class="hljs-params">first_name,last_name,age=<span class="hljs-literal">None</span></span>):<br>person=&#123;<span class="hljs-string">&#x27;first&#x27;</span>:first_name,<span class="hljs-string">&#x27;last&#x27;</span>:last_name&#125;<br><span class="hljs-keyword">if</span> age:<br>person[<span class="hljs-string">&#x27;age&#x27;</span>]=age<br><span class="hljs-keyword">return</span> person<br>people=full_name(<span class="hljs-string">&#x27;love&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>,age=<span class="hljs-number">521</span>)<br><span class="hljs-built_in">print</span>(people)<br></code></pre></td></tr></table></figure><p>可选形参age 设置为特殊值None，可将None 视为占位值。在条件测试中，None相当于False 。</p><p><strong>结合使用函数和while 循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">full_name</span>(<span class="hljs-params">first_name,last_name</span>):<br>person=&#123;<span class="hljs-string">&#x27;first&#x27;</span>:first_name,<span class="hljs-string">&#x27;last&#x27;</span>:last_name&#125;<br><span class="hljs-keyword">return</span> person<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\nPlease tell me your name:&quot;</span>) <br>f_name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;First name: &quot;</span>) <br>l_name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Last name: &quot;</span>)<br>formatted_name = full_name(f_name, l_name) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\nHello, <span class="hljs-subst">&#123;formatted_name&#125;</span>!&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>向函数中传递列表</strong></p><p>需要参数过于复杂时，向函数传递列表很有用，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">great</span>(<span class="hljs-params">names</span>):<br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names:<br>msg=<span class="hljs-string">f&quot;Hello,<span class="hljs-subst">&#123;name.title()&#125;</span>&quot;</span><br><span class="hljs-built_in">print</span>(msg)<br>usernames=[<span class="hljs-string">&#x27;sfd&#x27;</span>,<span class="hljs-string">&#x27;sagf&#x27;</span>,<span class="hljs-string">&#x27;yth&#x27;</span>,<span class="hljs-string">&#x27;her&#x27;</span>,<span class="hljs-string">&#x27;sdg&#x27;</span>,<span class="hljs-string">&#x27;ewrt&#x27;</span>]<br>great(usernames)<br></code></pre></td></tr></table></figure><p><strong>在函数中修改列表</strong> </p><p>将列表传递给函数后，函数就可对其进行修改。在函数中对这个列表所做的任何修改都是永久性的，这让你能够高效地处理大量数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">prev=[<span class="hljs-string">&#x27;phone case&#x27;</span>, <span class="hljs-string">&#x27;robot pendant&#x27;</span>, <span class="hljs-string">&#x27;dodecahedron&#x27;</span>]<br>cur=[]<br><span class="hljs-keyword">while</span> prev:<br>item=prev.pop()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Printing model: <span class="hljs-subst">&#123;item&#125;</span>&quot;</span>)<br>cur.append(item)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\nThe following models have been printed:&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> cur:<br><span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>为重新组织这些代码，可编写两个函数，每个都做一件具体的工作，这样的效率更高。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">prev=[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>cur=[]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">copy</span>(<span class="hljs-params">prev,cur</span>):<br><span class="hljs-keyword">while</span> prev:<br>item=prev.pop()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Printing model: <span class="hljs-subst">&#123;item&#125;</span>&quot;</span>)<br>cur.append(item)<br><span class="hljs-keyword">return</span> cur<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">prt</span>(<span class="hljs-params">cur</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\nThe following models have been printed:&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> cur:<br><span class="hljs-built_in">print</span>(i)<br>prt(copy(prev,cur))<br></code></pre></td></tr></table></figure><p>由于列表作为参数传入函数后的修改是永久性的，因此不用设置中间变量，直接顺着写下来就行。</p><p><strong>禁止函数修改列表</strong></p><p>如果不想修改列表，可以向函数传递列表的副本而非原件。这样，函数所做的任何修改都只影响副本，而原件丝 毫不受影响。要将列表的副本传递给函数，可以像下面这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">function_name(list_name_[:])<br></code></pre></td></tr></table></figure><p>虽然向函数传递列表的副本可保留原始列表的内容，但除非有充分的理由，否则还是应该将原始列表传递给函数。这是因为让函数使用现成的列表可避免花时间和内存创建副本，从而提高效率，在处理大型列表时尤其如此。</p><p><strong>传递任意数量的实参</strong></p><p>有时候，预先不知道函数需要接受多少个实参，好在Python允许函数从调用语句中收集任意数量的实参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">eat_food</span>(<span class="hljs-params">name,*food</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span> eats <span class="hljs-subst">&#123;food&#125;</span>&quot;</span>)<br>eat_food(<span class="hljs-string">&#x27;xmm&#x27;</span>,<span class="hljs-string">&#x27;burger&#x27;</span>,<span class="hljs-string">&#x27;rice&#x27;</span>,<span class="hljs-string">&#x27;chicken&#x27;</span>,<span class="hljs-string">&#x27;cola&#x27;</span>)<br></code></pre></td></tr></table></figure><p>形参名中的星号让Python创建一个名为<code>food</code>的空元组，并将收到的所有参数都封装到这个元组中。</p><p>如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。</p><p><strong>使用任意数量的关键字实参</strong></p><p>有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。</p><p>在这种情况下，可将函数编写成能够接受任意数量的键值对——调用语句提供了多少就接受多少。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_dec</span>(<span class="hljs-params">first,last,**user_info</span>):<br>user_info[<span class="hljs-string">&#x27;fn&#x27;</span>]=first<br>user_info[<span class="hljs-string">&#x27;ln&#x27;</span>]=last<br><span class="hljs-keyword">return</span> user_info<br>dic=build_dec(<span class="hljs-string">&#x27;albert&#x27;</span>,<span class="hljs-string">&#x27;leo&#x27;</span>,location=<span class="hljs-string">&#x27;princeton&#x27;</span>, field=<span class="hljs-string">&#x27;physics&#x27;</span>)<br><span class="hljs-built_in">print</span>(dic)<br></code></pre></td></tr></table></figure><p>函数定义要求提供名和姓，同时允许根据需要提供任意数量的名称值对。形参<code>**user_info</code>中的两个星号让 Python创建一个名为<code>user_info</code> 的空字典，并将收到的所有名称值对都放到这个字典中。</p><p>注意：你经常会看到形参名<code>**kwargs</code> ，它用于收集任意数量的关键字实参。</p><p><strong>将函数存储在模块中</strong></p><p>使用函数的优点之一是可将代码块与主程序分离。通过给函数指定描述性名称，可让主程序容易理解得多。你还可以更进一步，将函数存储在称为模块的独立文件中，再将模块通过<code>import</code>导入到主程序 中。</p><p>导入模块的方法有多种，下面对每种进行简要的介绍。</p><p>(1) 导入整个模块</p><p>要让函数是可导入的，得先创建模块。模块是扩展名为.py的文件，包含要导入到程序中的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建pizza.py，在主程序中导入</span><br><span class="hljs-keyword">import</span> pizza<br>pizza.f1()<br>pizza.f2()<br></code></pre></td></tr></table></figure><p>(2) 导入特定的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建pizza.py，在主程序中导入特定函数fn1()、fn2()</span><br><span class="hljs-keyword">from</span> pizza <span class="hljs-keyword">import</span> fn1,fn2<br>fn1()<br>fn2()<br></code></pre></td></tr></table></figure><p><strong>使用as 给函数指定别名</strong></p><p>如果要导入函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pizza <span class="hljs-keyword">import</span> fn1 <span class="hljs-keyword">as</span> f1<br>f1()<br></code></pre></td></tr></table></figure><p><strong>使用as 给模块指定别名</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pizza <span class="hljs-keyword">as</span> p<br>p.fn1()<br>p.fn2()<br></code></pre></td></tr></table></figure><p><strong>导入模块中的所有函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pizza <span class="hljs-keyword">import</span> *<br>fn1()<br>fn2()<br></code></pre></td></tr></table></figure><p>最好不要采用这种导入方法，Python可能遇到多个名称相同的函数或变量，进而覆盖函数，而不是分别导入所有的函数。</p><p>最佳的做法是，要么只导入需要使用的函数，要么导入整个模块并使用句点表示法。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>要看的书</title>
    <link href="/2022/09/01/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/09/01/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<hr><p><a class="btn" href="https://www.jianshu.com/p/8f73d05a93c3" title="title">逃避自由</a></p><p><a class="btn" href="https://blog.csdn.net/qq_42406643/article/details/103644256" title="title">优化方法</a></p><p><a class="btn" href="https://blog.csdn.net/weixin_46864174/article/details/119146172?spm=1001.2014.3001.5501" title="title">梯度下降</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小样本学习综述</title>
    <link href="/2022/08/31/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/"/>
    <url>/2022/08/31/%E5%B0%8F%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<hr><p><a class="btn" href="https://www.cnblogs.com/jiangxinyang/p/12163215.html#:~:text=Task-invariant%E6%98%AF%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%A4%A7%E7%9A%84%E4%B8%94%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9B%B8%E4%BC%BC%E7%9A%84source,%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8A%E8%AE%AD%E7%BB%83%E4%B8%80%E4%B8%AA%E5%B5%8C%E5%85%A5%E6%A8%A1%E5%9E%8B%EF%BC%8C%E7%84%B6%E5%90%8E%E7%9B%B4%E6%8E%A5%E7%94%A8%E4%BA%8E%E5%BD%93%E5%89%8D%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%AE%AD%E7%BB%83%E9%9B%86%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86%E5%B5%8C%E5%85%A5%E3%80%82" title="title">FSL综述</a></p><h3 id="小样本学习："><a href="#小样本学习：" class="headerlink" title="小样本学习："></a>小样本学习：</h3><p>在样本很少的情况下，不足以训练一个神经网络，只能提供一些参考信息。</p><p>举个例子，下面这张图，人能根据左边这个很小的数据集总结出犰狳和穿山甲的区别，正确地对新的样本进行分类，但是机器不能。<img src="/../img/image-20220925163936847.png" alt="image-20220925163936847"></p><h3 id="FSL和传统机器学习的区别："><a href="#FSL和传统机器学习的区别：" class="headerlink" title="FSL和传统机器学习的区别："></a>FSL和传统机器学习的区别：</h3><p>FSL的目标不是让机器能够识别训练集里的图片，并泛化到测试集，而是让机器自己学会学习。</p><ul><li>FSL的测试样本是以前从未见过的东西，而传统神经网络已经见了几百上千次了</li><li>FSL的训练集里没有query sample的类别</li></ul><p><img src="/../img/image-20220925164330392.png" alt="image-20220925164330392"></p><p>例如上面这个数据集，FSL的目标并不是让机器学习这些动物图片，并能够识别没见过的哈士奇或者鹦鹉。而是<strong>理解模型的异同，区分不同的事物。</strong>在训练完成后，我们问的问题是：下面这两张图片，是同一种东西吗？这时模型机已经学会了分辨异同，知道这两张图片都是同一种东西，但是如果没有告诉他这是松鼠，他并不知道，也不用知道他们其实是松鼠。</p><p><img src="/../img/image-20220925164750331.png" alt="image-20220925164750331"></p><p>Support Set和训练集的区别：训练集是一个很大的，用来训练神经网络的数据集，但是Support Set只能训练提供一些额外信息。</p><p>例如下图，FSL并不知道query是什么，但是在给出Support Set后，FSL开始把query和Support Set里的动物类型进行比对，发现query和Otter最相似，所以把query分类为Otter。</p><p><img src="/../img/image-20220925165147799.png" alt="image-20220925165147799"></p><h3 id="元学习Meta-Learning"><a href="#元学习Meta-Learning" class="headerlink" title="元学习Meta Learning"></a>元学习Meta Learning</h3><p>笼统地说，FSL就是元学习。元学习和传统的监督学习不一样，传统学习要求模型去识别训练数据，并能泛化到测试数据。而元学习的目标是让模型学会怎么自己去学习。</p><p><img src="/../img/image-20220925174038715.png" alt="image-20220925174038715"></p><p>如上图，小朋友的学习资料只有这堆卡片，如果只靠一张图片就能识别是不是Otter，就叫One-Shot-Learning。</p><h3 id="FSL术语："><a href="#FSL术语：" class="headerlink" title="FSL术语："></a>FSL术语：</h3><p><img src="/../img/image-20220926012333714.png" alt="image-20220926012333714"></p><ul><li>K-way：Support Set里有多少个类别，本例中有6个类别</li><li>N-shot：每个类里有多少个样本，本例中有每个类里有1个样本</li></ul><p>因此，这是一个6-way 1-shot的Support Set。</p><p><img src="/../img/image-20220926013140024.png" alt="image-20220926013140024"></p><p>如图所示，随着Support Set里的类别增加，FSL分类的准确性会降低，因为在给出一个样本，然后和Support Set里的每一个类进行比较的过程中，1/3的正确率明显要大于1/10。</p><p><img src="/../img/image-20220926013730483.png" alt="image-20220926013730483"></p><p>随着每个类的样本数增加，做预测越容易，准确率越高。</p><h3 id="FSL的中心思想："><a href="#FSL的中心思想：" class="headerlink" title="FSL的中心思想："></a>FSL的中心思想：</h3><p>学习一个函数，然后判断Similaritu相似度。把函数记为<script type="math/tex">sim(x,x')</script>，可以比较两张图片$x$和$x’$的相似度，两个图片越相似，输出值越高。</p><p><img src="/../img/image-20220926014110093.png" alt="image-20220926014110093"></p><p>这里有三张图片，分别是斗牛犬、斗牛犬和狐狸，最理想的情况是把$x_1 , x_2$作为输入，sim函数输出1，意思是这两张图片是相同的动物，而把$x_1 ,x_3$或者$x_2,x_3$作为输入时，函数输出0，意思是这是两种完全不一样的动物。</p><p>具体实现：从一个很大的数据集上学习一个相似度函数，可以判断两张图的相似度有多高。然后把query和Support Set里的图片逐一计算相似度，返回相似度最高的class为结果。</p><p><img src="/../img/image-20220926014743390.png" alt="image-20220926014743390"></p><p>用这种方式，可以做到One-Shot-Learning。</p><h3 id="常用数据集："><a href="#常用数据集：" class="headerlink" title="常用数据集："></a>常用数据集：</h3><ul><li>Omniglot手写字体数据集，50个字母表，每个字母表24个字符，每个字符由20个人手写。</li></ul><p><img src="/../img/image-20220926014932600.png" alt="image-20220926014932600"></p><ul><li><p>Mini-ImageNet</p><p><img src="/../img/image-20220926015120240.png" alt="image-20220926015120240"></p></li></ul><h3 id="孪生-连体网络Siamese-Network"><a href="#孪生-连体网络Siamese-Network" class="headerlink" title="孪生/连体网络Siamese Network"></a>孪生/连体网络Siamese Network</h3><p>这个方法对输入的结构进行限制并自动发现可以从新样本上泛化的特征。通过一个有监督的基于孪生网络的度量学习来训练，然后重用那个网络所提取的特征进行one/few-shot学习。</p><p>两种训练方法：</p><h4 id="第一种训练方法："><a href="#第一种训练方法：" class="headerlink" title="第一种训练方法："></a>第一种训练方法：</h4><p>每次取两个样本，分别计算它们的相似度。</p><p><img src="/../img/image-20220926015331293.png" alt="image-20220926015331293"></p><p>这是一个很大的数据集，我们需要用训练集来构造正样本和负样本，正样本告诉神经网络什么是同一类，负样本告诉神经网络事物之间的区别。</p><p>Positive Samples：每次从训练集中随机抽取一张图片，然后从和这张照片的同一类里抽取另一张图片，并把标签设置为1，意思为相似度满分。 </p><p>Negative Samples：每次从训练集中随机抽取一张图片，然后从和这张照片不同的类里抽取另一张图片，并把标签设置为0，意思是完全不相似。 </p><p><img src="/../img/image-20220926015839134.png" alt="image-20220926015839134"></p><p>搭一个神经网络来提取特征，这个神经网络有很多卷积层，和一个平面层，输入是一张图片，输出是提取的特征向量。</p><p><img src="/../img/image-20220926020017283.png" alt="image-20220926020017283"></p><p>现在开始训练一个神经网络，刚才已经准备好了训练数据，把两张图片作为输入，输进刚刚搭建好的卷积神经网络f，卷积神经网络输出刚刚提取的特征向量$h_1$，$h_2$。</p><p>因为这两个输入共享了特征提取的部分，所以叫孪生/连体网络。</p><p>然后拿$h_1$减去$h_2$得到一个向量，再对这个这个向量的所有元素求绝对，表示这两个向量的区别，即$z=|h_1-h_2|$，再用一些权连接层处理这个向量$z$，输出一个标量，然后用$Sigmoid$激活函数，得到的输出是一个介于0-1之间的实数，这个输出就可以用来衡量两个图片之间的相似度。</p><p><img src="/../img/image-20220926173317759.png" alt="image-20220926173317759"></p><p>在输入两张图片的时候，我们已经准备好了标签，因为这是两张同类的图片，所以标签为1，而我们经过训练得到的函数输出可能不是1，将标签与预测值相减，得到的就是损失函数Loss。</p><p>有了损失函数，就可以用反向传播计算梯度，然后用梯度下降来更新参数。</p><p>模型主要有两个部分：</p><ul><li>一个是CNN卷积神经网络f，用来从图片汲取特征。</li><li>另一部分是权连接层，用来预测相似度。</li></ul><p>训练的过程就是更新这两部分的参数。</p><p><img src="/../img/image-20220926174827528.png" alt="image-20220926174827528"></p><p>作反向传播，梯度从Loss函数反向传播到梯度z，就可以更新权连接层的参数来，然后进一步传播到卷积层f，就可以进而更新卷积层的参数，这样就完成了一轮训练。</p><p>做训练的时候，要准备同样数量的正样本和负样本，标签分别设为1和0。</p><p>训练好模型后，就可以用这个模型来做One-Shot-Prediction，注意的是，这里Support Set里的类别都不在训练集里，然后给出Query，让模型在Support Set里进行多选一，这就是FSL的困难之处。</p><p><img src="/../img/image-20220926175455066.png" alt="image-20220926175455066"></p><p>如上图，模型选择了小松鼠。</p><h4 id="第二种训练方法："><a href="#第二种训练方法：" class="headerlink" title="第二种训练方法："></a>第二种训练方法：</h4><p>想要使用Triplet Loss，要这样准备训练数据：</p><p><img src="/../img/image-20220926175943492.png" alt="image-20220926175943492"></p><p>在给定的数据集里，先随机选择一张图片作为锚点anchor，然后再从这张图片的同一类里随机选择另一种图片作正样本positive，再从别的随机一类里抽一张图片作负样本negative。</p><p>把这三张图片一起输入同一个神经网络f（孪生网络的中心思想就是共用同一个卷积神经网络），分别提取这三个特征向量，然后计算正负样本和锚点在特征空间上的距离，相减后计算其二范数的平方，得到距离。</p><p><img src="/../img/image-20220926180744654.png" alt="image-20220926180744654"></p><p>我们希望得到这样一个特征，相同类别的特征向量都聚在一起，不同类别的特征向量都分得很开，因此结果应该符合这样的特征：$d^+$很小，$d^-$很大。</p><p>举个例子，卷积神经网络得出的特征向量映射出的特征图片如图所示。</p><p><img src="/../img/image-20220926181021129.png" alt="image-20220926181021129"></p><p>基于我们的期望，我们这样定义损失函数：鼓励正样本接近锚点，$d^+$很小，鼓励负样本远离锚点，$d^-$很大。</p><p>我们自己指定一个margin，记作$\alpha$，这是一个超参数，需要我们自己来调。</p><p>如果$d^-$比$d^+$大了$\alpha$，我们就认为这一组样本分类是正确的，Loss等于0，如果不满足，就认为这个模型分不开正负样本，那么就会有Loss，把Loss定义为$d^+ +\alpha -d^-$。我们希望Loss越小越好，因此定义完整的Loss损失函数为：</p><script type="math/tex; mode=display">Loss(x^a,x^+,x^-)=\max(0,d^+ +\alpha -d^-)</script><p>即使一下，意思是$x^a,x^+,x^-$为输入，定义损失函数为：如果$d^-&gt;d^+ +\alpha $，说明模型可以把正负样本分开，损失函数记为0，如果$d^-&lt;d^+ +\alpha $，说明模型是个废物，差异这么小，根本分不开，损失函数就记为$d^+ +\alpha -d^-$，直到损失函数变为0，能分开二者为止。</p><p><img src="/../img/image-20220926183220869.png" alt="image-20220926183220869"></p><p>有了损失函数，就可以求损失函数关于CNN神经网络参数的梯度，然后做梯度下降来更新模型参数。训练好神经网络后，就可以进行OSL。</p><p>如下图，在用做好的CNN提取特征向量后，把Support Set和Query的图片都变成特征向量，然后比较特征向量之间的距离，计算可得，和小松鼠的距离最小，因此这是一只小松鼠。</p><p><img src="/../img/image-20220926183631963.png" alt="image-20220926183631963"></p><p>注意：孪生网络虽然很简单，但并不是准确率最高的做法，这几年发表的论文里，基本上都是inflecting，把图片映射成神经网络这种做法，思路和孪生网络还是很像的。</p><h3 id="Pratraining-and-Fine-Tuning"><a href="#Pratraining-and-Fine-Tuning" class="headerlink" title="Pratraining and Fine Tuning"></a>Pratraining and Fine Tuning</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>这是一种很简单的方法，基本思想是在一个规模很大的数据集上先预训练模型，然后在小规模的Support Set上做fine-tuning，方法虽然简单但是准确率还是挺高的。</p><h5 id="余弦相似度-——-Cosine-Similarity"><a href="#余弦相似度-——-Cosine-Similarity" class="headerlink" title="余弦相似度 —— Cosine Similarity"></a>余弦相似度 —— Cosine Similarity</h5><p>用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异的大小。相比距离度量，余弦相似度更加注重两个向量在方向上的差异，而非距离或长度上。</p><p>对于长度不等1的向量，用下面这个公式来计算Cosine Similarity：</p><p><img src="/../img/image-20220927001733597.png" alt="image-20220927001733597" style="zoom: 50%;"></p><p><img src="/../img/image-20220927003427883.png" alt="image-20220927003427883"></p><p>如上图中，因为x和w的长度都为1，他们的二范数都为1，所以他们的余弦相似度就是他们的内积。可以这么理解向量相似度，把向量x投影到w这个方向上，这段投影的长度就是Cosine Similarity，投影的长度在-1到+1之间。</p><h5 id="Softmax函数"><a href="#Softmax函数" class="headerlink" title="Softmax函数"></a>Softmax函数</h5><p>二分类问题必须用到的就是逻辑回归算法，它负责将线性模型输出的实数域映射到[0, 1]这个表示概率分布的有效实数空间。</p><p>例如使用逻辑回归算法预测患者是否有恶性肿瘤的二分类问题中，输出层可以只设置一个节点，表示良性肿瘤发生的概率为 $P(A | x)$ ，其中x为患者的一些特征指标，作为输入。而双节点输出的二分类就相当于多了一个$P(\overline{A}|x)$表示的恶性肿瘤发生的概率，并满足约束各个输出节点的输出值的和为1。</p><p>有没有将各个输出节点的输出值范围映射到[0, 1]，并且约束各个输出节点的输出值的和为1的函数呢？这个函数就是Softmax函数。</p><p>给出Softmax函数的定义（以第i个节点输出为例）：</p><script type="math/tex; mode=display">Softmax(z_i)=\frac{e^{z_i}}{∑_{c=1}^{C}e^{z_c}}</script><p>zi 为第i个节点的输出值，C为输出节点的个数，即分类的类别个数。通过Softmax函数就可以将多分类的输出值转换为范围在[0, 1]内的和为1的概率分布。</p><p><img src="/../img/image-20220927005430747.png" alt="image-20220927005430747"></p><p>那么它是怎么把一个向量映射成一个概率分布的呢？</p><p>Softmax的输入是$\phi$，它是任意的k维向量，每一个方向都是输入在这个类上的相似度，把$\phi$的每一个元素做指数变换，得到k个大于0的数，然后对结果做上面公式所示的归一化，让得到的k个数相加等于1，把得到的k个数记做向量p，这个向量p就是softmax函数的输出，因此，它们相加是肯定等于1的，所以，p也是一个概率分布，。</p><p>softmax函数常用于分类器的输出层，如果有k个类别，那么softmax的输出就是k个概率值，每个概率值表示对一个类别的confidence，这里举个例子：</p><p><img src="/../img/image-20220927011127183.png" alt="image-20220927011127183"></p><p>左边是输入，右边是输出。不同于max函数把最大值变1，其余值变0的操作，softmax()的作用是让最大值变大，其余值变小，但是最大值也没有大到1，这是指数化的作用。</p><p><img src="/../img/image-20220927011517529.png" alt="image-20220927011517529"></p><p>softmax分类器是由一个权连接层加一个softmax函数组成的，分类器输入是向量x，输出是向量p，假如类别数量等于k，那么向量p就是k维的。</p><p>矩阵W和向量b是这一层的参数，可以从训练数据中学习，所以W的每一行对应一个类别，每一列对应一个特征，输入x显示的是这个图片的不同特征，经过$Wx+b$变换后得到一个k维向量，对其使用Softmax激活函数后，得到的就是一个k维向量p。</p><h5 id="cross-Entropy交叉熵"><a href="#cross-Entropy交叉熵" class="headerlink" title="cross Entropy交叉熵"></a>cross Entropy交叉熵</h5><p>有时，我们可能希望预测的概率分布接近我们观察到的数据的分布，也就是说，我们希望一种分布（可以是概率向量）与另一种分布接近， 而交叉熵为我们提供了一种自然的方法测量两个分布之间的差距，这个差距就可以被当作损失函数。</p><p>香农提出的<strong>熵的定义</strong>：无损编码事件信息的最小平均编码长度。</p><p><img src="/../img/v2-8de58ebed3434892762f5809c1320462_1440w.jpg" alt="img" style="zoom:50%;"></p><p>举个例子，下图传消息时，明显方式3编码长度最小，且是平均意义上的最小。方式3胜出的原因在于：对高可能性事件(Fine,Cloudy)用短编码，对低可能性事件(Rainy,Snow)用长编码。<img src="/../img/v2-73be23174f9ab59fe8ea5b2aa3e38f00_1440w.jpg" alt="img"></p><h6 id="如何直接计算熵？"><a href="#如何直接计算熵？" class="headerlink" title="如何直接计算熵？"></a>如何直接计算熵？</h6><p>再举个例子，假设一个信息事件有8种可能的状态，且各状态等可能性，即每一种可能性都是12.5%=1/8。我们需要多少位来编码8个值呢？</p><p>1位可以编码2个值(0或1)，2位可以编码2×2=4个值(00,01,10,11)，则8个值需要3位，2×2×2=8(000,001,010,011,100,101,110,111)。</p><p>归纳来看，对于具有N种等可能性状态的信息，每种状态的可能性P = 1/N，编码该信息所需的最小编码长度为：</p><script type="math/tex; mode=display">log_2 N=-log_2 P</script><p>那么计算平均最小长度，也就是熵的公式为：</p><script type="math/tex; mode=display">Entropy=-\sum_i P(i)log_2 P(i)</script><p>其中P(i)是第i个信息状态的可能性。</p><p>同理，对于连续变量 x 的概率分布P(x)，熵的公式可以表示为：</p><script type="math/tex; mode=display">Entropy=-\int P(i)log_2 P(i)dx</script><p>因此，只要我们知道了任何事件的概率分布，我们就可以计算它的熵。但如果在不知道的情况下，我们需要对它做一个估计，这就引出了交叉熵。</p><h6 id="熵的估计"><a href="#熵的估计" class="headerlink" title="熵的估计"></a>熵的估计</h6><h4 id="FSL思想："><a href="#FSL思想：" class="headerlink" title="FSL思想："></a>FSL思想：</h4><p>大多数FSL学习都基于类似的想法，先用一个大数据集来预训练一个神经网络，用来从图片中提取特征，然后用这个神经网络把query和Support Set中的图片都映射成特征向量，再比较特征空间上的相似度，比如可以计算两两之间的consine similarity，最后选择相似度最高的，作为对Query分类的结果。</p><p>预训练有很多种方法，包括传统的监督学习，训练好之后把权连接层都去掉，也可以用孪生网络，都可以。但这个神经网络的结构和训练方法都会对最终结果产生影响。</p><h4 id="FSL常用分类方法："><a href="#FSL常用分类方法：" class="headerlink" title="FSL常用分类方法："></a>FSL常用分类方法：</h4><p><img src="/../img/image-20220927013600678.png" alt="image-20220927013600678"></p><p>这是一个共三类，每类两个的Support set，对这六张图片分别进行特征提取。然后对相同类提取出的特征向量取均值，就作为小松鼠或者小狗狗这一总类的对照向量。然后对这个向量进行归一化（方法各异，可以采用不同的激活函数，怎么都可以），分别得到$\mu_1,\mu_2,\mu_3$，他们的二范数都等于1，这就是对这三个类别的表征。做分类的时候，就拿query的特征向量跟这三个向量分别作对比（可以采用cosine similarity，也是怎么都可以）。</p><p><img src="/../img/image-20220927014332395.png" alt="image-20220927014332395"></p><p>把query特征提取再归一化后，得到一个向量q，然后再对Support set里的三个类做相同操作，把得到的三个$\mu$向量堆叠起来，作为矩阵M的三个行向量。把q乘到矩阵M上，然后再做softmax变换，得到一个概率分布的向量p，每个元素表示对该类别的confidence，这时候做内积就等于在求cosine similarity。</p><p><img src="/../img/image-20220927014926040.png" alt="image-20220927014926040"></p><p>很明显是$\mu_1$，也就是模型认为结果是第一类——小松鼠。</p><h4 id="Fine-Tuning"><a href="#Fine-Tuning" class="headerlink" title="Fine-Tuning"></a>Fine-Tuning</h4><p>一般训练完神经网络后就要直接开始预测了，这时候我们在这两部分之间插入fine-tuning，，用support set进一步做训练，可以更好的提高准确率。</p><p>这种方法已被广泛地应用。获得一定量的标注数据，然后基于一个基础网络进行微调。这个基础网络是通过含有丰富标签的大规模数据集获得的，比如imagenet，我们的淘宝电商数据，称为通用数据域。然后在特定数据域上进行训练。训练时，会固定基础网络部分的参数，对领域特定的网络参数进行训练（这里有很多训练的trick，包括如何设置固定层和学习率等）。这个方法相对较快，依赖数据量也不必太多，效果还行。</p><p>刚刚我们用的是神经网络在训练集上预训练好的W和b，在比较Support set和query时直接固定这些参数，但其实我们可以在support set上学习W和b，这就叫做Fine tuning。</p><p><img src="/../img/image-20220928014751753.png" alt="image-20220928014751753"></p><p>学习过程：用交叉熵衡量真实标签(one-hot向量形式)与预测标签的差别有多大，得到一个损失函数，Support Set里有几个或者几十个这样的样本，每一个样本都对应一个交叉熵损失函数，把这些函数都加起来作为目标函数，对目标损失函数做最小化，让预测标签尽量接近真实标签。</p><p>这个最小化是相对于分类器参数W和b求的，希望学习W和b。当然也可以让梯度反向传播会卷积神经网络，更新神经网络参数，让提取的特征向量更有效。</p><p>但是由于Support Set通常很小，所以最好加一个regularization来防止过拟合。有多种regularization可供选择，其中entropy regularization较为合理。</p><h5 id="技巧一：初始化参数："><a href="#技巧一：初始化参数：" class="headerlink" title="技巧一：初始化参数："></a>技巧一：初始化参数：</h5><p>做Fine-Tuning的时候，我们想要从Support Set中学习这样一个Softmax分类器：矩阵W和向量b是分类器的参数。但由于Support Set中的样本数量太少了，如果随机初始化参数，最终结果并不理想。</p><p>因此，可以把W初始化为前面得出的矩阵M，把b初始化为全零向量。</p><p><img src="/../img/image-20220928015328051.png" alt="image-20220928015328051"></p><p>在矩阵M中，有几个类就有几行，每一行代表的是该类的均值向量，之前我们用的就是固定M，并把b设为0向量进行softmax的方法，这样做的情况下，哪怕不做训练，用这样固定的设置就已经有了很好的效果。</p><p>所以这是一个很合理的初始化方法。</p><h5 id="技巧二：防止过拟合"><a href="#技巧二：防止过拟合" class="headerlink" title="技巧二：防止过拟合"></a>技巧二：防止过拟合</h5><p><img src="/../img/image-20220928022725476.png" alt="image-20220928022725476"></p><p>把query看作输入x，经过特征提取后得到f(x)，把f(x)输入softmax分类器，得到预测p向量，p是个概率分布，每一个元素都是一个概率值，可以用Entropy来衡量概率分布p的信息量，如第三行公式所示。这是用一个样本x求出的Entropy，通常会有多个query图片，对于每个query，求出一个Entropy，然后对其取平均，所有Entropy的均值就是Entropy regularization。</p><p>我们希望Entropy regularization越小越好。</p><p><img src="/../img/image-20220928023403969.png" alt="image-20220928023403969"></p><p>假设分类问题有三个类别，分类器输出每个类别的概率值，左图所示的情况三个概率值差不多，说明分类器判别不出query图片属于哪一类，我们不喜欢这种结果。右图分类器则认为query属于第二类，而且非常有信心，这就是我们想要的结果。</p><h5 id="技巧三：结合consine-Similarity和softmax分类器"><a href="#技巧三：结合consine-Similarity和softmax分类器" class="headerlink" title="技巧三：结合consine Similarity和softmax分类器"></a>技巧三：结合consine Similarity和softmax分类器</h5><p>根据最新论文表明，这种方法可以显著提高分类准确率。</p><p><img src="/../img/image-20220928024230677.png" alt="image-20220928024230677"></p><p>本来是直接向量相乘就softmax的，现在先把$w^Tq$作归一化处理，然后再和b向量相加。</p><p>根据相关论文，这个很小的改动就可以大幅度提高准确率。</p><h3 id="小样本学习综述"><a href="#小样本学习综述" class="headerlink" title="小样本学习综述"></a>小样本学习综述</h3><p>本文根据机器学习中的误差分解理论，认为FSL任务中最小化经验风险是不可信的，这也是FSL难以训练的原因。</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h6 id="Notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h6><p>通常而言，一个N-way K-shot的分类任务，假定任务的真实分布为$𝑝(𝑥,𝑦)$，而这个真实分布有一个最优假设$ℎ̂$可以描述它。通常的做法是给定一个假设空间𝐻，然后从里面找一个接近$ℎ̂$的假设$ℎ$，在这里𝐻是由你选择的模型和参数的初始化分布决定的，用一些优化方法（通常为梯度下降）来逼近这个最优假设。</p><h6 id="Problem-Definition"><a href="#Problem-Definition" class="headerlink" title="Problem Definition"></a>Problem Definition</h6><p>在经典机器学习中，给定一个任务T，任务的性能P，给定一些额外的条件E，比如标注的训练数据，可以提升任务T的性能P，FSL任务本质也是这样。</p><h6 id="Relevant-Learning-Problems"><a href="#Relevant-Learning-Problems" class="headerlink" title="Relevant Learning Problems"></a>Relevant Learning Problems</h6><p>FSL可以是各种形式的学习，监督，半监督，强化学习，迁移学习等等，弱监督学习是强调在不完整、不准确、有噪声、数据少的数据上学习，半监督学习是强调在少量标注数据和大量非标注数据上学习，迁移学习是把充足数据上学习的知识迁移到数据匮乏的任务上。本质上的定义取决于可用的数据。</p><p>当然，大多数时候用的都是meta learning，直接把它看作meta learning就行。</p><h5 id="Core-Issue"><a href="#Core-Issue" class="headerlink" title="Core Issue"></a>Core Issue</h5><p>在机器学习中寻找最适合的模型时，通常都是通过找到一组最优的参数来确定这个模型，并通过给定的训练集，最小化损失函数这一目标来指示最优参数的搜索，最小化损失函数如下所示：</p><p>　　　　<img src="/../img/1335117-20200107180341483-79584449.png" alt="img"></p><p>h就是我们企图逼近最优模型$ℎ̂$的模型，y是真实标签，l是损失函数，对每一个训练样本的损失函数进行求和，找到这个和的最小值。</p><p>在训练模型中，我们是通过训练集来拟合真实分布，我们训练出来的分布和真实分布往往不一样，这中间的差值称为期望风险（期望损失），表达式如下：</p><p>　　　　<img src="/../img/1335117-20200107181052551-1263293547.png" alt="img"></p><p>p为真实分布，要求对损失函数求期望，需要将它放到以真实分布为坐标轴的维度上，它与坐标轴围成的面积就是期望损失。</p><p>理论上说，让期望风险最小化才能逼近真实分布，但因为真实分布只有神知道，因此最小化期望风险是无法实现的，而在机器学习中通常用经验风险来替换期望风险，经验风险就是在训练集上预测的结果和真实结果的差异，也是我们常说的损失函数，表达式如下：</p><p><img src="/../img/image-20221009224149062.png" alt="image-20221009224149062" style="zoom:50%;"></p><p>给出符号描述：</p><p><img src="/../img/image-20221009224256524.png" alt="image-20221009224256524"></p><p>$ℎ̂ $是真实分布的模型，$ℎ∗$是假设空间$𝐻$中最接近$ℎ̂ $的模型，而$h_I$是通过最小化经验损失得到的模型。根据机器学习中的误差分解可得：</p><p><img src="/../img/1335117-20200107181555284-1137027787.png" alt="img"></p><p>等式右边第一项只能靠玄学，我们能做到的只有选个合适的模型，有时候模型选择的简单了，给再多的数据也训练不好，欠拟合。</p><p>第二项就是我们训练得到的模型和𝐻中最优模型的误差，有时候训练的太好会陷入局部最优，或者提供的训练数据分布有偏差，导致无法到全局最优。</p><p>但理论上对于第二项，当样本数量𝐼足够大时，有：</p><p><img src="/../img/1335117-20200107182014950-124597622.png" alt="img"></p><p>即只要样本够多，没有做不出来的模型。</p><p>传统的机器学习都是建立在大规模的训练数据上的，因此𝜀𝑒𝑠𝑡(𝐻,𝐼)是很小的，但是在FSL任务上，训练数据很小，因此𝜀𝑒𝑠𝑡(𝐻,𝐼)是很大的，所以此时采用传统的训练模式，如softmax+交叉熵，是极容易陷入过拟合的，这个应该很好理解。</p><p>针对上面的问题再去拓展寻求解决方案，在机器学习中正则化是一项，正则化可以约束你的假设空间𝐻，但是在FSL中不行，它的约束是没有指示性的，而FSL中的约束是需要有指示性的，即能指示你更好的接近真实假设。引入霍夫丁不等式：</p><p><img src="/../img/1335117-20200107183222190-1115277030.png" alt="img"></p><p>给定样本复杂度为S，保证上述不等式能在ϵ很小且δ很小时成立时，需要给定的样本数I大于S，给定<a href="https://blog.csdn.net/shenxiaoming77/article/details/51881321">VC维理论</a>：</p><p><img src="/../img/image-20221010001459061.png" alt="image-20221010001459061" style="zoom:50%;"></p><p>知道就行了，算是对降低模型复杂度的理论支撑。</p><h4 id="Taxonomy"><a href="#Taxonomy" class="headerlink" title="Taxonomy"></a><strong>Taxonomy</strong></h4><p>如果把小样本学习比作一个黑盒子，给这个黑盒子喂少量的数据，凭什么能让它表现得好呢？显然我们需要外力来帮助，这个外力就是“先验知识”。</p><p>小样本学习的先验知识来自三方面：<strong>数据、模型、算法</strong>，小样本学习的研究也都是从这三方面着手。因此，小样本学习方法大致可分为基于<strong>数据增强</strong>的方法、基于<strong>模型改进</strong>的方法、基于<strong>算法优化</strong>的方法。</p><p>在这里作者将解决这个问题的方法分为了三类：Data，Model，Algorithm。具体的图如下：</p><p><img src="/../img/1335117-20200107184200179-1606317169.png" alt="img"></p><p><strong>一、基于数据增强的方法</strong></p><p>​    主要思路就是数据增强，通俗地讲就是扩充样本。想到数据增强，我们通常会想到平移、裁剪、翻转、加噪声等操作，但是这些操作可能在特定数据集表现很好，不具有普适性。而且设计这些操作需要对所处理的领域具有足够的了解。小样本学习所使用的数据增强方法主要有三个思路：</p><ol><li>只有小样本数据集：可以训练一个transformer学习样本之间的变化，然后使用该transformer对小样本数据集进行扩充；</li><li>有小样本数据集+弱标注数据集：可以训练transformer从弱标注数据集中“挑选”样本来扩充小样本数据集；</li><li>有小样本数据集+相似的数据集：可以训练一个GAN网络，通过学习给小样本数据集加上扰动来生成新样本。    </li></ol><p><img src="/../img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ1NTEzNQ==,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>基于数据的方法比较容易理解，但是存在的问题是：很多工作都不具备普适性，难以迁移到别的数据集。</p><p><strong>二、基于模型改进的方法</strong></p><p>每个模型经过迭代都会得到近似解，而当样本有限时，在假设空间搜索解就变得困难。这类方法为了缩小假设空间，主要有四种方法：</p><ol><li><p>多任务学习（Multitask Learning）：这种模型可以处理多个任务，因此也就兼备了模型的普适性和一般性。在处理多个任务时，模型的参数可以是共享的，也可以是相关联的；</p></li><li><p><strong>嵌入学习</strong>（Embedding Learning）：将样本映射到一个低维度空间，从而达到了缩小假设空间的效果，然后就可以通过少量的样本求出模型在该假设空间下的近似解。根据映射到低维空间的方法又分为三类：任务特定型（结合任务的具体特点进行映射）、通用型、结合型（结合任务和通用）；</p></li><li><p><strong>基于外部记忆的学习</strong>（Learning with External Memory）：通过对小样本数据集学习得到知识，然后存储到外部，对于新样本，都使用存储在外部的知识进行表示，并根据表示来完成匹配。这种方法大大降低假设空间；</p></li><li><p><strong>生成模型</strong>（Generative Modeling）：生成模型学习小样本数据集的数据分布，并可将其用于各种任务。</p></li></ol><p><strong>三、基于算法优化的方法</strong></p><p>这类方法的核心是通过改进优化算法来更快地搜索到合适解。主要方法有三种：</p><ol><li><p>改善已有参数：这种方法从<strong>参数初始化</strong>的角度着手，主要思路是借助已训练好的模型参数来调整小样本模型的参数，例如：在大数据集训练好模型来初始化小样本模型；聚合其他已训练好的模型到一个模型；给已训练好的模型加一些特别用于小样本任务的参数；等等。</p></li><li><p>改善元学习参数。元学习（meta-learning）是当下很火的一个研究方向，它的思想是学习如何学习。它的结构一般是由一个底层模型和一个顶层模型组成，底层模型是model的主体，顶层模型是meta-learner。更新参数时，它除了要更新底层model，还要更新meta参数。改善策略大致有三类：1）结合不同特定任务模型参数来对新任务的参数进行初始化；2）对模型不确定性建模，以备后续提升；3）改进参数调整流程。</p></li><li><strong>学习优化器。</strong>如下图所示，optimizer每次都迭代会更新上一次的模型参数，现在通过学习小样本数据集中每个迭代的更新值，从而应用在新的测试数据上。</li></ol><p><img src="/../img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ1NTEzNQ==,size_16,color_FFFFFF,t_70-20221021144046567.png" alt="img"></p><p>接下来的工作都是围绕这几个方向展开来求解FSL问题。</p><p><img src="/../img/1335117-20200107185138248-285067125.png" alt="img"></p><h5 id="DATA"><a href="#DATA" class="headerlink" title="DATA"></a>DATA</h5><p>　　数据增强的方式有很多种，平时也被使用的比较多，在这里作者将数据增强的方法概括成4类：　<img src="/../img/1335117-20200107195137257-1424668420.png" alt="img"></p><p>　　总之，数据增强没有什么神秘感，也是大家比较熟悉的，无论是手动在数据上修改，比如图片的旋转，句子中的同义词替换等，以及复杂的生成模型生成和真实数据相近的数据。数据增强的方式有很多种，大量的合适的增强一定程度上可以缓解FSL问题，但其能力还是有限的。</p><h5 id="MODEL"><a href="#MODEL" class="headerlink" title="MODEL"></a>MODEL</h5><p>　　为了完美收集样本的所有特征，我们一开始给一个假设空间𝐻很大的模型，然后通过一些先验知识将这个空间中无效的hypothesis去掉，缩小假设空间𝐻，这样做感觉很绕，但实际上和<a href="https://www.jianshu.com/p/8e1209d3127a">模型剪枝</a>中的理念类似，你一开始给一个小的模型，这个模型空间离真实假设太远了，而你给一个大的模型空间，它离真实假设近的概率比较大，然后通过先验知识去掉哪些离真实假设远的假设。</p><p>　　作者根据使用不同的先验知识将MODEL的方法分成4类：　　　　<img src="/../img/1335117-20200107200328079-2038936314.png" alt="img"></p><p>​        其中，<strong>多任务学习</strong>是比较常见的，对于多个共享信息的任务，可以是数据相同任务不同，也可以是数据和任务都不同，但是数据具有领域性等等，都可以用多任务学习来训练，多任务分为硬参数共享和软参数共享两种模式：<img src="/../img/1335117-20200107201451814-1465095916.png" alt="img"></p><p>　　硬参数共享认为任务之间的假设空间是有部分重叠的，体现在模型上就是有部分参数是共享的，而共享的参数可以是模型的前面一些层，表征任务的低阶信息。也可以是在嵌入层之后，不同的嵌入层将不同任务嵌入到同一不变任务空间，然后共享模型参数等等。</p><p>　　软参数共享不再显式的共享模型参数，而是让不同任务的参数相似，这就可以通过不同任务的参数正则，或者通过损失来影响参数的相似，以此让不同任务的假设空间类似。</p><p>　　多任务学习通过多个任务来限制模型的假设空间，对于硬参数共享，多个任务会有一个共享的假设空间，然后每个任务还有自己特定的假设空间；对于软参数共享也类似，软参数更灵活，但也需要精心设计。</p><p>​        <strong>嵌入学习</strong>很好理解，将训练集中所有的样本通过一个函数𝑓(.)嵌入到一个低维可分的空间𝑍，然后将测试集中的样本通过一个函数𝑔(.)嵌入到这个低维空间𝑍，然后计算测试样本和所有训练样本的相似度，选择相似度最高的样本的标签作为测试样本的标签，根据task-specific和task-invariant，以及两者的结合可以分为三种，嵌入学习如下：</p><p>　　　　<img src="/../img/1335117-20200107203731133-1752571664.png" alt="img"></p><p>　　Task-specific是在任务自身的训练集上训练的，通过构造“同类样本相同，不同类样本不同”的<strong>样本对</strong>作为数据集，这样数据集会有一个爆炸式的扩充，可以提高样本的复杂度，然后可以用如siamese network孪生网络等来训练，前面有讲。</p><p>　　Task-invariant是在一个大的且和任务相似的source数据集上训练一个嵌入模型，然后直接用于当前任务的训练集和测试集嵌入，前面也有讲。</p><p>　　但实际上现在用的比较多的还是两者的结合，既可以利用大的通用数据集学习通用特征，又可以在特定任务上学习特定的特征，而现在常用的训练模式是meta learning中的metric-based的方式，此类常见的模型有match network，prototypical network ，relation network等，详细可以见<a href="https://www.cnblogs.com/jiangxinyang/p/11346764.html">小样本学习（few-shot learning）在文本分类中的应用</a>。</p><p>​    <u>用具有外部存储机制的网络和生成式模型来学习不是很熟，学了迁移学习再看看。</u></p><h5 id="ALGORITHM"><a href="#ALGORITHM" class="headerlink" title="ALGORITHM"></a><strong>ALGORITHM</strong></h5><p>在FSL任务中，样本数量很少，许多梯度下降的优化方法都会失效。因此我们不再限制假设空间，根据使用不同的先验知识，可以将ALGORITHM分为下面3类：</p><h6 id="Refine-Existing-Parameters-theta-0"><a href="#Refine-Existing-Parameters-theta-0" class="headerlink" title="Refine Existing Parameters ${\theta} ^ {0}$"></a><img src="/../img/1335117-20200107211620794-1625958996.png" alt="img">Refine Existing Parameters ${\theta} ^ {0}$</h6><p>　　本质上就是我们常用的pretrained + fine-tuning的模式，最常见的就是直接在pretrianed的模型上直接fine-tuning参数，其他的还有可以在一个新的网络上使用pretrained的部分参数来初始化等等。</p><h6 id="Refine-Meta-learned-𝜃"><a href="#Refine-Meta-learned-𝜃" class="headerlink" title="Refine Meta-learned 𝜃"></a><strong>Refine Meta-learned 𝜃</strong></h6><p>基于meta learning的解决方法，利用元学习器<u>学习一个好的初始化参数</u>，之后在新的任务上，只要对这个初始化参数少量迭代更新就能很好的适应新的任务。</p><p>元学习区别于机器学习的是，机器学习通常是在拟合一个数据的分布，而元学习是在拟合一系列相似任务的分布，因此元学习的训练样本其实是一系列任务。</p><p>但这样的方式也有一个问题，就是新的任务的特性必须要和元训练中的任务相近，这样𝜃值才能作为一个较好的初始化值。否则效果会很差。因此也就有不少研究在根据新任务的数据集来动态的生成一个适合它的初始化参数。</p><h6 id="Learn-Search-Steps"><a href="#Learn-Search-Steps" class="headerlink" title="Learn Search Steps"></a><strong>Learn Search Steps</strong></h6><p>还没看RNN，不是很懂。</p><h4 id="FUTURE-WORKS"><a href="#FUTURE-WORKS" class="headerlink" title="FUTURE WORKS"></a><strong>FUTURE WORKS</strong></h4><p>未来的方向可以从：</p><ul><li>先验数据：例如利用更多的先验知识，多模态的数据等。</li><li>模型方法：用一些新的网络结构去替换以前的，比如用transformer替换RNN会不会有更好的结果</li><li>使用的场景：现在FSL也只是在字符识别，图像识别等取得不错的效果，在CV其他方向，如目标检测，目标跟踪，NLP中的各项任务上又是什么样的表现，该怎样改进；理论分析等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3.x 组件篇</title>
    <link href="/2022/08/25/vue3-x-%E7%BB%84%E4%BB%B6%E7%AF%87/"/>
    <url>/2022/08/25/vue3-x-%E7%BB%84%E4%BB%B6%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="Vue3-x从零开始学-组件篇"><a href="#Vue3-x从零开始学-组件篇" class="headerlink" title="Vue3.x从零开始学 组件篇"></a>Vue3.x从零开始学 组件篇</h1><h3 id="01-全局组件和复用性"><a href="#01-全局组件和复用性" class="headerlink" title="01.全局组件和复用性"></a>01.全局组件和复用性</h3><p><a href="https://jspang.com/article/69#toc32">一张图了解组件概念</a></p><p>一个完整的页面被分割成多个模块，这些模块就是组件。有两个以上的DOM元素，就可以用组件开发。</p><p><img src="/../img/image-20220919194751728.png" alt="image-20220919194751728"></p><p><strong>Vue中的组件是页面中的一部分，通过层层拼装，最终形成了一个完整的组件。这也是目前前端最流行的开发方式。</strong></p><p><code>Vue.createApp</code>实际是建立一个Vue的实例，也就是第一个<code>根组件</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;h2&gt;糖果屋&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;div&gt;小明明&lt;/div&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/69#toc34">全局组件的定义</a></p><p>现在页面有两个dom元素组成，可以把这两部分拆分成两个全局的字组件。代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/body&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123; </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">        &lt;website /&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">        &lt;describe/&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">`</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;) </span></span><br><span class="language-javascript"><span class="language-xml">    app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;website&#x27;</span>,&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;h2&gt;糖果屋&lt;/h2&gt;`</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;describe&#x27;</span>,&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;div&gt;小明明&lt;/div&gt;`</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> vm=app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>业务逻辑复杂这样拆分，会降低开发难度。</p><p><a href="https://jspang.com/article/69#toc35">组件的可复用性讲解</a></p><p>定义一个新的计数组件count，每次点击按钮，组件中的count变量自动加1.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;count&#x27;</span>,&#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span>&#123;<br>            <span class="hljs-attr">count</span>:<span class="hljs-number">0</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;div&gt;&#123;&#123;count&#125;&#125;&lt;button @click=&quot;count++&quot;&gt;增加1&lt;/button&gt;&lt;/div&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>在根组件中复用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;website /&gt;</span><br><span class="hljs-string">        &lt;describe /&gt;</span><br><span class="hljs-string">        &lt;count/&gt;</span><br><span class="hljs-string">                &lt;count/&gt;</span><br><span class="hljs-string">                &lt;count/&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>然后在浏览器中进行预览，你会发现对一个<code>count</code>变量进行加一动作后，只有他自己的变量会发生改变，不会影响别的组件里的<code>count</code>变量，所以每个组件都是互不干扰的，即使是同一类组件。</p><p>就是因为这个特性，Vue中的组件就具有了复用性。</p><p>弊端：<strong>只要定义了，处处可以使用，性能不高，会占用系统资源，但是使用起来简单。</strong></p><h3 id="02-局部组件"><a href="#02-局部组件" class="headerlink" title="02.局部组件"></a>02.局部组件</h3><p>局部组件可以看成一个变量，然后在使用的地方注册这个组件，才可以使用。局部组件的最大好处就是只有在使用的时候，才会耗费系统资源，不像全局组件一样，一直都存在。</p><p><a href="https://jspang.com/article/69#toc39">创建局部组件</a></p><p>注册局部组件，可以理解成声明一个变量，这个变量是一个对象，所以最外层我们使用大括号。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> counter = &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;&#123;&#123;count&#125;&#125;&lt;button @click=&quot;count++&quot;&gt;增加1&lt;/button&gt;&lt;/div&gt;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不同于全局组件，声明完组件后，还要在<code>vue.CreateApp（ ）</code>方法里进行注册。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123; <br>    <span class="hljs-attr">components</span>:&#123;counter&#125;,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;counter/&gt;</span><br><span class="hljs-string">`</span>&#125;) <br></code></pre></td></tr></table></figure><p>这是简写方法，正确的写法应该是<code>components: &#123;自定义一个命名:组件名&#125;</code> 。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>        <span class="hljs-attr">components</span>: &#123; <span class="hljs-attr">xmm</span>: counter &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;jspang /&gt;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，局部变量也是拥有独立性的，所以可以进行复用。</p><h3 id="03-父子组件的静态和动态传值"><a href="#03-父子组件的静态和动态传值" class="headerlink" title="03. 父子组件的静态和动态传值"></a>03. 父子组件的静态和动态传值</h3><p><a href="https://jspang.com/article/69#toc314">父组件向子组件传值（静态传值）</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123; <br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;h2&gt;Dad&lt;/h2&gt;</span><br><span class="hljs-string">        &lt;Son name=&#x27;xmm&#x27;/&gt;`</span><br>    &#125;) <br>    app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;Son&#x27;</span>,&#123;<br>        <span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;name&#x27;</span>],<br>        <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;Son &#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="hljs-string">        `</span><br>    &#125;)<br>    <span class="hljs-keyword">const</span> vm=app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>使用子组件里的props进行接收父组件传过来的参数，在子组件里作为字面量使用。</p><p><a href="https://jspang.com/article/69#toc315">动态数据作为参数</a></p><p>如果想让代码更加的灵活，这里可以使用动态参数的传递。</p><p>动态参数传递首先要把参数的具体值放到Vue的<strong>数据项</strong>里，也就是<code>data</code>属性里。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123; <br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">mingzi</span>:<span class="hljs-string">&#x27;sym&#x27;</span><br>            &#125;<br>        &#125;,<br><span class="hljs-comment">//在父组件的data属性里声明要传入的变量名，在模版中将子组件的变量名与父组件中的变量名进行绑定</span><br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;h2&gt;Dad&lt;/h2&gt;</span><br><span class="hljs-string">        &lt;Son :name=&#x27;mingzi&#x27;/&gt;`</span><br>    &#125;) <br>    app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;Son&#x27;</span>,&#123;<br>        <span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;name&#x27;</span>],<br>        <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;Son &#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="hljs-string">        `</span><br>    &#125;)<br>    <span class="hljs-keyword">const</span> vm=app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>静态参数这里还有一个小坑需要说明一下，就是静态传递的只能是字符串类型<code>String</code>，而动态传参的就可以是多种类型了，甚至是一个函数(方法).</strong></p><p>举例说明，比如我们现在改回静态传参，而传递的内容是数字<code>123</code>,但在模板中使用<code>typeof</code>查看属性时，仍然是字符串（String）。</p><p>改为静态传参，参数为<code>123</code>.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h2&gt;JSPang.com&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;Son name=&quot;123&quot; /&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>在子组件用<code>typeof</code>查看类型，会发现仍然是<code>string</code>类型.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;Son&#x27;</span>,&#123;<br>    <span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;name&#x27;</span>],<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;div&gt;&#123;&#123; typeof name&#125;&#125; div &lt;/div&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>但是改为动态传参，就变成了数字类型。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">name</span>:<span class="hljs-number">123</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;h2&gt;JSPang.com&lt;/h2&gt;</span><br><span class="hljs-string">        &lt;Son :name=&quot;name&quot; /&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/69#toc316">参数为函数时的用法</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123; <br>        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span>&#123;<br>                <span class="hljs-attr">pay</span>:<span class="hljs-function">()=&gt;</span>&#123;<br>                    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;you are free&#x27;</span>)<br>                &#125;<br>            &#125;<br>        &#125;,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;makeMoney :pay=&#x27;pay&#x27;&gt;`</span><br>    &#125;) <br>    app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;makeMoney&#x27;</span>,&#123;<br>        <span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;pay&#x27;</span>],<br>        <span class="hljs-attr">methods</span>:&#123;<br>            <span class="hljs-title function_">handClick</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;pay money&#x27;</span>);<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">pay</span>();<br>            &#125;<br>        &#125;, <br>        <span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;button @click=&#x27;handClick&#x27;&gt;和小姐姐打招呼&lt;/button&gt;`</span><br>    &#125;)<br>    <span class="hljs-keyword">const</span> vm=app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>声明全局子组件，父组件传入的参数为pay函数，进行数据绑定后子组件的方法就可以调用传入的子函数。</p><h3 id="04-组件传值时的校验操作"><a href="#04-组件传值时的校验操作" class="headerlink" title="04. 组件传值时的校验操作"></a>04. 组件传值时的校验操作</h3><p><a href="https://jspang.com/article/69#toc319">对类型的校验</a></p><p>有时候我们希望传递过来的属性是一个某一个特定类型，这就涉及到了对参数类型的判断。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;Son&#x27;</span>, &#123;<br>        <span class="hljs-attr">props</span>: &#123;<br>            <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span><br>        &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;&#123;&#123;name&#125;&#125; div &lt;/div&gt;`</span><br>    &#125;)<br></code></pre></td></tr></table></figure><p>Vue支持的校验类型包括:String、Boolean、Array、Object、Function和Symbol。</p><p><a href="https://jspang.com/article/69#toc320">必填校验和默认值设置</a></p><p><strong>required必填项</strong></p><p>如果要求组该项必须传递参数，可以使用<code>required</code>来校验</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;Son&#x27;</span>, &#123;<br>        <span class="hljs-attr">props</span>: &#123;<br>            <span class="hljs-attr">name</span>: &#123;<br>                <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>                <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;&#123;&#123;name&#125;&#125; div &lt;/div&gt;`</span><br>    &#125;)<br></code></pre></td></tr></table></figure><p>这时候的校验规则就是，name的值必须是字符串，并且不可以不传值。</p><p><strong>default默认值</strong></p><p>再来看一下默认值的写法，在原来写<code>required</code>的地方直接写<code>default</code>就可以了。比如写成下面的样子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;Son&#x27;</span>, &#123;<br>        <span class="hljs-attr">props</span>: &#123;<br>            <span class="hljs-attr">name</span>: &#123;<br>                <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>                <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;JSPang.com&#x27;</span><br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;&#123;&#123;name&#125;&#125; div &lt;/div&gt;`</span><br>    &#125;)<br></code></pre></td></tr></table></figure><p>这时候的意思就是在调用组件时，如果不传递参数，则默认值为<code>JSPang.com</code>。</p><p><a href="https://jspang.com/article/69#toc321">精准校验-validator</a></p><p>当要求传递的字符串中必须包括<code>JSPang</code>这几个字符，就可以用<code>validator</code>来进行校验。它是一个函数，并接受一个<code>value</code>值，这个value就是传递过来的值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123; <br>        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;小明明&#x27;</span><br>    &#125;<br>&#125;,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;loveU :name=&#x27;name&#x27;/&gt;`</span><br>    &#125;)<br>    app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;loveU&#x27;</span>,&#123;<br>        <span class="hljs-attr">props</span>:&#123;<br>            <span class="hljs-attr">name</span>:&#123;<br>                <span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>,<br>                <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">validator</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>                    <span class="hljs-title function_">alert</span>(value.<span class="hljs-title function_">search</span>(<span class="hljs-string">&#x27;明&#x27;</span>)!=-<span class="hljs-number">1</span>)<br>                &#125;<br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;LOVE U &#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="hljs-string">        `</span><br>    &#125;) <br>    <span class="hljs-keyword">const</span> vm=app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>因为使用<code>search</code>来验证，返回来的是字符串出现的位置，没有找到时才显示<code>-1</code>。所以这里判定如果不为<code>-1</code>就是包含。</p><h3 id="05-组件中重要机制-单项数据流"><a href="#05-组件中重要机制-单项数据流" class="headerlink" title="05.组件中重要机制-单项数据流"></a>05.组件中重要机制-单项数据流</h3><p><a href="https://jspang.com/article/69#toc323">编写一个计数器</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> counter=&#123;     <br>        <span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;num&#x27;</span>] ,       <br>        <span class="hljs-attr">methods</span>:&#123;&#125;,<br>        <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">            &#123;&#123;num&#125;&#125;</span><br><span class="hljs-string">            &lt;button @click=&#x27;num++&#x27;&gt;纪阿姨&lt;/button&gt;</span><br><span class="hljs-string">            &lt;/div&gt;</span><br><span class="hljs-string">        `</span>&#125;<br>    <span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123; <br>    <span class="hljs-attr">components</span>:&#123;counter&#125;,<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">count</span>:<span class="hljs-number">5</span>,<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;counter :num=&#x27;count&#x27;/&gt;`</span><br>    &#125;)   <br>    <span class="hljs-keyword">const</span> vm=app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在父组件里定义数据后和组件成功绑定了，但运行后会发现按钮并不进行加一操作，这就是单向数据流机制限制的结果。</p><p><a href="https://jspang.com/article/69#toc324">单向数据流概念</a></p><p>什么是单向数据流？官方的解释还是比较晦涩难懂的。</p><ul><li>可以简单的说：<strong>数据从父级组件传递给子组件，只能单向绑定。子组件内部不能直接修改从父组件传递过来的数据。</strong></li></ul><p>这也就是为什么，我们上面写的程序不能使用的原因了。</p><p>如何修改这个程序让其好用？需要在组件内的数据项中声明一个变量，把父组件传递过来的变量赋值给内部变量，然后就可以随意修改了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;Counter&#x27;</span>, &#123;<br>    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;counter&#x27;</span>],<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">newCounter</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &#123;&#123;newCounter&#125;&#125;</span><br><span class="hljs-string">        &lt;button @click=&quot;this.newCounter+=1&quot;&gt;增加数量&lt;/button&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这样就可以进行修改了。当我们通过程序，更好的理解了什么是<code>单项数据流</code>后，我们再来总结一下。<strong>单向数据流就是父组件可以向子组件传递数据，但是子组件不能修改数据。</strong></p><p><a href="https://jspang.com/article/69#toc325">为什么要有单向数据流机制</a></p><p>单项数据流的最终目的，就是为了降低组件的耦合度和独立性。比如现在页面上同时调用了三个<code>&lt;counter/&gt;</code>组件，没有单项数据流的机制，很容易变成一个组件数值变化，其他组件的数值也跟着变化的现象。让页面组件的数据耦合在一起，没办法独立使用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h2&gt;JSPang.com&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;counter :counter=&quot;counter&quot;/&gt;</span><br><span class="hljs-string">    &lt;counter :counter=&quot;counter&quot;/&gt;</span><br><span class="hljs-string">    &lt;counter :counter=&quot;counter&quot;/&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><h3 id="06-Non-props使用技巧"><a href="#06-Non-props使用技巧" class="headerlink" title="06.Non-props使用技巧"></a>06.Non-props使用技巧</h3><p><a href="https://jspang.com/article/69#toc327">基础页面和子组件的准备</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">        </span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;div&gt;Love You&lt;/div&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">            &lt;hello /&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">             `</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">        app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">template</span>:<span class="hljs-string">`</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">            &lt;h3&gt;Hello,XMM!&lt;/h3&gt;`</span></span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">        app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/69#toc328">初始Non-props 属性</a></p><p>上面的代码，子组件里没有可供接受参数的props`,但这时候在调用的时候，是仍然可以传值的。</p><p>打开控制台，查看<code>Elements</code>标签，可以看到此时的<code>&lt;h3&gt;</code>标签上已经由了<code>msg=good</code>这样的属性，也就是父组件直接把属性移植给了子属性。</p><p><img src="/../img/image-20220920005944549.png" alt="image-20220920005944549"></p><p>如果要消除这种移植，可以在子组件里接受这个属性，但并不在<code>template</code>里使用他。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,&#123;<br>    <span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;msg&#x27;</span>],<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h3&gt;Hello,XMM!&lt;/h3&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这时候在打开浏览器的<code>Elements</code>标签查看，就没有多余的属性了。</p><p><img src="/../img/image-20220920010258899.png" alt="image-20220920010258899"></p><p>总结：<code>Non-prop</code>属性就是父组件向子组件传递参数的时候，如果子组件不给接受参数的接口。这个时候父组件就会直接把属性完全复制给子组件，子组件也是可以得到属性值的。</p><p>最常见的使用案例就是直接在标签上写CSS样式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;h2&gt;JSPang.com&lt;/h2&gt;</span><br><span class="hljs-string">        &lt;hello style=&quot;color:red;&quot; /&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这时候子组件会直接得到这个属性，也就把字体变成了红色。</p><p><a href="https://jspang.com/article/69#toc329">inheritAttrs属性</a></p><p>有些时候我们就是不想接受参数，也不想让<code>Non-props</code>属性起作用，这时候可以在子组件上使用<code>inheritAttrs</code>是否继承父属性来解决这个问题。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, &#123;<br>    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;h3&gt;Hello World&lt;/h3&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这时候style标签就不会再被复制到子组件上了，组件上的<code>Hello World</code>也不会变成红色了。</p><p><a href="https://jspang.com/article/69#toc330">Non-Prop多节点失效解决方法</a></p><p>刚才说了，组件在没有接受参数时，会把属性自动复制到组件的根节点上，但如果组件不是一个根节点，比如写成下面的样子，复制就会失效。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, &#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;h3&gt;Hello World&lt;/h3&gt;</span><br><span class="hljs-string">        &lt;h3&gt;Hello World&lt;/h3&gt;</span><br><span class="hljs-string">        &lt;h3&gt;Hello World&lt;/h3&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>解决方案：</p><ol><li>增加一个根节点</li><li>单独继承，如下：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx">pp.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, &#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h3 v-bind=&quot;$attrs&quot;&gt;Hello World&lt;/h3&gt;</span><br><span class="hljs-string">    &lt;h3&gt;Hello World&lt;/h3&gt;</span><br><span class="hljs-string">    &lt;h3&gt;Hello World&lt;/h3&gt;</span><br><span class="hljs-string">`</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>注意，<code>$attrs</code>不是单指某一个属性，而是指全部属性，<code>v-bind=&quot;$attrs&quot;</code>的意思是把父组件传递的所有参数属性都复制到子组件当中。</p><p>如果想只复制一个属性，比如现在我们只复制一个属性<code>style</code>，就这个这么写。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h3 v-bind=&#x27;$attrs&#x27;&gt;Hello,XMM!&lt;/h3&gt;</span><br><span class="hljs-string">    &lt;h3 :style=&#x27;$attrs.style&#x27;&gt;Hello,XMM!&lt;/h3&gt;</span><br><span class="hljs-string">    &lt;h3&gt;Hello,XMM!&lt;/h3&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="/../img/image-20220920011421602.png" alt="image-20220920011421602"></p><p><a href="https://jspang.com/article/69#toc331">在业务逻辑中使用Non-props属性</a></p><p>刚才讲的都是在标签上使用<code>Non-props</code>属性，如果想在业务逻辑中使用<code>Non-props</code>属性也是可以的。比如在生命周期中使用:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,&#123;<br>    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$attrs</span>.<span class="hljs-property">msg</span>)<br>    &#125;,<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h3 v-bind=&#x27;$attrs&#x27;&gt;Hello,XMM!&lt;/h3&gt;</span><br><span class="hljs-string">    &lt;h3 :style=&#x27;$attrs.style&#x27;&gt;Hello,XMM!&lt;/h3&gt;</span><br><span class="hljs-string">    &lt;h3&gt;Hello,XMM!&lt;/h3&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>然后到浏览器中的控制台进行查看，就可以看到打印出了<code>good</code>字样。</p><p><code>this.$attrs</code>是Vue的一个常用属性，我们需要善于利用。</p><h3 id="07-组件中通过事件进行通信"><a href="#07-组件中通过事件进行通信" class="headerlink" title="07 组件中通过事件进行通信"></a>07 组件中通过事件进行通信</h3><p>前面我们讲了单项数据流的概念，这节学习一下组件如何通过事件向父组件传递参数，打破单项数据流的限制。</p><p><a href="https://jspang.com/article/69#toc333">编写计数器案例</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        </span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        const app=Vue.createApp(&#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            data()&#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                return&#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                    count:0</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                &#125;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            &#125;,</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            template:`</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">counter</span> <span class="hljs-attr">:num</span>=<span class="hljs-string">&#x27;count&#x27;</span>/&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">counter</span> <span class="hljs-attr">:num</span>=<span class="hljs-string">&#x27;count&#x27;</span>/&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">counter</span> <span class="hljs-attr">:num</span>=<span class="hljs-string">&#x27;count&#x27;</span>/&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">             `</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        &#125;)</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        app.component(&#x27;counter&#x27;,&#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            props:[&#x27;num&#x27;],</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            template:`</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">num</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;num++&#x27;</span>&gt;</span>增加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            `</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        &#125;)</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        app.mount(&quot;#app&quot;)</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>上面的代码，当我们在浏览器中点击增加时，是不能增加<code>counter</code>的值的，这就是Vue<code>单向数据流</code>的限制。</p><p>但是如果，我们就是想在子组件里改变父组件传递过来的值，怎么办呢？</p><p><a href="https://jspang.com/article/69#toc334">子组件调用父组件事件</a></p><p>先在父组件里编写一个方法，叫做<code>handleAddCounter</code>。每执行一次，数据项里的<code>counter</code>加一。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">handleAddCounter</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span> += <span class="hljs-number">1</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>父组件有了这个方法，就可以改变<code>couter</code>数据行的值了，但子组件并不能调用他，需要先在<code>子组件</code>的模板<code>template</code>中编写一个<code>click</code>事件，然后用<code>$emit</code>调用父组件的响应事件<code>add</code>。具体代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;Counter&#x27;</span>, &#123;<br>    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;counter&#x27;</span>],<br>  <span class="hljs-comment">//需要在这里声明</span><br>    <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;add&#x27;</span>],<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;add&#x27;</span>)<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &#123;&#123;counter&#125;&#125;&lt;button @click=&quot;handleClick&quot;&gt;增加数量&lt;/button&gt;</span><br><span class="hljs-string">`</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这个<code>add</code>就是父组件模板<code>template</code>中的响应事件，由响应事件调用方法<code>handleAdCounter</code>。</p><p>父组件里的模板：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">            &lt;h2&gt;JSPang.com&lt;/h2&gt;</span><br><span class="hljs-string">            &lt;counter :counter=&quot;counter&quot; @add=&quot;handleAddCounter&quot;/&gt;  </span><br><span class="hljs-string">        `</span><br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/69#toc335">子组件向父组件传递参数</a></p><p>子组件想要向父组件传值，可以在子组件中这样编写。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-number">2</span>)<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后在父组件中接受这个参数<code>param</code> ，在控制台进行打印。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">handleAddCounter</span>(<span class="hljs-params">param</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(param)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span> += param<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>还有更好的选择，就是把所有业务逻辑都放在子组件中，然后把结果传递给父组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">//这里传递的counter是自组件的变量，得到一个值后传给父组件</span><br>        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;add&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span> + <span class="hljs-number">3</span>)<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>父组件直接接受结果就可以了</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">handleAddCounter</span>(<span class="hljs-params">param</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(param)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span> = param<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/69#toc336">对传递值的校验</a></p><p>在子组件向父组件传递值的时候，还可以开启校验功能。比如现在我们要求传递到add中的值，不大于20。如果大于20就进行警告。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">emits</span>: &#123;<br>    <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> num &lt; <span class="hljs-number">20</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p><img src="/../img/image-20220920015500642.png" alt="image-20220920015500642"></p><h3 id="08-组件中插槽的使用Slot-1"><a href="#08-组件中插槽的使用Slot-1" class="headerlink" title="08. 组件中插槽的使用Slot -1"></a>08. 组件中插槽的使用Slot -1</h3><p><a href="https://jspang.com/article/69#toc339">初识插槽</a></p><p>插槽的声明：在子组件中加入<code>&lt;slot&gt;&lt;/slot&gt;</code>标签，然后在父组件中使用子组件的双标签进行调用。具体代码如下:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        const app = Vue.createApp(&#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            template: `</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>欢迎光临<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Caidan</span>&gt;</span> 小明明 <span class="hljs-tag">&lt;/<span class="hljs-name">Caidan</span>&gt;</span>`</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        &#125;)</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    </span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        app.component(&#x27;Caidan&#x27;, &#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            template: `</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> 串串店 <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        `</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        &#125;)</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    </span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        const vm = app.mount(&quot;#app&quot;)</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>插槽支持任何的DOM元素，比如加入一个<code>&lt;div&gt;</code>然后让字体变成红色和50像素的字体大小。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">&lt;h2&gt;欢迎光临&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;Caidan&gt; </span><br><span class="hljs-string">    &lt;div style=&quot;color:red;font-size:50px;&quot;&gt;小明明&lt;/div&gt; </span><br><span class="hljs-string">    &lt;/Caidan&gt;`</span><br></code></pre></td></tr></table></figure><p>比如现在调用两次<code>&lt;ji-shi&gt;</code>组件，给与不同的样式也是可以的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">&lt;h2&gt;欢迎光临&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;Caidan&gt; </span><br><span class="hljs-string">    &lt;div style=&quot;color:red;font-size:50px;&quot;&gt;小明明&lt;/div&gt; </span><br><span class="hljs-string">    &lt;/Caidan&gt;</span><br><span class="hljs-string">    &lt;Caidan&gt; </span><br><span class="hljs-string">    &lt;div style=&quot;color:blue;font-size:25px;&quot;&gt;小明明&lt;/div&gt; </span><br><span class="hljs-string">    &lt;/Caidan&gt;`</span><br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/69#toc340">插槽中使用子组件</a></p><p>插槽可以强大到直接使用<code>子组件</code>，接下来就作一个在插槽中使用子组件的小例子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        const app = Vue.createApp(&#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            template: `</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>欢迎光临<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Caidan</span>&gt;</span> </span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:blue;font-size:25px;&quot;</span>&gt;</span>小明明<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> </span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">list</span> /&gt;</span>      </span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Caidan</span>&gt;</span>`</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        &#125;)</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    </span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        app.component(&#x27;Caidan&#x27;, &#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            template: `</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> 串串店 <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        `</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        &#125;)</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        app.component(&#x27;list&#x27;,&#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            template:`</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;color:yellow;font-size:30px;&#x27;</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                吃串串</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            `</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        &#125;)    </span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        const vm = app.mount(&quot;#app&quot;)</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/69#toc341">插槽中使用动态数据</a></p><p>插槽中也可以直接使用动态数据，也就是我们常说的数据项，比如定义一个数据项,然后在插槽中使用，直接就可以使用了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        const app = Vue.createApp(&#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            data()&#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">              return&#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                customer:&#x27;小明明&#x27;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">              &#125;  </span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            &#125;,</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            template: `</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>欢迎光临<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Caidan</span>&gt;</span> </span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:blue;font-size:25px;&quot;</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">customer</span>&#125;&#125;</span><span class="language-xml">    </span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>     </span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Caidan</span>&gt;</span>`</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        &#125;)</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    </span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        app.component(&#x27;Caidan&#x27;, &#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            data()&#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">              return&#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                customer:&#x27;小琳琳&#x27;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">              &#125;  </span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            &#125;,</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            template: `</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> 串串店 <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        `</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        &#125;)</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        const vm = app.mount(&quot;#app&quot;)</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>这里有一个变量作用域的问题，子组件和父组件都有一个数据项<code>customer</code>，我们得出了一个结论：</p><ul><li>父模板里调用的数据属性，使用的都是父模板里的数据</li><li>子模板里调用的数据属性，使用的都是子模板里的数据</li></ul><h3 id="09-组件中插槽的使用Slot-2"><a href="#09-组件中插槽的使用Slot-2" class="headerlink" title="09. 组件中插槽的使用Slot-2"></a>09. 组件中插槽的使用Slot-2</h3><p>插槽有两个编写方法，使用插槽的默认值或具名插槽。</p><p><a href="https://jspang.com/article/69#toc344">插槽默认值的写法</a></p><p>在文件中编写一个全局的组件<code>JiShi</code>，默认值的关键语法就是在<code>&lt;slot&gt;</code>插槽中直接输入值就可以了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;Caidan&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">            你选择了</span><br><span class="hljs-string">            &lt;slot&gt;</span><br><span class="hljs-string">            &lt;span style=&quot;color:green;&quot;&gt;咖喱棒&lt;/span&gt;</span><br><span class="hljs-string">            &lt;/slot&gt;</span><br><span class="hljs-string">            作为主食。</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>现在这种编写方法，在有值传递过来的时候，会显示正常的值，没有值的时候就会显示默认值”咖喱棒”。</p><p><a href="https://jspang.com/article/69#toc345">具名插槽的使用</a></p><p>在一个组件需要用到多个插槽的情况下，为了区分这些插槽，需要为插槽命名。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;HongLangMan&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">                &lt;slot name=&quot;one&quot;&gt;&lt;/slot&gt;</span><br><span class="hljs-string">                &lt;div&gt;2.点菜&lt;/div&gt;</span><br><span class="hljs-string">                &lt;slot name=&quot;two&quot;&gt;&lt;/slot&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>然后在父组件调用的时候传递对应的值，比如把代码写成下面的样子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">` </span><br><span class="hljs-string">        &lt;h2&gt;欢迎光临红浪漫-请选择您的技师&lt;/h2&gt;</span><br><span class="hljs-string">        &lt;hong-lang-man&gt;</span><br><span class="hljs-string">            &lt;template v-slot:one&gt;</span><br><span class="hljs-string">            &lt;div&gt;1.选座&lt;/div&gt;</span><br><span class="hljs-string">            &lt;/template&gt;</span><br><span class="hljs-string">            &lt;template v-slot:two&gt;</span><br><span class="hljs-string">            &lt;div&gt;3.恰饭&lt;/div&gt;</span><br><span class="hljs-string">            &lt;/template&gt;</span><br><span class="hljs-string">        &lt;/hong-lang-man&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>在调用时，不只要写子组件的双标签，还要用<code>template</code>占位，<code>v-slot</code>绑定插槽名。</p><h3 id="10-具名插槽简写和作用域插槽"><a href="#10-具名插槽简写和作用域插槽" class="headerlink" title="10. 具名插槽简写和作用域插槽"></a>10. 具名插槽简写和作用域插槽</h3><p><a href="https://jspang.com/article/69#toc347">具名插槽的简写方法</a></p><p>在父模板中确定插槽位置时，<code>v-slot:one</code>可以简写成<code>#one</code>。这时候的代码就变成了下面的样子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">` </span><br><span class="hljs-string">    &lt;h2&gt;欢迎光临红浪漫-请选择您的技师&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;hong-lang-man&gt;</span><br><span class="hljs-string">        &lt;template #one&gt;&lt;div&gt;1.女宾一位，请上三楼。&lt;/div&gt;&lt;/template&gt;</span><br><span class="hljs-string">        &lt;template #two&gt;&lt;div&gt;3.顾客选择了全身SPA。&lt;/div&gt;&lt;/template&gt;</span><br><span class="hljs-string">    &lt;/hong-lang-man&gt;</span><br><span class="hljs-string">`</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/69#toc348">作用域插槽-基础代码准备</a></p><p>其实作用域插槽主要解决的问题是，子组件中有插槽，也有变量，这些变量如何在父组件中进行使用，在页面上显示出循环的值：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">template</span>: <span class="hljs-string">` </span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">    &lt;h2&gt;欢迎光临红浪漫-请选择您的技师&lt;/h2&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">    &lt;list /&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">    `</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;list&#x27;</span>,&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span>&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">lists</span>:[<span class="hljs-string">&#x27;mm&#x27;</span>,<span class="hljs-string">&#x27;ll&#x27;</span>,<span class="hljs-string">&#x27;yy&#x27;</span>]</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">        &lt;div&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">            &lt;div v-for=&quot;item in lists&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">        &lt;/div&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">    `</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> vm = app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/69#toc349">作用域插槽-具体讲解</a></p><p>改造子组件，增加<code>slot</code>插槽，增加插槽后的模板代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">        &lt;slot v-for=&quot;item in list&quot;  /&gt;    </span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>那么，父组件如何使用子组件中的变量来显示呢？</p><p>父组件想使用子组件插槽中的值，使用<code>:</code>绑定的形式进行传递，比如写成<code>:item=&quot;item&quot;</code>，具体的代码可以写成下面的样子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;List&#x27;</span>, &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">lists</span>:[<span class="hljs-string">&#x27;mm&#x27;</span>,<span class="hljs-string">&#x27;ll&#x27;</span>,<span class="hljs-string">&#x27;yy&#x27;</span>]<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">            &lt;slot v-for=&quot;item in list&quot; :item=&quot;item&quot; /&gt;    </span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br></code></pre></td></tr></table></figure><p>写完后父组件中用<code>v-slot=&quot;xxx&quot;</code>的形式接受，接收后就可以使用了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`  </span><br><span class="hljs-string">    &lt;h2&gt;欢迎光临&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;list v-slot=&quot;props&quot;&gt; </span><br><span class="hljs-string">        &lt;span&gt;&#123;&#123;props.item&#125;&#125;&lt;/span&gt; </span><br><span class="hljs-string">    &lt;/list&gt;</span><br><span class="hljs-string">`</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这里的<code>props</code>是子组件传递过来的数据对象<code>data()</code>，所以我们要加上<code>.item</code>才能使用。可以把代码修改一下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;list v-slot=<span class="hljs-string">&quot;props&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;props.item&#125;&#125;-&#123;&#123;props&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> <br>&lt;/list&gt;<br></code></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">mm-&#123; <span class="hljs-string">&quot;item&quot;</span>: <span class="hljs-string">&quot;mm&quot;</span> &#125;<br>ll-&#123; <span class="hljs-string">&quot;item&quot;</span>: <span class="hljs-string">&quot;ll&quot;</span> &#125;<br>yy-&#123; <span class="hljs-string">&quot;item&quot;</span>: <span class="hljs-string">&quot;yy&quot;</span> &#125;<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/69#toc350">简化作用域插槽写法</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`  </span><br><span class="hljs-string">        &lt;h2&gt;欢迎光临&lt;/h2&gt;</span><br><span class="hljs-string">        &lt;list v-slot=&quot;&#123;item&#125;&quot;&gt; </span><br><span class="hljs-string">            &lt;div&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt; </span><br><span class="hljs-string">        &lt;/list&gt;</span><br><span class="hljs-string">        `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>插槽直接接受数据对象的<code>&#123;item&#125;</code>，作为变量以字面量的形式显示。</p><h3 id="11-动态组件和状态保存"><a href="#11-动态组件和状态保存" class="headerlink" title="11. 动态组件和状态保存"></a>11. 动态组件和状态保存</h3><p>现在来虚拟一个需求，为菜单编写一个带图片的选择菜的功能，并且可以让顾客手动切换这些菜。</p><p><a href="https://jspang.com/article/69#toc353">创建子组件</a></p><p>现在创建两个子组件，用来展示照片。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;tuone&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;img src=&quot;./photo33.jpeg&quot; /&gt;`</span><br>&#125;)<br><br>app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;tutwo&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;img src=&quot;./photo35.jpeg&quot; /&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>然后在父组件中直接使用这两个组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">` </span><br><span class="hljs-string">        &lt;h2&gt;欢迎光临&lt;/h2&gt; </span><br><span class="hljs-string">        &lt;tuone /&gt;</span><br><span class="hljs-string">    &lt;tutwo /&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/69#toc354">原始切换效果</a></p><p>现在的需求是如果显示其中一个组件，另一个组件就不显示。这里我最先想到的是用<code>v-show</code>这种代码来实现。</p><p>我们先来定义一个数据项，用来控制显示那个组件，数据项叫做<code>showItem</code>，然后在两个子组件的位置增加<code>v-show</code>属性，控制最终的显示。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span>&#123;<br>                <span class="hljs-attr">showItem</span>:<span class="hljs-string">&#x27;tuone&#x27;</span><br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">` </span><br><span class="hljs-string">        &lt;h2&gt;欢迎光临&lt;/h2&gt;</span><br><span class="hljs-string">        &lt;tuone v-show=&#x27;showItem===&quot;tuone&quot;&#x27;/&gt;</span><br><span class="hljs-string">        &lt;tutwo v-show=&#x27;showItem===&quot;tutwo&quot;&#x27;/&gt;</span><br><span class="hljs-string">        `</span><br>    &#125;)<br></code></pre></td></tr></table></figure><p>这时候的<code>showItem</code>值是<code>tuone</code>，所以浏览器中只显示<code>tuone</code>的组件。</p><p>然后再编写一个按钮，用来切换两个组件，按钮需要绑定一个方法<code>handleClick</code>,方法中我使用了三元运算符来编写这部分内容。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">showItem</span>=showItem==<span class="hljs-string">&#x27;tuone&#x27;</span>?<span class="hljs-string">&#x27;tutwo&#x27;</span>:<span class="hljs-string">&#x27;tuone&#x27;</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/69#toc355">动态组件优化代码</a></p><p>使用<code>动态组件</code>的编程方式，省略<code>v-show</code>代码，让代码看起来更加的优雅。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span>&#123;<br>            <span class="hljs-attr">showItem</span>:<span class="hljs-string">&#x27;tuone&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>:&#123;<br>        <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">showItem</span>=<span class="hljs-variable language_">this</span>.<span class="hljs-property">showItem</span>==<span class="hljs-string">&#x27;tuone&#x27;</span>?<span class="hljs-string">&#x27;tutwo&#x27;</span>:<span class="hljs-string">&#x27;tuone&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">` </span><br><span class="hljs-string">    &lt;h2&gt;欢迎光临&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;component :is=&quot;showItem&quot; /&gt;</span><br><span class="hljs-string">    &lt;button @click=&#x27;handleClick&#x27;&gt;换菜&lt;/button&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>有了这段简短的代码，就可以删除掉下面这两句代码了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;dajiao  v-show=<span class="hljs-string">&quot;showItem===&#x27;dajiao&#x27;&quot;</span> /&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">liuying</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;showItem===&#x27;liuying&#x27;&quot;</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><p>意思是，使用一个动态组件<code>component</code>展示组件，具体展示哪个由数据项<code>showItem</code>决定，它的值是<code>tuone</code>就显示第一个组件，它的值是<code>tutwo</code>，就显示第二个组件。</p><p><a href="https://jspang.com/article/69#toc356">动态组件中的状态保存</a></p><p>动态组件用起来非常方便，但是有一点小问题，把照片变成一个<code>input</code>框。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;dajiao&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;input /&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>在切换组件后。<code>input</code>框中的文字是无法保存的。</p><p>为了保存<code>input</code>框中的文字，可以使用<code>&lt;keep-alive&gt;</code>标签，把动态组件包裹起来。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;keep-alive&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;showItem&quot;</span> /&gt;</span></span><br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure><p>这时候相当启用了缓存，把<code>input</code>框的值存了起来。在使用动态组件时，经常配合<code>&lt;keep-alive&gt;</code>标签一起使用。</p><h3 id="12-异步组件和Promise讲解"><a href="#12-异步组件和Promise讲解" class="headerlink" title="12.异步组件和Promise讲解"></a>12.异步组件和Promise讲解</h3><p><a href="https://jspang.com/article/69#toc358">编写基本代码和同步组件</a></p><p>编写一个同步组件（其实以前学的全部都是同步组件），并在父组件里使用它。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`  &lt;div&gt;&lt;tongbu /&gt;&lt;/div&gt;`</span><br>&#125;)<br>app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;tongbu&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;div&gt;JSPang.com&lt;/div&gt;`</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> vm = app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br></code></pre></td></tr></table></figure><p>这时候就是一个同步组件，因为调用后，代码直接就会被执行。那我们了解同步组件后，我们再了解一下异步组件。</p><p><a href="https://jspang.com/article/69#toc359">vue3中的异步组件</a></p><p>异步组件就是在调用组件时，这个组件并不立即渲染，而是要等带一些业务逻辑完成后，才会进行执行组件内的逻辑和渲染到页面上。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;async-component&#x27;</span>,<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-title function_">resolve</span>(&#123;<br>                <span class="hljs-attr">template</span>:<span class="hljs-string">`&lt;div&gt;这是一个异步组件&lt;/div&gt;`</span><br>            &#125;)<br>        &#125;,<span class="hljs-number">3000</span>)<br>    &#125;)<br><br>&#125;))<br></code></pre></td></tr></table></figure><p>新建了一个组件，然后用<code>defineAsyncComponent()</code>声明这是一个异步组件，在组件内部我们用<code>Promise</code>来完成逻辑。逻辑非常简单，用<code>setTimeout</code>控制3秒后渲染模板<code>template</code>，展示内容。也就是说3秒后，组件才知道最终展示的内容是什么。这就是一个典型的异步组件。</p><p>异步组件经常在去后台请求数据的时候进行使用，也可以把一个大项目拆分成很多小的异步组件，然后根据需要，异步加载这些小项目。</p><h3 id="13-provide和inject多级组件传值"><a href="#13-provide和inject多级组件传值" class="headerlink" title="13.provide和inject多级组件传值"></a>13.provide和inject多级组件传值</h3><p><a href="https://jspang.com/article/69#toc361">创建一个多级组件</a></p><p>写一个子组件，然后子组件里调用另一个子组件（也可以想象成孙子组件），然后从最上层的父组件里传递值给子组件。</p><p>我们先来编写两个子组件的代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">house</span>:<span class="hljs-string">&#x27;北京别墅一套&#x27;</span>&#125;<br>        &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;我有一套房子，我先传给我的儿子&lt;/div&gt; `</span><br>    &#125;)<br><br>    app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;child&#x27;</span>,&#123;<br>        <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">            &lt;div&gt;我是子组件，我要把房子再传给我儿子。&lt;/div&gt;</span><br><span class="hljs-string">        `</span><br>    &#125;)<br><br>    app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;child-child&#x27;</span>,&#123;<br>        <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">            &lt;div&gt;我是孙子，等待接收房子&lt;/div&gt;</span><br><span class="hljs-string">        `</span><br>    &#125;)<br>    <span class="hljs-keyword">const</span> vm = app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>基本结果和组件已经有了，下面我们看看这种情况如何传递。</p><p><a href="https://jspang.com/article/69#toc362">常用传递方式</a></p><p>现在的需求就是一层层传递下去，我们可以使用<code>props</code>的形式进行接收，然后继续传递，代码可以可成这样。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">house</span>:<span class="hljs-string">&#x27;北京别墅一套&#x27;</span>&#125;<br>        &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">            &lt;div&gt;我有一套房子，我先传给我的儿子&lt;/div&gt;</span><br><span class="hljs-string">            &lt;child :house=&quot;house&quot; /&gt;</span><br><span class="hljs-string">         `</span><br>    &#125;)<br><br>    app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;child&#x27;</span>,&#123;<br>        <span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;house&#x27;</span>],<br>        <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">            &lt;div&gt;我是子组件，我要把房子再传给我儿子。&lt;/div&gt;</span><br><span class="hljs-string">            &lt;div&gt;儿子接收&#123;&#123;house&#125;&#125;&lt;/div&gt;</span><br><span class="hljs-string">            &lt;child-child :house=&quot;house&quot; /&gt;</span><br><span class="hljs-string">        `</span><br>    &#125;)<br><br>    app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;child-child&#x27;</span>,&#123;<br>        <span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;house&#x27;</span>],<br>        <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">            &lt;div&gt;我是孙子，等待接收房子&lt;/div&gt;</span><br><span class="hljs-string">            &lt;div&gt;孙子接收&#123;&#123;house&#125;&#125;&lt;/div&gt;</span><br><span class="hljs-string">        `</span><br>    &#125;)<br>    <span class="hljs-keyword">const</span> vm = app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>这时候到浏览器中查看一下结果，可以发现结果是可以成功的。每次用props接收，然后再用绑定属性的方式传递给下一层。</p><p>但现在需求变化了，富豪北京三环内还有一套200平方的房子，不想通过儿子的手，直接传递给孙子，那如何操作那？</p><p><a href="https://jspang.com/article/69#toc363">多级组件传值provide和inject</a></p><p>这时候就可以使用使用provide传递和inject接收了，先在数据项的下面声明一个<code>provide</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">house</span>:<span class="hljs-string">&#x27;北京别墅一套&#x27;</span>&#125;<br>    &#125;,<br>    <span class="hljs-attr">provide</span>:&#123;<br>        <span class="hljs-attr">newHouse</span>:<span class="hljs-string">&#x27;北京200平方房子一套&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;我有一套房子，我先传给我的儿子&lt;/div&gt;</span><br><span class="hljs-string">        &lt;child :house=&quot;house&quot; /&gt;</span><br><span class="hljs-string">        `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>然后儿子组件不用作任何更改，直接在孙子组件里用<code>inject</code>接收就可以了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;child-child&#x27;</span>,&#123;<br>    <span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;house&#x27;</span>],<br>    <span class="hljs-attr">inject</span>:[<span class="hljs-string">&#x27;newHouse&#x27;</span>],<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;我是孙子，等待接收房子&lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;孙子接收&#123;&#123;house&#125;&#125;,&#123;&#123;newHouse&#125;&#125;&lt;/div&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>写完后，可以打开浏览器中进行查看，发现孙子组件也是可以顺利接收到的。</p><p>这样<code>provide</code>和<code>inject</code>成对传输，就可以隔着子组件，往孙子组件传输数据了。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序开发</title>
    <link href="/2022/08/25/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <url>/2022/08/25/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<hr>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习相关知识</title>
    <link href="/2022/08/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/08/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="一、残差神经网络ResNet"><a href="#一、残差神经网络ResNet" class="headerlink" title="一、残差神经网络ResNet"></a>一、<a href="https://zhuanlan.zhihu.com/p/463935188">残差神经网络ResNet</a></h2><h3 id="为什么ResNet会诞生"><a href="#为什么ResNet会诞生" class="headerlink" title="为什么ResNet会诞生"></a>为什么ResNet会诞生</h3><p>深度神经网络由于其具有很多层数（卷积层+全连接层）而冠以“深度”之名，基于神经网络的机器学习算法因此也被称作“深度学习”，然而随着算力的不断增强、数据集的不断扩张，一系列问题随之而来，例如：</p><ul><li>层数越多，训练效果一定越好吗？</li><li>如何优化过深的神经网络？</li><li>如何避免梯度消失和梯度爆炸？</li></ul><p>对于第一个问题，在相同的优化条件下，更深神经网络的训练效果更强是十分显然的，然而由于参数过多、模型复杂度更高，深层神经网络会出现十分严重的过拟合问题，即训练集与测试集准确度之间的gap过大，由此引发了一系列的正则化方法。</p><p>然而，何恺明在实际实验时发现，不仅在测试精度上，而且在训练精度上，更深的（56层）神经网络也远不如浅一些的（20层）神经网络：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208231923390.jpg" alt="preview"></p><p>由此产生了负优化问题，也就是说，56层的神经网络相比于20层，新增加的36层是对神经网络的“恶化”，它们非但没有起到自己应有的作用，反而扭曲了网络空间，升高了training error。</p><p>由此一个想法自然而然的产生：如果这36层神经网络是恒等映射（identity mapping），那么56层的神经网络不就和20层的一样好了吗？</p><p>更进一步呢？如果这36层神经网络相比于恒等映射再好上那么一点点（更接近最优函数），那么不就起到了正优化的作用了吗？ResNet的insight由此诞生。</p><h3 id="ResNet的数学表示"><a href="#ResNet的数学表示" class="headerlink" title="ResNet的数学表示"></a>ResNet的数学表示</h3><p>基于以上的考虑，我们在所拟合的函数中加入恒等函数。</p><p>假设某一层内，最优函数记为$ H(x) $，那么我们所拟合的目标函数 $F(x) $定义为$ F(x):=H(x)−x$ ，函数 $F(x) $被称为“残差函数”。</p><p>残差在数理统计中是指实际观察值与估计值(拟合值)之间的差，实际观察值就是$ H(x)$ ，拟合值是 $x$ ，这里的 $F(x) $就叫残差。</p><p>由此可见，我们所需要的函数由两部分组成：恒等函数和残差函数。恒等函数的存在，避免了“负优化”问题，而残差函数则起到了“锦上添花”的作用。</p><p>因此，ResNet的基本架构就由如下图的残差块所组成。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208232100797.jpg" alt="img"></p><p>对应到神经网络中，残差块的数学表达式可以写成：$ y=σ(F(x,W)+x)$ 。</p><p>其中， $y$ 代表残差块的输出，$ σ(·) $代表激活函数，$ F(·) $代表残差函数， $x$ 代表输入， $W$ 代表残差块内的所有权重。weight layer代表着卷积操作，一般一个残差部分包含2-3个卷积操作，将卷积后的特征图与$x$相加得到新的特征图。</p><p>如前所述，ResNet基于这样一种假设：最优函数与线性函数有一定的相似性。初始化常规神经网络时，其权重参数接近零，因此网络仅输出其输入的副本。换言之，它首先对恒等函数建模。所以如果目标函数和恒等函数相当接近（通常是这种情况），那么训练速度会大大加快。这也是残差学习相对更加容易的原因。</p><p>此外，利用残差块可以训练出一个有效的深层神经网络：输入可以通过层间的残余连接更快地向前传播。</p><h2 id="二、多GPU分布式训练"><a href="#二、多GPU分布式训练" class="headerlink" title="二、多GPU分布式训练"></a>二、<a href="https://blog.csdn.net/qq_35398033/article/details/107303236">多GPU分布式训练</a></h2><p>总的来说，分布式训练分为这几类：</p><ul><li>按照并行方式来分：<strong>模型并行 vs 数据并行</strong></li><li>按照更新方式来分：<strong>同步更新 vs 异步更新</strong></li></ul><p><strong>模型并行 vs 数据并行</strong></p><p>假设我们有n张GPU：</p><ul><li>模型并行：不同的GPU输入相同的数据，运行模型的不同部分，比如多层网络的不同层；</li><li>数据并行：不同的GPU输入不同的数据，运行相同的完整的模型。</li></ul><p>当模型非常大，一张GPU已经存不下的时候，可以使用模型并行，把模型的不同部分交给不同的机器负责，但是这样会带来很大的通信开销，而且模型并行各个部分存在一定的依赖，规模伸缩性差。因此，通常一张可以放下一个模型的时候，会采用数据并行的方式，各部分独立，伸缩性好。</p><p><strong>同步更新 vs 异步更新</strong></p><p>对于数据并行来说，由于每个GPU负责一部分数据，那就涉及到如果更新参数的问题，分为同步更新和异步更新两种方式。</p><blockquote><p><em>“sample”, “batch”, “epoch” 分别是什么？</em><br>Sample: 样本，数据集中的一个元素，一条数据。例 : 在卷积神经网络中，一张图像是一个样本，在语音识别模型中，一段音频是一个样本。</p><p>Batch: 批，含有 n 个样本的集合。</p><p>Epoch: 轮次，通常被定义为「在整个数据集上的一轮迭代」，用于训练的不同的阶段，这有利于记录和定期评估。</p><p>假设有一个包含200个样本（数据行）的数据集，并且我们选择的Batch大小为5和1,000个Epoch。</p><p>这意味着数据集将分为40个Batch，每个Batch有5个样本。每批五个样品后，模型权重将更新。</p><p>这也意味着一个epoch将涉及40个Batch或40个模型更新。</p><p>有1000个Epoch，模型将暴露或传递整个数据集1,000次。在整个培训过程中，总共有40,000Batch。</p></blockquote><ul><li><p>同步更新：每个batch所有GPU计算完成后，再统一计算新权值，然后所有GPU同步新值后，再进行下一轮计算。</p></li><li><p>异步更新：每个GPU计算完梯度后，无需等待其他更新，立即更新整体权值并同步。</p></li></ul><p><strong>一般我们使用的都是数据并行+同步更新。因此本文主要讲解数据并行+同步更的细节。</strong></p><p>分别以单机单卡和单机4卡，batchsize=64为例。</p><p>在单机单卡的模式下，一次性输入一个batch的数据进行forward。在得到网络的output后，由output和target进行loss的计算。但要注意，这里的loss要对bacth中的样本量（batchsize）取平均。</p><p> 在单机4卡的模式下，因为batchsize=64。因此分配给每块GPU的size为16。各块GPU上模型一致并共享参数，只是数据输入不同。4块GPU分别进行forward，各GPU上loss的计算依旧要根据本卡上的样本量（size=16）取平均。在梯度计算上，我看到过两个版本，一种是将多卡loss收集到主GPU上再次按卡数进行平均。随后再进行梯度回传并更新参数，将更新后的参数分发给其他GPU。另外一种是各GPU先分别进行梯度回传，再将梯度gather到主GPU上取平均，随后更新参数并分发给其他GPU。两种方法最终的结果实际上是一致的，只是步骤不同。因此这里不再深究。</p><p> 从上面的分析可以看出，无论是单卡训练还是多卡训练，最终用来计算梯度的loss值，是要对样本量取平均的。因此在借助Pytorch累加梯度的特性，变相增加batchsize的过程中，需要将loss除以累加迭代的次数。</p><p>那么问题来了，单机单卡、单机多卡、借助梯度累加变相增加batchsize三者是否完全等价？</p><p>除去训练速度以及不同GPU随机种子设定不同导致的细微差别，单从forward、backward、parameter、update三方面来看，是没有什么差别的。</p><p>但是，有个东西叫<a href="https://zhuanlan.zhihu.com/p/24810318">Bach Normalization</a>。大家都知道，这神器对模型训练大有脾益，有了他不但减小了对dropout的依赖，更削弱了参数初始化的影响。可是，这玩意儿是基于batch来计算的。在单卡，多卡、变相增大batchsize的情况下，Bach Normalization单次处理的数据量可就不一样了。</p><p>单卡时，每次处理的数据量等于batchsize。而在多卡情况下，由于数据分发，每次处理的数据量等于batchsize/卡数。在变相增大batchsize的情况下，每次处理的数据量与不进行这种操作是相等的，也就是说采用这种方法，其loss计算和梯度计算与增大的batchsize是一致的。但是在Bach Normalization上依旧是从前那个少年！</p><h2 id="三、卷积神经网络CNN"><a href="#三、卷积神经网络CNN" class="headerlink" title="三、卷积神经网络CNN"></a>三、<a href="https://easyai.tech/ai-definition/cnn/">卷积神经网络CNN</a></h2><p>CNN 有2大特点：</p><ol><li>能够有效的将大数据量的图片降维成小数据量</li><li>能够有效的保留图片特征，符合图片处理的原则</li></ol><p>目前 CNN 已经得到了广泛的应用，比如：人脸识别、自动驾驶、美图秀秀、安防等很多领域。</p><p>在 CNN 出现之前，图像对于人工智能来说是一个难题，有2个原因：</p><ol><li>图像需要处理的数据量太大，导致成本很高，效率很低</li><li>图像在数字化的过程中很难保留原有的特征，导致图像处理的准确率不高</li></ol><p><strong>卷积神经网络 – CNN 解决的第一个问题就是“将复杂问题简化”，把大量参数降维成少量参数，再做处理。</strong></p><p>更重要的是：我们在大部分场景下，降维并不会影响结果。比如1000像素的图片缩小成200像素，并不影响肉眼认出来图片中是一只猫还是一只狗，机器也是如此。</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue开发文档</title>
    <link href="/2022/08/17/Vite%E4%B8%96%E7%95%8C%E6%8C%87%E5%8D%97/"/>
    <url>/2022/08/17/Vite%E4%B8%96%E7%95%8C%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="API-风格"><a href="#API-风格" class="headerlink" title="API 风格"></a>API 风格</h2><p>API说得通俗易懂一些，别人写好的代码，或者编译好的程序，屏蔽了很多底层细节，提供给你使用，就叫做API。你使用了别人代码（或者程序）中的某个函数、类、对象，就叫做使用了某个API。</p><p>Vue 的组件可以按两种不同的风格书写：<strong>选项式 API</strong> 和<strong>组合式 API</strong>。</p><h3 id="选项式-API-Options-API"><a href="#选项式-API-Options-API" class="headerlink" title="选项式 API (Options API)#"></a>选项式 API (Options API)<a href="https://cn.vuejs.org/guide/introduction.html#options-api">#</a></h3><p>选项式 API可以用对象来描述组件的逻辑，例如对象 <code>data</code>、<code>methods</code> 和 <code>mounted</code>。选项所定义的属性都会暴露在函数内部的 <code>this</code> 上，它会指向当前的组件实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default &#123;<br>  // data() 返回的属性将会成为响应式的状态<br>  // 并且暴露在 `this` 上<br>  data() &#123;<br>    return &#123;<br>      count: 0<br>    &#125;<br>  &#125;，<br>  // methods 是一些用来更改状态与触发更新的函数<br>  // 它们可以在模板中作为事件监听器绑定<br>  methods: &#123;<br>    increment() &#123;<br>      this.count++<br>    &#125;<br>  &#125;，<br>  // 生命周期钩子会在组件生命周期的各个不同阶段被调用<br>  // 例如这个函数就会在组件挂载完成后被调用<br>  mounted() &#123;<br>    console.log(`The initial count is $&#123;this.count&#125;.`)<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br>&lt;template&gt;<br>  &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="组合式-API-Composition-API"><a href="#组合式-API-Composition-API" class="headerlink" title="组合式 API (Composition API)#"></a>组合式 API (Composition API)<a href="https://cn.vuejs.org/guide/introduction.html#composition-api">#</a></h3><p>通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。</p><p>在单文件组件中，组合式 API 通常会与<code>&lt;script setup&gt;</code>搭配使用。这个 <code>setup</code> attribute 是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，<code>&lt;script setup&gt;</code> 中的导入和顶层变量和函数都能够在模板中直接使用。</p><p>当使用 <code>&lt;script setup&gt;</code> 的时候，任何在 <code>&lt;script setup&gt;</code> 声明的顶层的绑定 (包括变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>// 变量<br>const msg = &#x27;Hello!&#x27;<br><br>// 函数<br>function log() &#123;<br>  console.log(msg)<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=&quot;log&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>import 导入的内容也会以同样的方式暴露。这意味着我们可以在模板表达式中直接使用导入的 helper 函数，而不需要通过 <code>methods</code> 选项来暴露它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; capitalize &#125; from &#x27;./helpers&#x27;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div&gt;&#123;&#123; capitalize(&#x27;hello&#x27;) &#125;&#125;&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>下面是使用了组合式 API 与 <code>&lt;script setup&gt;</code> 改造后和上面的模板完全一样的组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref， onMounted &#125; from &#x27;vue&#x27;<br><br>// 响应式状态<br>const count = ref(0)<br><br>// 用来修改状态、触发更新的函数<br>function increment() &#123;<br>  count.value++<br>&#125;<br><br>// 生命周期钩子<br>onMounted(() =&gt; &#123;<br>  console.log(`The initial count is $&#123;count.value&#125;.`)<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h2 id="根组件"><a href="#根组件" class="headerlink" title="根组件#"></a>根组件<a href="https://cn.vuejs.org/guide/essentials/application.html#the-root-component">#</a></h2><p>如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">// 从一个单文件组件中导入根组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br></code></pre></td></tr></table></figure><h2 id="挂载应用"><a href="#挂载应用" class="headerlink" title="挂载应用#"></a>挂载应用<a href="https://cn.vuejs.org/guide/essentials/application.html#mounting-the-app">#</a></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>应用根组件的内容将会被渲染在容器元素里面。容器元素自己将<strong>不会</strong>被视为应用的一部分。</p><p><code>.mount()</code> 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是<strong>根组件</strong>实例而非应用实例。</p><h2 id="什么是组合式-API？"><a href="#什么是组合式-API？" class="headerlink" title="什么是组合式 API？#"></a>什么是组合式 API？<a href="https://cn.vuejs.org/guide/extras/composition-api-faq.html#what-is-composition-api">#</a></h2><p>组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。它是一个概括性的术语，涵盖了以下方面的 API：</p><ul><li><a href="https://cn.vuejs.org/api/reactivity-core.html">响应式 API</a>：例如 <code>ref()</code> 和 <code>reactive()</code>，使我们可以直接创建响应式状态、计算属性和侦听器。<strong><code>ref</code>接受参数并返回它包装在一个带有value属性的对象中，然后可以使用该属性访问或改变反应变量的值</strong></li><li><a href="https://cn.vuejs.org/api/composition-api-lifecycle.html">生命周期钩子</a>：例如 <code>onMounted()</code> 和 <code>onUnmounted()</code>，使我们可以在组件各个生命周期阶段添加逻辑。</li><li><a href="https://cn.vuejs.org/api/composition-api-dependency-injection.html">依赖注入</a>：例如 <code>provide()</code> 和 <code>inject()</code>，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref， onMounted &#125; from &#x27;vue&#x27;<br><br>// 响应式状态<br>const count = ref(0)<br><br>// 更改状态、触发更新的函数<br>function increment() &#123;<br>  count.value++<br>&#125;<br><br>// 生命周期钩子<br>onMounted(() =&gt; &#123;<br>  console.log(`计数器初始值为 $&#123;count.value&#125;。`)<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;button @click=&quot;increment&quot;&gt;点击了：&#123;&#123; count &#125;&#125; 次&lt;/button&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h3 id="Vue3-中-ref-访问元素"><a href="#Vue3-中-ref-访问元素" class="headerlink" title="Vue3 中 ref 访问元素"></a>Vue3 中 ref 访问元素</h3><ul><li>让数据变成响应式，即改变会引发视图层的变化</li><li>ref通过给value属性设置setter和getter实现数据劫持</li><li>使我们能创造一种任意值的 “引用” 并能够不丢失响应性地随意传递</li></ul><p>使用ref：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; ref &#125; from &#x27;vue&#x27;<br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">setup()&#123;<br>const xx =ref(初始值)   <br></code></pre></td></tr></table></figure><p>若无初始值则设置为null，返回一个Ref对象，即reference引用对象</p><p>如果传入<code>.value</code>赋值的是对象，将自动调用reactive方法进行深层响应转换，在模板中需要<code>&#123;&#123;xx.属性&#125;&#125;</code>调用，不需要<code>xx.value.属性</code>这么麻烦    </p><p>调用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">xx.value<br>let count = $ref(0)<br></code></pre></td></tr></table></figure><p>之后的操作都不需要.value，直接操作count就行</p><p>自动解套(即不需要xx.value获取值)：</p><p>在setup的<code>return&#123;xx&#125;</code>中，在template中直接<code>&#123;&#123;xx&#125;&#125;</code>，模板会自动加上<code>.value</code>，深层次依旧需要.value</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vue">setup()&#123;<br>let conut =ref(0)<br>let isActive=ref(true)<br>let hasError=ref(false)<br><br>return &#123;<br>nested:&#123;<br>count，<br>isActive，<br>hasError<br>&#125;<br>&#125;<br>&#125;<br>&#123;&#123;count&#125;&#125;<br>:class=&quot;&#123; active: isActive， &#x27;text-danger&#x27;: hasError &#125;&quot;<br></code></pre></td></tr></table></figure><p>使用模板语法遍历获取dom：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">template中:<br> &lt;li v-for=&#x27;(item，index) in 3&#x27; <br> :key=index :ref=&quot;el=&gt;&#123;divs[index]=el&#125;&quot;&gt;<br>          &#123;&#123;item&#125;&#125;<br>      &lt;/li&gt;<br>     或：<br>     &lt;li v-for=&#x27;(item，index) in 3&#x27; :key=index :ref=&quot;divs&quot;&gt;<br>          &#123;&#123;item&#125;&#125;<br>      &lt;/li&gt;<br></code></pre></td></tr></table></figure><p>组件挂载后，即能通过divs.value获取遍历元素的所有dom：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">const divs = ref([])<br>return&#123;<br>divs<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类型声明:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">Ref对象:<br>interface Ref&lt;T&gt; &#123;<br>  value: T<br>&#125;<br></code></pre></td></tr></table></figure><p>ref函数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">function ref&lt;T&gt;(value: T): Ref&lt;T&gt;<br></code></pre></td></tr></table></figure><p>类型约束:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">const foo = ref&lt;string | number&gt;(&#x27;foo&#x27;)<br>未知类型:<br>function useState&lt;T&gt;(initial: T) &#123;<br>  const state = ref(initial) as Ref&lt;T&gt; <br>  return state<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础知识</title>
    <link href="/2022/08/14/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/08/14/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="JavaScript基础知识"><a href="#JavaScript基础知识" class="headerlink" title="JavaScript基础知识"></a>JavaScript基础知识</h1><h2 id="一、现代模式，”use-strict”"><a href="#一、现代模式，”use-strict”" class="headerlink" title="一、现代模式，”use strict”"></a>一、现代模式，”use strict”</h2><p>长久以来，JavaScript 不断向前发展且并未带来任何兼容性问题。新的特性被加入，旧的功能也没有改变。</p><p>这么做有利于兼容旧代码，但缺点是 JavaScript 创造者的任何错误或不完善的决定也将永远被保留在 JavaScript 语言中。</p><p>这种情况一直持续到 2009 年 ECMAScript 5 (ES5) 的出现。ES5 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。你需要一个特殊的指令 —— <code>&quot;use strict&quot;</code> 来明确地激活这些特性。</p><h3 id="“use-strict”"><a href="#“use-strict”" class="headerlink" title="“use strict”"></a><a href="https://zh.javascript.info/strict-mode#usestrict">“use strict”</a></h3><p><code>&quot;use strict&quot;</code> 可以被放在函数体的开头。这样则可以只在该函数中启用严格模式。但通常人们会在整个脚本中启用严格模式。</p><p><strong>确保 “use strict” 出现在最顶部</strong></p><p>请确保 <code>&quot;use strict&quot;</code> 出现在脚本的最顶部，否则严格模式可能无法启用。</p><p>这里的严格模式就没有被启用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;some code&quot;</span>);<br><span class="hljs-comment">// 下面的 &quot;use strict&quot; 会被忽略，必须在最顶部。</span><br><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br><span class="hljs-comment">// 严格模式没有被激活</span><br></code></pre></td></tr></table></figure><p>只有注释可以出现在 <code>&quot;use strict&quot;</code> 的上面。</p><p><strong>没有办法取消 <code>use strict</code></strong></p><p>没有类似于 <code>&quot;no use strict&quot;</code> 这样的指令可以使程序返回默认模式。</p><p>一旦进入了严格模式，就没有回头路了。</p><h3 id="我们应该使用-“use-strict”-吗？"><a href="#我们应该使用-“use-strict”-吗？" class="headerlink" title="我们应该使用 “use strict” 吗？"></a><a href="https://zh.javascript.info/strict-mode#wo-men-ying-gai-shi-yong-usestrict-ma">我们应该使用 “use strict” 吗？</a></h3><p>有人可能会建议在脚本的最顶部放置 <code>&quot;use strict&quot;</code> 这行代码…… 但你知道更酷的方式吗？</p><p>现代 JavaScript 支持 “class” 和 “module” —— 高级语言结构（本教程后续章节会讲到），它们会自动启用 <code>use strict</code>。因此，如果我们使用它们，则无需添加 <code>&quot;use strict&quot;</code> 指令。</p><p><strong>因此，目前我们欢迎将 <code>&quot;use strict&quot;;</code> 写在脚本的顶部。稍后，当你的代码全都写在了 class 和 module 中时，你则可以将 <code>&quot;use strict&quot;;</code> 这行代码省略掉。</strong></p><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><p>JavaScript 中有八种基本的数据类型。</p><ul><li>七种原始数据类型：<ul><li><code>number</code> 用于任何类型的数字：整数或浮点数，在 <code>±(253-1)</code> 范围内的整数。</li><li><code>bigint</code> 用于任意长度的整数。</li><li><code>string</code> 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。</li><li><code>boolean</code> 用于 <code>true</code> 和 <code>false</code>。</li><li><code>null</code> 用于未知的值 —— 只有一个 <code>null</code> 值的独立类型。</li><li><code>undefined</code> 用于未定义的值 —— 只有一个 <code>undefined</code> 值的独立类型。</li><li><code>symbol</code> 用于唯一的标识符。</li></ul></li><li>以及一种非原始数据类型：<ul><li><code>object</code> 用于更复杂的数据结构。</li></ul></li></ul><p>我们可以通过 <code>typeof</code> 运算符查看存储在变量中的数据类型。</p><ul><li>通常用作 <code>typeof x</code>，但 <code>typeof(x)</code> 也可行。</li><li>以字符串的形式返回类型名称，例如 <code>&quot;string&quot;</code>。</li><li><code>typeof null</code> 会返回 <code>&quot;object&quot;</code> —— 这是 JavaScript 编程语言的一个错误，实际上它并不是一个 <code>object</code>。</li></ul><h2 id="三、空值合并运算符-‘-’"><a href="#三、空值合并运算符-‘-’" class="headerlink" title="三、空值合并运算符 ‘??’"></a>三、空值合并运算符 ‘??’</h2><p><strong>最近新增的特性</strong></p><p>空值合并运算符（nullish coalescing operator）的写法为两个问号 <code>??</code>。</p><p><code>a ?? b</code> 的结果是：</p><ul><li>如果 <code>a</code> 是已定义的，则结果为 <code>a</code>，</li><li>如果 <code>a</code> 不是已定义的，则结果为 <code>b</code>。</li></ul><p>如果第一个参数不是 <code>null/undefined</code>，则 <code>??</code> 返回第一个参数。否则，返回第二个参数。</p><p>我们可以使用我们已知的运算符重写 <code>result = a ?? b</code>，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">result = (a !== <span class="hljs-literal">null</span> &amp;&amp; a !== <span class="hljs-literal">undefined</span>) ? a : b;<br></code></pre></td></tr></table></figure><p><code>??</code> 的常见使用场景是提供默认值。</p><p>例如，在这里，如果 <code>user</code> 的值不为 <code>null/undefined</code> 则显示 <code>user</code>，否则显示 <code>匿名</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user;<br><br><span class="hljs-title function_">alert</span>(user ?? <span class="hljs-string">&quot;匿名&quot;</span>); <span class="hljs-comment">// 匿名（user 未定义）</span><br></code></pre></td></tr></table></figure><p>在下面这个例子中，我们将一个名字赋值给了 <code>user</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-string">&quot;John&quot;</span>;<br><br><span class="hljs-title function_">alert</span>(user ?? <span class="hljs-string">&quot;匿名&quot;</span>); <span class="hljs-comment">// John（user 已定义）</span><br></code></pre></td></tr></table></figure><p>我们还可以使用 <code>??</code> 序列从一系列的值中选择出第一个非 <code>null/undefined</code> 的值。</p><p>假设我们在变量 <code>firstName</code>、<code>lastName</code> 或 <code>nickName</code> 中存储着一个用户的数据。如果用户决定不填写相应的值，则所有这些变量的值都可能是未定义的。</p><p>我们想使用这些变量之一显示用户名，如果这些变量的值都是 <code>null/undefined</code>，则显示 “匿名”。</p><p>让我们使用 <code>??</code> 运算符来实现这一需求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> firstName = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> lastName = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> nickName = <span class="hljs-string">&quot;Supercoder&quot;</span>;<br><br><span class="hljs-comment">// 显示第一个已定义的值：</span><br><span class="hljs-title function_">alert</span>(firstName ?? lastName ?? nickName ?? <span class="hljs-string">&quot;匿名&quot;</span>); <span class="hljs-comment">// Supercoder</span><br></code></pre></td></tr></table></figure><h2 id="四、箭头函数，基础知识"><a href="#四、箭头函数，基础知识" class="headerlink" title="四、箭头函数，基础知识"></a>四、箭头函数，基础知识</h2><p>创建函数还有另外一种非常简单的语法，并且这种方法通常比函数表达式更好。</p><p>函数表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Hello&quot;</span> );<br>&#125;;<br></code></pre></td></tr></table></figure><p>箭头函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg1, arg2, ..., argN</span>) =&gt; expression;<br></code></pre></td></tr></table></figure><p>这里创建了一个函数 <code>func</code>，它接受参数 <code>arg1..argN</code>，然后使用参数对右侧的 <code>expression</code> 求值并返回其结果。</p><p>换句话说，它是下面这段代码的更短的版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> func = <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2, ..., argN</span>) &#123;<br>  <span class="hljs-keyword">return</span> expression;<br>&#125;;<br></code></pre></td></tr></table></figure><p>让我们来看一个具体的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><br><span class="hljs-comment">/* 这个箭头函数是下面这个函数的更短的版本：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">let sum = function(a, b) &#123;</span><br><span class="hljs-comment">  return a + b;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>可以看到 <code>(a, b) =&gt; a + b</code> 表示一个函数接受两个名为 <code>a</code> 和 <code>b</code> 的参数。在执行时，它将对表达式 <code>a + b</code> 求值，并返回计算结果。</p><ul><li><p>如果我们只有一个参数，还可以省略掉参数外的圆括号，使代码更短。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">double</span> = n =&gt; n * <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 差不多等同于：let double = function(n) &#123; return n * 2 &#125;</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-title function_">double</span>(<span class="hljs-number">3</span>) ); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure></li><li><p>如果没有参数，括号则是空的（但括号必须保留）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">sayHi</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br><br><span class="hljs-title function_">sayHi</span>();<br></code></pre></td></tr></table></figure></li></ul><p>箭头函数可以像函数表达式一样使用。</p><p>例如，动态创建一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;What is your age?&quot;</span>, <span class="hljs-number">18</span>);<br><br><span class="hljs-keyword">let</span> welcome = (age &lt; <span class="hljs-number">18</span>) ?<br>  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>) :<br>  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Greetings!&quot;</span>);<br><br><span class="hljs-title function_">welcome</span>();<br></code></pre></td></tr></table></figure><p>一开始，箭头函数可能看起来并不熟悉，也不容易读懂，但一旦我们看习惯了之后，这种情况很快就会改变。</p><p>箭头函数对于简单的单行行为（action）来说非常方便，尤其是当我们懒得打太多字的时候。</p><h3 id="多行的箭头函数"><a href="#多行的箭头函数" class="headerlink" title="多行的箭头函数"></a><a href="https://zh.javascript.info/arrow-functions-basics#duo-hang-de-jian-tou-han-shu">多行的箭头函数</a></h3><p>到目前为止，我们看到的箭头函数非常简单。它们从 <code>=&gt;</code> 的左侧获取参数，计算并返回右侧表达式的计算结果。</p><p>有时我们需要更复杂一点的函数，比如带有多行的表达式或语句。</p><p>在这种情况下，我们可以使用花括号将它们括起来。主要区别在于，用花括号括起来之后，需要包含 <code>return</code> 才能返回值（就像常规函数一样）。</p><p>就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;  <span class="hljs-comment">// 花括号表示开始一个多行函数</span><br>  <span class="hljs-keyword">let</span> result = a + b;<br>  <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 如果我们使用了花括号，那么我们需要一个显式的 “return”</span><br>&#125;;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h2 id="五、回调函数"><a href="#五、回调函数" class="headerlink" title="五、回调函数"></a>五、回调函数</h2><p>让我们多举几个例子，看看如何将函数作为值来传递以及如何使用函数表达式。</p><p>我们写一个包含三个参数的函数 <code>ask(question, yes, no)</code>：</p><ul><li><p><code>question</code></p><p>关于问题的文本</p></li><li><p><code>yes</code></p><p>当回答为 “Yes” 时，要运行的脚本</p></li><li><p><code>no</code></p><p>当回答为 “No” 时，要运行的脚本</p></li></ul><p>函数需要提出 <code>question</code>（问题），并根据用户的回答，调用 <code>yes()</code> 或 <code>no()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ask</span>(<span class="hljs-params">question, yes, no</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">confirm</span>(question)) <span class="hljs-title function_">yes</span>()<br>  <span class="hljs-keyword">else</span> <span class="hljs-title function_">no</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showOk</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;You agreed.&quot;</span> );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showCancel</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;You canceled the execution.&quot;</span> );<br>&#125;<br><br><span class="hljs-comment">// 用法：函数 showOk 和 showCancel 被作为参数传入到 ask</span><br><span class="hljs-title function_">ask</span>(<span class="hljs-string">&quot;Do you agree?&quot;</span>, showOk, showCancel);<br></code></pre></td></tr></table></figure><p>在实际开发中，这样的函数是非常有用的。实际开发与上述示例最大的区别是，实际开发中的函数会通过更加复杂的方式与用户进行交互，而不是通过简单的 <code>confirm</code>。在浏览器中，这样的函数通常会绘制一个漂亮的提问窗口。但这是另外一件事了。</p><p><code>ask</code> 的两个参数值 <code>showOk</code> 和 <code>showCancel</code> 可以被称为 <strong>回调函数</strong> 或简称 <strong>回调</strong>。</p><p>主要思想是我们传递一个函数，并期望在稍后必要时将其“回调”。在我们的例子中，<code>showOk</code> 是回答 “yes” 的回调，<code>showCancel</code> 是回答 “no” 的回调。</p><p>我们可以使用函数表达式来编写一个等价的、更简洁的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ask</span>(<span class="hljs-params">question, yes, no</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">confirm</span>(question)) <span class="hljs-title function_">yes</span>()<br>  <span class="hljs-keyword">else</span> <span class="hljs-title function_">no</span>();<br>&#125;<br><br><span class="hljs-title function_">ask</span>(<br>  <span class="hljs-string">&quot;Do you agree?&quot;</span>,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;You agreed.&quot;</span>); &#125;,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;You canceled the execution.&quot;</span>); &#125;<br>);<br></code></pre></td></tr></table></figure><p>这里直接在 <code>ask(...)</code> 调用内进行函数声明。这两个函数没有名字，所以叫 <strong>匿名函数</strong>。这样的函数在 <code>ask</code> 外无法访问（因为没有对它们分配变量），不过这正是我们想要的。</p><p>这样的代码在我们的脚本中非常常见，这正符合 JavaScript 语言的思想。</p><p><strong>一个函数是表示一个“行为”的值</strong></p><p>字符串或数字等常规值代表 <strong>数据</strong>。</p><p>函数可以被视为一个 <strong>行为（action）</strong>。</p><p>我们可以在变量之间传递它们，并在需要时运行。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3.x 基础语法篇</title>
    <link href="/2022/08/13/vue3-x-01/"/>
    <url>/2022/08/13/vue3-x-01/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="Vue3-x-基础语法"><a href="#Vue3-x-基础语法" class="headerlink" title="Vue3.x 基础语法"></a>Vue3.x 基础语法</h1><h3 id="一、初识Vue"><a href="#一、初识Vue" class="headerlink" title="一、初识Vue"></a>一、初识Vue</h3><h4 id="什么是vue"><a href="#什么是vue" class="headerlink" title="什么是vue"></a>什么是vue</h4><p>vue是一套用于构建用户界面的渐进式框架。</p><blockquote><p>渐进式：可以用不同的小功能组装成一个大功能。</p></blockquote><p>它是一个开源的js框架，内部对js进行了封装，也是单页面应用的web应用框架。 </p><blockquote><p>单页面应用：只有一个html 的应用，所有的功能都是用js在一个html中去操作。</p></blockquote><h4 id="什么是MVVM框架"><a href="#什么是MVVM框架" class="headerlink" title="什么是MVVM框架"></a>什么是MVVM框架</h4><p>MVC： model数据层    view 视图层    cotrol控制器。</p><p>连接view和model层，并做一些逻辑处理。mvc更适合后端的开发。</p><p>MVVM：model数据    view dom渲染用户界面 vm：view-model 处理视图和数据的中间层</p><h4 id="vue3的新特性"><a href="#vue3的新特性" class="headerlink" title="vue3的新特性"></a>vue3的新特性</h4><ol><li>更小。精简的库带来一个轻量级的包，只有15K，比vue2小了50%</li><li>更快。很多框架都进行了全面的升级，重写了虚拟dom，有效提升了速度</li><li>通过composition API 将各个功能的代码组合在一起，同时提供出色的ts支持，代码更简洁，易于维护。</li></ol><h4 id="vue-的安装"><a href="#vue-的安装" class="headerlink" title="vue 的安装"></a>vue 的安装</h4><ol><li>在页面上以cdn的包的形式直接引入js，就像引入jquery一样</li><li>下载vue文件到本地引入</li><li>通过npm的方式引入</li><li>通过vite构建工具引入</li></ol><h4 id="vue的使用"><a href="#vue的使用" class="headerlink" title="vue的使用"></a>vue的使用</h4><p>1.通过cdn引入，创建dom容器</p><p>2.创建一个组件，组件就是vue拥有的一段比较完整功能的业务逻辑。用代码表示组件就是一个对象</p><p>3.实例化vue，把生成的vue实例挂载到真实dom上面，dom就可以使用vue的语法或者属性，使用vue的mount方法挂载。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">const app = Vue.createApp(HelloVue).mount(&#x27;#app&#x27;)<br></code></pre></td></tr></table></figure><p>4.在dom上使用字面量的形式展示数据，里面除了写数据以外，还可以写单行的js表达式，比如 + - * / 三元表达式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;div id=&quot;app&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure><h4 id="创建Vite项目"><a href="#创建Vite项目" class="headerlink" title="创建Vite项目"></a>创建Vite项目</h4><p>第一步：创建vite项目</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">npm init vite@latest app01 --template vue<br></code></pre></td></tr></table></figure><p>第二步：进入app01文件夹 <code>npm install</code> 安装项目依赖</p><p>第三步：<code>npm run dev</code> 运行项目</p><p><strong>.vue文件组件</strong></p><p>.vue结尾的就是我们的vue组件，vite会在我们开发完以后把它打包。我们平时开发，都是开发一个一个的.vue文件。</p><p><strong>.vue 文件的注释：</strong></p><p>script setup：script标签里面写js代码，setup属性表示该js是一个setup函数</p><p>template:  vue的模板文件，一个.vue文件只能有一个顶层的template标签，但是里面可以包含多个template</p><p>style scope.: style标签是写样式， scope属性表示样式是局部样式，只能在这个组件内使用。style标签一个vue组件里可以有多个。</p><p>lang可以指定编译语言，比如sass，（需要安装sass：<code>npm i sass -D</code>）</p><p>可以引入外部的css文件 style src = “xxx.sass”</p><h4 id="reander函数"><a href="#reander函数" class="headerlink" title="reander函数"></a>reander函数</h4><p>render函数可以渲染解析编译器的模板，内部是需要返回h() 函数创建的dom</p><p>h() 函数是根据js生成对应的dom，也是vue虚拟dom的一个第三方库提供的方法</p><p><strong>子组件向父组件传递参数</strong></p><p>方法1：通过父组件传递函数作为属性给子组件，子组件调用函数传递参数（在mounted中调用）</p><p>父组件通过属性给子组件传递函数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;HelloWorld :sendMsg=&quot;getMsg&quot;/&gt;<br>   methods:&#123;<br>    getMsg(data)&#123;<br>      console.log(data)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>子组件通过props接收，并且在mounted中调用</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">data()&#123;<br>    return &#123;<br>      msg:&#x27;子组件数据&#x27;<br>    &#125;<br>  &#125;,<br>  props:&#123;<br>    sendMsg:&#123;<br>      type:Function<br>    &#125;<br>  &#125;,<br>  mounted()&#123;<br>    this.sendMsg(this.msg)<br>  &#125;<br></code></pre></td></tr></table></figure><p>方法2：通过事件触发的方式向父组件传递参数（发布订阅模式）</p><p>第一步：在子组件上绑定事件和事件触发函数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;HelloWorld @getValue=&quot;getValue&quot;/&gt;<br></code></pre></td></tr></table></figure><p>第二步：子组件通过$emit触发函数传递参数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">mounted()&#123;<br>    this.$emit(&#x27;getValue&#x27;,this.msg)<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="vue3新增内容"><a href="#vue3新增内容" class="headerlink" title="vue3新增内容"></a>vue3新增内容</h4><p>vue3行政setup函数，取代了beforecreate和created生命周期函数。</p><p>vue3的setup函数里没有this指向，也没有data和methods等，vue3的逻辑代码都是写在setup里。</p><p>vue3通过ref函数去返回一个响应式的可变对象，有一个value属性指向响应内部的值，修改值就给value属性赋值。</p><p>setup内部的数据或者方法，需要以对象的形式返回出去，template模板才能够使用它。</p><p>vue3的生命周期是从vue中引入的生命周期函数，仍然是写在setup函数中。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">import &#123;ref,onMounted&#125; from &#x27;vue&#x27;<br>    export default &#123;<br>        setup()&#123;<br>            let count = ref(0)<br>            let add = ()=&gt;&#123;<br>                count.value ++<br>            &#125;<br>            onMounted(()=&gt;&#123;<br>                console.log(1)<br>            &#125;)<br>            return &#123;<br>                count,add<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>vue3的简写：在script标签添加setup，表示script里面的代码都是在setup函数里，并且里面的属性和方法都是直接return到外部的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;script setup&gt;<br>    import &#123;ref,onMounted&#125; from &#x27;vue&#x27;<br>    let count = ref(0)<br>    let add = ()=&gt;&#123;<br>        count.value ++<br>    &#125;<br>    onMounted(()=&gt;&#123;<br>        console.log(1)<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="vue2-6以后的插槽变化"><a href="#vue2-6以后的插槽变化" class="headerlink" title="vue2.6以后的插槽变化"></a>vue2.6以后的插槽变化</h4><p>使用插槽需要v-slot：插槽名，slot没有指定插槽名的则是默认插槽default</p><p>slot插槽可以传值，有固定的语法套路，父组件中可以使用子组件的值</p><p>子组件定义插槽</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;slot&gt;&lt;/slot&gt;<br> &lt;slot name=&quot;footer&quot; :ctx=&quot;msg&quot;&gt;&lt;/slot&gt;<br></code></pre></td></tr></table></figure><p>父组件 data是子组件上所有属性的集合</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;vue3ComVue&gt;<br>  &lt;template v-slot:footer=&quot;data&quot;&gt;<br>    &lt;h2&gt;我是footer&lt;/h2&gt;<br>    &lt;div&gt;&#123;&#123;data.ctx.name&#125;&#125;&lt;/div&gt;<br>  &lt;/template&gt;<br>  &lt;template v-slot:default&gt;<br>    &lt;div&gt;我是default&lt;/div&gt;<br>  &lt;/template&gt;<br>&lt;/vue3ComVue&gt;<br></code></pre></td></tr></table></figure><h4 id="Setup语法糖"><a href="#Setup语法糖" class="headerlink" title="Setup语法糖"></a>Setup语法糖</h4><p>setup语法糖：使语言更加清晰，方便，更符合编程习惯。</p><p>使用setup语法糖，script直接引入组件就可以在template模板里使用，无需注册</p><p>setup语法糖，使用props，需要使用defineProps( 编译器宏)，不用import引入，直接调用，可以定义props，获取外部传递的属性。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;script setup&gt;<br> const props = defineProps(&#123;<br>        name:String,<br>        age:Number<br>    &#125;)<br>console.log(props.name,props.age)<br> &lt;/script&gt;<br></code></pre></td></tr></table></figure><p>setup语法糖中使用watch：</p><p>vue3中的watch是一个函数，需要从vue中引入,watch可以监听多个属性。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">watch</span><span class="hljs-params">([value1,value2...],(oldValue,newValue)</span></span>=&gt;&#123;&#125;)<br><span class="hljs-function"><span class="hljs-title">watch</span><span class="hljs-params">([count],(oldValue,newValue)</span></span>=&gt;&#123;<br>        console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;data:&#x27;</span>,newValue) <span class="hljs-comment">// newValue也是放在数组中</span><br>    &#125;)<br></code></pre></td></tr></table></figure><p>vue3中的计算属性的使用：</p><p>vue3中的计算属性是一个函数，需要从vue中引入，返回值就是计算属性的值。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">let countCom = computed(()=&gt;count.value + &#x27;元&#x27;)<br></code></pre></td></tr></table></figure><p>vue3中的ref获取元素dom</p><p>在元素上面绑定ref= ‘xxx1’ , 在setup中定义相同的变量名，在元素挂载以后，即可获取refs对应的dom元素</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;div ref=&quot;dom111&quot;&gt;我是dom111&lt;/div&gt;<br> let dom111 = ref(null)<br>  onMounted(()=&gt;&#123;<br>        console.log(dom111.value)<br>    &#125;)<br></code></pre></td></tr></table></figure><h3 id="二、框架"><a href="#二、框架" class="headerlink" title="二、框架"></a>二、框架</h3><h4 id="组件的data函数"><a href="#组件的data函数" class="headerlink" title="组件的data函数"></a>组件的data函数</h4><p>在创建组件的实例化过程中会调用这个函数，返回一个对象。vue会通过响应式系统将其包裹起来，以 $data的形式存储在组件实例中。</p><h4 id="组件的methods属性"><a href="#组件的methods属性" class="headerlink" title="组件的methods属性"></a>组件的methods属性</h4><p>methods可以创建组件的方法，methods的属性值是一个对象。this表示组件实例，data返回的数据都可以通过this.xx去获取到。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">methods: &#123;<br>              inc()&#123;<br>                this.count ++<br>              &#125;  <br>            &#125;,<br></code></pre></td></tr></table></figure><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>带有v-前缀的特殊属性，不同的指令有不同的功能</p><p>v-once 让dom元素只渲染一次，后续如果数据有变化则不会改变。</p><p>v-html 可以渲染html标签</p><p>v-bind 可以绑定属性，v-bind 可以简写为一个冒号 ：</p><p>动态参数：vue3增加了动态参数，可以用[] 表示动态参数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;p :[key]=&quot;value&quot;&gt;1213&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>v-model 实现数据的双向绑定（一边输入一边显示），一般是用在input等输入的元素上。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;input type=&quot;text&quot; v-model=&quot;value&quot;&gt;<br>&lt;p&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>v-on监听dom的事件，(绑定事件)，事件来源于methods定义的函数，v-on可以简写成@</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;button @click=&quot;inc&quot;&gt;&lt;/button&gt;<br></code></pre></td></tr></table></figure><h4 id="Vue3框架"><a href="#Vue3框架" class="headerlink" title="Vue3框架"></a>Vue3框架</h4><p>引入Vue3的框架之后，先在<code>&lt;body&gt;</code>标签中，加入一个<code>&lt;div&gt;</code>层,并给他一个<code>id=&quot;app&quot;</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Hello World&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    Vue.createApp(&#123;<br>        template: &#x27;&lt;div&gt;Hello World&lt;/div&gt;&#x27;<br>    &#125;).mount(&quot;#app&quot;)<br>&lt;/script&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>其中，Vue的语法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;   <span class="hljs-comment">//创建一个Vue实例，简单理解就说，我要使用Vue了</span><br>    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;Hello World&lt;/div&gt;&#x27;</span>   <span class="hljs-comment">// template是模板的意思，就是在JS里写html代码</span><br>&#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)   <span class="hljs-comment">//这个模板需要放一个位置，也就是说挂载，挂载到`id=app`的DOM上</span><br></code></pre></td></tr></table></figure><ol><li>用<code>Vue.</code>创建一个实例对象，符合命名规范即可</li><li>用<code>template</code>创建一个模版，里面是<code>html</code>代码</li><li><code>.mount</code>是模版要挂载的位置</li></ol><h4 id="事件触发多个绑定函数的方法"><a href="#事件触发多个绑定函数的方法" class="headerlink" title="事件触发多个绑定函数的方法"></a>事件触发多个绑定函数的方法</h4><p>每个函数都要加小括号，用逗号隔开</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;button @click=&quot;inc(),inc2()&quot;&gt;click&lt;/button&gt;<br></code></pre></td></tr></table></figure><h4 id="vue事件修饰符v-on"><a href="#vue事件修饰符v-on" class="headerlink" title="vue事件修饰符v-on"></a>vue事件修饰符v-on</h4><p>处理事件，提供了一些默认的操作。常用的有处理事件冒泡和默认行为</p><blockquote><p>冒泡事件就是从当前事件（事件源）一直执行到最外层事件</p><p>为什么要阻止冒泡？</p><p>很简单的一个例子，盒子one中有一个盒子two，盒子two中有一个button上面绑着事件a，而这个相同事件恰巧在盒子one和two中也有，当button事件被触发时，one和two中的事件也会被触发，所以我们需要进行阻止。</p></blockquote><p>事件修饰符可以串联使用</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">@click.top = xxx // 阻止事件冒泡<br>@click.prevent = xxx. //阻止默认行为<br></code></pre></td></tr></table></figure><p>键盘事件修饰符：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">@keydown.a // a键按下触发<br></code></pre></td></tr></table></figure><h4 id="条件语句v-if"><a href="#条件语句v-if" class="headerlink" title="条件语句v-if"></a>条件语句v-if</h4><p>v-if指令，为true的时候渲染，为false的时候不渲染dom</p><p>多个条件的话使用 v-if、v-else-if、v-else</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;div v-if=&quot;name === 123&quot;&gt;123 &lt;/div&gt;<br>&lt;div v-else-if=&quot;name === 234&quot;&gt;234&lt;/div&gt;<br>&lt;div v-else&gt;hhhh&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>v-show：和v-if有点像，为true则显示元素，为fasle则隐藏元素。</p><p>区别：v-show是通过css的display控制元素的显示和隐藏的，而v-if是通过是否加载（渲染）dom来实现的。</p><p>对于需要频繁切换显示隐藏的，使用v-show可以提高性能</p><p>v-for：循环渲染语句指令</p><p>for循环需要绑定key值，item是list的元素。用in去遍历list数组</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;div v-for=&quot;(item,index) in list&quot; ::key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;<br> // ===<br>  list:[&#x27;js&#x27;,&#x27;node&#x27;,&#x27;vue3&#x27;,&#x27;react&#x27;]<br></code></pre></td></tr></table></figure><p>遍历对象：</p><p>value对象属性，key对象的键，index是索引值</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;div v-for=&quot;(value,key,index) in obj&quot; ::key=&quot;value&quot;&gt;&#123;&#123;index&#125;&#125;=&#123;&#123;key&#125;&#125;==&#123;&#123;value&#125;&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure><blockquote><p>冒号左边是对象，右边是函数，该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p><p><strong>双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</strong></p></blockquote><p>迭代整数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;div v-for=&quot;i in 5&quot;&gt;&#123;&#123;i&#125;&#125;&lt;/div&gt;<br></code></pre></td></tr></table></figure><h4 id="vue的样式绑定v-bind"><a href="#vue的样式绑定v-bind" class="headerlink" title="vue的样式绑定v-bind"></a>vue的样式绑定v-bind</h4><p><strong>class属性绑定</strong></p><p>方法1：直接写对象</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;div :class=&quot;&#123;box:true&#125;&quot;&gt;box&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>方法2：class绑定一个变量，这个变量是一个对象</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;div :class=&quot;classObj&quot;&gt;classBox&lt;/div&gt;<br>// ====显示<br> classObj:&#123;name:true,box2:true,box3:false&#125;,<br></code></pre></td></tr></table></figure><p>方法3：class绑定数组，则数组中所有元素都是class的类名，数组的元素支持三元表达式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;div :class=&quot;[isTrue?&#x27;js&#x27;:&#x27;&#x27;,&#x27;node&#x27;,&#x27;vue3&#x27;,&#x27;react&#x27;]&quot;&gt;list&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>v-on绑定的class可以和静态的class共存。</p><p><strong>style属性绑定</strong></p><p>方法1：对象形式绑定style，此时-要变成驼峰</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;div :style=&quot;&#123;fontSize:&#x27;18px&#x27;,color:&#x27;red&#x27;&#125;&quot;&gt;miaomiaomiap&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>方法2：数组对象的形式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;div :style=&quot;[&#123;color:&#x27;red&#x27;&#125;,&#123;background:&#x27;yellow&#x27;&#125;]&quot;&gt;7777777&lt;/div&gt;<br></code></pre></td></tr></table></figure><h4 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h4><p>computed计算属性可以视为和data的数据一样，可以读取和赋值。</p><p>computed的计算结果会被缓存，如果监听数据没有变化，则用的是缓存的数据。</p><p>下面的就是double计算属性是依赖于count的，如果count没有变化，则double就不会重新渲染。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;div id=&quot;app&quot;&gt;<br>   &lt;p&gt; &#123;&#123;count&#125;&#125; &lt;/p&gt;<br>   &lt;p&gt; &#123;&#123;double&#125;&#125; &lt;/p&gt;<br>&lt;/div&gt;<br>data()&#123;<br>    return &#123;<br>        count:1 <br>    &#125;<br>&#125;,<br>computed:&#123;<br>    double()&#123;<br>        return this.count*2<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p><strong>计算属性的读写</strong></p><p>一般计算属性只会读取，所以用的简写，如果要设置计算属性，则计算属性要写成对象形式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">computed:&#123;<br>    double:&#123;<br>        get()&#123;<br>            return this.count*2<br>        &#125;,<br>        set(value)&#123;<br>            this.count = value<br>        &#125;  <br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h4 id="监听属性"><a href="#监听属性" class="headerlink" title="监听属性"></a>监听属性</h4><p>watch监听属性：可以观察和响应vue实例的数据变动</p><p>watch一次只能监听一个数据的状态，监听某个data属性，就在watch中把他写成方法</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">data()&#123;<br>    return &#123;<br>        count:1 <br>    &#125;<br>&#125;,<br>watch:&#123;<br>    count(value)&#123;<br>        if(value &gt; 10)&#123;<br>            console.log(&#x27;数量不能大于10！&#x27;)<br>            this.count = 0<br>        &#125;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>watch里面不要轻易修改监听的数据，容易陷入无限循环。</p><p>watch里面可以异步加载，比如发送ajax请求</p><p>watch主要是对监听的数据发生变化后，去进行一些操作</p><h4 id="watch和computed的区别"><a href="#watch和computed的区别" class="headerlink" title="watch和computed的区别"></a>watch和computed的区别</h4><p><strong>计算属性computed</strong></p><ol><li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li><li>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，使用computed</li><li>computed的简写是一个函数，函数走的是get方法；computed如果是对象的写法，属性都有一个get和一个set方法，当数据变化时，调用set方法</li><li>一些重复使用的数据或复杂及费时的运算时，把它放入computed中进行计算, 然后会在computed中缓存起来, 下次就可以直接获取</li></ol><p><strong>watch</strong></p><ol><li>watch它是一个对data的数据监听回调, 当依赖的data的数据变化时, 会执行回调。在回调中会传入newVal和oldVal两个参数。当在data中的某个数据发生变化时, 我们需要做一些操作，就使用watch。watch普通监听和深度监听不支持缓存，数据变，直接会触发相应的操作</li><li>immediate：组件加载立即触发回调函数执行， deep: 深度监听watch支持异步。</li></ol><p><strong>watch 和 computed的区别：</strong></p><p>相同点：他们两者都是观察页面数据变化的。</p><p>不同点：computed只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。 watch每次都需要执行函数。watch更适用于数据变化时的异步操作。</p><p>watch更注重数据变化时执行的过程，可以没有返回值作为结果</p><p>computed更注重数据变化得出的结果，一定要有返回值。</p><h4 id="数据绑定v-model"><a href="#数据绑定v-model" class="headerlink" title="数据绑定v-model"></a>数据绑定v-model</h4><p>form表单的值都是通过v-model绑定值到数据，数据是双向绑定的。</p><p>input输入框默认触发的是input事件</p><p>默认的input的事件该为change事件：加一个lazy修饰符 v-model.lazy = xxx</p><p>清除前后空格：trim修饰符 v-model.trim = xxx</p><p>v-model绑定radio单选框获取的是value值，给数据默认值可以控制默认选中的项。默认触发的是change事件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; v-model=&quot;sex&quot;&gt;男<br>&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;2&quot; v-model=&quot;sex&quot;&gt;女<br></code></pre></td></tr></table></figure><p><strong>v-model绑定checkebox多选框</strong></p><p>v-model绑定多选框的时候，绑定的是一个数组。默认触发的是change事件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;input type=&quot;checkbox&quot; v-model=&quot;like&quot; value=&quot;吃饭&quot;&gt;吃饭<br>&lt;input type=&quot;checkbox&quot; v-model=&quot;like&quot; value=&quot;睡觉&quot;&gt;睡觉<br></code></pre></td></tr></table></figure><p><strong>v-model绑定selsect下拉框</strong></p><p>v-model绑定在select上，单选的是一个字符串</p><p><strong>自定义指令</strong></p><p>directive可以自定义指令，自定义指令的名称不需要加v-，调用的时候加。mounted是指令挂载到dom的时候执行自定义指令的钩子函数的参数 el 挂载的dom对象，binding 一个对象，包含了指令相关的一些属性. vnode 真实的dom对象相关信息</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;div id=&quot;app&quot;&gt;<br>    &lt;input type=&quot;text&quot; v-focus&gt;<br>   &lt;/div&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@3&quot;&gt;&lt;/script&gt;<br>    &lt;script&gt;<br>        const app = Vue.createApp(&#123;&#125;)<br>        app.directive(&#x27;focus&#x27;,&#123;<br>            mounted(el,binding,vnode) &#123;<br>                console.log(el,binding,vnode);<br>                el.focus()<br>            &#125;,<br>        &#125;)<br>        app.mount(&#x27;#app&#x27;)<br>    &lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h3><h4 id="示例1：Vue3编写的计数器"><a href="#示例1：Vue3编写的计数器" class="headerlink" title="示例1：Vue3编写的计数器"></a>示例1：Vue3编写的计数器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;   <br>    &lt;script&gt;<br>        Vue.createApp(&#123;<br>            data()&#123;<br>                return&#123;<br>                    counter:1//在data()中声明counter变量<br>                &#125;<br>            &#125;,<br>            mounted()&#123;<br>                setInterval(()=&gt;&#123;<br>                    this.counter+=1<br>                &#125;,1000)<br>            &#125;,//只要页面一加载，就会执行这个步骤<br>            template:&#x27;&lt;div&gt;&#123;&#123;counter&#125;&#125;&lt;/div&gt;&#x27;//显示变量的值<br>        &#125;).mount(&quot;#app&quot;)<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>mounted( )中实现自增</strong></p><p><code>mounted</code>是一个声明周期钩子函数，可以把他想成是页加载渲染完成，<strong>自动执行</strong>，不用调用的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面加载完成后-自动执行&#x27;</span>)<br>    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span> += <span class="hljs-number">1</span>   <span class="hljs-comment">//这个this.counter指向的就是data中的counter</span><br>        <span class="hljs-comment">//this.$data.counter +=1   //效果相同</span><br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;,<br></code></pre></td></tr></table></figure><p>这节就是你要转变的一个观点，从面向DOM编程，改为面向数据编程。</p><h4 id="示例2：来宾欢迎语展示"><a href="#示例2：来宾欢迎语展示" class="headerlink" title="示例2：来宾欢迎语展示"></a>示例2：来宾欢迎语展示</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>    &lt;script&gt;<br>        Vue.createApp(&#123;<br>            data()&#123;<br>                return&#123;<br>                    content:&quot;&quot;,<br>                    setMeal:&#x27;芝士蛋糕 黄金脆皮鸡 螺蛳粉 火锅&#x27;,<br>                    isShowMeal:false,<br>                  //声明了三个变量，分别为文本显示内容，菜单栏，是否显示<br>                &#125;<br>            &#125;,<br>            methods:&#123;<br>                welcomBtnClick()&#123;<br>                    this.content=&quot;你来啦亲&quot;<br>                &#125;,<br>                byeBtnClick()&#123;<br>                    this.content=&quot;怎么又走了&quot;<br>                &#125;,<br>                showOrHide()&#123;<br>                    this.isShowMeal=!this.isShowMeal<br>                &#125;,<br>            &#125;,<br>            template:`<br>            &lt;div&gt;<br>                &lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;<br>                //给两个按钮用@绑定事件<br>                &lt;button v-on:click=&quot;welcomBtnClick&quot;&gt;有人来了&lt;/button&gt;&amp;nbsp;<br>                &lt;button v-on:click=&quot;byeBtnClick&quot;&gt;有人走了&lt;/button&gt;<br>                &lt;div v-if=&quot;isShowMeal&quot;&gt;&#123;&#123;setMeal&#125;&#125;&lt;/div&gt;<br>                &lt;button v-on:click=&quot;showOrHide&quot;&gt;显示/隐藏菜单&lt;/button&gt;<br>            &lt;/div&gt;<br>            `<br>        &#125;).mount(&quot;#app&quot;)<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>显示和隐藏服务</strong></p><p>我们需要新生成一个套餐的变量<code>setMeal</code>，然后还要有一个是否展示的变量<code>isShowMeal</code>。有了这个变量之后，我们还需要有一个能改变<code>isShowMeal</code>的响应方法<code>showOrHideBtnClick</code>.用来控制菜单的显示和隐藏。</p><p><code>v-if</code>的作用是如果值为真，就显示这个DOM元素，如果为假，就不显示这个元素。</p><h4 id="示例3：Vue3列表和循环-制作菜单"><a href="#示例3：Vue3列表和循环-制作菜单" class="headerlink" title="示例3：Vue3列表和循环-制作菜单"></a>示例3：Vue3列表和循环-制作菜单</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>    &lt;script&gt;<br>        Vue.createApp(&#123;<br>            data()&#123;<br>                return&#123;<br>                    list:[&#x27;1-芝士蛋糕&#x27;,&#x27;2-章鱼小丸子&#x27;,&#x27;3-车仔面&#x27;],<br>                    inputValue:&#x27;&#x27;<br>                &#125;<br>            &#125;,<br>            methods:&#123;<br>                handleAddItem()&#123;<br>                    this.list.push(this.inputValue)<br>                    this.inputValue=&#x27;&#x27;<br>                &#125;<br>            &#125;<br>            ,<br>            template:`<br>            &lt;div&gt;<br>                &lt;input v-model=&quot;inputValue&quot; /&gt; <br>                &lt;button v-on:click=&quot;handleAddItem&quot;&gt;增加&lt;/button&gt;<br>                &lt;ul&gt;<br>                    &lt;li v-for=&quot;item of list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;<br>                &lt;/ul&gt;<br>                &lt;ul&gt;<br>                    &lt;li v-for=&quot;(item,index) of list&quot;&gt;(&#123;&#123;index&#125;&#125;)&#123;&#123;item&#125;&#125;&lt;/li&gt;<br>                &lt;/ul&gt;<br>            &lt;/div&gt;<br>            `<br>        &#125;).mount(&quot;#app&quot;)<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>声明数组并循环</strong></p><p>在<code>createrApp()</code>方法里增加一个<code>data()</code>方法，声明<code>list[]</code>数组。有了数组，需要在模板中循环出来。这个需要用到<code>v-for</code>指令.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;ul&gt;</span><br><span class="hljs-string">        &lt;li v-for=&quot;item of list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="hljs-string">    &lt;/ul&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这句代码的意思是，我要进行遍历，遍历的列表是<code>list</code>，<code>list</code>中的每一项我会放到声明的item项中，然后使用字面量在模板中进行展示。</p><p><code>v-for</code>指令还有一个索引值，可以如下写法，打印出索引值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;li v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item,index) of list&quot;</span>&gt;[&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;&lt;/li&gt;<br></code></pre></td></tr></table></figure><p><strong>动态增加菜单</strong></p><p>先来做一个简单的效果，就是点击按钮后，就增加一个菜到列表中。先去掉数组中的值，然后来写一个按钮，按钮绑定<code>handleAddItem</code>事件。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">list</span>: []<br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">methods</span>: &#123;<br>            <span class="hljs-title function_">handleAddItem</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;&quot;</span>)<br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">            &lt;div&gt;</span><br><span class="hljs-string">                &lt;button v-on:click=&quot;handleAddItem&quot;&gt;增加&lt;/button&gt;</span><br><span class="hljs-string">                &lt;ul&gt;</span><br><span class="hljs-string">                    &lt;li v-for=&quot;(item,index) of list&quot;&gt;[&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="hljs-string">                &lt;/ul&gt;</span><br><span class="hljs-string">            &lt;/div&gt;</span><br><span class="hljs-string">        `</span><br>    &#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>现在增加的<code>菜</code>都是一样的，而我们最终的目的是能够自定义的增加菜单。这个时候我们就需要一个<code>input</code>输入框了，而且需要用<code>v-model</code>指令，进行绑定。代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-comment">//声明input输入框中的值和自定义列表</span><br>                <span class="hljs-attr">inputValue</span>: <span class="hljs-string">&#x27;&#x27;</span>,  <br>                <span class="hljs-attr">list</span>: []   <br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">methods</span>: &#123;<br>            <span class="hljs-title function_">handleAddItem</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-comment">//将输入框中的值添加到列表中</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>)<br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">            &lt;div&gt;</span><br><span class="hljs-string">                &lt;!--把输入框中的值双向绑定--&gt;</span><br><span class="hljs-string">                &lt;input v-model=&quot;inputValue&quot; /&gt;</span><br><span class="hljs-string">                &lt;button v-on:click=&quot;handleAddItem&quot;&gt;增加&lt;/button&gt;</span><br><span class="hljs-string">                &lt;ul&gt;</span><br><span class="hljs-string">                    &lt;li v-for=&quot;(item,index) of list&quot;&gt;[&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="hljs-string">                &lt;/ul&gt;</span><br><span class="hljs-string">            &lt;/div&gt;</span><br><span class="hljs-string">        `</span><br>    &#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>这时候我们就可以根据我们的喜欢增加菜了，比如增加一个<code>烤乳猪</code>、<code>螺蛳粉</code>。</p><p>现在这个效果还是不太完美，在实际工作中，如果我们增加完成后，希望<code>&lt;input/&gt;</code>的值为空。这个时候你要再明白Vue中的一个特性，就是双向数据绑定。也就是这时候我们改变<code>inputValue</code>的值，页面文本框的内容也会被清空。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">handleAddItem</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span> = <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h4 id="示例4：Vue3数据驱动思想"><a href="#示例4：Vue3数据驱动思想" class="headerlink" title="示例4：Vue3数据驱动思想"></a>示例4：Vue3数据驱动思想</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Hello World&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;<br>    &lt;style&gt;<br>        .wrap&#123;<br>            width:500px;<br>            margin:0 auto;<br>        &#125;<br>        .btn-primary&#123;<br>            margin-right: 10px;<br>            display: inline-block;<br>            width:80px;<br>            height: 40px;<br>            line-height: 40px;<br>            border-radius: 10px;<br>            text-align: center;<br>        &#125;<br>        .active&#123;<br>            background: yellowgreen;<br>        &#125;<br>        .content&#123;<br>            margin-top:10px;<br>            border-radius: 10px;<br>            padding:10px;<br>            width:100%;<br>            height: 200px;<br>            border: 1px solid #ccc;<br>            display: none;<br>        &#125;<br>        .show&#123;<br>            display: block;<br>        &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;<br>    &lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const HelloVue=&#123;<br>        data()&#123;<br>            return&#123;<br>                list:[<br>                    &#123;<br>                        title:&#x27;tab1&#x27;,<br>                        content:&#x27;我是tab1的内容&#x27;,<br>                        current:true<br>                    &#125;,<br>                    &#123;<br>                        title:&#x27;tab2&#x27;,<br>                        content:&#x27;我是tab2的内容&#x27;,<br>                        current:false<br>                    &#125;,<br>                    &#123;<br>                        title:&#x27;tab3&#x27;,<br>                        content:&#x27;我是tab3的内容&#x27;,<br>                        current:false<br>                    &#125;<br>                ]<br>            &#125;<br>        &#125;,<br>        methods:&#123;<br>            toggle(i)&#123;<br>                this.list.forEach(element =&gt; &#123;<br>                    element.current=false<br>                &#125;);<br>                this.list[i].current=true<br>            &#125;<br>        &#125;<br>        ,<br>        template:`<br>            &lt;div class=&quot;wrap&quot;&gt;<br>                &lt;span class=&quot;btn-primary&quot; <br>                v-for=&quot;(item,index) in list&quot;<br>                :class=&quot;&#123;active:item.current&#125;&quot;<br>                :key=&quot;index&quot; <br>                @click=&quot;toggle(index)&quot;&gt;<br>                &#123;&#123;item.title&#125;&#125;<br>                &lt;/span&gt;<br>                &lt;div class=&quot;content&quot; <br>                v-for=&quot;(item,index) in list&quot; <br>                :class=&quot;&#123;show:item.current&#125;&quot; <br>                :key=&quot;index&quot;&gt;<br>                &#123;&#123;item.content&#125;&#125;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        `<br>    &#125;<br>    const app=Vue.createApp(HelloVue).mount(&quot;#app&quot;)<br>&lt;/script&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>设置各元素样式</strong></p><p>wrap：宽500px的外框，margin设置为上下无间距，左右居中</p><p>btn-primary：按钮样式，<u>display：inline-block将元素显示为行内块状元素，设置该属性后，既可以在同一行显示，又可以设置宽高</u>，height和line-height将文字内容设置为上下居中，text-align将文字设置为左右居中，border-radius设置为圆角</p><p>Active：按钮被选中后背景色改变</p><p>show：<code>dispaly:block</code>将该块设置为块元素，不可以和别的元素显示为同一行，但可以设置宽高了</p><p>content：<code>display:none</code>该块将直接塌陷，被覆盖起来</p><p><strong>布局</strong></p><p>最外层的div绑定wrap样式，做为外框</p><p>设置切换按钮，文字为按钮标题，基础样式为btn-primary，绑定一个class为active样式为item.current属性的值，当该值为true时，叠加active属性，绑定key为索引值，绑定动作为只要点击该控件，则执行toggle函数</p><p>设置内容框，绑定一个class为show样式的item.current属性的值</p><p><strong>实现切换动作</strong></p><p>toggle函数传入的值为按下按钮的index值，先讲列表元素的每个值的current属性都设置为<code>false</code>，再把按下的按钮的值设置为<code>true</code></p><p><code>item.curent=true</code>的按钮项会改变按钮背景颜色，内容框显示对应的项</p><h3 id="四、组件"><a href="#四、组件" class="headerlink" title="四、组件"></a>四、组件</h3><p>组件就是对数据和方法的一个封装，（代码表现组件就是一个对象）</p><p>组件是vue最强大的功能之一，可以用组件组装出更大的组件和项目。</p><p>传入createapp的组件叫根组件，一个vue实例只有一个根组件</p><h4 id="全局方式创建组件"><a href="#全局方式创建组件" class="headerlink" title="全局方式创建组件"></a>全局方式创建组件</h4><p>component(name,option) 创建全局组件方法，整个vue实例都可以直接使用的组件，name是组件名，option是配置项</p><p>option中，data是数据，methods是方法，template是模板，就是html代码段</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">app.component(&#x27;add-count&#x27;,&#123;<br>        data()&#123;<br>            return &#123;<br>                count:0<br>            &#125;<br>        &#125;,<br>        methods: &#123;<br>            add()&#123;<br>                this.count++<br>            &#125;<br>        &#125;,<br>        template:`<br>        &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;<br>        &lt;div @click=&quot;add&quot;&gt;add&lt;/div&gt;<br>        `<br>      &#125;)<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;div id=&quot;app&quot;&gt;<br>        &lt;add-count&gt;&lt;/add-count&gt;<br>    &lt;/div&gt;<br></code></pre></td></tr></table></figure><p>全局组件创建以后会直接挂载到vue实例上。容易让包变大，而且不能实现按需加载。 一般项目中都是用局部组件。</p><p>创建局部组件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">const AddCount = &#123;<br>            data()&#123;<br>                return &#123;<br>                    count:0<br>                &#125;<br>            &#125;,<br>            methods: &#123;<br>                add()&#123;<br>                    this.count++<br>                &#125;<br>            &#125;,<br>            template:`<br>            &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;<br>            &lt;div @click=&quot;add&quot;&gt;add&lt;/div&gt;<br>            `<br>        &#125;<br></code></pre></td></tr></table></figure><p>在使用的组件里注册该组件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">const TestCom = &#123;<br>            data()&#123;<br>                return &#123;&#125;<br>            &#125;,<br>            components:&#123;AddCount&#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">template:`<br>&lt;div&gt;<br>        &lt;add-count&gt;&lt;/add-count&gt;<br>    &lt;/div&gt;`<br></code></pre></td></tr></table></figure><h4 id="动态组件的编写"><a href="#动态组件的编写" class="headerlink" title="动态组件的编写"></a>动态组件的编写</h4><blockquote><p>什么是动态组件？也许我说的并不标准，我这里指的动态组件是显示内容不固定，通过父组件或者程序控制而输出的内容。</p></blockquote><p>写一个组件，这个组件会绑定一些<code>props</code>，用于接受父组件传递过来的参数,然后动态显示出内容。 动态组件有一个关键的指令是<code>v-bind</code>，用这种方法，组件可以通过<code>props</code>取得对应的值。代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;my-jiali&#x27;</span>, &#123;<br>    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;item&#x27;</span>, <span class="hljs-string">&#x27;index&#x27;</span>],<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">` &lt;li &gt;[&#123;&#123;index&#125;&#125;]-&#123;&#123;item&#125;&#125;&lt;/li&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><code>props</code>是一个数组，可以接受多个值。有了<code>my-jiali</code>组件后，就可以在<code>app</code>的<code>template</code>中使用了，方法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;my-jiali <br>    v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item,index) of list&quot;</span>  <br>    v-<span class="hljs-attr">bind</span>:item=<span class="hljs-string">&quot;item&quot;</span> <br>    v-<span class="hljs-attr">bind</span>:index=<span class="hljs-string">&quot;index&quot;</span>  <br>/&gt;<br></code></pre></td></tr></table></figure><p>这时候肯定会有小伙伴认为，这也没有减少代码的工作量哦，第一是因为我们的代码还比较简单，第二是组件的意义是降低程序的耦合性，让大规模开发编程可能。比如一个页面，分成几个人开发，每个人写不同的模块，写好后拼凑在一起。有了组件这就变的非常容易。</p><p>这里给出全部代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;列表&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app = Vue.createApp(&#123;<br>        data() &#123;<br>            return &#123;<br>                inputValue: &#x27;&#x27;,<br>                list: []<br>            &#125;<br>        &#125;,<br>        methods: &#123;<br>            handleAddItem() &#123;<br>                this.list.push(this.inputValue)<br>                this.inputValue = &#x27;&#x27;<br>            &#125;<br>        &#125;,<br>        template: `<br>            &lt;div&gt;<br>                &lt;my-title /&gt;<br>                &lt;input v-model=&quot;inputValue&quot; /&gt;<br>                &lt;button v-on:click=&quot;handleAddItem&quot;&gt;增加&lt;/button&gt;<br>                &lt;ul&gt;<br>                    &lt;my-jiali <br>                        v-for=&quot;(item,index) of list&quot;  <br>                        v-bind:d1=&quot;index&quot; <br>                        v-bind:d2=&quot;item&quot;  <br>                    /&gt;<br>                &lt;/ul&gt;<br>            &lt;/div&gt;<br><br>        `<br>    &#125;)<br><br>    app.component(&#x27;my-title&#x27;, &#123;<br>        template: &#x27;&lt;h1 style=&quot;text-align:center&quot;&gt;芭芭拉&lt;/h1&gt;&#x27;<br>    &#125;)<br><br>    app.component(&#x27;my-jiali&#x27;, &#123;<br>        props: [&#x27;d1&#x27;, &#x27;d2&#x27;],<br>        template: ` &lt;li &gt;[&#123;&#123;d1&#125;&#125;]-&#123;&#123;d2&#125;&#125;&lt;/li&gt;`<br>    &#125;)<br>    app.mount(&quot;#app&quot;)<br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h4 id="组件的props"><a href="#组件的props" class="headerlink" title="组件的props"></a>组件的props</h4><p>props是组件接收父组件传递过来的数据的自定义属性。使用的时候直接作为数据使用，props里面的数据是只读父组件里传过来的数据的。</p><p>父组件传值，<code>:msg</code>绑定的是子组件里的变量名，<code>&#39;msg&#39;</code>为被绑定的父组件里的名为msg的数据</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;add-count :msg=&quot;msg&quot;&gt;&lt;/add-count&gt;<br></code></pre></td></tr></table></figure><p>子组件使用值：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">const AddCount = &#123;<br>            props:[&#x27;msg&#x27;],<br>            data()&#123;<br>                return &#123;<br>                    count:0, <br>                &#125;<br>            &#125;,<br>            template:`<br>            &lt;div&gt;&#123;&#123;count&#125;&#125;-- &#123;&#123;msg&#125;&#125;&lt;/div&gt;<br>            `<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="props接收参数的校验"><a href="#props接收参数的校验" class="headerlink" title="props接收参数的校验"></a>props接收参数的校验</h4><p>props简写的是数组形式，接收的变量是数组的字符串元素。</p><p>props可以写成对象形式，可以限制类型（type），设置默认值（default），进行校验（validator）。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">props:&#123;<br>  msg:&#123;<br>     type:String,<br>     default:&#x27;aaa&#x27;,<br>     validator(value)&#123;<br>      if(value === &#x27;asf&#x27;)&#123;<br>       console.log(&#x27;88888&#x27;)<br>      &#125;<br>     &#125;<br>   &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><p>可以让父组件向子组件指定位置插入html元素 关键词是slot</p><p>匿名插槽</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;add-count :msg=&quot;msg&quot;&gt;<br>   &lt;h2&gt;我是slot内容&lt;/h2&gt;<br> &lt;/add-count&gt;<br></code></pre></td></tr></table></figure><p>子组件定义：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">emplate:`<br>  &lt;div&gt;<br>    &lt;p&gt;&#123;&#123;count&#125;&#125; -- &#123;&#123;msg&#125;&#125;&lt;/p&gt;<br>    &lt;slot&gt;&lt;/slot&gt;<br>  &lt;/div&gt;<br>`<br></code></pre></td></tr></table></figure><p>具名插槽，关键词name ，父组件用template包裹，用#name的属性去对应。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;add-count :msg=&quot;msg&quot;&gt;<br>           &lt;template #slot1&gt;<br>            &lt;h2&gt;我是slot内容&lt;/h2&gt;<br>           &lt;/template&gt;<br>        &lt;/add-count&gt;<br></code></pre></td></tr></table></figure><p>自组组件定义：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">template:`<br>&lt;div&gt;<br>    &lt;p&gt;&#123;&#123;count&#125;&#125;-- &#123;&#123;msg&#125;&#125;&lt;/p&gt;<br>    &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt;<br>    &lt;/div&gt;<br>`<br></code></pre></td></tr></table></figure><h4 id="createApp-和mount-方法讲解"><a href="#createApp-和mount-方法讲解" class="headerlink" title="createApp()和mount()方法讲解"></a>createApp()和mount()方法讲解</h4><p><strong><code>createApp()</code>方法的参数</strong></p><p>首先它接受一个对象形式的参数<code>&#123;&#125;</code>。这个对象就是告诉Vue应该如何展现我们最外层的组件。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;jspang.com&#x27;</span><br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&quot;</span><br>    &#125;)<br>    app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/68#toc325">如何获取Vue的根组件vm</a></p><p>当你使用<code>creatApp()</code>方法创建了一个Vue应用时，如何能获取根组件。</p><p>其实你使用<code>mount()</code>方法时，就会返回根组件。下面的代码，声明一个变量来获取根组件，并打印出来。通过打印你可以看出根组件是一个<code>Proxy</code>形式的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm)<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/68#toc326">mvvm设计模式讲解</a></p><p>Vue的编程设计模式应该叫做<code>mvvm</code>的设计模式。什么叫做<code>mvvm</code>？它首先是面向数据的编程，程序中定义了数据，然后定义了模板，<code>Vue</code>就可以把数据和模板自动进行关联。最后挂载到真实的<code>DOM</code>上，展示给用户。</p><blockquote><p>mvvm解释: 第一个<code>m</code>代表<code>model</code>数据，第一个<code>v</code>代表<code>view</code>视图，最后两个字幕<code>vm</code>代表<code>viewModel</code>视图数据连接层。</p></blockquote><p>可以看一下代码进行理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;jspang.com&#x27;</span>   <span class="hljs-comment">//1.在这里定义了数据，也就是`model`数据</span><br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&quot;</span> <span class="hljs-comment">//2.在这里定义了模板，也就是`view`，</span><br>        <span class="hljs-comment">//定义后的自动关联，就叫做`vm`，viewModel数据视图连接层。</span><br>    &#125;)<br>    app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>model</code>数据，是我们自己定义的，<code>view</code>模板也是我们自己定义的，但是<code>vm</code>是Vue自动给我们关联的。</p><p>当我们明白了什么是<code>mvvm</code>后，你就知道为什么我们给根组件起名<code>vm</code>了。</p><p>当我们获取了<code>vm</code>根节点后，其实就可以操作里边的数据了。比如在控制台中输入下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.<span class="hljs-property">$data</span>.<span class="hljs-property">message</span> =<span class="hljs-string">&#x27;技术胖&#x27;</span><br></code></pre></td></tr></table></figure><p>这个时候你会发现网页界面也跟着发生了变化，变成了<code>技术胖</code>.</p><h3 id="五、生命周期函数"><a href="#五、生命周期函数" class="headerlink" title="五、生命周期函数"></a>五、生命周期函数</h3><p>如果要理解什么是自动执行函数，我认为可以对比来看，先清楚什么是被动执行函数。比如我们写了一个<code>handleItemClick( )</code>方法，然后让模板里的<code>&lt;h2&gt;</code>点击后执行此事件，代码如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">handleItemClick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;jspang.com&#x27;</span>)<br>     &#125;<br> &#125;,<br> <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h2 v-on:click=&#x27;handleItemClick&#x27;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&quot;</span><br></code></pre></td></tr></table></figure><p>这时候可以打开浏览器，看一下这个效果。你需要点击对应的dom元素，他才会执行方法，这个就是被动执行函数。当你了解被动执行函数，再来了解什么是自动执行函数。写一个<code>mounted</code>方法，它就会自动执行。这种就是自动执行函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;mounted&#x27;</span>)<br>&#125;,<br></code></pre></td></tr></table></figure><p>这时候你再刷新一下网页，就可以看出<code>mounted</code>被直接弹出了。这种没有任何操作，自动执行的方法，就叫做自动执行函数。</p><p>当你明白了什么是自动执行函数后，我们再来学习Vue3.x的生命周期函数。</p><p><img src="/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhb0xpYW5nIG8=,size_15,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p><img src="/../img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhb0xpYW5nIG8=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>Vue3中有八个生命周期函数，</p><ul><li>beforeCreate( ) ：在实例生成之前会自动执行的函数</li><li>created( ) : 在实例生成之后会自动执行的函数</li><li>beforeMount( ) : 在模板渲染完成之前执行的函数</li><li>mounted( ) : 在模板渲染完成之后执行的函数</li><li>beforeUpdate ：当data中的数据变化时， 会立即自动执行的函数</li><li>updated：当data中的数据发生变化，页面重新渲染完后，会自动执行的函数</li><li>beforeUnmount( ) :当Vue应用失效时，会自动执行的函数</li><li>unmounted() : 当Vue应用失效时，且DOM完全销毁之后，会自动执行</li></ul><p>这些生命周期虽然多，你可以成对的去记忆，这样就有四个关键节点了：创建、渲染、更新、销毁。最主要的理解是他们是自动执行的函数。这节课就到这里，我们下节继续学习。</p><h3 id="六、模版"><a href="#六、模版" class="headerlink" title="六、模版"></a>六、模版</h3><h4 id="插值表达式和v-html"><a href="#插值表达式和v-html" class="headerlink" title="插值表达式和v-html"></a>插值表达式和v-html</h4><p>以前经常说的<code>字面量</code>，其实正确叫法应该叫做<code>插值表达式</code>，当然我们公司大部分还是叫<code>字面量</code>的，也就是我们经常看到的<code>&#123;&#123;xxxx&#125;&#125;</code>这样的东西。</p><p>如果想在变量里写html标签，然后输出展现在页面中，这时候会出现点问题。</p><p>我们先修改代码，看看问题所在。例如在message中加入<code>&lt;i&gt;</code>标签。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;&lt;i&gt;jspang.com&lt;/i&gt;&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这时候如果什么都不做，直接输出，你在浏览器中看到的结果就是下面的样子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;i&gt;jspang.<span class="hljs-property">com</span>&lt;/i&gt;<br></code></pre></td></tr></table></figure><p>这并不是你想要的结果，这时候需要使用<code>v-html</code>的标签解决这个问题。把template属性的部分改成下面的样子。</p><p>需要注意的是这压力要改成”`”符号，否则不能使用双引号这种形式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;h2 v-html=&quot;message&quot;&gt; &lt;/h2&gt;`</span><br></code></pre></td></tr></table></figure><p>这时候再预览，就可以看到浏览器中的字变成了斜体。</p><h4 id="插值表达式只作一次渲染-v-once"><a href="#插值表达式只作一次渲染-v-once" class="headerlink" title="插值表达式只作一次渲染-v-once"></a>插值表达式只作一次渲染-v-once</h4><p>现在这种插值表达式，是跟着data中的数据一起变化的，也就是我们常说的数据双向绑定。但是如果我希望一个插值表达式，只有在第一次渲染去data中的值，而以后不再跟随data变化，这时候就要用到<code>v-once</code>指令。</p><p>先来看一下目前这种代码，我们为<code>h2</code>标签，加入相应事件<code>handleItemClick</code>，代码如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;h2 v-on:click=&quot;handleItemClick&quot; v-html=&quot;message&quot;&gt; &lt;/h2&gt;`</span><br></code></pre></td></tr></table></figure><p>这时候在浏览器中可以看到，我们每点击一次h2标签，<code>message</code>的值都是变化的。再改写一下代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;h2 </span><br><span class="hljs-string">                v-on:click=&quot;handleItemClick&quot; </span><br><span class="hljs-string">                v-html=&quot;message&quot;</span><br><span class="hljs-string">                v-once</span><br><span class="hljs-string">            &gt; &lt;/h2&gt;`</span><br></code></pre></td></tr></table></figure><p>加入了<code>v-once</code>后，无论data中的数据如何变化，模板也不会再次重新渲染了，这就是<code>v-once</code>的变化。</p><h4 id="插值表达式中使用JS表达式"><a href="#插值表达式中使用JS表达式" class="headerlink" title="插值表达式中使用JS表达式"></a>插值表达式中使用JS表达式</h4><p>其实在插值表达式中是可以使用JS表达式的，最常用的表达式是三元运算符。比如在data中新声明一个变量<code>count</code>，用三元运算符判断是否是大于2，如果大于2显示大，小于2显示小，编写代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;&#123;&#123;count&gt;2?&#x27;大&#x27;:&#x27;小&#x27;&#125;&#125;&lt;/div&gt;`</span><br></code></pre></td></tr></table></figure><p>当然也可以使用一些简单的表达式，比如下面这些样子的JS表达式.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;&#123;&#123;<span class="hljs-string">&#x27;jspang&#x27;</span>+<span class="hljs-string">&#x27;.com&#x27;</span>&#125;&#125;&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;1+2&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这些形式的表达式都是可以的，但是如果你想用if语句，就是不可以的，因为只能用JS表达式而不能用语句。</p><h4 id="v-bind指令的使用"><a href="#v-bind指令的使用" class="headerlink" title="v-bind指令的使用"></a>v-bind指令的使用</h4><p>现在我们给h2标签加入一个title属性(鼠标放上去会出现的小便签)，属性的值也想使用<code>message</code>。代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;h2 <br>  v-<span class="hljs-attr">on</span>:click=<span class="hljs-string">&quot;handleItemClick&quot;</span> <br>  v-html=<span class="hljs-string">&quot;message&quot;</span><br>  v-once<br>  title=<span class="hljs-string">&quot;message&quot;</span><br>&gt; &lt;/h2&gt;<span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这时候浏览器中鼠标放上时显示的是双引号里的<code>message</code>这个单词，而并没有出现我们想要的结果。</p><p>这时候就可以使用<code>v-bind</code>标签了，写成下面的样式把<code>message</code>和message变量进行绑定，输出<code>message</code>变量的内容了。</p><p>v-bind在title前面但实际上绑定的是<code>=</code>右面的变量，然后把这个值赋给title。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">v-<span class="hljs-attr">bind</span>:title=<span class="hljs-string">&quot;message&quot;</span><br></code></pre></td></tr></table></figure><h4 id="v-on的基本用法和简写"><a href="#v-on的基本用法和简写" class="headerlink" title="v-on的基本用法和简写"></a><a href="https://jspang.com/article/68#toc341">v-on的基本用法和简写</a></h4><p><code>v-on</code>是用来绑定响应事件的，这里写一个最简单的事件，弹出对话框。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">hanldClick</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;欢迎光临红浪漫&#x27;</span>)<br>    &#125;<br>&#125;,<br><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">&lt;h2 v-on:click=&quot;hanldClick&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p><code>v-on</code>还有一个简写方法，就是可以把<code>v-on:</code>用<code>@</code>代替，比如把代码改成下面的样子，也是完全可以使用的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">&lt;h2 @click=&quot;hanldClick&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>不仅<code>v-on</code>有简写方法，上节我们学习的<code>v-bind</code>也有简写方法<code>:</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;h2 v-<span class="hljs-attr">bind</span>:title=<span class="hljs-string">&quot;message&quot;</span>&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>Vue在开发中还是鼓励大家使用简写，这样可以让代码更加清晰。</p><h4 id="模板动态参数"><a href="#模板动态参数" class="headerlink" title="模板动态参数"></a><a href="https://jspang.com/article/68#toc342">模板动态参数</a></h4><p>现在绑定的事件<code>click</code>和<code>title</code>都是固定死的，显得不太灵活。</p><p>Vue也提供了动态参数，比如这里<code>v-bind:title</code>中的<code>title</code>是来自<code>data</code>中的，就可以这样写</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123; <br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span>&#123;<br>            <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;title&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;h2 </span><br><span class="hljs-string">            :[name]=&quot;message&quot;</span><br><span class="hljs-string">        &gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">&#125;)</span><br></code></pre></td></tr></table></figure><p>这样定义动态参数就相当于把<code>title</code>替换为<code>[name]</code>，<code>:[name]=&quot;message&quot;</code>就相当于是<code>:title=&quot;message&quot;</code>。</p><p><strong>事件动态绑定</strong></p><p>这种形式，也可以用到<code>v-on</code>事件绑定当中，比如在<code>data</code>中声明一个<code>event</code>的变量，然后给他一个<code>click</code>,然后用同样的方法实现事件动态绑定。</p><p>data中的写法如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">return</span>&#123;<br>    <span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;jspang.com&#x27;</span> ,<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;title&#x27;</span>,<br>    <span class="hljs-attr">event</span>:<span class="hljs-string">&#x27;click&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>模板中的写法如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h2 </span><br><span class="hljs-string">        @[event]=&quot;hanldClick&quot;</span><br><span class="hljs-string">        :[name]=&quot;message&quot;</span><br><span class="hljs-string">    &gt;</span><br><span class="hljs-string">    &#123;&#123;message&#125;&#125;</span><br><span class="hljs-string">    &lt;/h2&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><h4 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a><a href="https://jspang.com/article/68#toc343">阻止默认事件</a></h4><p>最常见的默认事件就是表单的默认提交事件，比如我们这里写一个表单，然后写一个属性为<code>submit</code>的按钮，当点击按钮时，表单就会默认提交到对应的网址。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;form action=<span class="hljs-string">&quot;https://jspang.com&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>默认提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/form&gt;<br></code></pre></td></tr></table></figure><p>这时候在浏览器中预览，点击“默认提交”按钮，就会立即跳转到action里的网址去，这就是默认响应事件。</p><p>但是在开发中我们经常需要阻止这种默认响应事件。所以Vue提供了一个模板修饰符，直接可以阻止默认行为。写法如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;form <br>    action=<span class="hljs-string">&quot;https://jspang.com&quot;</span> <br>    @click.<span class="hljs-property">prevent</span>=<span class="hljs-string">&quot;hanldeButton&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>默认提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/form&gt;<br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>methods中的写法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">hanldeButton</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;jspang.com&#x27;</span>) <br>&#125;<br></code></pre></td></tr></table></figure><p>这样再点击按钮的时候，相应的就不是默认的跳转到action网址的动作，而是自定义的阻止函数里的弹出动作。</p><h4 id="v-if条件判断"><a href="#v-if条件判断" class="headerlink" title="v-if条件判断"></a>v-if条件判断</h4><p>模板中使用条件判断，控制页面的样式，是最常见的应用。Vue中提供了两种基本的方法，一种是我们已经讲过的三元运算符，另一种就是<code>v-if</code>。</p><p>先来看三元运算符控制模板的样式，根据Data中值的不同，显示不同的样式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;style&gt;<br>    .<span class="hljs-property">one</span> &#123;<span class="hljs-attr">color</span>: red;&#125;<br>    .<span class="hljs-property">two</span> &#123;<span class="hljs-attr">color</span>: green;&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>这里有两个基本的CSS样式，分别是让文字是红色和绿色。现在的需求是，要根据<code>message</code>的值显示不同的颜色，是<code>jspang.com</code>显示红色，是<code>技术胖</code>时显示绿色。类似这样的需求，就可以使用三元运算符，然后绑定class的形式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;h2 </span><br><span class="hljs-string">                :class=&quot;message==&#x27;jspang.com&#x27;?&#x27;one&#x27;:&#x27;two&#x27;&quot; </span><br><span class="hljs-string">                @click=&quot;handleItemClick&quot; &gt;</span><br><span class="hljs-string">                &#123;&#123;message&#125;&#125;</span><br><span class="hljs-string">        &lt;/h2&gt;`</span><br></code></pre></td></tr></table></figure><p>这时候文字变化，对应的css样式也会变化。可以打开浏览器，看一下效果。</p><p>三元运算符的限制还是比较明显的，就是只能判断两个值，如果这时候我们再加入一个值，就是既不是<code>jspang.com</code>,也不是<code>技术胖</code>的时候，我们显示橙色。这时候三元运算符就满足不了需求了。vue给我们准备了v-if判断。</p><p>我们先加入一个CSS样式<code>three</code>:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;style&gt;<br>    .<span class="hljs-property">one</span> &#123;<span class="hljs-attr">color</span>: red;&#125;<br>    .<span class="hljs-property">two</span> &#123;<span class="hljs-attr">color</span>: green;&#125;<br>    .<span class="hljs-property">three</span>&#123;<span class="hljs-attr">color</span>:orange;&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>然后可以使用<code>v-if</code>来进行编写模板。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">&lt;h2 @click=&quot;handleItemClick&quot; v-if=&quot;message==&#x27;jspang.com&#x27;&quot; class=&quot;one&quot; &gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt;</span><br><span class="hljs-string">&lt;h2 @click=&quot;handleItemClick&quot; v-if=&quot;message==&#x27;技术胖&#x27;&quot; class=&quot;two&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt;</span><br><span class="hljs-string">&lt;h2 @click=&quot;handleItemClick&quot; v-if=&quot;message==&#x27;bilibili&#x27;&quot;  class=&quot;three&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt;</span><br><span class="hljs-string">    `</span><br></code></pre></td></tr></table></figure><p>当然，你也可以使用<code>v-else</code>，比如下面把代码改为这个样子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">&lt;h2 @click=&quot;handleItemClick&quot; v-if=&quot;message==&#x27;jspang.com&#x27;&quot; class=&quot;one&quot; &gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt;</span><br><span class="hljs-string">&lt;h2 @click=&quot;handleItemClick&quot; v-else  class=&quot;three&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt;</span><br><span class="hljs-string">    `</span><br></code></pre></td></tr></table></figure><p>相当于在执行完<code>v-if</code>语句后，符合条件则执行后面的内容，不符合的话直接下一条。</p><h4 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性-computed"></a>计算属性-computed</h4><p>计算属性的特性是：当计算属性依赖的内容发生变更时，才会重新执行计算。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>        <span class="hljs-title function_">getTotal</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++);<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">` &lt;h2&gt; &#123;&#123;getTotal()&#125;&#125;&lt;/h2&gt;`</span><br></code></pre></td></tr></table></figure><p>这时候问题产生了，你会发现只要修改网页中任何一个值，getTotal( )方法都会被重新执行。这就是这个问题的所在，这个问题其实可以用今天的主角coumputed计算属性来解决。</p><p><a href="https://jspang.com/article/68#toc350">编写计算属性</a></p><p>在了计算属性中获取当前的时间戳，计算属性的关键字是<code>computed</code>，然后里边可以写计算用的方法，这里我起名叫做<code>total</code>，当然你可以起任何的名字。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">computed</span>:&#123;<br>    <span class="hljs-title function_">total</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后我们把上面模板中的方法<code>getTotal( )</code>换成计算属性<code>total</code>。模板的代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">` </span><br><span class="hljs-string">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;h2&gt; &#123;&#123;total()&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这时候到浏览器中，用手动的方法，修改<code>message</code>的值，<code>total</code>的值就不会进行改变了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">vm.<span class="hljs-property">message</span>=<span class="hljs-string">&#x27;1111&#x27;</span><br></code></pre></td></tr></table></figure><p>通过这个例子，你会对普通方法和计算属性的区别有所了解。这时候我们作一下总结：</p><ol><li>方法methods：只要有任何参数发生改变进行页面重新渲染，就会重新执行方法</li><li>计算属性computed: 当计算属性依赖的内容发生变更时，才会重新执行计算</li></ol><p>那我们再来看计算属性改变的例子。</p><p><a href="https://jspang.com/article/68#toc351">计算属性-computed实例</a></p><p>我们用<code>单价X数量=总和</code>这个小例子，来说明具体计算属性的使用方法。每点击一下按钮，就会让数量<code>count</code>加1。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">computed</span>:&#123;<br>    <span class="hljs-title function_">total</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后在模板中写一个按钮，每次点击按钮<code>count</code>数量进行增加。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">addCount</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++<br>    &#125;<br>&#125;,<br><span class="hljs-attr">template</span>:<span class="hljs-string">` </span><br><span class="hljs-string">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;h2&gt; &#123;&#123;total&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;button @click=&quot;addCount&quot;&gt;再买一个&lt;/button&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这时候我们再到浏览器中查看效果，当点击按钮的时候，计算属性会帮助我们完成模板的自动更新。</p><p>computed可用于数据绑定+节省内存，当存在对数据依赖项的函数时可以放到计算属性里</p><h4 id="侦听器-监听器-watch"><a href="#侦听器-监听器-watch" class="headerlink" title="侦听器/监听器-watch"></a>侦听器/监听器-watch</h4><p>侦听器可以侦听data中值的变化，做出相应的操作。</p><p><a href="https://jspang.com/article/68#toc353">侦听器的基本写法</a></p><p>watch侦听器的作用就是侦听一个data中的值的变化，变化后可以写一个方法，让其进行一些操作（业务逻辑的编写）。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">watch</span>:&#123;<br>    <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;count changed&#x27;</span>)<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>上面代码的意思是，写一个侦听器来侦听<code>count</code>的数据变化，当<code>count</code>变化之后立即在控制台打印出<code>count changed</code>。</p><p>侦听器中的方法还可以接收两个参数，一个是现在的值（current），一个是变化之前的值（prev），是系统内置的，顺序固定，变量名可任意取。我们分别接收这两个值，并打印在控制台，看一下效果。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">watch</span>:&#123;<br>    <span class="hljs-title function_">count</span>(<span class="hljs-params">current,prev</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;watch changed&#x27;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;现在的值：&#x27;</span>,current)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;变化前的值：&#x27;</span>,prev)<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>在浏览器中可以看到打印的效果。先打印出了3，然后又打印出了2。需要注意的是两个参数的先后顺序，如果不小心，是很容易记反的。</p><p><a href="https://jspang.com/article/68#toc354">侦听器和计算属性的区别</a></p><p>计算属性computed必须要返回一个值，而且在页面渲染的同时就会执行里边的业务逻辑，也就是会先执行一遍你写的业务逻辑，而<code>watch</code>只有发生变化时才会执行，也就是说值没有变化，它是不执行里边业务逻辑的。为了验证结果，先注释掉侦听器watch相关的内容，在计算属性<code>total</code>中写这样的代码。</p><p>代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">computed</span>:&#123;<br>    <span class="hljs-title function_">total</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;....count changed&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/68#toc355">计算属性（computed）更加简洁</a></p><p>再来思考一个问题，用watch侦听器，可以写出类似计算属性的代码吗？答案是肯定的。现在我们就写一个类似计算属性效果。</p><p>先在data中声明一个新的变量，叫做<code>newTotal</code>，给出一个<code>20</code>的值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-comment">//....</span><br>        <span class="hljs-attr">newTotal</span>:<span class="hljs-number">20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后修改watch中代码，写一个乘法表达式算出<code>总和</code>，赋值给<code>this.newTotal</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">watch</span>:&#123;<br>    <span class="hljs-title function_">count</span>(<span class="hljs-params">current,prev</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">newTotal</span>=<span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * current<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>最后把模板中的渲染值，改为<code>newTotal</code>就可以了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    //......</span><br><span class="hljs-string">    &lt;h2&gt;总和：&#123;&#123;newTotal&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">    //......</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>写完这些，你在浏览器中看到的效果和计算是属性是一样的。但是从代码简洁性上，显然侦听器的写法是麻烦并冗余，所以建议优先使用计算属性来完成同样的操作。</p><p><a href="https://jspang.com/article/68#toc356">method、watch和computed三者使用优先级</a></p><p>现在总结一下method、watch和computed三者如果都能实现相同的功能，它们之间的取舍和使用优先级。</p><ul><li><code>computed</code> 和 <code>method</code>都能实现的功能，建议使用computed,因为有缓存，不用渲染页面就刷新。</li><li><code>computed</code> 和 <code>watch</code> 都能实现的功能，建议使用 computed，因为更加简洁。</li></ul><h4 id="模板样式绑定详细讲解"><a href="#模板样式绑定详细讲解" class="headerlink" title="模板样式绑定详细讲解"></a>模板样式绑定详细讲解</h4><p>预设几个style样式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;style&gt;<br>        .<span class="hljs-property">one</span>&#123;<br>            <span class="hljs-attr">color</span>: aqua;<br>        &#125;<br>        .<span class="hljs-property">two</span>&#123;<br>            <span class="hljs-attr">color</span>: bisque;<br>        &#125;<br>        .<span class="hljs-property">three</span>&#123;<br>            <span class="hljs-attr">color</span>: blueviolet;<br>        &#125;<br>        <br>    &lt;/style&gt;<br></code></pre></td></tr></table></figure><p>再在Data中声明变量，然后在模板<code>template</code>中进行绑定。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;        <br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">classString</span>:<span class="hljs-string">&#x27;three&#x27;</span>,<br>        &#125;<br>&#125;,<br>    <span class="hljs-attr">methods</span>:&#123;<br>     <span class="hljs-title function_">chgClass</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">classString</span>=<span class="hljs-string">&#x27;two&#x27;</span>;<br>     &#125;<br>&#125;,<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">` </span><br><span class="hljs-string">        &lt;button @click=&#x27;chgClass&#x27;&gt;变色&lt;/button&gt;</span><br><span class="hljs-string">        &lt;h2 :class=&#x27;classString&#x27;&gt;JSPang.com&lt;/h2&gt;</span><br><span class="hljs-string">        &lt;h2 class=&#x27;two&#x27;&gt;JSPang.com&lt;/h2&gt;</span><br><span class="hljs-string">    `</span>, <br>&#125;)<br>    app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>此时你可以利用浏览器的控制台，输入对应的代码，直接控制样式了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">vm.<span class="hljs-property">$data</span>.<span class="hljs-property">classString</span>=<span class="hljs-string">&#x27;two&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>对象的绑定方式</strong></p><p>现在用对象的形式进行绑定样式，好处是一次可以绑定多个样式。比如这样的代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">classString</span>:<span class="hljs-string">&#x27;one&#x27;</span>,<br>        <span class="hljs-attr">classObject</span>:&#123;<span class="hljs-attr">two</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">three</span>:<span class="hljs-literal">true</span>&#125;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>值为<code>true</code>代表绑定，值为<code>false</code>代表不绑定这个样式。</p><p>然后进行绑定</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">` </span><br><span class="hljs-string">        &lt;button @click=&#x27;chgClass&#x27;&gt;变色&lt;/button&gt;</span><br><span class="hljs-string">        &lt;h2 :class=&#x27;classString&#x27;&gt;JSPang.com&lt;/h2&gt;</span><br><span class="hljs-string">        &lt;h2 :class=&#x27;classObject&#x27;&gt;JSPang.com&lt;/h2&gt;</span><br><span class="hljs-string">    `</span>, <br></code></pre></td></tr></table></figure><p>这时候再到浏览器中查看效果，就会有两个样式被绑定了<code>two</code>和<code>three</code>。如果你这时候把two改为false，那效果就是只有背景颜色，没有字体颜色了。</p><p><strong>数组的绑定方式</strong></p><p>再来看一下数组的绑定方式，数组也是可以绑定多个样式的。</p><p>代码如下:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">classArray</span>:[<span class="hljs-string">&#x27;two&#x27;</span>,<span class="hljs-string">&#x27;three&#x27;</span>],<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>这时候再修改一下绑定值,页面样式就变成了绿字，橙色的底啦。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h2 :class=&quot;classArray&quot;&gt;JSPang.com&lt;/h2&gt;  </span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>你也可以在这种数组的数据项中，再嵌套对象的形式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">classArray</span>:[<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;background&#x27;</span>,&#123;<span class="hljs-attr">red</span>:<span class="hljs-literal">true</span>&#125;],<br></code></pre></td></tr></table></figure><p>如果看不到效果，可以在CSS样式中增加<code>!important</code>，把优先级提高，当然你也可以在浏览器的控制台查看。</p><p><a href="https://jspang.com/article/68#toc362">子组件的样式绑定</a></p><p>先来看一下子组件如何绑定样式。编写一个子组件<code>SonCom</code>，组件中就是展示一个简单的内容。</p><p>代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script&gt;  <br>    <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;        <br>        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>&#125;,<br>        <span class="hljs-comment">//父组件调用</span><br>    <span class="hljs-attr">template</span>:<span class="hljs-string">` </span><br><span class="hljs-string">        &lt;sonCom /&gt;</span><br><span class="hljs-string">    `</span>, <br>&#125;)<br>  <span class="hljs-comment">//子组件声明</span><br>app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;sonCom&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;SonCom&lt;/div&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br>    app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>有了子组件后，就可以在父组件的模板中进行使用了，使用就是直接写一个类似html的标签进去就可以。</p><p><strong>如何区分父子组件</strong></p><p>在<code>vue.createApp( )</code>方法中用对象形式<code>&#123; &#125;</code>配置的一般叫做父组件，而下面使用的其他组件，叫做子组件。<strong>你也可以这样理解，主动调用的是父组件，被调用的是子组件</strong>。</p><ul><li>最简单的为子组件添加样式的方法，就是自己在子组件里加上<code>class</code>。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;sonCom&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div class=&quot;green&quot;&gt;SonCom&lt;/div&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这时候子组件的字体颜色就变成了绿色。</p><ul><li>你还可以把class写在父组件里，例如下面的代码。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h2 :class=&quot;classArray&quot;&gt;JSPang.com&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;sonCom class=&#x27;green&#x27; /&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>先去掉子组件里的class，在调用地方增加class样式。这时候效果也是一样的。</p><ul><li>二者可以同时使用</li></ul><p><a href="https://jspang.com/article/68#toc363">子组件使用样式的小坑</a></p><p>这时候我们修改一下子组件，再写一个<code>&lt;div&gt;</code>进去，里边写上<code>技术胖</code>的字样。这时候再来看结果。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;sonCom&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;SonCom&lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;技术胖&lt;/div&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>你会发现两个<code>&lt;div&gt;</code>的样式都不起作用了。那我们如何让它变成绿色那，其实只有再两个并列的<code>&lt;div&gt;</code>外层，加上一个包括性的标签就可以了。也就是说让子组件的最外层只有一个根元素。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;sonCom&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">            &lt;div&gt;SonCom&lt;/div&gt;</span><br><span class="hljs-string">            &lt;div&gt;技术胖&lt;/div&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这样就又变成了绿色字体。还有一种用到动态绑定的方法，直接绑定属性中的class。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;sonCom&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div :class=&quot;$attrs.class&quot;&gt;SonCom&lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;技术胖&lt;/div&gt; </span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/68#toc364">行内样式的编写</a></p><ul><li>直接在模板的DOM元素上写CSS样式，比如下面的这样。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;h2 style=<span class="hljs-string">&quot;color:orange;&quot;</span>&gt;<span class="hljs-title class_">JSPang</span>.<span class="hljs-property">com</span>&lt;/h2&gt;<br></code></pre></td></tr></table></figure><ul><li>在data中编写样式，比如在Data中这样写。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">styleString</span>:<span class="hljs-string">&#x27;color:orange;&#x27;</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后用绑定行内样式的形式，在模板中进行绑定。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h2 :style=&quot;styleString&quot;&gt;JSPang.com&lt;/h2&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><ul><li><strong>用对象的形式在data中编写CSS样式。</strong>比如写成下面的代码，然后再进行绑定。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>       <span class="hljs-comment">//.....</span><br>        <span class="hljs-attr">styleString</span>:<span class="hljs-string">&#x27;color:orange;&#x27;</span>,<br>        <span class="hljs-attr">styleObject</span>:&#123;<br>            <span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;red&#x27;</span>,<br>            <span class="hljs-attr">background</span>:<span class="hljs-string">&#x27;yellow&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>在写行内样式的使用，个人觉得对象的写法更加直观和简洁，所以建议小伙伴可以采用这种对象的形式来进行编写。</p><h4 id="v-show和v-if的差别"><a href="#v-show和v-if的差别" class="headerlink" title="v-show和v-if的差别"></a>v-show和v-if的差别</h4><p>准备好最基本的结构后，在数据项中声明一个<code>show</code>的变量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">show</span>:<span class="hljs-literal">true</span>,<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>注意这里的<code>true</code>是布尔类型，不是字符串类型。</p><p>有了变量后，可以在模板中使用<code>v-show</code>来控制CSS样式，从而控制DOM元素的展示与否。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h2 v-show=&quot;show&quot;&gt;JSPang.com&lt;/h2&gt;  </span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这时候打开浏览器进行预览，是可以看到<code>JSPang.com</code>这个h2的DOM元素的。如果把数据项<code>show</code>改成<code>false</code>就看不到了。</p><p><a href="https://jspang.com/article/68#toc367">v-if和v-show的区别</a></p><p>v-show看起来和v-if语法的功能基本一样，但其实他们无论是灵活性还是功能都是有区别的。</p><p><code>v-if</code><strong>更加灵活</strong>，可以增加多个判断，比如<code>v-else-iif</code>和<code>else</code>，而<code>v-show</code><strong>不具备这样的灵活性</strong>。</p><p>如果显示和隐藏的状态切换比较频繁，并且没有什么多余复杂的业务逻辑，建议使用<code>v-show</code>，因为他不会一直渲染你的页面DOM元素，这或多或少对性能和稳定性有点提升。反之可以使用<code>v-if</code>。</p><h4 id="v-for循环详细讲解"><a href="#v-for循环详细讲解" class="headerlink" title="v-for循环详细讲解"></a>v-for循环详细讲解</h4><p>在<code>data</code>中声明一个数组，数组叫做<code>listArray</code>,代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;  <br>        <span class="hljs-attr">listArray</span>:[<span class="hljs-string">&#x27;谢大脚&#x27;</span>,<span class="hljs-string">&#x27;刘英&#x27;</span>,<span class="hljs-string">&#x27;晓红&#x27;</span>]<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>用<code>v-for</code>在<code>template</code>模版里遍历数组，代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;ul&gt;</span><br><span class="hljs-string">        &lt;li v-for=&quot;item in listArray&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="hljs-string">    &lt;/ul&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>上面代码写完后在浏览器中预览效果，可以看到，已经如我们所愿，在页面渲染出了列表。在<code>v-for</code>渲染数组时中还可以加入索引<code>index</code>,也就是 数组的下标。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;ul&gt;</span><br><span class="hljs-string">        &lt;li v-for=&quot;(item,index)  in listArray&quot;&gt;[&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="hljs-string">    &lt;/ul&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p><strong>循环中的key值</strong></p><p>为了提高循环时性能，在数组其中一项变化后，整个数组不进行全部重新渲染，Vue提供了绑定key值的使用方法，目的就是增加渲染性能，避免重复渲染。</p><p>为了理解这个概念，先编写出一个按钮，然后每次点击按钮后向数组中增加<code>push</code>一个新值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">handleChangeBtnClick</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">listArray</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;JSPang.com&#x27;</span>)<br>    &#125;,<br>&#125;,<br><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    //......</span><br><span class="hljs-string">    &lt;button @click=&quot;handleChangeBtnClick&quot;&gt;点我改变&lt;/button&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>当你点击按钮时，表面上你看到增加了一个新的内容，实际整个列表都被重新渲染了。</p><p>在实际工作中，这样的代码是不被允许的，它会降低页面的性能，在数据量变多的时候，用户用起来会变的卡顿。这时，你可以加具有<strong>唯一</strong>性的<code>key</code>值，增加后vue就会辨认出哪些内容被渲染后并没有变化，而只渲染新变化的内容。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index)  in listArray&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index+item&quot;</span>&gt;</span></span><br><span class="language-xml">        [&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>官方不建议使用索引<code>index</code>为key值，因为若存在多个数组，会出现重复，但此时又为了保持唯一性，所以这里使用了<code>index+item</code>进行绑定key值</p><p><a href="https://jspang.com/article/68#toc371">v-for循环对象的方法</a></p><p>v-for不仅可以循环数组，还可以循环对象，使用方法基本和数组一样（但其中参数值是不一样的）。这里先在data中建立一个对象。代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;  <br>        <span class="hljs-comment">//......</span><br>        <span class="hljs-attr">listObject</span>:&#123;<br>            <span class="hljs-title class_">Girl</span>:<span class="hljs-string">&#x27;谢大脚&#x27;</span>,<br>            <span class="hljs-title class_">Boy</span>:<span class="hljs-string">&#x27;刘英&#x27;</span>,<br>            <span class="hljs-title class_">Old</span>:<span class="hljs-string">&#x27;晓红&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>在模板中进行循环的时候，循环的是同一个对象的不同的项，为了更好的语义化，我们把参数改为了<code>value</code>,<code>key</code>和<code>index</code>。然后进行循环。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value,key,index)  in listObject&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;key&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">        [&#123;&#123;index&#125;&#125;]&#123;&#123;value&#125;&#125;-&#123;&#123;key&#125;&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>写完后可以到浏览器中预览，也是可以得到你想要的结果的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">[<span class="hljs-number">0</span>]谢大脚-<span class="hljs-title class_">Girl</span><br>[<span class="hljs-number">1</span>]刘英-<span class="hljs-title class_">Boy</span><br>[<span class="hljs-number">2</span>]晓红-<span class="hljs-title class_">Old</span><br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/68#toc373">v-for循环数字</a></p><p><code>v-for</code>是可以用来循环数字的，比如你要循环1-99的数字，可以直接写成下面的样子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;span v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;count in 99&quot;</span>&gt;&#123;&#123;count&#125;&#125;,&lt;/span&gt;<br></code></pre></td></tr></table></figure><p>这样就可以快速的循环出1-99的值在页面上。可以在浏览器中看一下这个效果。</p><p><a href="https://jspang.com/article/68#toc374">v-for中如何使用判断</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in listArray&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index+item&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;item != &#x27;谢大脚&#x27;&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span></span><br><span class="language-xml">        [&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>在浏览器中进行预览，你会发现<code>谢大脚</code>的循环项并没有消失。</p><p>这是<strong>因为在同一个标签里，v-for循环的优先级要高于<code>v-if</code>判断的优先级，所以判断失效。</strong></p><p>正确的写法应该是在<code>&lt;li&gt;</code>外层独立出一个标签，在<code>&lt;li&gt;</code>上做循环。比如写成下面的代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in listArray&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index+item&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;item != &#x27;谢大脚&#x27;&quot;</span>&gt;</span></span><br><span class="language-xml">        [&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>这时候到浏览器中预览，<code>谢大脚</code>如愿以偿的消失了。</p><p><a href="https://jspang.com/article/68#toc375">template标签的使用</a></p><p>上面的结果完美吗？当你打开浏览器的控制台，看Elements选项卡时，你会发现DOM结构是有问题的，明明循环出两项，却有3个<code>&lt;div&gt;</code>，而且这种外层套用<code>&lt;div&gt;</code>里边使用<code>&lt;li&gt;</code>的形式，不符合HTML语法的基本结构。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>为了解决这个问题，Vue给我们提供了<code>&lt;template&gt;</code>模版标签，也就是一个空的占位符，目的就是解决模板中为完成业务逻辑，而使用的无用html标签的现象。</p><p>现在可以把上面的代码写成这样。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in listArray&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index+item&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;item != &#x27;谢大脚&#x27;&quot;</span>&gt;</span></span><br><span class="language-xml">        [&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>这时候再到浏览器看一下结果，这样就符合我们的期待了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;ul&gt;<br>    &lt;!--v-<span class="hljs-keyword">if</span>--&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><h3 id="七、绑定事件"><a href="#七、绑定事件" class="headerlink" title="七、绑定事件"></a>七、绑定事件</h3><ul><li>绑定method中的函数</li></ul><p>现在的需求是这样的，只要顾客点击按钮，我们就会增加菜单数量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo19&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot; &gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app=Vue.createApp(&#123; <br>    data()&#123;<br>        return&#123;<br>            count:0<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>    addCountClick()&#123;<br>        this.count++;<br>    &#125;,<br>&#125;,<br>    template:`<br>      &lt;div&gt;目前已点菜的数量&#123;&#123;count&#125;&#125;.&lt;/div&gt;<br>      &lt;button @click=&quot;addCountClick&quot;&gt;增加一道菜&lt;/button&gt;<br>        ` <br>    &#125;) <br>    const vm=app.mount(&quot;#app&quot;)<br><br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><ul><li>直接用表达式实现</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button @click=<span class="hljs-string">&quot;count++&quot;</span>&gt;增加一位&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>保持代码的精简，但这样灵活性也会比较差。</p><ul><li>用event对象代替</li></ul><p>在编写响应事件事，是可以接受一个event参数的，这个参数就是关于响应事件的一些内容。我们直接打印出event，你会发现内容比较多，其实这些参数还是值得一看的，在工作中有时真的会用到。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">addCountClick</span>(<span class="hljs-params">event</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event)<br>    &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><p>这时候你可以打开浏览器，然后打开<code>控制台</code>查看一下效果。可以看到event的内容非常多，想直观看到是那个DOM元素触发事件，可以使用<code>target</code>属性。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>)<br></code></pre></td></tr></table></figure><ul><li>单参数/多参数的传递</li></ul><p>先来看传入单独的参数，比如现在每次点击的增量不再是1，而是2。就可以这样来编写。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">addCountClick</span>(<span class="hljs-params">num</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>+=num<br>    &#125;,<br>&#125;,<br><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        //.....</span><br><span class="hljs-string">    &lt;button @click=&quot;addCountClick(2)&quot;&gt;增加一&lt;/button&gt;</span><br><span class="hljs-string">    `</span> <br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>有参数的情况下使用event</strong></p><p>这时候你还想使用<code>event</code>参数，方法是参数增加<code>$event</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">addCountClick</span>(<span class="hljs-params">num,event</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>+=num;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>)<br>    &#125;,<br>&#125;,<br><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;目前已点数量&#123;&#123;count&#125;&#125;.&lt;/div&gt;</span><br><span class="hljs-string">    &lt;button @click=&quot;addCountClick(2,$event)&quot;&gt;增加一位&lt;/button&gt;</span><br><span class="hljs-string">    `</span> <br>&#125;)<br></code></pre></td></tr></table></figure><p>总结一下，在有多个参数的情况下，要继续使用event，需要在调用的地方使用<code>$event</code>，进行传递参数，然后在方法上正常接收就可以了。</p><ul><li>一个按钮调用两个方法</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-title function_">handleBtnClick1</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>)<br>    &#125;,<br>    <span class="hljs-title function_">handleBtnClick2</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">2</span>)<br>    &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><p>在模板的按钮中可以这样使用这两个方法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button @click=<span class="hljs-string">&quot;handleBtnClick1(),handleBtnClick2()&quot;</span>&gt;增加&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>这里需要注意的是:调用方法的时候，要加上<code>( )</code>如果不加，调用是无效的。</p><p>总结一下：如果想在模板中一次触发两个事件方法，需要 用<code>,</code>逗号，把事件隔开，然后每个事件后边必须加上<code>( )</code>才能起作用。</p><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p>事件修饰符分别是：<code>stop</code>,<code>prevent</code>,<code>capture</code>,<code>self</code>,<code>once</code>和<code>passive</code>。</p><p><a href="https://jspang.com/article/68#toc383">通过修饰符解决冒泡事件</a></p><p>在JavaScript中冒泡事件是经常处理的事件，先写一段代码，手动创造一个冒泡事件。</p><ul><li>修改模板<code>template</code>部分，在最外层增加一个<code>&lt;div&gt;</code>并添加click事件。</li><li>修改方法<code>methods</code>部分，删除无用方法，保留两个方法，增加alter提示。</li><li>形成冒泡效果，就是有嵌套的DOM元素时，两个都有绑定事件，JS会自动向上传递事件。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo19&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot; &gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app=Vue.createApp(&#123; <br>    data()&#123;<br>        return&#123;<br>            count:0<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>        addCountClick()&#123;<br>            this.count++<br>        &#125;,<br>        handleBtnClick1()&#123;<br>            alert(1)<br>        &#125;,<br>    &#125;,<br>    template:`<br>        &lt;div @click=&quot;handleBtnClick1&quot;&gt;<br>            &lt;div&gt;目前已点数量&#123;&#123;count&#125;&#125;&lt;/div&gt;<br>            &lt;button @click=&quot; addCountClick()&quot;&gt;增加&lt;/button&gt;<br>       &lt;/div&gt;<br>        ` <br>    &#125;) <br>    const vm=app.mount(&quot;#app&quot;)<br><br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>stop修饰符</strong></p><p>在Vue中要停止冒泡是非常简单的，只要加一个事件修饰符<code>stop</code>就可以了，相当于点这个按钮的时候不会触发外层效果，只有点除按钮外的区域时才出发。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button @click.<span class="hljs-property">stop</span>=<span class="hljs-string">&quot; addCountClick()&quot;</span>&gt;增加&lt;/button&gt;<br></code></pre></td></tr></table></figure><p><strong>self修饰符</strong></p><p>只有点击自己的时候才会被执行， 只不过加的位置要在外层DOM元素的事件上。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div @click.self=&quot;handleBtnClick1&quot;&gt;</span><br><span class="hljs-string">            &lt;div&gt;目前已点数量&#123;&#123;count&#125;&#125;.&lt;/div&gt;</span><br><span class="hljs-string">            &lt;button @click=&quot; addCountClick()&quot;&gt;增加一位&lt;/button&gt;</span><br><span class="hljs-string">       &lt;/div&gt;</span><br><span class="hljs-string">        `</span><br></code></pre></td></tr></table></figure><p>这时候你会发现无论点击哪里，都没办法触发<code>hanldeBtnClick1</code>方法了，这是因为目前最外层div下都是独立的DOM元素，就是都有成对标签出现，都不属于最外自己，都是他们的子元素。</p><p>可以编写一段专属最外层DIV的文字。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div @click.self=&quot;handleBtnClick1&quot;&gt;</span><br><span class="hljs-string">            我是最外层的DIV文字</span><br><span class="hljs-string">            &lt;div&gt;目前已点数量&#123;&#123;count&#125;&#125;.&lt;/div&gt;</span><br><span class="hljs-string">            &lt;button @click=&quot; addCountClick()&quot;&gt;增加一位&lt;/button&gt;</span><br><span class="hljs-string">       &lt;/div&gt;</span><br><span class="hljs-string">        `</span><br></code></pre></td></tr></table></figure><p>这样当点击<code>我是最外层的DIV文字</code>时，就会触发<code>handleBtnClick1</code>方法了。</p><p><a href="https://jspang.com/article/68#toc384">其它常用修饰符</a></p><p><strong>prevent修饰符：</strong>阻止默认行为的修饰符</p><p><strong>capture修饰符：</strong>改成捕获模式，默认的模式都是冒泡模式，也就是从下到上，从内到外，但是你用capture后，是从上到下，从外到内的。</p><p>修改一下模板部分的代码，不再使用修饰符，而是让事件存在冒泡。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">addCountClick</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">0</span>)  <span class="hljs-comment">//修改了此处</span><br>    &#125;,<br>    <span class="hljs-title function_">handleBtnClick1</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>)<br>    &#125;,<br>&#125;,<br><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div @click.capture=&quot;handleBtnClick1&quot;&gt;  //修改了此处</span><br><span class="hljs-string">        我是最外层的DIV文字</span><br><span class="hljs-string">        &lt;div&gt;目前已点数量&#123;&#123;count&#125;&#125;.&lt;/div&gt;</span><br><span class="hljs-string">        &lt;button @click=&quot; addCountClick()&quot;&gt;增加一位&lt;/button&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br></code></pre></td></tr></table></figure><p><strong>once修饰符：</strong>事件只执行一次</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div @click.self=&quot;handleBtnClick1&quot;&gt;</span><br><span class="hljs-string">        我是最外层的DIV文字</span><br><span class="hljs-string">        &lt;div&gt;目前已点数量&#123;&#123;count&#125;&#125;.&lt;/div&gt;</span><br><span class="hljs-string">        &lt;button @click.once=&quot; addCountClick()&quot;&gt;增加一位&lt;/button&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br></code></pre></td></tr></table></figure><p>此时再点击按钮，事件只执行一次。这时候我们修改了两个地方，最外层的事件加了<code>self</code>修饰符，button上加了<code>once</code>修饰符。</p><p><strong>passive修饰符</strong>：解决滚动时性能的修饰符，不太好演示，等以后用到我们会再详细讲解。</p><h4 id="按键、鼠标饰修符"><a href="#按键、鼠标饰修符" class="headerlink" title="按键、鼠标饰修符"></a>按键、鼠标饰修符</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;body&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/body&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123; </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span>&#123;&#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">methods</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">        &lt;div&quot;&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">            &lt;input /&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">        &lt;/div&gt;</span></span></span><br><span class="hljs-string"><span class="language-javascript"><span class="language-xml">        `</span> </span></span><br><span class="language-javascript"><span class="language-xml">    &#125;) </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> vm=app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>然后在<code>methods</code>部分加入一个方法<code>handleKeyDwon( )</code>，具体内容只是在控制台打印出来<code>keydown</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">handleKeyDown</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;keydow....&#x27;</span>)<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><ul><li>绑定键盘按下</li></ul><p>在模板中的<code>&lt;input /&gt;</code>中绑定键盘按下时响应<code>keydown</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&quot;&gt;</span><br><span class="hljs-string">        &lt;input @keydown=&quot;handleKeyDown&quot;/&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br></code></pre></td></tr></table></figure><ul><li>绑定单个按键按下</li></ul><p>指定键盘上某个特殊的按键时才会响应事件方法。</p><p>如果现在的需求是，上面的代码只有在按下回车时，才在控制台进行打印，这时候就需要按键修饰符了。我们学的第一个按键修饰符<code>enter</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&quot;&gt;</span><br><span class="hljs-string">        &lt;input @keydown.enter=&quot;handleKeyDown&quot;/&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    `</span> <br>    &#125;)<br></code></pre></td></tr></table></figure><p>类似这样只响应单个按键的修饰符有很多</p><p>enter回车 、tab、delete、esc、up 、down、left、right</p><ul><li>绑定鼠标按下</li></ul><p>除了按键修饰符，还有鼠标修饰符，就是按下鼠标上的某个键时，才会响应。</p><p>最常用的就是: left、right、middle</p><p>现在的需求是在页面上作一行文字<code>JSPang.com</code>，然后只有用鼠标右键点击时，才会弹出<code>alert( )</code>。</p><p>先在<code>methods</code>里编写一个<code>handleClick</code>方法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>   <span class="hljs-comment">//...</span><br>    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;click&#x27;</span>)<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后在模板中使用鼠标修饰符，确定只有点击鼠标右键时才会响应。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div @click.<span class="hljs-property">right</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;<span class="hljs-title class_">JSPang</span>.<span class="hljs-property">com</span>&lt;/div&gt;<br></code></pre></td></tr></table></figure><h4 id="表单数据的双绑定"><a href="#表单数据的双绑定" class="headerlink" title="表单数据的双绑定"></a>表单数据的双绑定</h4><p><a href="https://jspang.com/article/68#toc391">input的数据双向绑定</a></p><p>这个可能是最简单和最常用的双向绑定方式，我们先在模板中给写一个<code>&lt;input/&gt;</code>，然后在<code>data</code>中声明一个<code>name</code>的变量，有了变量后和<code>input</code>进行双向数据绑定。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123; <br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span>&#123;<br>            <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">            &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="hljs-string">            &lt;input v-model=&quot;name&quot; /&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">        `</span> <br>    &#125;) <br>    <span class="hljs-keyword">const</span> vm=app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>写完这个，打开浏览器预览一下效果。可以看到，当<code>input</code>改变时，对应的变量也会变化，页面中的值也会变化。</p><p>那什么是双向绑定呢？</p><ul><li><p><strong>data中的变量改变时，绑定的数据会跟随变化，此为一项修改；</strong></p></li><li><p><strong>当通过页面修改数据，data中的变量也随之改变，这就是另一项修改。两个彼此依存改变，就为双向数据绑定。</strong></p></li></ul><p>目前这种就完成了<code>&lt;input /&gt;</code>的双向数据绑定。</p><p><a href="https://jspang.com/article/68#toc392">textarea的数据双向绑定</a></p><p>以前我们写<code>HTML</code>的时候，写<code>textarea</code>标签都是成对出现的，比如这样<code>&lt;textarea&gt;&lt;/textarea&gt;</code>，如果想在Vue中实现textarea的双向数据绑定，这时候只要写单标签就可以了，剩下的事情Vue底层就帮你完成了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">        &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;&lt;input v-model=&quot;name&quot; /&gt;&lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;&lt;textarea v-model=&quot;name&quot; /&gt;&lt;/div&gt;  </span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br></code></pre></td></tr></table></figure><p>这样也是可以实现数据的双向绑定的。</p><p><a href="https://jspang.com/article/68#toc393">checkbox数据双向绑定</a></p><p><code>checkbox</code>是一个勾选框（复选框），如果只有一个选项时，我们可以给<code>&lt;checkbox /&gt;</code>一个布尔值，也就是true或者false。</p><p>现在data中新声明一个变量<code>checked</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">checked</span>:<span class="hljs-literal">false</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后在模板中进行双向数据绑定。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;&#123;&#123;checked&#125;&#125;&lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> v-model=<span class="hljs-string">&quot;checked&quot;</span> /&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>写完后进行预览，双向绑定是完全可以实现的。<code>checkbox</code>还有一个功能就是复选，可以选择多个。</p><p>比如还是象牙山三女的例子，现在勾选谁，谁就可以显示在页面上。</p><p>这时候要先定义一个变量，这个变量是一个空数组。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">checked</span>:<span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">girls</span>:[]<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后增加模板中的内容如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>    &#123;&#123;girls&#125;&#125;<br>    大脚&lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> v-model=<span class="hljs-string">&quot;girls&quot;</span> value=<span class="hljs-string">&quot;大脚&quot;</span> /&gt;<br>    刘英&lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> v-model=<span class="hljs-string">&quot;girls&quot;</span> value=<span class="hljs-string">&quot;刘英&quot;</span> /&gt;<br>    晓红&lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> v-model=<span class="hljs-string">&quot;girls&quot;</span> value=<span class="hljs-string">&quot;晓红&quot;</span> /&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>这时候就可以实现多选的双向数据绑定了。</p><p><a href="https://jspang.com/article/68#toc394">Radio的双向数据绑定</a></p><p>学会了<code>checkbox</code>的双向数据绑定，<code>radio</code>单选按钮就简单了。但是需要注意的是，既然是单选，这时候data中的变量就不能是一个数字了，一般是一个字符串。比如我们这里新定义了一个<code>girl</code>的变量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">girl</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>复制上面的template代码，然后进行修改，把<code>checkbox</code>换成<code>radio</code>,代码如下:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>    &#123;&#123;girl&#125;&#125;<br>    大脚&lt;input type=<span class="hljs-string">&quot;radio&quot;</span> v-model=<span class="hljs-string">&quot;girl&quot;</span> value=<span class="hljs-string">&quot;大脚&quot;</span> /&gt;<br>    刘英&lt;input type=<span class="hljs-string">&quot;radio&quot;</span> v-model=<span class="hljs-string">&quot;girl&quot;</span> value=<span class="hljs-string">&quot;刘英&quot;</span> /&gt;<br>    晓红&lt;input type=<span class="hljs-string">&quot;radio&quot;</span> v-model=<span class="hljs-string">&quot;girl&quot;</span> value=<span class="hljs-string">&quot;晓红&quot;</span> /&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>这样就完成了单项选择的数据双向数据绑定了。</p><p><strong>checkbox里的true-value和false-value</strong></p><p>在浏览器中预览时，当选择复选框时，会显示true，没选中显示false。</p><p>现在的需求是，我选中的时候显示<code>JSPang.com</code>，没选中的时候显示<code>技术胖</code>。这时候要如何处理那？</p><p>Vue给我们提供了这样两个属性<code>true-value</code>和<code>false-value</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">checked</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>这时候在模板中编写下面的代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">&lt;div&gt;&#123;&#123;name&#125;&#125;</span><br><span class="hljs-string">    &lt;input </span><br><span class="hljs-string">        type=&quot;checkbox&quot; </span><br><span class="hljs-string">        v-model=&quot;name&quot;  </span><br><span class="hljs-string">        true-value=&quot;JSPang.com&quot;</span><br><span class="hljs-string">        false-value=&quot;技术胖&quot;</span><br><span class="hljs-string">        /&gt;&lt;/div&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这时候到浏览器中预览，就可以看到，在选择时插值表达式会变成<code>JSPang.com</code>，在没选中时会变成<code>技术胖</code>。</p><p><a href="https://jspang.com/article/68#toc396">v-model数据双向绑定修饰符</a></p><p><strong>lazy修饰符</strong></p><p>我们作一个<code>input</code>的绑定效果，现在data中声明一个<code>message</code>变量，值为空。然后在模板中写一个<code>&lt;input /&gt;</code>并和<code>message</code>进行双向数据绑定。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">checked</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>模板中进行双向数据绑定：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>    &#123;&#123;message&#125;&#125;&lt;input v-model=<span class="hljs-string">&quot;message&quot;</span> /&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>这时候当你在文本框中输入任何内容的时候，插值表达式会跟着改变。如果你不想马上显示，就可以用<code>lazy</code>修饰符，这样就可以实现当输入完成后，失去焦点再进行改变。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>    &#123;&#123;message&#125;&#125;&lt;input v-model.<span class="hljs-property">lazy</span>=<span class="hljs-string">&quot;message&quot;</span> /&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>写完lazy修饰符后，可以看一下效果，这时候的效果就和我们想象的一样了。</p><p><strong>number修饰符</strong></p><p><code>&lt;input /&gt;</code>输入的内容无论是数字还是字母，最终都会变为<code>字符串</code>。如果想最终输入的变成数字，你就可以使用<code>number</code>修饰符了。</p><p>比如我们现在去掉<code>lazy</code>修饰符，直接输入数字，这时候你修改插值表达式的结果，输出当前类型。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>    &#123;&#123;<span class="hljs-keyword">typeof</span> message&#125;&#125;&lt;input v-model=<span class="hljs-string">&quot;message&quot;</span> /&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>这时候你预览，就会发现最终input绑定的值会变成字符串类型。这是html的底层逻辑造成的，这时候我们可以使用<code>number</code>修饰，解决这个问题。加上<code>number</code>修饰符后，<strong>你输入的值只要是数字</strong>，就变成了number类型。（也就是说，如果你输入的是字母，它还会是字符串类型）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>    &#123;&#123;<span class="hljs-keyword">typeof</span> message&#125;&#125;&lt;input v-model.<span class="hljs-property">number</span>=<span class="hljs-string">&quot;message&quot;</span> /&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p><strong>trim修饰</strong></p><p><code>trim</code>修饰符大家一定不陌生，它是用来消除<code>input</code>框输入内容前后的空格的。现在我们再字符串上输入空格，其实它会在DOM元素上进行增加空格的，这个可以在控制台清楚的看出(详细请看视频操作)。 加入<code>trim</code>修饰符后，Vue就会自动给我们去除前后的空格。</p><p>现在data中新声明一个变量，比如叫做<code>message1</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-comment">//......</span><br>        <span class="hljs-attr">message1</span>: <span class="hljs-string">&#x27;JSPang.com&#x27;</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>用法如下:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>    &#123;&#123;message1&#125;&#125;&lt;input v-model.<span class="hljs-property">trim</span>=<span class="hljs-string">&quot;message1&quot;</span> /&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>这时候Vue就会自动为我们去除前后空格，但不会去除字符串中间的空格。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 05</title>
    <link href="/2022/08/13/JavaScript-05/"/>
    <url>/2022/08/13/JavaScript-05/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="JavaScript-基础-第五天"><a href="#JavaScript-基础-第五天" class="headerlink" title="JavaScript 基础 - 第五天"></a>JavaScript 基础 - 第五天</h1><h2 id="一、构造器和操作符-“new”"><a href="#一、构造器和操作符-“new”" class="headerlink" title="一、构造器和操作符 “new”"></a>一、构造器和操作符 “new”</h2><p>常规的 <code>&#123;...&#125;</code> 语法允许创建一个对象。但是我们经常需要创建很多类似的对象，例如多个用户或菜单项等。</p><p>这可以使用构造函数和 <code>&quot;new&quot;</code> 操作符来实现。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><a href="https://zh.javascript.info/constructor-new#gou-zao-han-shu">构造函数</a></h3><p>构造函数在技术上是常规函数。不过有两个约定：</p><ol><li>它们的命名以大写字母开头。</li><li>它们只能由 <code>&quot;new&quot;</code> 操作符来执行。</li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Jack&quot;</span>);<br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// Jack</span><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">isAdmin</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>当一个函数被使用 <code>new</code> 操作符执行时，它按照以下步骤：</p><ol><li>一个新的空对象被创建并分配给 <code>this</code>。</li><li>函数体执行。通常它会修改 <code>this</code>，为其添加新的属性。</li><li>返回 <code>this</code> 的值，即整个新对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-comment">// this = &#123;&#125;;（隐式创建）</span><br><br>  <span class="hljs-comment">// 添加属性到 this</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// return this;（隐式返回）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以 <code>new User(&quot;Jack&quot;)</code> 的结果是相同的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Jack&quot;</span>,<br>  <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">false</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>现在，如果我们想创建其他用户，我们可以调用 <code>new User(&quot;Ann&quot;)</code>，<code>new User(&quot;Alice&quot;)</code> 等。比每次都使用字面量创建要短得多，而且更易于阅读。</p><p>这是构造器的主要目的 —— 实现可重用的对象创建代码。</p><p>让我们再强调一遍 —— 从技术上讲，任何函数（除了箭头函数，它没有自己的 <code>this</code>）都可以用作构造器。即可以通过 <code>new</code> 来运行，它会执行上面的算法。</p><p><u>“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 <code>new</code> 来运行。</u></p><p><strong>new function() { … }</strong></p><p>如果我们有许多行用于创建单个复杂对象的代码，我们可以将它们封装在一个立即调用的构造函数中，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个函数并立即使用 new 调用它</span><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// ……用于用户创建的其他代码</span><br>  <span class="hljs-comment">// 也许是复杂的逻辑和语句</span><br>  <span class="hljs-comment">// 局部变量等</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><u>这个构造函数不能被再次调用</u>，因为它不保存在任何地方，只是被创建和调用。因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。</p><h3 id="构造器的-return"><a href="#构造器的-return" class="headerlink" title="构造器的 return"></a><a href="https://zh.javascript.info/constructor-new#gou-zao-qi-de-return">构造器的 return</a></h3><p>通常，构造器没有 <code>return</code> 语句。它们的任务是将所有必要的东西写入 <code>this</code>，并自动转换为结果。</p><p>但是，如果这有一个 <code>return</code> 语句，那么规则就简单了：</p><ul><li>如果 <code>return</code> 返回的是一个对象，则返回这个对象，而不是 <code>this</code>。</li><li>如果 <code>return</code> 返回的是一个原始类型，则忽略。</li></ul><p>换句话说，带有对象的 <code>return</code> 返回该对象，在所有其他情况下返回 <code>this</code>。</p><p>例如，这里 <code>return</code> 通过返回一个对象覆盖 <code>this</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">BigUser</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;<br><br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Godzilla&quot;</span> &#125;;  <span class="hljs-comment">// &lt;-- 返回这个对象</span><br>&#125;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUser</span>().<span class="hljs-property">name</span> );  <span class="hljs-comment">// Godzilla，得到了那个对象</span><br></code></pre></td></tr></table></figure><p>这里有一个 <code>return</code> 为空的例子（或者我们可以在它之后放置一个原始类型，没有什么影响）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SmallUser</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;<br><br>  <span class="hljs-keyword">return</span>; <span class="hljs-comment">// &lt;-- 返回 this</span><br>&#125;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmallUser</span>().<span class="hljs-property">name</span> );  <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure><p>通常构造器没有 <code>return</code> 语句。这里我们主要为了完整性而提及返回对象的特殊行为。</p><p><strong>省略括号</strong></p><p>顺便说一下，如果没有参数，我们可以省略 <code>new</code> 后的括号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>; <span class="hljs-comment">// &lt;-- 没有参数</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br></code></pre></td></tr></table></figure><p>这里省略括号不被认为是一种“好风格”，但是规范允许使用该语法。</p><h3 id="构造器中的方法"><a href="#构造器中的方法" class="headerlink" title="构造器中的方法"></a><a href="https://zh.javascript.info/constructor-new#gou-zao-qi-zhong-de-fang-fa">构造器中的方法</a></h3><p>我们不仅可以将属性添加到构造器中，还可以添加方法。</p><p>例如，下面的 <code>new User(name)</code> 用给定的 <code>name</code> 和方法 <code>sayHi</code> 创建了一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;My name is: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;John&quot;</span>);<br><br>john.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// My name is: John</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">john = &#123;</span><br><span class="hljs-comment">   name: &quot;John&quot;,</span><br><span class="hljs-comment">   sayHi: function() &#123; ... &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><a href="https://zh.javascript.info/classes">类</a> 是用于创建复杂对象的一个更高级的语法，我们稍后会讲到。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/constructor-new#zong-jie">总结</a></h3><ul><li>构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其命名首字母要大写。</li><li>构造函数只能使用 <code>new</code> 来调用。这样的调用意味着在开始时创建了空的 <code>this</code>，并在最后返回填充了值的 <code>this</code>。</li></ul><p>我们可以使用构造函数来创建多个类似的对象。</p><p>JavaScript 为许多内建的对象提供了构造函数：比如日期 <code>Date</code>、集合 <code>Set</code> 以及其他我们计划学习的内容。</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a><a href="https://zh.javascript.info/constructor-new#tasks">任务</a></h3><h4 id="两个函数-——-一个对象"><a href="#两个函数-——-一个对象" class="headerlink" title="两个函数 —— 一个对象"></a><a href="https://zh.javascript.info/constructor-new#liang-ge-han-shu-yi-ge-dui-xiang">两个函数 —— 一个对象</a></h4><p>是否可以创建像 <code>new A() == new B()</code> 这样的函数 <code>A</code> 和 <code>B</code>？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123; ... &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) &#123; ... &#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> A;<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B;<br><br><span class="hljs-title function_">alert</span>( a == b ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>是的，这是可以的。</p><p>如果一个函数返回一个对象，那么 <code>new</code> 返回那个对象而不是 <code>this</code>。</p><p>所以它们可以，例如，返回相同的外部定义的对象 <code>obj</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj=&#123;&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> obj<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-keyword">return</span> obj<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> A;<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B;<br><br><span class="hljs-title function_">alert</span>( a == b ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="创建-new-Calculator"><a href="#创建-new-Calculator" class="headerlink" title="创建 new Calculator"></a><a href="https://zh.javascript.info/constructor-new#chuang-jian-newcalculator">创建 new Calculator</a></h4><p>重要程度: 5</p><p>创建一个构造函数 <code>Calculator</code>，它创建的对象中有三个方法：</p><ul><li><code>read()</code> 使用 <code>prompt</code> 请求两个值并把它们记录在对象的属性中。</li><li><code>sum()</code> 返回这些属性的总和。</li><li><code>mul()</code> 返回这些属性的乘积。</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> calculator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br>calculator.<span class="hljs-title function_">read</span>();<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Sum=&quot;</span> + calculator.<span class="hljs-title function_">sum</span>() );<br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Mul=&quot;</span> + calculator.<span class="hljs-title function_">mul</span>() );<br></code></pre></td></tr></table></figure><p>解决方案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Calculator</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>=<span class="hljs-literal">null</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>=<span class="hljs-literal">null</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">read</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>=<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入第一个值&quot;</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>=<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入第二个值&quot;</span>)<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sum</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> -(-<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>-<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>)<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mul</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>*<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> calculator=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>()<br>calculator.<span class="hljs-title function_">read</span>()<br><span class="hljs-title function_">alert</span>(calculator.<span class="hljs-title function_">sum</span>())<br><span class="hljs-title function_">alert</span>(calculator.<span class="hljs-title function_">mul</span>())<br></code></pre></td></tr></table></figure><p>构造函数不同于直接创建对象，而是一个函数，所以每一个语句都要用<code>;</code>或换行分割，并且也没有本身属性，所以必须用this来调用属性和方法。</p><h4 id="创建-new-Accumulator"><a href="#创建-new-Accumulator" class="headerlink" title="创建 new Accumulator"></a><a href="https://zh.javascript.info/constructor-new#chuang-jian-newaccumulator">创建 new Accumulator</a></h4><p>重要程度: 5</p><p>创建一个构造函数 <code>Accumulator(startingValue)</code>。</p><p>它创建的对象应该：</p><ul><li>将“当前 value”存储在属性 <code>value</code> 中。起始值被设置到构造器 <code>startingValue</code> 的参数。</li><li><code>read()</code> 方法应该使用 <code>prompt</code> 来读取一个新的数字，并将其添加到 <code>value</code> 中。</li></ul><p>换句话说，<code>value</code> 属性是所有用户输入值与初始值 <code>startingValue</code> 的总和。</p><p>下面是示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> accumulator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Accumulator</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 初始值 1</span><br><br>accumulator.<span class="hljs-title function_">read</span>(); <span class="hljs-comment">// 添加用户输入的 value</span><br>accumulator.<span class="hljs-title function_">read</span>(); <span class="hljs-comment">// 添加用户输入的 value</span><br><br><span class="hljs-title function_">alert</span>(accumulator.<span class="hljs-property">value</span>); <span class="hljs-comment">// 显示这些值的总和</span><br></code></pre></td></tr></table></figure><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Accumulator</span>(<span class="hljs-params">startingValue</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>=startingValue<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">read</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>+=<span class="hljs-built_in">parseInt</span>(<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入一个值&quot;</span>))<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> acc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Accumulator</span>(<span class="hljs-number">5</span>)<br>acc.<span class="hljs-title function_">read</span>()<br>acc.<span class="hljs-title function_">read</span>()<br><span class="hljs-title function_">alert</span>(acc.<span class="hljs-property">value</span>)<br></code></pre></td></tr></table></figure><p>在构造函数里定义方法时，等号左边是为函数命名，而不是声明函数，记得别加括号。</p><h2 id="二、可选链-“-”"><a href="#二、可选链-“-”" class="headerlink" title="二、可选链 “?.”"></a>二、可选链 “?.”</h2><p><strong>最近新增的特性</strong></p><p>这是一个最近添加到 JavaScript 的特性。 旧式浏览器可能需要 polyfills.</p><p>可选链 <code>?.</code> 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误。</p><h3 id="“不存在的属性”的问题"><a href="#“不存在的属性”的问题" class="headerlink" title="“不存在的属性”的问题"></a><a href="https://zh.javascript.info/optional-chaining#bu-cun-zai-de-shu-xing-de-wen-ti">“不存在的属性”的问题</a></h3><p>举个例子，假设我们有很多个 <code>user</code> 对象，其中存储了我们的用户数据。</p><p>我们大多数用户的地址都存储在 <code>user.address</code> 中，街道地址存储在 <code>user.address.street</code> 中，但有些用户没有提供这些信息。</p><p>在这种情况下，当我们尝试获取 <code>user.address.street</code>，而该用户恰好没提供地址信息，我们则会收到一个错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// 一个没有 &quot;address&quot; 属性的 user 对象</span><br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span>); <span class="hljs-comment">// Error!</span><br></code></pre></td></tr></table></figure><p>这是预期的结果。JavaScript 的工作原理就是这样的。因为 <code>user.address</code> 为 <code>undefined</code>，尝试读取 <code>user.address.street</code> 会失败，并收到一个错误。</p><p>但是在很多实际场景中，我们更希望得到的是 <code>undefined</code>（表示没有 <code>street</code> 属性）而不是一个错误。</p><p>还有另一个例子。在 Web 开发中，我们可以使用特殊的方法调用（例如 <code>document.querySelector(&#39;.elem&#39;)</code>）以对象的形式获取一个网页元素，如果没有这种对象，则返回 <code>null</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 如果 document.querySelector(&#x27;.elem&#x27;) 的结果为 null，则这里不存在这个元素</span><br><span class="hljs-keyword">let</span> html = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.elem&#x27;</span>).<span class="hljs-property">innerHTML</span>; <span class="hljs-comment">// 如果 document.querySelector(&#x27;.elem&#x27;) 的结果为 null，则会出现错误</span><br></code></pre></td></tr></table></figure><p>同样，如果该元素不存在，则访问 <code>null</code> 的 <code>.innerHTML</code> 属性时会报错。在某些情况下，当元素的缺失是没问题的时候，我们希望避免出现这种错误，而是接受 <code>html = null</code> 作为结果。</p><p>我们如何实现这一点呢？</p><p>可能最先想到的方案是在访问该值的属性之前，使用 <code>if</code> 或条件运算符 <code>?</code> 对该值进行检查，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;;<br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">address</span> ? user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span> : <span class="hljs-literal">undefined</span>);<br></code></pre></td></tr></table></figure><p>这样可以，这里就不会出现错误了……但是不够优雅。就像你所看到的，<code>&quot;user.address&quot;</code> 在代码中出现了两次。</p><p>对于嵌套层次更深的属性，代码会变得更丑，因为需要更多的重复。</p><p>例如，让我们以相同的方式尝试获取 <code>user.address.street.name</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// user 没有 address 属性</span><br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">address</span> ? user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span> ? user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span>.<span class="hljs-property">name</span> : <span class="hljs-literal">null</span> : <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>这样就太扯淡了，并且这可能导致写出来的代码很难让别人理解。</p><p>这里有一种更好的实现方式，就是使用 <code>&amp;&amp;</code> 运算符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// user 没有 address 属性</span><br><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">address</span> &amp;&amp; user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span> &amp;&amp; user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span>.<span class="hljs-property">name</span> ); <span class="hljs-comment">// undefined（不报错）</span><br></code></pre></td></tr></table></figure><p>依次对整条路径上的属性使用与运算进行判断，以确保所有节点是存在的（如果不存在，则停止计算），但仍然不够优雅。</p><p>就像你所看到的，在代码中我们仍然重复写了好几遍对象属性名。例如在上面的代码中，<code>user.address</code> 被重复写了三遍。</p><p>这就是为什么可选链 <code>?.</code> 被加入到了 JavaScript 这门编程语言中。那就是彻底地解决以上所有问题！</p><h3 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a><a href="https://zh.javascript.info/optional-chaining#ke-xuan-lian">可选链</a></h3><p>如果可选链 <code>?.</code> 前面的值为 <code>undefined</code> 或者 <code>null</code>，它会停止运算并返回 <code>undefined</code>。</p><p><strong>为了简明起见，在本文接下来的内容中，我们会说如果一个属性既不是 <code>null</code> 也不是 <code>undefined</code>，那么它就“存在”。</strong></p><p>换句话说，例如 <code>value?.prop</code>：</p><ul><li>如果 <code>value</code> 存在，则结果与 <code>value.prop</code> 相同，</li><li>否则（当 <code>value</code> 为 <code>undefined/null</code> 时）则返回 <code>undefined</code>。</li></ul><p>下面这是一种使用 <code>?.</code> 安全地访问 <code>user.address.street</code> 的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// user 没有 address 属性</span><br><br><span class="hljs-title function_">alert</span>( user?.<span class="hljs-property">address</span>?.<span class="hljs-property">street</span> ); <span class="hljs-comment">// undefined（不报错）</span><br></code></pre></td></tr></table></figure><p>代码简洁明了，也不用重复写好几遍属性名。?在哪边，哪边就是不确认但需要返回的量。</p><p>这里是一个结合 <code>document.querySelector</code> 使用的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> html = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.elem&#x27;</span>)?.<span class="hljs-property">innerHTML</span>; <span class="hljs-comment">// 如果没有符合的元素，则为 undefined</span><br></code></pre></td></tr></table></figure><p>即使 对象 <code>user</code> 不存在，使用 <code>user?.address</code> 来读取地址也没问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-literal">null</span>;<br><br><span class="hljs-title function_">alert</span>( user?.<span class="hljs-property">address</span> ); <span class="hljs-comment">// undefined</span><br><span class="hljs-title function_">alert</span>( user?.<span class="hljs-property">address</span>.<span class="hljs-property">street</span> ); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>请注意：<code>?.</code> 语法使其前面的值成为可选值，但不会对其后面的起作用。</p><p><strong>不要过度使用可选链</strong></p><p>我们应该只将 <code>?.</code> 使用在一些东西可以不存在的地方。</p><p>例如，如果根据我们的代码逻辑，<code>user</code> 对象必须存在，但 <code>address</code> 是可选的，那么我们应该这样写 <code>user.address?.street</code>，而不是这样 <code>user?.address?.street</code>。</p><p>那么，如果 <code>user</code> 恰巧为 undefined，我们会看到一个编程错误并修复它。否则，如果我们滥用 <code>?.</code>，会导致代码中的错误在不应该被消除的地方消除了，这会导致调试更加困难。</p><p><strong><code>?.</code> 前的变量必须已声明</strong></p><p>如果未声明变量 <code>user</code>，那么 <code>user?.anything</code> 会触发一个错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ReferenceError: user is not defined</span><br>user?.<span class="hljs-property">address</span>;<br></code></pre></td></tr></table></figure><p><strong>短路效应</strong></p><p>正如前面所说的，如果 <code>?.</code> 左边部分不存在，就会立即停止运算（“短路效应”）。</p><p>因此，如果在 <code>?.</code> 的右侧有任何进一步的函数调用或操作，它们均不会执行。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>;<br><br>user?.<span class="hljs-title function_">sayHi</span>(x++); <span class="hljs-comment">// 没有 &quot;user&quot;，因此代码执行没有到达 sayHi 调用和 x++</span><br><br><span class="hljs-title function_">alert</span>(x); <span class="hljs-comment">// 0，值没有增加</span><br></code></pre></td></tr></table></figure><p><strong>其它变体：?.( )，?.[ ]</strong></p><ul><li><p><code>?.()</code>用于访问不确定是否存在的方法</p><p>在下面这段代码中，有些用户具有 <code>admin</code> 方法，而有些没有：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> userAdmin = &#123;<br>  <span class="hljs-title function_">admin</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;I am admin&quot;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> userGuest = &#123;&#125;;<br><br>userAdmin.<span class="hljs-property">admin</span>?.(); <span class="hljs-comment">// I am admin</span><br><br>userGuest.<span class="hljs-property">admin</span>?.(); <span class="hljs-comment">// 啥都没发生（没有这样的方法）</span><br></code></pre></td></tr></table></figure><p>如果 <code>admin</code> 函数存在，那么就调用运行它（对于 <code>userAdmin</code>）。否则（对于 <code>userGuest</code>）运算停止，没有报错。</p></li><li><p><code>?.[]</code>用于访问不确定是否存在对象的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;firstName&quot;</span>;<br><br><span class="hljs-keyword">let</span> user1 = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> user2 = <span class="hljs-literal">null</span>;<br><br><span class="hljs-title function_">alert</span>( user1?.[key] ); <span class="hljs-comment">// John</span><br><span class="hljs-title function_">alert</span>( user2?.[key] ); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure></li><li><p>还可以将 <code>?.</code> 跟 <code>delete</code> 一起使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> user?.<span class="hljs-property">name</span>; <span class="hljs-comment">// 如果 user 存在，则删除 user.name</span><br></code></pre></td></tr></table></figure><p><strong>我们可以使用 <code>?.</code> 来安全地读取或删除，但不能写入</strong></p><p>可选链 <code>?.</code> 不能用在赋值语句的左侧。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> user = <span class="hljs-literal">null</span>;<br><br>user?.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>; <span class="hljs-comment">// Error，不起作用</span><br><span class="hljs-comment">// 因为它在计算的是：undefined = &quot;John&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/optional-chaining#zong-jie">总结</a></h3><p>可选链 <code>?.</code> 语法有三种形式：</p><ol><li><code>obj?.prop</code> —— 如果 <code>obj</code> 存在则返回 <code>obj.prop</code>，否则返回 <code>undefined</code>。</li><li><code>obj?.[prop]</code> —— 如果 <code>obj</code> 存在则返回 <code>obj[prop]</code>，否则返回 <code>undefined</code>。</li><li><code>obj.method?.()</code> —— 如果 <code>obj.method</code> 存在则调用 <code>obj.method()</code>，否则返回 <code>undefined</code>。</li></ol><p>正如我们所看到的，这些语法形式用起来都很简单直接。<code>?.</code> 检查左边部分是否为 <code>null/undefined</code>，如果不是则继续运算。</p><p><code>?.</code> 链使我们能够安全地访问嵌套属性。</p><p>但是，我们应该谨慎地使用 <code>?.</code>，根据我们的代码逻辑，仅在当左侧部分不存在也可接受的情况下使用为宜。以保证在代码中有编程上的错误出现时，也不会对我们隐藏。</p><h2 id="三、symbol-类型"><a href="#三、symbol-类型" class="headerlink" title="三、symbol 类型"></a>三、symbol 类型</h2><p>根据规范，只有两种原始类型可以用作对象属性键：</p><ul><li>字符串类型</li><li>symbol 类型</li></ul><p>否则，如果使用另一种类型，例如数字，它会被自动转换为字符串。所以 <code>obj[1]</code> 与 <code>obj[&quot;1&quot;]</code> 相同，而 <code>obj[true]</code> 与 <code>obj[&quot;true&quot;]</code> 相同。</p><p>到目前为止，我们一直只使用字符串。</p><p>现在我们来看看 symbol 能给我们带来什么。</p><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a><a href="https://zh.javascript.info/symbol#symbol">symbol</a></h3><p>“symbol” 值表示唯一的标识符。</p><p>可以使用 <code>Symbol()</code> 来创建这种类型的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>();<br></code></pre></td></tr></table></figure><p>创建时，我们可以给 symbol 一个描述（也称为 symbol 名），这在代码调试时非常有用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// id 是描述为 &quot;id&quot; 的 symbol</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br></code></pre></td></tr></table></figure><p>symbol 保证是唯一的。即使我们创建了许多具有相同描述的 symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。</p><p>例如，这里有两个描述相同的 symbol —— 它们不相等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-keyword">let</span> id2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-title function_">alert</span>(id1 == id2); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>如果你熟悉 Ruby 或者其他有 “symbol” 的语言 —— 别被误导。JavaScript 的 symbol 是不同的。</p><p>所以，总而言之，symbol 是带有可选描述的“原始唯一值”。让我们看看我们可以在哪里使用它们。</p><p><strong>symbol 不会被自动转换为字符串</strong></p><p>JavaScript 中的大多数值都支持字符串的隐式转换。例如，我们可以 <code>alert</code> 任何值，都可以生效。symbol 比较特殊，它不会被自动转换。</p><p>例如，这个 <code>alert</code> 将会提示出错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-title function_">alert</span>(id); <span class="hljs-comment">// 类型错误：无法将 symbol 值转换为字符串。</span><br></code></pre></td></tr></table></figure><p>这是一种防止混乱的“语言保护”，因为字符串和 symbol 有本质上的不同，不应该意外地将它们转换成另一个。</p><p>如果我们真的想显示一个 symbol，我们需要在它上面调用 <code>.toString()</code>，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-title function_">alert</span>(id.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// Symbol(id)，现在它有效了</span><br></code></pre></td></tr></table></figure><p>或者获取 <code>symbol.description</code> 属性，只显示描述（description）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-title function_">alert</span>(id.<span class="hljs-property">description</span>); <span class="hljs-comment">// id</span><br></code></pre></td></tr></table></figure><h3 id="“隐藏”属性"><a href="#“隐藏”属性" class="headerlink" title="“隐藏”属性"></a><a href="https://zh.javascript.info/symbol#yin-cang-shu-xing">“隐藏”属性</a></h3><p>symbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。</p><p>例如，如果我们使用的是属于第三方代码的 <code>user</code> 对象，我们想要给它们添加一些标识符。</p><p>我们可以给它们使用 symbol 键：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-comment">// 属于另一个代码</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br>user[id] = <span class="hljs-number">1</span>;<span class="hljs-comment">//给user对象添加id属性，并且赋值为1</span><br><br><span class="hljs-title function_">alert</span>( user[id] ); <span class="hljs-comment">// 我们可以使用 symbol 作为键来访问数据</span><br></code></pre></td></tr></table></figure><p>使用 <code>Symbol(&quot;id&quot;)</code> 作为键，比起用字符串 <code>&quot;id&quot;</code> 来有什么好处呢？</p><p>由于 <code>user</code> 对象属于另一个代码库，所以向它们添加字段是不安全的，因为我们可能会影响代码库中的其他预定义行为。但 symbol 属性不会被意外访问到。第三方代码不会知道新定义的 symbol，因此将 symbol 添加到 <code>user</code> 对象是安全的。</p><p>另外，假设另一个脚本希望在 <code>user</code> 中有自己的标识符，以实现自己的目的。</p><p>那么，该脚本可以创建自己的 <code>Symbol(&quot;id&quot;)</code>，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br>user[id] = <span class="hljs-string">&quot;Their id value&quot;</span>;<br></code></pre></td></tr></table></figure><p>我们的标识符和它们的标识符之间不会有冲突，因为 symbol 总是不同的，即使它们有相同的名字。</p><p>……但如果我们处于同样的目的，使用字符串 <code>&quot;id&quot;</code> 而不是用 symbol，那么 <strong>就会</strong> 出现冲突：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><br><span class="hljs-comment">// 我们的脚本使用了 &quot;id&quot; 属性。</span><br>user.<span class="hljs-property">id</span> = <span class="hljs-string">&quot;Our id value&quot;</span>;<br><br><span class="hljs-comment">// ……另一个脚本也想将 &quot;id&quot; 用于它的目的……</span><br><br>user.<span class="hljs-property">id</span> = <span class="hljs-string">&quot;Their id value&quot;</span><br><span class="hljs-comment">// 砰！无意中被另一个脚本重写了 id！</span><br></code></pre></td></tr></table></figure><h3 id="对象字面量中的-symbol"><a href="#对象字面量中的-symbol" class="headerlink" title="对象字面量中的 symbol"></a><a href="https://zh.javascript.info/symbol#dui-xiang-zi-mian-liang-zhong-de-symbol">对象字面量中的 symbol</a></h3><p>如果我们要在对象字面量 <code>&#123;...&#125;</code> 中使用 symbol，则需要使用方括号<code>[]</code>把它括起来。</p><p>就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  [id]: <span class="hljs-number">123</span> <span class="hljs-comment">// 而不是 &quot;id&quot;：123</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这是因为我们需要变量 <code>id</code> 的值作为键，而不是字符串 “id”。</p><h3 id="symbol-在-for…in-中会被跳过"><a href="#symbol-在-for…in-中会被跳过" class="headerlink" title="symbol 在 for…in 中会被跳过"></a><a href="https://zh.javascript.info/symbol#symbol-zai-forin-zhong-hui-bei-tiao-guo">symbol 在 for…in 中会被跳过</a></h3><p>symbol 属性不参与 <code>for..in</code> 循环。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  [id]: <span class="hljs-number">123</span><br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) <span class="hljs-title function_">alert</span>(key); <span class="hljs-comment">// name, age（没有 symbol）</span><br><br><span class="hljs-comment">// 使用 symbol 任务直接访问</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Direct: &quot;</span> + user[id]); <span class="hljs-comment">// Direct: 123</span><br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">Object.keys(user)</a> 也会忽略它们。这是一般“隐藏符号属性”原则的一部分。如果另一个脚本或库遍历我们的对象，它不会意外地访问到符号属性。</p><p>相反，<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 会同时复制字符串和 symbol 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-keyword">let</span> user = &#123;<br>  [id]: <span class="hljs-number">123</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, user);<br><br><span class="hljs-title function_">alert</span>( clone[id] ); <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>这里并不矛盾，就是这样设计的。这里的想法是当我们克隆或者合并一个 object 时，通常希望 <strong>所有</strong> 属性被复制（包括像 <code>id</code> 这样的 symbol）。</p><h3 id="全局-symbol"><a href="#全局-symbol" class="headerlink" title="全局 symbol"></a><a href="https://zh.javascript.info/symbol#quan-ju-symbol">全局 symbol</a></h3><p>有时我们想要名字相同的 symbol 具有相同的实体。例如，应用程序的不同部分想要访问的 symbol <code>&quot;id&quot;</code> 指的是完全相同的属性。</p><p>为了实现这一点，这里有一个 <strong>全局 symbol 注册表</strong>。我们可以在其中创建 symbol 并在稍后访问它们，它可以确保每次访问相同名字的 symbol 时，返回的都是相同的 symbol。</p><p>要从注册表中读取（不存在则创建）symbol，请使用 <code>Symbol.for(key)</code>。</p><p>该调用会检查全局注册表，如果有一个描述为 <code>key</code> 的 symbol，则返回该 symbol，否则将创建一个新 symbol（<code>Symbol(key)</code>），并通过给定的 <code>key</code> 将其存储在注册表中。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 从全局注册表中读取</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>); <span class="hljs-comment">// 如果该 symbol 不存在，则创建它</span><br><br><span class="hljs-comment">// 再次读取（可能是在代码中的另一个位置）</span><br><span class="hljs-keyword">let</span> idAgain = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-comment">// 相同的 symbol</span><br><span class="hljs-title function_">alert</span>( id === idAgain ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>注册表内的 symbol 被称为 <strong>全局 symbol</strong>。如果我们想要一个应用程序范围内的 symbol，可以在代码中随处访问 —— 这就是它们的用途。</p><p><strong>这听起来像 Ruby</strong></p><p>在一些编程语言中，例如 Ruby，每个名字都有一个 symbol。</p><p>正如我们所看到的，在 JavaScript 中，全局 symbol 也是这样的。</p><h3 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor"></a><a href="https://zh.javascript.info/symbol#symbolkeyfor">Symbol.keyFor</a></h3><p>我们已经看到，对于全局 symbol，<code>Symbol.for(key)</code> 按名字返回一个 symbol。相反，通过全局 symbol 返回一个名字，我们可以使用 <code>Symbol.keyFor(sym)</code>：</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 通过 name 获取 symbol</span><br><span class="hljs-keyword">let</span> sym = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-keyword">let</span> sym2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-comment">// 通过 symbol 获取 name</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(sym) ); <span class="hljs-comment">// name</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(sym2) ); <span class="hljs-comment">// id</span><br></code></pre></td></tr></table></figure><p><code>Symbol.keyFor</code> 内部使用全局 symbol 注册表来查找 symbol 的键。所以它不适用于非全局 symbol。如果 symbol 不是全局的，它将无法找到它并返回 <code>undefined</code>。</p><p>也就是说，所有 symbol 都具有 <code>description</code> 属性。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> globalSymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-keyword">let</span> localSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(globalSymbol) ); <span class="hljs-comment">// name，全局 symbol</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(localSymbol) ); <span class="hljs-comment">// undefined，非全局</span><br><br><span class="hljs-title function_">alert</span>( localSymbol.<span class="hljs-property">description</span> ); <span class="hljs-comment">// name</span><br></code></pre></td></tr></table></figure><h2 id="系统-symbol"><a href="#系统-symbol" class="headerlink" title="系统 symbol"></a><a href="https://zh.javascript.info/symbol#xi-tong-symbol">系统 symbol</a></h2><p>JavaScript 内部有很多“系统” symbol，我们可以使用它们来微调对象的各个方面。</p><p>它们都被列在了 <a href="https://tc39.github.io/ecma262/#sec-well-known-symbols">众所周知的 symbol</a> 表的规范中：</p><ul><li><code>Symbol.hasInstance</code></li><li><code>Symbol.isConcatSpreadable</code></li><li><code>Symbol.iterator</code></li><li><code>Symbol.toPrimitive</code></li><li>……</li></ul><p>例如，<code>Symbol.toPrimitive</code> 允许我们将对象描述为原始值转换。我们很快就会看到它的使用。</p><p>当我们研究相应的语言特征时，我们对其他的 symbol 也会慢慢熟悉起来。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/symbol#zong-jie">总结</a></h3><p><code>symbol</code> 是唯一标识符的基本类型</p><p>symbol 是使用带有可选描述（name）的 <code>Symbol()</code> 调用创建的。</p><p>symbol 总是不同的值，即使它们有相同的名字。如果我们希望同名的 symbol 相等，那么我们应该使用全局注册表：<code>Symbol.for(key)</code> 返回（如果需要的话则创建）一个以 <code>key</code> 作为名字的全局 symbol。使用 <code>Symbol.for</code> 多次调用 <code>key</code> 相同的 symbol 时，返回的就是同一个 symbol。</p><p>symbol 有两个主要的使用场景：</p><ol><li><p>“隐藏” 对象属性。</p><p>如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 symbol 并使用它作为属性的键。symbol 属性不会出现在 <code>for..in</code> 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。</p><p>因此我们可以使用 symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。</p></li><li><p>JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 <code>Symbol.*</code> 访问。我们可以使用它们来改变一些内建行为。例如，在本教程的后面部分，我们将使用 <code>Symbol.iterator</code> 来进行 <a href="https://zh.javascript.info/iterable">迭代</a> 操作，使用 <code>Symbol.toPrimitive</code> 来设置 <a href="https://zh.javascript.info/object-toprimitive">对象原始值的转换</a> 等等。</p></li></ol><p>从技术上说，symbol 不是 100% 隐藏的。有一个内建方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols(obj)</a> 允许我们获取所有的 symbol。还有一个名为 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys">Reflect.ownKeys(obj)</a> 的方法可以返回一个对象的 <strong>所有</strong> 键，包括 symbol。但大多数库、内建方法和语法结构都没有使用这些方法。</p><h2 id="四、对象-——-原始值转换"><a href="#四、对象-——-原始值转换" class="headerlink" title="四、对象 —— 原始值转换"></a>四、对象 —— 原始值转换</h2><p>JavaScript 不允许自定义运算符对对象的处理方式。与其他一些编程语言（Ruby，C++）不同）。</p><p>在进行此类运算时，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值）。</p><p>这是一个重要的限制：因为 <code>obj1 + obj2</code>（或者其他数学运算）的结果不能是另一个对象！</p><p>例如，我们无法使用对象来表示向量或矩阵（或成就或其他），把它们相加并期望得到一个“总和”向量作为结果。这样的想法是行不通的。</p><p>因此，由于我们从技术上无法实现此类运算，所以在实际项目中不存在对对象的数学运算。如果你发现有，除了极少数例外，通常是写错了。</p><p>本章将介绍对象是如何转换为原始值的，以及如何对其进行自定义。</p><p>我们有两个目的：</p><ol><li>让我们在遇到类似的对对象进行数学运算的编程错误时，能够更加理解到底发生了什么。</li><li>也有例外，这些操作也可以是可行的。例如日期相减或比较（<code>Date</code> 对象）。我们稍后会遇到它们。</li></ol><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a><a href="https://zh.javascript.info/object-toprimitive#zhuan-huan-gui-ze">转换规则</a></h3><ol><li><code>true</code>和<code>false</code>不会转换为布尔值。只有字符串和数字转换。</li><li>数字转换发生在对象相减或应用数学函数时。例如，<code>Date</code> 对象（将在 <a href="https://zh.javascript.info/date">日期和时间</a> 一章中介绍）可以相减，<code>date1 - date2</code> 的结果是两个日期之间的差值。</li><li>至于字符串转换 —— 通常发生在我们像 <code>alert(obj)</code> 这样输出一个对象和类似的上下文中。</li></ol><p>我们可以使用特殊的对象方法，自己实现字符串和数字的转换。</p><p>现在让我们一起探究技术细节，因为这是深入讨论该主题的唯一方式。</p><h3 id="hint"><a href="#hint" class="headerlink" title="hint"></a><a href="https://zh.javascript.info/object-toprimitive#hint">hint</a></h3><p>JavaScript 是如何决定应用哪种转换的？</p><p>类型转换在各种情况下有三种变体。它们被称为 “hint”，在 <a href="https://tc39.github.io/ecma262/#sec-toprimitive">规范</a> 所述：</p><ul><li><p><code>&quot;string&quot;</code>对象到字符串的转换</p></li><li><p><code>&quot;number&quot;</code>对象到数字的转换</p></li><li><p><code>&quot;default&quot;</code>在少数情况下发生，当运算符“不确定”期望值的类型时。</p></li></ul><p>上面这些规则看起来比较复杂，但在实践中其实挺简单的。</p><p>除了一种情况（<code>Date</code> 对象，我们稍后会讲到）之外，所有内建对象都以和 <code>&quot;number&quot;</code> 相同的方式实现 <code>&quot;default&quot;</code> 转换。我们也可以这样做。</p><p><strong>为了进行转换，JavaScript 尝试查找并调用三个对象方法：</strong></p><ol><li><code>obj[Symbol.toPrimitive](hint)</code> —— 带有 symbol 键 <code>Symbol.toPrimitive</code>（系统 symbol）的方法，如果这个方法存在的话，</li><li>否则，如果 hint 是 <code>&quot;string&quot;</code> —— 尝试调用 <code>obj.toString()</code> 或 <code>obj.valueOf()</code>。</li><li>否则，如果 hint 是 <code>&quot;number&quot;</code> 或 <code>&quot;default&quot;</code> —— 尝试调用 <code>obj.valueOf()</code> 或 <code>obj.toString()</code>。</li></ol><h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a><a href="https://zh.javascript.info/object-toprimitive#symboltoprimitive">Symbol.toPrimitive</a></h3><p>我们从第一个方法开始。有一个名为 <code>Symbol.toPrimitive</code> 的内建 symbol，它被用来给转换方法命名，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params">hint</span>) &#123;<br>  <span class="hljs-comment">// 这里是将此对象转换为原始值的代码</span><br>  <span class="hljs-comment">// 它必须返回一个原始值</span><br>  <span class="hljs-comment">// hint = &quot;string&quot;、&quot;number&quot; 或 &quot;default&quot; 中的一个</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>Symbol.toPrimitive</code> 方法存在，则它会被用于所有 hint，无需更多其他方法。</p><p>例如，这里 <code>user</code> 对象实现了它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">money</span>: <span class="hljs-number">1000</span>,<br><br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>](hint) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`hint: <span class="hljs-subst">$&#123;hint&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> hint == <span class="hljs-string">&quot;string&quot;</span> ? <span class="hljs-string">`&#123;name: &quot;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>&quot;&#125;`</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-property">money</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 转换演示：</span><br><span class="hljs-title function_">alert</span>(user); <span class="hljs-comment">// hint: string -&gt; &#123;name: &quot;John&quot;&#125;</span><br><span class="hljs-title function_">alert</span>(+user); <span class="hljs-comment">// hint: number -&gt; 1000</span><br><span class="hljs-title function_">alert</span>(user + <span class="hljs-number">500</span>); <span class="hljs-comment">// hint: default -&gt; 1500</span><br></code></pre></td></tr></table></figure><p>从代码中我们可以看到，根据转换的不同，<code>user</code> 变成一个自描述字符串或者一个金额。<code>user[Symbol.toPrimitive]</code> 方法处理了所有的转换情况。</p><h3 id="toString-valueOf"><a href="#toString-valueOf" class="headerlink" title="toString/valueOf"></a><a href="https://zh.javascript.info/object-toprimitive#tostringvalueof">toString/valueOf</a></h3><p>如果没有 <code>Symbol.toPrimitive</code>，那么 JavaScript 将尝试寻找 <code>toString</code> 和 <code>valueOf</code> 方法：</p><ul><li>对于 <code>&quot;string&quot;</code> hint：调用 <code>toString</code> 方法，如果它不存在，则调用 <code>valueOf</code> 方法（因此，对于字符串转换，优先调用 <code>toString</code>）。</li><li>对于其他 hint：调用 <code>valueOf</code> 方法，如果它不存在，则调用 <code>toString</code> 方法（因此，对于数学运算，优先调用 <code>valueOf</code> 方法）。</li></ul><p><code>toString</code> 和 <code>valueOf</code> 方法很早己有了。它们不是 symbol（那时候还没有 symbol 这个概念），而是“常规的”字符串命名的方法。它们提供了一种可选的“老派”的实现转换的方法。</p><p>这些方法必须返回一个原始值。如果 <code>toString</code> 或 <code>valueOf</code> 返回了一个对象，那么返回值会被忽略（和这里没有方法的时候相同）。</p><p>默认情况下，普通对象具有 <code>toString</code> 和 <code>valueOf</code> 方法：</p><ul><li><code>toString</code> 方法返回一个字符串 <code>&quot;[object Object]&quot;</code>。</li><li><code>valueOf</code> 方法返回对象自身。</li></ul><p>下面是一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>&#125;;<br><br><span class="hljs-title function_">alert</span>(user); <span class="hljs-comment">// [object Object]</span><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-title function_">valueOf</span>() === user); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>所以，如果我们尝试将一个对象当做字符串来使用，例如在 <code>alert</code> 中，那么在默认情况下我们会看到 <code>[object Object]</code>。</p><p>让我们实现一下这些方法来自定义转换。</p><p>例如，这里的 <code>user</code> 执行和前面提到的那个 <code>user</code> 一样的操作，使用 <code>toString</code> 和 <code>valueOf</code> 的组合（而不是 <code>Symbol.toPrimitive</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">money</span>: <span class="hljs-number">1000</span>,<br><br>  <span class="hljs-comment">// 对于 hint=&quot;string&quot;</span><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`&#123;name: &quot;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>&quot;&#125;`</span>;<br>  &#125;,<br><br>  <span class="hljs-comment">// 对于 hint=&quot;number&quot; 或 &quot;default&quot;</span><br>  <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">money</span>;<br>  &#125;<br><br>&#125;;<br><br><span class="hljs-title function_">alert</span>(user); <span class="hljs-comment">// toString -&gt; &#123;name: &quot;John&quot;&#125;</span><br><span class="hljs-title function_">alert</span>(+user); <span class="hljs-comment">// valueOf -&gt; 1000</span><br><span class="hljs-title function_">alert</span>(user + <span class="hljs-number">500</span>); <span class="hljs-comment">// valueOf -&gt; 1500</span><br></code></pre></td></tr></table></figure><p>我们可以看到，执行的动作和前面使用 <code>Symbol.toPrimitive</code> 的那个例子相同。</p><p>通常我们希望有一个“全能”的地方来处理所有原始转换。在这种情况下，我们可以只实现 <code>toString</code>，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-title function_">alert</span>(user); <span class="hljs-comment">// toString -&gt; John</span><br><span class="hljs-title function_">alert</span>(user + <span class="hljs-number">500</span>); <span class="hljs-comment">// toString -&gt; John500</span><br></code></pre></td></tr></table></figure><p>如果没有 <code>Symbol.toPrimitive</code> 和 <code>valueOf</code>，<code>toString</code> 将处理所有原始转换。</p><h3 id="转换可以返回任何原始类型"><a href="#转换可以返回任何原始类型" class="headerlink" title="转换可以返回任何原始类型"></a><a href="https://zh.javascript.info/object-toprimitive#zhuan-huan-ke-yi-fan-hui-ren-he-yuan-shi-lei-xing">转换可以返回任何原始类型</a></h3><p>关于所有原始转换方法，有一个重要的点需要知道，就是它们不一定会返回 “hint” 的原始值。</p><p>没有限制 <code>toString()</code> 是否返回字符串，或 <code>Symbol.toPrimitive</code> 方法是否为 <code>&quot;number&quot;</code> hint 返回数字。</p><p>唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。</p><p><strong>历史原因</strong></p><p>由于历史原因，如果 <code>toString</code> 或 <code>valueOf</code> 返回一个对象，则不会出现 error，但是这种值会被忽略（就像这种方法根本不存在）。这是因为在 JavaScript 语言发展初期，没有很好的 “error” 的概念。</p><p>相反，<code>Symbol.toPrimitive</code> 更严格，它 <strong>必须</strong> 返回一个原始值，否则就会出现 error。</p><h3 id="进一步的转换"><a href="#进一步的转换" class="headerlink" title="进一步的转换"></a><a href="https://zh.javascript.info/object-toprimitive#jin-yi-bu-de-zhuan-huan">进一步的转换</a></h3><p>我们已经知道，许多运算符和函数执行类型转换，例如乘法 <code>*</code> 将操作数转换为数字。</p><p>如果我们将对象作为参数传递，则会出现两个运算阶段：</p><ol><li>对象被转换为原始值（通过前面我们描述的规则）。</li><li>如果还需要进一步计算，则生成的原始值会被进一步转换。</li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-comment">// toString 在没有其他方法的情况下处理所有转换</span><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-title function_">alert</span>(obj * <span class="hljs-number">2</span>); <span class="hljs-comment">// 4，对象被转换为原始值字符串 &quot;2&quot;，之后它被乘法转换为数字 2。</span><br></code></pre></td></tr></table></figure><ol><li>乘法 <code>obj * 2</code> 首先将对象转换为原始值（字符串 “2”）。</li><li>之后 <code>&quot;2&quot; * 2</code> 变为 <code>2 * 2</code>（字符串被转换为数字）。</li></ol><p>二元加法在同样的情况下会将其连接成字符串，因为它更愿意接受字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-title function_">alert</span>(obj + <span class="hljs-number">2</span>); <span class="hljs-comment">// 22（&quot;2&quot; + 2）被转换为原始值字符串 =&gt; 级联</span><br></code></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/object-toprimitive#zong-jie">总结</a></h3><p>对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。</p><p>这里有三种类型（hint）：</p><ul><li><code>&quot;string&quot;</code>（对于 <code>alert</code> 和其他需要字符串的操作）</li><li><code>&quot;number&quot;</code>（对于数学运算）</li><li><code>&quot;default&quot;</code>（少数运算符，通常对象以和 <code>&quot;number&quot;</code> 相同的方式实现 <code>&quot;default&quot;</code> 转换）</li></ul><p>规范明确描述了哪个运算符使用哪个 hint。</p><p>转换算法是：</p><ol><li><p>调用 <code>obj[Symbol.toPrimitive](hint)</code> 如果这个方法存在，</p></li><li><p>否则，如果 hint 是</p></li></ol>   <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;string&quot;</span><br></code></pre></td></tr></table></figure><ul><li>尝试调用 <code>obj.toString()</code> 或 <code>obj.valueOf()</code>，无论哪个存在。</li></ul><ol><li>否则，如果 hint 是</li></ol>   <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;number&quot;</span><br></code></pre></td></tr></table></figure><p>   或者</p>   <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;default&quot;</span><br></code></pre></td></tr></table></figure><ul><li>尝试调用 <code>obj.valueOf()</code> 或 <code>obj.toString()</code>，无论哪个存在。</li></ul><p>所有这些方法都必须返回一个原始值才能工作（如果已定义）。</p><p>在实际使用中，通常只实现 <code>obj.toString()</code> 作为字符串转换的“全能”方法就足够了，该方法应该返回对象的“人类可读”表示，用于日志记录或调试。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 04</title>
    <link href="/2022/08/12/JavaScript-04/"/>
    <url>/2022/08/12/JavaScript-04/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="JavaScript-基础-第四天"><a href="#JavaScript-基础-第四天" class="headerlink" title="JavaScript 基础 - 第四天"></a>JavaScript 基础 - 第四天</h1><h2 id="一、垃圾回收"><a href="#一、垃圾回收" class="headerlink" title="一、垃圾回收"></a>一、垃圾回收</h2><p>对于开发者来说，JavaScript 的内存管理是自动的、无形的。我们创建的原始值、对象、函数……这一切都会占用内存。</p><p>当我们不再需要某个东西时会发生什么？JavaScript 引擎如何发现它并清理它？</p><h3 id="可达性（Reachability）"><a href="#可达性（Reachability）" class="headerlink" title="可达性（Reachability）"></a><a href="https://zh.javascript.info/garbage-collection#ke-da-xing-reachability">可达性（Reachability）</a></h3><p>JavaScript 中主要的内存管理概念是 <strong>可达性</strong>。</p><p>简而言之，“可达值“是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。</p><p>如果一个值可以通过引用链从根访问任何其他值，则认为该值是可达的，这些值被称作 <strong>根（roots）</strong>。</p><p>比方说，如果全局变量中有一个对象，并且该对象有一个属性引用了另一个对象，则 <strong>该</strong> 对象被认为是可达的。而且它引用的内容也是可达的。下面是详细的例子。</p><p>在 JavaScript 引擎中有一个被称作 <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science">垃圾回收器</a>) 的东西在后台执行。它监控着所有对象的状态，并删除掉那些已经不可达的。</p><p>这里是一个最简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// user 具有对这个对象的引用</span><br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的箭头描述了一个对象引用。全局变量 <code>&quot;user&quot;</code> 引用了对象 <code>&#123;name：&quot;John&quot;&#125;</code>（为简洁起见，我们称它为 John）。John 的 <code>&quot;name&quot;</code> 属性存储一个原始值，所以它被写在对象内部。</p><p>如果 <code>user</code> 的值被重写了，这个引用就没了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">user = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122129707.png" alt="image-20220812212903662" style="zoom:50%;"></p><p>现在 John 变成不可达的了。因为没有引用了，就不能访问到它了。垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。</p><h3 id="两个引用"><a href="#两个引用" class="headerlink" title="两个引用"></a>两个引用</h3><p>现在让我们想象下，我们把 <code>user</code> 的引用复制给 <code>admin</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// user 具有对这个对象的引用</span><br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> admin = user;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122130890.png" alt="image-20220812213046846" style="zoom:50%;"></p><p>现在如果执行刚刚的那个操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">user = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>user的引用箭头会指向一个空对象，然后原来的John对象仍然可以被 <code>admin</code> 这个全局变量访问到，因此它必须被保留在内存中。如果我们又重写了 <code>admin</code>，对象就会被删除。</p><h3 id="相互关联的对象"><a href="#相互关联的对象" class="headerlink" title="相互关联的对象"></a><a href="https://zh.javascript.info/garbage-collection#xiang-hu-guan-lian-de-dui-xiang">相互关联的对象</a></h3><p>现在来看一个更复杂的例子。这是个家庭：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">marry</span>(<span class="hljs-params">man, woman</span>) &#123;<br>  woman.<span class="hljs-property">husband</span> = man;<br>  man.<span class="hljs-property">wife</span> = woman;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">father</span>: man,<br>    <span class="hljs-attr">mother</span>: woman<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> family = <span class="hljs-title function_">marry</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;, &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Ann&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><code>marry</code> 函数通过让两个对象相互引用使它们“结婚”了，并返回了一个包含这两个对象的新对象。</p><p>由此产生的内存结构：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122208797.png" alt="image-20220812220856765" style="zoom:67%;"></p><p>到目前为止，所有对象都是可达的。</p><p>现在让我们移除两个引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> family.<span class="hljs-property">father</span>;<br><span class="hljs-keyword">delete</span> family.<span class="hljs-property">mother</span>.<span class="hljs-property">husband</span>;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122211563.png" alt="image-20220812221147533" style="zoom:67%;"></p><p>仅删除这两个引用中的一个是不够的，因为所有的对象仍然都是可达的。</p><p>但是，如果我们把这两个都删除，那么我们可以看到再也没有对 John 的引用了：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122212756.png" alt="image-20220812221239727" style="zoom:67%;"></p><p>对外引用不重要，只有传入引用才可以使对象可达。所以，John 现在是不可达的，并且将被从内存中删除，同时 John 的所有数据也将变得不可达。</p><h3 id="无法到达的岛屿"><a href="#无法到达的岛屿" class="headerlink" title="无法到达的岛屿"></a><a href="https://zh.javascript.info/garbage-collection#wu-fa-dao-da-de-dao-yu">无法到达的岛屿</a></h3><p>几个对象相互引用，但外部没有对其任意对象的引用，这些对象也可能是不可达的，并被从内存中删除。</p><p>源对象与上面相同。然后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">family = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>内存内部状态将变成：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122214946.png" alt="image-20220812221424918" style="zoom: 50%;"></p><p>这个例子展示了可达性概念的重要性。</p><p>显而易见，John 和 Ann 仍然连着，都有传入的引用。但是，这样还不够。</p><p>前面说的 <code>&quot;family&quot;</code> 对象已经不再与根相连，相当于在family引用这一步就把下面的全删了，没有了外部对其的引用，所以它变成了一座“孤岛”，并且将被从内存中删除。</p><h3 id="内部算法"><a href="#内部算法" class="headerlink" title="内部算法"></a><a href="https://zh.javascript.info/garbage-collection#nei-bu-suan-fa">内部算法</a></h3><p>垃圾回收的基本算法被称为 “mark-and-sweep”。</p><p>定期执行以下“垃圾回收”步骤：</p><ul><li>垃圾收集器找到所有的根，并“标记”（记住）它们。</li><li>然后它遍历并“标记”来自它们的所有引用。</li><li>然后它遍历标记的对象并标记 <strong>它们的</strong> 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。</li><li>如此操作，直到所有可达的（从根部）引用都被访问到。</li><li>没有被标记的对象都会被删除。</li></ul><p>例如，使我们的对象有如下的结构：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122217549.png" alt="image-20220812221744508" style="zoom:50%;"></p><p>我们可以清楚地看到右侧有一个“无法到达的岛屿”。现在我们来看看“标记和清除”垃圾收集器如何处理它。</p><p>第一步标记所有的根：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122225381.png" alt="image-20220812222535340" style="zoom:50%;"></p><p>然后，我们跟随它们的引用标记它们所引用的对象：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122226193.png" alt="image-20220812222618154" style="zoom:50%;"></p><p>……如果还有引用的话，继续标记：</p><p>现在，无法通过这个过程访问到的对象被认为是不可达的，并且会被删除。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122226826.png" alt="image-20220812222656786" style="zoom:50%;"></p><p>这是垃圾收集工作的概念。JavaScript 引擎做了许多优化，使垃圾回收运行速度更快，并且不会对代码执行引入任何延迟。</p><p>一些优化建议：</p><ul><li><strong>分代收集（Generational collection）</strong>—— 对象被分成两组：“新的”和“旧的”。在典型的代码中，许多对象的生命周期都很短：它们出现、完成它们的工作并很快死去，因此在这种情况下跟踪新对象并将其从内存中清除是有意义的。那些长期存活的对象会变得“老旧”，并且被检查的频次也会降低。</li><li><strong>增量收集（Incremental collection）</strong>—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。<u>因此，引擎将现有的整个对象集拆分为多个部分，然后将这些部分逐一清除。</u>这样就会有很多小型的垃圾收集，而不是一个大型的。这需要它们之间有额外的标记来追踪变化，但是这样会带来许多微小的延迟而不是一个大的延迟。</li><li><strong>闲时收集（Idle-time collection）</strong>—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</li></ul><p>还有其他垃圾回收算法的优化和风格。尽管我想在这里描述它们，但我必须打住了，因为不同的引擎会有不同的调整和技巧。而且，更重要的是，随着引擎的发展，情况会发生变化，所以在没有真实需求的时候，“提前”学习这些内容是不值得的。当然，除非你纯粹是出于兴趣。我在下面给你提供了一些相关链接。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/garbage-collection#zong-jie">总结</a></h3><p>主要需要掌握的内容：</p><ul><li>垃圾回收是自动完成的，我们不能强制执行或是阻止执行。</li><li>当对象是可达状态时，它一定是存在于内存中的。</li><li>被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达，正如我们在上面的例子中看到的那样。</li></ul><h2 id="二、对象方法、”this”"><a href="#二、对象方法、”this”" class="headerlink" title="二、对象方法、”this”"></a>二、对象方法、”this”</h2><p>通常创建对象来表示真实世界中的实体，如用户和订单等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>并且，在现实世界中，用户可以进行 <strong>操作</strong>：如从购物车中挑选某物、登录和注销等。</p><p>在 JavaScript 中，行为（action）由属性中的函数来表示。</p><h3 id="方法示例"><a href="#方法示例" class="headerlink" title="方法示例"></a><a href="https://zh.javascript.info/object-methods#fang-fa-shi-li">方法示例</a></h3><p>语法1：使用函数表达式创建一个函数，并将其指定给对象的 <code>user.sayHi</code> 属性。</p><p>随后我们像这样 <code>user.sayHi()</code> 调用它。用户现在可以说话了！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br>user.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;;<br><br>user.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hello!</span><br></code></pre></td></tr></table></figure><p>语法2：使用预先声明的函数作为方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// 首先，声明函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 然后将其作为一个方法添加</span><br>user.<span class="hljs-property">sayHi</span> = sayHi;<br><br>user.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hello!</span><br></code></pre></td></tr></table></figure><p><strong>面向对象编程</strong></p><p>当我们在代码中用对象表示实体时，就是所谓的 <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">面向对象编程</a>，简称为 “OOP”。</p><p><strong>语法3：方法简写，最为常用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这些对象作用一样</span><br><br>user = &#123;<br>  <span class="hljs-attr">sayHi</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 方法简写看起来更好，对吧？</span><br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 与 &quot;sayHi: function()&#123;...&#125;&quot; 一样</span><br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>  &#125;，<br>&#125;;<br></code></pre></td></tr></table></figure><p>如上所示，我们可以省略 <code>&quot;function&quot;</code>，只写 <code>sayHi()</code>。</p><p>在几乎所有的情况下，更短的语法是首选的。</p><h3 id="方法中的-“this”"><a href="#方法中的-“this”" class="headerlink" title="方法中的 “this”"></a><a href="https://zh.javascript.info/object-methods#fang-fa-zhong-de-this">方法中的 “this”</a></h3><p><strong>为了访问调用该方法的对象，方法中可以使用 <code>this</code> 关键字。</strong></p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br><br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// &quot;this&quot; 指的是“当前的对象”</span><br>    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br><br>&#125;;<br><br>user.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure><p>在这里 <code>user.sayHi()</code> 执行过程中，<code>this</code> 的值是 <code>user</code>。</p><p>技术上讲，也可以在不使用 <code>this</code> 的情况下，通过外部变量名来引用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br><br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;user&quot; 替代 &quot;this&quot;</span><br>  &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>但这样的代码是不可靠的。如果我们决定将 <code>user</code> 复制给另一个变量，例如 <code>admin = user</code>，并赋另外的值给 <code>user</code>，那么它将访问到错误的对象。</p><p>下面这个示例证实了这一点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br><br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>( user.<span class="hljs-property">name</span> ); <span class="hljs-comment">// 导致错误</span><br>  &#125;<br><br>&#125;;<br><br><br><span class="hljs-keyword">let</span> admin = user;<br>user = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 重写让其更明显</span><br><br>admin.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// TypeError: Cannot read property &#x27;name&#x27; of null</span><br></code></pre></td></tr></table></figure><p>如果我们在 <code>alert</code> 中以 <code>this.name</code> 替换 <code>user.name</code>，那么代码就会正常运行。</p><h3 id="“this”-不受限制"><a href="#“this”-不受限制" class="headerlink" title="“this” 不受限制"></a><a href="https://zh.javascript.info/object-methods#this-bu-shou-xian-zhi">“this” 不受限制</a></h3><p>在 JavaScript 中，<code>this</code> 关键字与其他大多数编程语言中的不同。JavaScript 中的 <code>this</code> 可以用于任何函数，即使它不是对象的方法。</p><p>下面这样的代码没有语法错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>&#125;<br></code></pre></td></tr></table></figure><p><code>this</code> 的值是在代码运行时计算出来的，它取决于代码上下文。</p><p>例如，这里相同的函数被分配给两个不同的对象，在调用中有着不同的 “this” 值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> admin = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Admin&quot;</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>&#125;<br><br><span class="hljs-comment">// 在两个对象中使用相同的函数</span><br>user.<span class="hljs-property">f</span> = sayHi;<br>admin.<span class="hljs-property">f</span> = sayHi;<br><br><span class="hljs-comment">// 这两个调用有不同的 this 值</span><br><span class="hljs-comment">// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象</span><br>user.<span class="hljs-title function_">f</span>(); <span class="hljs-comment">// John（this == user）</span><br>admin.<span class="hljs-title function_">f</span>(); <span class="hljs-comment">// Admin（this == admin）</span><br><br>admin[<span class="hljs-string">&#x27;f&#x27;</span>](); <span class="hljs-comment">// Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）</span><br></code></pre></td></tr></table></figure><p><strong>在没有对象的情况下调用：<code>this == undefined</code></strong></p><p>我们甚至可以在没有对象的情况下调用函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>在这种情况下，严格模式下的 <code>this</code> 值为 <code>undefined</code>。如果我们尝试访问 <code>this.name</code>，将会报错。</p><p>在非严格模式的情况下，<code>this</code> 将会是 <strong>全局对象</strong>（浏览器中的 <code>window</code>，我们稍后会在 <a href="https://zh.javascript.info/global-object">全局对象</a> 一章中学习它）。这是一个历史行为，<code>&quot;use strict&quot;</code> 已经将其修复了。</p><p><strong>解除 <code>this</code> 绑定的后果</strong></p><p>如果你经常使用其他的编程语言，那么你可能已经习惯了“绑定 <code>this</code>”的概念，即在对象中定义的方法总是有指向该对象的 <code>this</code>。</p><p>在 JavaScript 中，<code>this</code> 是“自由”的，它的值是在调用时计算出来的，它的值并不取决于方法声明的位置，而是取决于在“点符号前”的是什么对象。</p><p>在运行时对 <code>this</code> 求值的这个概念既有优点也有缺点。一方面，函数可以被重用于不同的对象。另一方面，更大的灵活性造成了更大的出错的可能。</p><p>这里我们的立场并不是要评判编程语言的这个设计是好是坏。而是要了解怎样使用它，如何趋利避害。</p><h3 id="箭头函数没有自己的-“this”"><a href="#箭头函数没有自己的-“this”" class="headerlink" title="箭头函数没有自己的 “this”"></a><a href="https://zh.javascript.info/object-methods#jian-tou-han-shu-mei-you-zi-ji-de-this">箭头函数没有自己的 “this”</a></h3><p>箭头函数有些特别：它们没有自己的 <code>this</code>。如果我们在这样的函数中引用 <code>this</code>，<code>this</code> 值取决于外部“正常的”函数。</p><p>举个例子，这里的 <code>arrow()</code> 使用的 <code>this</code> 来自于外部的 <code>user.sayHi()</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Ilya&quot;</span>,<br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">arrow</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>);<br>    <span class="hljs-title function_">arrow</span>();<br>  &#125;<br>&#125;;<br><br>user.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Ilya</span><br></code></pre></td></tr></table></figure><p>这是箭头函数的一个特性，当我们并不想要一个独立的 <code>this</code>，反而想从外部上下文中获取时，它很有用。在后面的 <a href="https://zh.javascript.info/arrow-functions">深入理解箭头函数</a> 一章中，我们将深入介绍箭头函数。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/object-methods#zong-jie">总结</a></h3><ul><li>存储在对象属性中的函数被称为“方法”。</li><li>方法允许对象进行像 <code>object.doSomething()</code> 这样的“操作”。</li><li>方法可以将对象引用为 <code>this</code>。</li></ul><p><code>this</code> 的值是在程序运行时得到的。</p><ul><li>一个函数在声明时，可能就使用了 <code>this</code>，但是这个 <code>this</code> 只有在函数被调用时才会有值。</li><li>可以在对象之间复制函数。</li><li>以“方法”的语法调用函数时：<code>object.method()</code>，调用过程中的 <code>this</code> 值是 <code>object</code>。</li></ul><p>请注意箭头函数有些特别：它们没有 <code>this</code>。在箭头函数内部访问到的 <code>this</code> 都是从外部获取的。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a><a href="https://zh.javascript.info/object-methods#tasks">任务</a></h2><h3 id="创建一个计算器"><a href="#创建一个计算器" class="headerlink" title="创建一个计算器"></a><a href="https://zh.javascript.info/object-methods#chuang-jian-yi-ge-ji-suan-qi">创建一个计算器</a></h3><p>重要程度: 5</p><p>创建一个有三个方法的 <code>calculator</code> 对象：</p><ul><li><code>read()</code> 提示输入两个值，并将其保存为对象属性，属性名分别为 <code>a</code> 和 <code>b</code>。</li><li><code>sum()</code> 返回保存的值的和。</li><li><code>mul()</code> 将保存的值相乘并返回计算结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> calculator = &#123;<br>  <span class="hljs-comment">// ……你的代码……</span><br>&#125;;<br><br>calculator.<span class="hljs-title function_">read</span>();<br><span class="hljs-title function_">alert</span>( calculator.<span class="hljs-title function_">sum</span>() );<br><span class="hljs-title function_">alert</span>( calculator.<span class="hljs-title function_">mul</span>() );<br></code></pre></td></tr></table></figure><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> calculator = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">b</span>:<span class="hljs-literal">null</span>,<br>    <span class="hljs-title function_">read</span>(<span class="hljs-params"></span>)&#123;<br>       a=<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入第一个值&quot;</span>) <br>       b=<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入第二个值&quot;</span>) <br>    &#125;,<br>    <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> -(-a-b)<span class="hljs-comment">//为了输出数值对象</span><br>    &#125;,<br>    <span class="hljs-title function_">mul</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> a*b<br>    &#125;,<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params">obj</span>)&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> calculator)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-title function_">alert</span>(<span class="hljs-title function_">isEmpty</span>(calculator))<br>calculator.<span class="hljs-title function_">read</span>();<br><span class="hljs-title function_">alert</span>( calculator.<span class="hljs-title function_">sum</span>() );<br><span class="hljs-title function_">alert</span>( calculator.<span class="hljs-title function_">mul</span>() );<br></code></pre></td></tr></table></figure><h3 id="链式（调用）"><a href="#链式（调用）" class="headerlink" title="链式（调用）"></a><a href="https://zh.javascript.info/object-methods#lian-shi-tiao-yong">链式（调用）</a></h3><p>重要程度: 2</p><p>有一个可以上下移动的 <code>ladder</code> 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ladder = &#123;<br>  <span class="hljs-attr">step</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-title function_">up</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">step</span>++;<br>  &#125;,<br>  <span class="hljs-title function_">down</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">step</span>--;<br>  &#125;,<br>  <span class="hljs-attr">showStep</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 显示当前的 step</span><br>    <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">step</span> );<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>现在，如果我们要按顺序执行几次调用，可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ladder.<span class="hljs-title function_">up</span>();<br>ladder.<span class="hljs-title function_">up</span>();<br>ladder.<span class="hljs-title function_">down</span>();<br>ladder.<span class="hljs-title function_">showStep</span>(); <span class="hljs-comment">// 1</span><br>ladder.<span class="hljs-title function_">down</span>();<br>ladder.<span class="hljs-title function_">showStep</span>(); <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>修改 <code>up</code>，<code>down</code> 和 <code>showStep</code> 的代码，让调用可以链接，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ladder.<span class="hljs-title function_">up</span>().<span class="hljs-title function_">up</span>().<span class="hljs-title function_">down</span>().<span class="hljs-title function_">showStep</span>().<span class="hljs-title function_">down</span>().<span class="hljs-title function_">showStep</span>(); <span class="hljs-comment">// 展示 1，然后 0</span><br></code></pre></td></tr></table></figure><p>这种方法在 JavaScript 库中被广泛使用。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>润学笔记</title>
    <link href="/2022/08/09/%E6%B6%A601/"/>
    <url>/2022/08/09/%E6%B6%A601/</url>
    
    <content type="html"><![CDATA[<hr>]]></content>
    
    
    
    <tags>
      
      <tag>Run</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 03</title>
    <link href="/2022/08/06/JavaScript-03/"/>
    <url>/2022/08/06/JavaScript-03/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="JavaScript-基础-第三天"><a href="#JavaScript-基础-第三天" class="headerlink" title="JavaScript 基础 - 第三天"></a>JavaScript 基础 - 第三天</h1><h2 id="一、对象"><a href="#一、对象" class="headerlink" title="一、对象"></a>一、对象</h2><p>JavaScript 中有八种数据类型。</p><p>有七种是原始类型，它们的值只包含一种类型（字符串，数字或者其他）。相反，对象则用来存储键值对或更复杂的实体。</p><p>我们可以通过使用带有可选 <strong>属性列表</strong> 的花括号 <code>&#123;…&#125;</code> 来创建对象。一个属性就是一个键值对（“key: value”），其中键（<code>key</code>）是一个字符串（也叫做属性名），值（<code>value</code>）可以是任何值。</p><p>我们可以把对象想象成一个带有签名文件的文件柜。每一条数据都基于键（<code>key</code>）存储在文件中。这样我们就可以很容易根据文件名（也就是“键”）查找文件或添加/删除文件了。</p><p>我们可以用下面两种语法中的任一种来创建一个空的对象（“空柜子”）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// “构造函数” 的语法</span><br><span class="hljs-keyword">let</span> user = &#123;&#125;;  <span class="hljs-comment">// “字面量” 的语法</span><br></code></pre></td></tr></table></figure><p>通常，我们用花括号。这种方式我们叫做 <strong>字面量</strong>。</p><h3 id="文本和属性"><a href="#文本和属性" class="headerlink" title="文本和属性"></a><a href="https://zh.javascript.info/object#wen-ben-he-shu-xing">文本和属性</a></h3><p>我们可以在创建对象的时候，立即将一些属性以键值对的形式放到 <code>&#123;...&#125;</code> 中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;     <span class="hljs-comment">// 一个对象</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,  <span class="hljs-comment">// 键 &quot;name&quot;，值 &quot;John&quot;</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>        <span class="hljs-comment">// 键 &quot;age&quot;，值 30</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>属性有键（或者也可以叫做“名字”或“标识符”），位于冒号 <code>&quot;:&quot;</code> 的前面，值在冒号的右边。</p><p>在 <code>user</code> 对象中，有两个属性：</p><ol><li>第一个的键是 <code>&quot;name&quot;</code>，值是 <code>&quot;John&quot;</code>。</li><li>第二个的键是 <code>&quot;age&quot;</code>，值是 <code>30</code>。</li></ol><p>生成的 <code>user</code> 对象可以被想象为一个放置着两个标记有 “name” 和 “age” 的文件的柜子。</p><p>我们可以随时添加、删除和读取文件。</p><p>可以使用点符号访问属性值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 读取文件的属性：</span><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">name</span> ); <span class="hljs-comment">// John</span><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">age</span> ); <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure><p>属性的值可以是任意类型，让我们加个布尔类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">user.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>我们可以用 <code>delete</code> 操作符移除属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> user.<span class="hljs-property">age</span>;<br></code></pre></td></tr></table></figure><p>我们也可以用多字词语来作为属性名，但必须给它们加上引号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-string">&quot;likes birds&quot;</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 多词属性名必须加引号</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>列表中的最后一个属性应以逗号结尾：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>这叫做尾随（trailing）或悬挂（hanging）逗号。这样便于我们添加、删除和移动属性，因为所有的行都是相似的。</p><h3 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a><a href="https://zh.javascript.info/object#fang-kuo-hao">方括号</a></h3><p>对于多词属性，点操作就不能用了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这将提示有语法错误</span><br>user.<span class="hljs-property">likes</span> birds = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>JavaScript 理解不了。它认为我们在处理 <code>user.likes</code>，然后在遇到意外的 <code>birds</code> 时给出了语法错误。</p><p>有另一种方法，就是使用方括号，可用于任何字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;;<br><br><span class="hljs-comment">// 设置</span><br>user[<span class="hljs-string">&quot;likes birds&quot;</span>] = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 读取</span><br><span class="hljs-title function_">alert</span>(user[<span class="hljs-string">&quot;likes birds&quot;</span>]); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-keyword">delete</span> user[<span class="hljs-string">&quot;likes birds&quot;</span>];<br></code></pre></td></tr></table></figure><p>现在一切都可行了。<u>请注意方括号中的字符串要放在引号中，单引号或双引号都可以。</u></p><p>方括号同样提供了一种可以通过任意表达式来获取属性名的方式</p><p>在这里，变量 <code>key</code> 可以是程序运行时计算得到的，也可以是根据用户的输入得到的。然后我们可以用它来访问属性。这给了我们很大的灵活性。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//为name属性起一个变量名为key，再通过变量名获取属性值</span><br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><span class="hljs-comment">//第二个参数为初始值</span><br><span class="hljs-comment">//let key = prompt(&quot;What do you want to know about the user?&quot;, &quot;name&quot;);</span><br><br><span class="hljs-keyword">let</span> key = <span class="hljs-string">&#x27;name&#x27;</span><br><br><span class="hljs-comment">// 访问变量</span><br><span class="hljs-title function_">alert</span>( user[key] ); <span class="hljs-comment">// John（如果输入 &quot;name&quot;）</span><br></code></pre></td></tr></table></figure><p>点符号不能以类似的方式使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;name&quot;</span>;<br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">key</span> ) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a><a href="https://zh.javascript.info/object#ji-suan-shu-xing">计算属性</a></h3><p>当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 <strong>计算属性</strong>。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//给属性apple赋予变量名fruit，再为其赋值为5</span><br><span class="hljs-keyword">let</span> fruit = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;Which fruit to buy?&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>);<br><br><span class="hljs-keyword">let</span> bag = &#123;<br>  [fruit]: <span class="hljs-number">5</span>, <span class="hljs-comment">// 属性名是从 fruit 变量中得到的</span><br>&#125;;<br><br><span class="hljs-title function_">alert</span>( bag.<span class="hljs-property">apple</span> ); <span class="hljs-comment">// 5 如果 fruit=&quot;apple&quot;</span><br></code></pre></td></tr></table></figure><p>本质上，这跟下面的语法效果相同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruit = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;Which fruit to buy?&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>);<br><span class="hljs-keyword">let</span> bag = &#123;&#125;;<br><br><span class="hljs-comment">// 从 fruit 变量中获取值</span><br>bag[fruit] = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>我们可以在方括号中使用更复杂的表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruit = <span class="hljs-string">&#x27;apple&#x27;</span>;<br><span class="hljs-keyword">let</span> bag = &#123;<br>  [fruit + <span class="hljs-string">&#x27;Computers&#x27;</span>]: <span class="hljs-number">5</span> <span class="hljs-comment">// bag.appleComputers = 5</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>方括号比点符号更强大。它允许任何属性名和变量，但写起来也更加麻烦。</p><p>所以，大部分时间里，当属性名是已知且简单的时候，就使用点符号。如果我们需要一些更复杂的内容，那么就用方括号。</p><h3 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a><a href="https://zh.javascript.info/object#shu-xing-zhi-jian-xie">属性值简写</a></h3><p>在实际开发中，我们通常用已存在的变量当做属性名。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeUser</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">name</span>: name,<br>    <span class="hljs-attr">age</span>: age,<br>    <span class="hljs-comment">// ……其他的属性</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-title function_">makeUser</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">30</span>);<br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，属性名跟变量名一样。这种通过变量生成属性的应用场景很常见，在这有一种特殊的 <strong>属性值缩写</strong> 方法，使属性名变得更短。</p><p>可以用 <code>name</code> 来代替 <code>name:name</code> 像下面那样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeUser</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    name, <span class="hljs-comment">// 与 name: name 相同</span><br>    age,  <span class="hljs-comment">// 与 age: age 相同</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以把属性名简写方式和正常方式混用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeUser</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        name,<span class="hljs-attr">age</span>:<span class="hljs-number">30</span>,<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> user = <span class="hljs-title function_">makeUser</span>(<span class="hljs-string">&#x27;xm&#x27;</span>)<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(user.<span class="hljs-property">name</span>+user.<span class="hljs-property">age</span>)<br><span class="hljs-comment">//document.write(user[&#x27;name&#x27;]+user[&#x27;age&#x27;])     </span><br></code></pre></td></tr></table></figure><h3 id="属性名称限制"><a href="#属性名称限制" class="headerlink" title="属性名称限制"></a><a href="https://zh.javascript.info/object#shu-xing-ming-cheng-xian-zhi">属性名称限制</a></h3><p>我们已经知道，变量名不能是编程语言的某个保留字，如 “for”、“let”、“return” 等……</p><p>但对象的属性名并不受此限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这些属性都没问题</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">for</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">let</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">return</span>: <span class="hljs-number">3</span><br>&#125;;<br><br><span class="hljs-title function_">alert</span>( obj.<span class="hljs-property">for</span> + obj.<span class="hljs-property">let</span> + obj.<span class="hljs-property">return</span> );  <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><p>简而言之，属性命名没有限制。属性名可以是任何字符串或者 symbol（一种特殊的标志符类型，将在后面介绍）。</p><p>其他类型会被自动地转换为字符串。</p><p>例如，当数字 <code>0</code> 被用作对象的属性的键时，会被转换为字符串 <code>&quot;0&quot;</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;test&quot;</span> <span class="hljs-comment">// 等同于 &quot;0&quot;: &quot;test&quot;</span><br>&#125;;<br><br><span class="hljs-comment">// 都会输出相同的属性（数字 0 被转为字符串 &quot;0&quot;）</span><br><span class="hljs-title function_">alert</span>( obj[<span class="hljs-string">&quot;0&quot;</span>] ); <span class="hljs-comment">// test</span><br><span class="hljs-title function_">alert</span>( obj[<span class="hljs-number">0</span>] ); <span class="hljs-comment">// test (相同的属性)</span><br></code></pre></td></tr></table></figure><p>这里有个小陷阱：一个名为 <code>__proto__</code> 的属性。我们不能将它设置为一个非对象的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">__proto__</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// 分配一个数字</span><br><span class="hljs-title function_">alert</span>(obj.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">// [object Object] —— 值为对象，与预期结果不同</span><br></code></pre></td></tr></table></figure><p>我们从代码中可以看出来，把它赋值为 <code>5</code> 的操作被忽略了。</p><p>我们将在 <a href="https://zh.javascript.info/prototype-inheritance">后续章节</a> 中学习 <code>__proto__</code> 的特殊性质，并给出了解决此问题的方法。</p><h3 id="属性存在性检测，“in”-操作符"><a href="#属性存在性检测，“in”-操作符" class="headerlink" title="属性存在性检测，“in” 操作符"></a><a href="https://zh.javascript.info/object#shu-xing-cun-zai-xing-ce-shi-in-cao-zuo-fu">属性存在性检测，“in” 操作符</a></h3><p>相比于其他语言，JavaScript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！</p><p>读取不存在的属性只会得到 <code>undefined</code>。所以我们可以很容易地判断一个属性是否存在：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;;<br><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">noSuchProperty</span> === fruit ); <span class="hljs-comment">// true 意思是没有这个属性</span><br></code></pre></td></tr></table></figure><p>这里还有一个特别的，检查属性是否存在的操作符 <code>&quot;in&quot;</code>。</p><p>语法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;key&quot;</span> <span class="hljs-keyword">in</span> object<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;age&quot;</span> <span class="hljs-keyword">in</span> user ); <span class="hljs-comment">// true，user.age 存在</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;blabla&quot;</span> <span class="hljs-keyword">in</span> user ); <span class="hljs-comment">// false，user.blabla 不存在。</span><br></code></pre></td></tr></table></figure><p>请注意，<code>in</code> 的左边必须是 <strong>属性名</strong>。通常是一个带引号的字符串。</p><p>如果我们省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><br><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;age&quot;</span>;<br><span class="hljs-title function_">alert</span>( key <span class="hljs-keyword">in</span> user ); <span class="hljs-comment">// true，属性 &quot;age&quot; 存在</span><br></code></pre></td></tr></table></figure><p>为何会有 <code>in</code> 运算符呢？与 <code>undefined</code> 进行比较来判断还不够吗？</p><p>确实，大部分情况下与 <code>undefined</code> 进行比较来判断就可以了。但有一个例外情况，这种比对方式会有问题，但 <code>in</code> 运算符的判断结果仍是对的。</p><p>那就是属性存在，但存储的值是 <code>undefined</code> 的时候：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-literal">undefined</span><br>&#125;;<br><br><span class="hljs-title function_">alert</span>( obj.<span class="hljs-property">test</span> ); <span class="hljs-comment">// 显示 undefined，所以属性不存在？</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;test&quot;</span> <span class="hljs-keyword">in</span> obj ); <span class="hljs-comment">// true，属性存在！</span><br></code></pre></td></tr></table></figure><p>这种情况很少发生，因为通常情况下不应该给对象赋值 <code>undefined</code>。我们通常会用 <code>null</code> 来表示未知的或者空的值。因此，<code>in</code> 运算符是代码中的特殊来宾。</p><h3 id="“for-in”-循环"><a href="#“for-in”-循环" class="headerlink" title="“for..in” 循环"></a><a href="https://zh.javascript.info/object#forin">“for..in” 循环</a></h3><p>为了遍历一个对象的所有键（key），可以使用一个特殊形式的循环：<code>for...in</code>。这跟我们在前面学到的 <code>for(;;)</code> 循环是完全不一样的东西。</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> object) &#123;<br>  <span class="hljs-comment">// 对此对象属性中的每个键执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如，让我们列出 <code>user</code> 所有的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) &#123;<br>  <span class="hljs-comment">// keys,可以随便命名，i也可以</span><br>  <span class="hljs-title function_">alert</span>( key );  <span class="hljs-comment">// name, age, isAdmin</span><br>  <span class="hljs-comment">// 属性键的值</span><br>  <span class="hljs-title function_">alert</span>( user[key] ); <span class="hljs-comment">// John, 30, true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="像对象一样排序"><a href="#像对象一样排序" class="headerlink" title="像对象一样排序"></a><a href="https://zh.javascript.info/object#xiang-dui-xiang-yi-yang-pai-xu">像对象一样排序</a></h3><p>对象的属性有顺序吗？</p><p>回答是：“有特别的顺序”：整数属性会被进行排序，其他属性则按照创建的顺序显示。详情如下：</p><p>例如，让我们考虑一个带有电话号码的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> codes = &#123;<br>  <span class="hljs-string">&quot;49&quot;</span>: <span class="hljs-string">&quot;Germany&quot;</span>,<br>  <span class="hljs-string">&quot;41&quot;</span>: <span class="hljs-string">&quot;Switzerland&quot;</span>,<br>  <span class="hljs-string">&quot;44&quot;</span>: <span class="hljs-string">&quot;Great Britain&quot;</span>,<br>  <span class="hljs-comment">// ..,</span><br>  <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;USA&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> code <span class="hljs-keyword">in</span> codes) &#123;<br>  <span class="hljs-title function_">alert</span>(+code); <span class="hljs-comment">// 1, 41, 44, 49</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的“整数属性”指的是一个可以在不做任何更改的情况下与一个整数进行相互转换的字符串，而不是“1sd”这种以数字开头的字符串。但是 “+49” 和 “1.2” 就不行了：</p><p>此外，如果属性名不是整数，那它们就按照创建时的顺序来排序，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Smith&quot;</span><br>&#125;;<br>user.<span class="hljs-property">age</span> = <span class="hljs-number">25</span>; <span class="hljs-comment">// 增加一个</span><br><br><span class="hljs-comment">// 非整数属性是按照创建的顺序来排列的</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> user) &#123;<br>  <span class="hljs-title function_">alert</span>( prop ); <span class="hljs-comment">// name, surname, age</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以，为了解决电话号码的问题，我们可以使用非整数属性名来 <strong>欺骗</strong> 程序。只需要给每个键名加一个加号 <code>&quot;+&quot;</code> 前缀就行了。</p><p>像这样，属性名为“+49”被理解为非整数属性，然后再在便历时通过在属性前加一个算术符号“+”来转换成数字。</p><p>因为是两个<code>+</code>，所以得到的结果依然是正数，同样加两个<code>-</code>，得到的结果是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> codes = &#123;<br>  <span class="hljs-string">&quot;+49&quot;</span>: <span class="hljs-string">&quot;Germany&quot;</span>,<br>  <span class="hljs-string">&quot;+41&quot;</span>: <span class="hljs-string">&quot;Switzerland&quot;</span>,<br>  <span class="hljs-string">&quot;+44&quot;</span>: <span class="hljs-string">&quot;Great Britain&quot;</span>,<br>  <span class="hljs-comment">// ..,</span><br>  <span class="hljs-string">&quot;+1&quot;</span>: <span class="hljs-string">&quot;USA&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> code <span class="hljs-keyword">in</span> codes) &#123;<br>  <span class="hljs-title function_">alert</span>( +code ); <span class="hljs-comment">// 49, 41, 44, 1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/object#zong-jie">总结</a></h3><p>对象是具有一些特殊特性的关联数组。</p><p>它们存储属性（键值对），其中：</p><ul><li>属性的键必须是字符串或者 symbol（通常是字符串）。</li><li>值可以是任何类型。</li></ul><p>我们可以用下面的方法访问属性：</p><ul><li>点符号: <code>obj.property</code>。</li><li>方括号 <code>obj[&quot;property&quot;]</code>，方括号允许从变量中获取键，例如 <code>obj[varWithKey]</code>。</li></ul><p>其他操作：</p><ul><li>删除属性：<code>delete obj.prop</code>。</li><li>检查是否存在给定键的属性：<code>&quot;key&quot; in obj</code>。</li><li>遍历对象：<code>for(let key in obj)</code> 循环。</li></ul><p>我们在这一章学习的叫做“普通对象（plain object）”，或者就叫对象。</p><p>JavaScript 中还有很多其他类型的对象：</p><ul><li><code>Array</code> 用于存储有序数据集合，</li><li><code>Date</code> 用于存储时间日期，</li><li><code>Error</code> 用于存储错误信息。</li><li>……等等。</li></ul><p>它们有着各自特别的特性，我们将在后面学习到。有时候大家会说“Array 类型”或“Date 类型”，但其实它们并不是自身所属的类型，而是属于一个对象类型即 “object”。它们以不同的方式对 “object” 做了一些扩展。</p><p>JavaScript 中的对象非常强大。这里我们只接触了其冰山一角。在后面的章节中，我们将频繁使用对象进行编程，并学习更多关于对象的知识。</p><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a><a href="https://zh.javascript.info/object#tasks">作业</a></h2><h3 id="检查空对象"><a href="#检查空对象" class="headerlink" title="检查空对象"></a><a href="https://zh.javascript.info/object#jian-cha-kong-dui-xiang">检查空对象</a></h3><p>重要程度: 5</p><p>写一个 <code>isEmpty(obj)</code> 函数，当对象没有属性的时候返回 <code>true</code>，否则返回 <code>false</code>。</p><p>答案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj=&#123;&#125;<span class="hljs-comment">//true</span><br><span class="hljs-keyword">let</span> obj=&#123;<br>    <span class="hljs-attr">ff</span>:<span class="hljs-number">2</span><br>&#125;<span class="hljs-comment">//false</span><br><span class="hljs-comment">//函数逻辑：如果能被遍历相当于属性非空</span><br><span class="hljs-keyword">let</span> schedule = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-title function_">alert</span>(<span class="hljs-title function_">schedule</span>())<br></code></pre></td></tr></table></figure><h3 id="对象属性求和"><a href="#对象属性求和" class="headerlink" title="对象属性求和"></a><a href="https://zh.javascript.info/object#dui-xiang-shu-xing-qiu-he">对象属性求和</a></h3><p>重要程度: 5</p><p>我们有一个保存着团队成员工资的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> salaries = &#123;<br>  <span class="hljs-title class_">John</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-title class_">Ann</span>: <span class="hljs-number">160</span>,<br>  <span class="hljs-title class_">Pete</span>: <span class="hljs-number">130</span><br>&#125;<br></code></pre></td></tr></table></figure><p>写一段代码求出我们的工资总和，将计算结果保存到变量 <code>sum</code>。从所给的信息来看，结果应该是 <code>390</code>。</p><p>如果 <code>salaries</code> 是一个空对象，那结果就为 <code>0</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> salaries = &#123;<br>    <span class="hljs-title class_">John</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-title class_">Ann</span>: <span class="hljs-number">160</span>,<br>    <span class="hljs-title class_">Pete</span>: <span class="hljs-number">130</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">obj</span>)&#123;<br>    <span class="hljs-keyword">let</span> end=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj)&#123;<br>        end+=obj[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> end<br>&#125;<br><span class="hljs-title function_">alert</span>(<span class="hljs-title function_">sum</span>(salaries))<br></code></pre></td></tr></table></figure><h3 id="将数值属性值都乘以-2"><a href="#将数值属性值都乘以-2" class="headerlink" title="将数值属性值都乘以 2"></a><a href="https://zh.javascript.info/object#jiang-shu-zhi-shu-xing-zhi-du-cheng-yi-2">将数值属性值都乘以 2</a></h3><p>重要程度: 3</p><p>创建一个 <code>multiplyNumeric(obj)</code> 函数，把 <code>obj</code> 所有的数值属性值都乘以 <code>2</code>。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在调用之前</span><br><span class="hljs-keyword">let</span> menu = &#123;<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">300</span>,<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;My menu&quot;</span><br>&#125;;<br><br><span class="hljs-title function_">multiplyNumeric</span>(menu);<br><br><span class="hljs-comment">// 调用函数之后</span><br>menu = &#123;<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">400</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">600</span>,<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;My menu&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>注意 <code>multiplyNumeric</code> 函数不需要返回任何值，它应该就地修改对象。</p><p>P.S. 用 <code>typeof</code> 检查值类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> menu = &#123;<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">300</span>,<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;My menu&quot;</span>,<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiplyNumeric</span>(<span class="hljs-params">obj</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_">typeof</span>(obj[i])==<span class="hljs-string">&quot;number&quot;</span>)&#123;        <br>            obj[i]*=<span class="hljs-number">2</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">multiplyNumeric</span>(menu);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> menu)&#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;i&#125;</span>:<span class="hljs-subst">$&#123;menu[i]&#125;</span>\n`</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、对象引用和复制"><a href="#二、对象引用和复制" class="headerlink" title="二、对象引用和复制"></a>二、对象引用和复制</h2><p>对象与原始类型的根本区别之一是，对象是“通过引用”存储和复制的，而原始类型：字符串、数字、布尔值等总是“作为一个整体”复制。</p><p>让我们从原始类型开始，当我们复制一个字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;Hello!&quot;</span>;<br><span class="hljs-keyword">let</span> phrase = message;<br></code></pre></td></tr></table></figure><p>结果我们就有了两个独立的变量，每个都存储着字符串 <code>&quot;Hello!&quot;</code>。</p><p>但对象不这样。</p><p><strong>赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址” —— 换句话说就是对该对象的“引用”。</strong></p><p>让我们看一个这样的变量的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>它实际存储在内存中的方式：该对象被存储在内存中的某个位置，而变量 <code>user</code>（在左侧）保存的是对其的“引用”。</p><p>我们可以将一个对象变量（例如 <code>user</code>）想象成一张写有对象的地址的纸。</p><p>当我们对对象执行操作时，例如获取一个属性 <code>user.name</code>，JavaScript 引擎会查看该地址中的内容，并在实际对象上执行操作。</p><p><strong>当一个对象变量被复制 —— 引用被复制，而该对象自身并没有被复制。</strong></p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><br><span class="hljs-keyword">let</span> admin = user; <span class="hljs-comment">// 复制引用</span><br></code></pre></td></tr></table></figure><p>现在我们有了两个变量，它们保存的都是对同一个对象的引用，但是其实都是同一个对象</p><p>我们可以通过其中任意一个变量来访问该对象并修改它的内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><br><span class="hljs-keyword">let</span> admin = user;<br><br>admin.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Pete&#x27;</span>; <span class="hljs-comment">// 通过 &quot;admin&quot; 引用来修改</span><br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Pete&#x27;，修改能通过 &quot;user&quot; 引用看到</span><br></code></pre></td></tr></table></figure><h3 id="通过引用来比较"><a href="#通过引用来比较" class="headerlink" title="通过引用来比较"></a><a href="https://zh.javascript.info/object-copy#tong-guo-yin-yong-lai-bi-jiao">通过引用来比较</a></h3><p>用<code>==</code>进行比较时，仅当两个变量指向同一个对象时，两者才相等。</p><p>例如，这里 <code>a</code> 和 <code>b</code> 两个变量都引用同一个对象，所以它们相等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = &#123;&#125;;<br><span class="hljs-keyword">let</span> b = a; <span class="hljs-comment">// 复制引用</span><br><br><span class="hljs-title function_">alert</span>( a == b ); <span class="hljs-comment">// true，都引用同一对象</span><br><span class="hljs-title function_">alert</span>( a === b ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>而这里两个独立的对象则并不相等，即使它们看起来很像（都为空）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = &#123;&#125;;<br><span class="hljs-keyword">let</span> b = &#123;&#125;; <span class="hljs-comment">// 两个独立的对象</span><br><br><span class="hljs-title function_">alert</span>( a == b ); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="克隆与合并Object-assign"><a href="#克隆与合并Object-assign" class="headerlink" title="克隆与合并Object.assign"></a><a href="https://zh.javascript.info/object-copy#cloning-and-merging-object-assign">克隆与合并Object.assign</a></h3><p>如果想要复制一个对象，那该怎么做呢？</p><p>我们可以创建一个新对象，通过遍历已有对象的属性，并在原始类型值的层面复制它们，以实现对已有对象结构的复制。</p><p>就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> clone = &#123;&#125;; <span class="hljs-comment">// 新的空对象</span><br><br><span class="hljs-comment">// 将 user 中所有的属性拷贝到其中</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) &#123;<br>  clone[key] = user[key];<br>&#125;<br><br><span class="hljs-comment">// 现在 clone 是带有相同内容的完全独立的对象</span><br>clone.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Pete&quot;</span>; <span class="hljs-comment">// 改变了其中的数据</span><br><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">name</span> ); <span class="hljs-comment">// 原来的对象中的 name 属性依然是 John</span><br></code></pre></td></tr></table></figure><p>我们也可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 方法来达成同样的效果。</p><p>语法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, [src1, src2, src3...])<br></code></pre></td></tr></table></figure><ul><li>第一个参数 <code>dest</code> 是指目标对象。</li><li>更后面的参数 <code>src1, ..., srcN</code>（可按需传递多个参数）是源对象。</li><li>该方法将所有源对象的属性拷贝到目标对象 <code>dest</code> 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中。</li><li>调用结果返回 <code>dest</code>。</li></ul><p>例如，我们可以用它来合并多个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><br><span class="hljs-keyword">let</span> permissions1 = &#123; <span class="hljs-attr">canView</span>: <span class="hljs-literal">true</span> &#125;;<br><span class="hljs-keyword">let</span> permissions2 = &#123; <span class="hljs-attr">canEdit</span>: <span class="hljs-literal">true</span> &#125;;<br><br><span class="hljs-comment">// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(user, permissions1, permissions2);<br><br><span class="hljs-comment">// 现在 user = &#123; name: &quot;John&quot;, canView: true, canEdit: true &#125;</span><br></code></pre></td></tr></table></figure><p>如果被拷贝的属性的属性名已经存在，那么它会被覆盖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(user, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span> &#125;);<br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// 现在 user = &#123; name: &quot;Pete&quot; &#125;</span><br></code></pre></td></tr></table></figure><p>我们也可以用 <code>Object.assign</code> 代替 <code>for..in</code> 循环来进行简单克隆：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, user);<br></code></pre></td></tr></table></figure><p>它将 <code>user</code> 中的所有属性拷贝到了一个空对象中，并返回这个新的对象。</p><p>还有其他克隆对象的方法，例如使用 <a href="https://zh.javascript.info/rest-parameters-spread">spread 语法</a> <code>clone = &#123;...user&#125;</code>，在后面的章节中我们会讲到。</p><h2 id="深层克隆"><a href="#深层克隆" class="headerlink" title="深层克隆"></a><a href="https://zh.javascript.info/object-copy#shen-ceng-ke-long">深层克隆</a></h2><p>到现在为止，我们都假设 <code>user</code> 的所有属性均为原始类型。但属性可以是对其他对象的引用。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">sizes</span>: &#123;<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">182</span>,<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">50</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">sizes</span>.<span class="hljs-property">height</span> ); <span class="hljs-comment">// 182</span><br></code></pre></td></tr></table></figure><p>现在这样拷贝 <code>clone.sizes = user.sizes</code> 已经不足够了，因为 <code>user.sizes</code> 是个对象，它会以引用形式被拷贝。因此 <code>clone</code> 和 <code>user</code> 会共用一个 sizes：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">sizes</span>: &#123;<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">182</span>,<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">50</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, user);<br><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">sizes</span> === clone.<span class="hljs-property">sizes</span> ); <span class="hljs-comment">// true，同一个对象</span><br><br><span class="hljs-comment">// user 和 clone 分享同一个 sizes</span><br>user.<span class="hljs-property">sizes</span>.<span class="hljs-property">width</span>++;       <span class="hljs-comment">// 通过其中一个改变属性值</span><br><span class="hljs-title function_">alert</span>(clone.<span class="hljs-property">sizes</span>.<span class="hljs-property">width</span>); <span class="hljs-comment">// 51，能从另外一个获取到变更后的结果</span><br></code></pre></td></tr></table></figure><p>为了解决这个问题，并让 <code>user</code> 和 <code>clone</code> 成为两个真正独立的对象，我们应该使用一个拷贝循环来检查 <code>user[key]</code> 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的“深拷贝”。</p><p>我们可以使用递归来实现它。或者为了不重复造轮子，采用现有的实现，例如 <a href="https://lodash.com/">lodash</a> 库的 <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>。</p><p><strong>使用 const 声明的对象也是可以被修改的</strong></p><p>通过引用存储对象的一个很大的副作用是声明为 <code>const</code> 的对象 <strong>可以</strong> 被修改。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br><br>user.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Pete&quot;</span>; <span class="hljs-comment">// (*)</span><br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// Pete</span><br></code></pre></td></tr></table></figure><p>看起来 <code>(*)</code> 行的代码会触发一个错误，但实际并没有。<code>user</code> 的值是一个常量，它必须始终引用同一个对象，但该对象的属性可以被自由修改。</p><p>换句话说，只有当我们尝试将 <code>user=...</code> 作为一个整体进行赋值时，<code>const user</code> 才会报错。</p><p>也就是说，如果我们真的需要创建常量对象属性，也是可以的，但使用的是完全不同的方法。我们将在 <a href="https://zh.javascript.info/property-descriptors">属性标志和属性描述符</a> 一章中学习它。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/object-copy#zong-jie">总结</a></h2><p>对象通过引用被赋值和拷贝。换句话说，一个变量存储的不是“对象的值”，而是一个对值的“引用”（内存地址）。因此，拷贝此类变量或将其作为函数参数传递时，所拷贝的是引用，而不是对象本身。</p><p>所有通过被拷贝的引用的操作（如添加、删除属性）都作用在同一个对象上。</p><p>为了创建“真正的拷贝”（一个克隆），我们可以使用 <code>Object.assign</code> 来做所谓的“浅拷贝”（嵌套对象被通过引用进行拷贝）或者使用“深拷贝”函数，例如 <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 02</title>
    <link href="/2022/08/05/02/"/>
    <url>/2022/08/05/02/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="JavaScript-基础-第二天"><a href="#JavaScript-基础-第二天" class="headerlink" title="JavaScript 基础 - 第二天"></a>JavaScript 基础 - 第二天</h1><h2 id="一、运算符"><a href="#一、运算符" class="headerlink" title="一、运算符"></a>一、运算符</h2><h3 id="1-1-算术运算符"><a href="#1-1-算术运算符" class="headerlink" title="1.1 算术运算符"></a>1.1 算术运算符</h3><p>加+、减-、乘*、除/、取余%</p><p>优先级：先乘除后加减，括号最先</p><h3 id="1-2-赋值运算符"><a href="#1-2-赋值运算符" class="headerlink" title="1.2 赋值运算符"></a>1.2 赋值运算符</h3><p>=、+=、-=、*=、/=、%=</p><p>将等号右边的值赋予给左边, 要求左边必须是一个容器</p><h3 id="1-3-一元运算符"><a href="#1-3-一元运算符" class="headerlink" title="1.3 一元运算符"></a>1.3 一元运算符</h3><p>自增++、自减—</p><p>经常用于计数来使用。 比如进行10次操作，用它来计算进行了多少次了</p><p>前置和后置单独使用（自己独占一行）没有区别，如果参与运算就有区别：</p><ul><li>前置自增：先自加再使用(记忆口诀:++在前 先加)</li><li>后置自增：先使用再自加(记忆口诀:++在后 后加)</li><li>后置自增由于其内存占用较小问题使用相对较多</li></ul><h3 id="1-4-比较运算符"><a href="#1-4-比较运算符" class="headerlink" title="1.4 比较运算符"></a>1.4 比较运算符</h3><ul><li><code>&gt;、&lt;、&gt;=、&lt;=</code> 这四个比较基础</li><li><code>==</code>左右两边是否相等</li><li><code>===</code>左右两边是否类型和值都相等</li><li><code>！==</code>左右两边是否不全等</li></ul><p>比较结果为boolean类型，即只会得到<code>true</code>和<code>false</code></p><p>注意：</p><ul><li>字符串比较，是比较的字符对应的ASCII码 <ul><li>从左往右依次比较</li><li>如果第一位一样再比较第二位，以此类推  比较的少，了解即可</li></ul></li><li>NaN不等于任何值，包括它本身</li><li>尽量不要比较小数，因为小数有精度问题</li><li>不同类型之间比较会发生隐式转换<ul><li>数据会隐式转换转成number类型再比较</li><li>所以开发中，如果进行准确的比较我们更喜欢用<code>===</code>或者<code>!==</code></li></ul></li></ul><h3 id="1-5-逻辑运算符"><a href="#1-5-逻辑运算符" class="headerlink" title="1.5 逻辑运算符"></a>1.5 逻辑运算符</h3><p>逻辑运算符用来解决多重条件判断</p><ul><li>短路：只存在于 &amp;&amp; 和 || 中，当满足一定条件会让右边代码不执行</li></ul><h2 id="二、语句"><a href="#二、语句" class="headerlink" title="二、语句"></a>二、<strong>语句</strong></h2><h3 id="2-1-表达式和语句"><a href="#2-1-表达式和语句" class="headerlink" title="2.1 表达式和语句"></a>2.1 表达式和语句</h3><ul><li><p>区别:</p><ul><li>表达式用来计算出一个值，但语句用来自行以使某件事发生(做什么事)</li><li>表达式： 3 + 4</li><li>语句： alert() 弹出对话框 </li></ul><p>其实某些情况，也可以把表达式理解为语句，因为它是在计算结果，也是做事</p></li></ul><h3 id="2-2-分支语句"><a href="#2-2-分支语句" class="headerlink" title="2.2 分支语句"></a>2.2 分支语句</h3><p>分支语句可以让我们有选择性的执行想要的代码，分支语句包含:</p><ul><li>If分支语句</li><li>三元运算符</li><li>switch 语句</li></ul><p><strong>if语句：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">if(条件 1)&#123;<br>代码 1<br>&#125;else if(条件 2)&#123;<br>代码 2<br>&#125;else if(条件 3)&#123;<br>代码 3<br>&#125;else&#123;<br>代码 n<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>三元运算符：</strong>一般用来取值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">条件？为true执行的代码:为false执行的代码<br></code></pre></td></tr></table></figure><p><strong>switch语句：</strong></p><ul><li>找到跟小括号里数据<strong>全等</strong>的case值，并执行里面对应的代码</li><li>若没有全等 === 的则执行default里的代码</li><li>例：数据若跟值2全等，则执行代码2</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html">switch(data)&#123;<br>case value1:<br>code 1<br>break<br>case value2:<br>code 2<br>break<br>case value3:<br>code 3<br>break<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>switch case语句一般用于等值判断,不适合于区间判断</li><li>switch case一般需要配合break关键字使用 没有break会造成case穿透</li></ol><h3 id="2-3-循环语句"><a href="#2-3-循环语句" class="headerlink" title="2.3 循环语句"></a>2.3 循环语句</h3><p>浏览器打开调试界面，进行<strong>断点调试</strong>：</p><ol><li>按F12打开开发者工具 </li><li>点到sources一栏</li><li>选择代码文件</li></ol><p>断点：在某句代码上加的标记就叫断点，当程序执行到这句有标记的代码时会暂停下来</p><p><strong>while循环：</strong></p><p>跟if语句很像，都要满足小括号里的条件为true才会进入执行代码，当条件为false时跳出循环。</p><p>循环的本质就是以某个变量为起始值，然后不断产生变化量，慢慢靠近终止条件的过程。 所以，循环需要具备三要素:</p><ol><li>变量起始值</li><li>终止条件(没有终止条件，循环会一直执行，造成死循环)</li><li>变量变化量(用自增或者自减)</li></ol><p><strong>for循环：</strong></p><p>把声明起始值、循环条件、变化值写到一起，让人一目了然</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">for(声明记录循环次数的变量；循环条件；变化值)&#123;<br>循环体<br>&#125;<br></code></pre></td></tr></table></figure><p>当如果明确了循环的次数的时候推荐使用for循环</p><p>当不明确循环的次数的时候推荐使用while循环</p><p><strong>循环结束</strong>:</p><ul><li>continue：结束本次循环，继续下次循环</li><li>break：跳出所在的循环</li></ul><p><strong>for循环嵌套：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">for(外部声明记录循环次数的变量；循环条件；变化值)&#123;<br>for(内部声明记录循环次数的变量；循环条件；变化值)&#123;<br>循环体<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h3><h3 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3.1 基本语法"></a>3.1 基本语法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">let 数组名 = [data1,data2,...,data n]<br></code></pre></td></tr></table></figure><ul><li>数组是按顺序保存，所以每个数据都有自己的编号</li><li>计算机中的编号从0开始</li><li>在数组中，数据的编号也叫<strong>索引或下标</strong></li><li>数组可以存储任意类型的数据</li></ul><p><strong>取值语法：</strong></p><ul><li>通过下标取数据</li><li>取出来是什么类型的，就根据这种类型特点来访问</li></ul><p><strong>遍历：</strong></p><p>用循环把数组中每个元素都访问到，一般会用for循环遍历</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> names = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]</span><br><span class="language-javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;names.<span class="hljs-property">length</span>;i++)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(names[i])</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>操作数组：</strong></p><p><strong>增：</strong></p><p><strong>数组.push()</strong>：将一个或多个元素添加到数组的末尾，并返回该数组的新长度 </p><p><strong>arr.unshift(新增的内容)</strong> ：将一个或多个元素添加到数组的<strong>开头</strong>，并返回该数组的新长度</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> arr =  [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-number">52</span>, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>, <span class="hljs-number">7</span>]</span><br><span class="language-javascript">  arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">17</span>)</span><br><span class="language-javascript">  arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">43</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>)</span><br><span class="language-javascript">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">if</span>(arr[i]&gt;<span class="hljs-number">10</span>)&#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(arr[i])</span><br><span class="language-javascript">          <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;\n&quot;</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>删：</strong></p><p>数组. pop() 方法从数组中删除最后一个元素，并返回该元素的值</p><p>数组. shift() 方法从数组中删除第一个元素，并返回该元素的值</p><p>数组. splice() 方法 删除指定元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">arr.splice(2,4)<br>//第一个参数为要删除的起始位置，第二个参数为要删除的元素个数，可以缺省，会默认删到最后<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> arr =  [<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">77</span>, <span class="hljs-number">30</span>, <span class="hljs-number">52</span>, <span class="hljs-number">50</span>, <span class="hljs-number">25</span>, <span class="hljs-number">7</span>]</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> min=arr[<span class="hljs-number">0</span>]</span><br><span class="language-javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=i;j&lt;arr.<span class="hljs-property">length</span>;j++)&#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span>(arr[j]&gt;arr[i])&#123;</span><br><span class="language-javascript">                min=arr[i]</span><br><span class="language-javascript">                arr[i]=arr[j]</span><br><span class="language-javascript">                arr[j]=min</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>利用js渲染画面案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 1. 利用循环弹出四次输入框， 会得到4个数据，放到数组里面</span></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> arr = []</span><br><span class="language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span>; i++) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// prompt(`请输入第 $&#123;i&#125; 季度的数据`)  ===  123</span></span><br><span class="language-javascript">        arr.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">prompt</span>(<span class="hljs-string">`请输入第 <span class="hljs-subst">$&#123;i&#125;</span> 季度的数据`</span>))</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(arr)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 注意我们渲染循环的是柱子 </span></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`&lt;div class=&quot;box&quot;&gt;`</span>)</span><br><span class="language-javascript">    <span class="hljs-comment">// 循环4个柱子</span></span><br><span class="language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`</span></span><br><span class="hljs-string"><span class="language-javascript">             &lt;div style=&quot;height: <span class="hljs-subst">$&#123;arr[i]&#125;</span>px;&quot;&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">                 &lt;span&gt;<span class="hljs-subst">$&#123;arr[i]&#125;</span>&lt;/span&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">                &lt;h4&gt;第<span class="hljs-subst">$&#123;i + <span class="hljs-number">1</span>&#125;</span>季度&lt;/h4&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">            &lt;/div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">        `</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`&lt;/div&gt;`</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在<code>script</code>标签里把css语句写到函数参数里，用<code>$&#123;&#125;</code>把括号外的变量包裹起来。</p><h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><p><strong>函数:</strong></p><p>function，是被设计为执行特定任务的代码块，可以实现代码复用，提高开发效率</p><p><strong>声明语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">function 函数名()&#123;<br>函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">mulTable</span>(<span class="hljs-params">a,b</span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span>x<span class="hljs-subst">$&#123;b&#125;</span>=<span class="hljs-subst">$&#123;a*b&#125;</span>`</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)&#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">mulTable</span>(i,j)</span><br><span class="language-javascript">            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;\n&quot;</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>函数名命名规范：</strong></p><ul><li>和变量命名基本一致</li><li>尽量小驼峰式命名法</li><li>前缀应该为动词</li><li>命名建议:常用动词约定</li></ul><div class="table-container"><table><thead><tr><th>动词</th><th>含义</th></tr></thead><tbody><tr><td>can</td><td>判断是否可执行某个动作，eg.canShow( )</td></tr><tr><td>has</td><td>判断是否含有某个值，eg.hasShot( )</td></tr><tr><td>is</td><td>判断是否为某个值，eg.isText( )</td></tr><tr><td>get</td><td>获取某个值，eg.getName( )</td></tr><tr><td>set</td><td>设置某个值</td></tr><tr><td>Load</td><td>加载某些数据，eg.loadTable( )</td></tr></tbody></table></div><p><strong>函数传参：</strong></p><p>调用语法：<code>函数名(传递的参数列表)</code></p><p>调用函数时，需要传入几个数据就写几个，用逗号隔开</p><p>形参和实参：</p><ul><li>形参：声明函数时括号里的叫形参</li><li>实参：调用函数时括号里的叫实参</li><li>开发中尽量保持形参和实参个数一致</li><li>两个相同的函数后面的会覆盖前面的函数</li><li>在Javascript中实参的个数和形参的个数可以不一致<ul><li>如果形参过多 会自动填上undefined (了解即可)</li><li>如果实参过多 那么多余的实参会被忽略 (函数内部有一个arguments,以伪数组的形式装着所有的实参)</li></ul></li></ul><p>小技巧：可以通过符号<code>||</code>来指定参数默认值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x,y</span>)&#123;</span><br><span class="language-javascript">        x=x||<span class="hljs-number">0</span></span><br><span class="language-javascript">        y=y||<span class="hljs-number">0</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(x,y)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-title function_">fn</span>()</span><br><span class="language-javascript">    <span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出：0    0</p><pre><code class="hljs">       1    2</code></pre><p><strong>函数返回值：</strong></p><p>当函数需要返回数据出去时，用return关键字</p><p>注意:</p><ul><li>函数内部只能出现 1 次 return，并且 return 后面代码不会再被执行，所以 return 后面的数据不要换行写 </li><li>return会立即结束当前函数</li><li>函数可以没有 return，这种情况函数默认返回值为 undefined</li></ul><p><strong>作用域：</strong></p><p>全局作用域：作用于所有代码执行的环境(整个 <code>script</code> 标签内部)或者一个独立的 js 文件</p><p>局部作用域：作用于函数内的代码环境</p><p>块级作用域：由 { } 包括，只在{ }内有效，例如if语句和for语句里面的{ }等</p><p><strong>变量的作用域：</strong></p><p>全局变量：函数外部用<code>let</code>定义的变量，在任何区域都可以访问和修改</p><p>局部变量：函数内部用<code>let</code>的变量，局部变量只能在当前函数内部访问和修改</p><p>块级变量：{ } 内部的<code>let</code>变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问</p><blockquote><p>注意：</p><ol><li>如果函数内部或者块级作用域内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐 </li><li>但是有一种情况，函数内部的形参可以看做是局部变量。</li></ol></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        name=<span class="hljs-string">&#x27;xmm&#x27;</span></span><br><span class="language-javascript">        num=<span class="hljs-number">100</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;Hi!&#x27;</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>\n`</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">sayHi</span>()</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出：xmm Hi！</p><p><strong>作用域链：</strong></p><p>采取<strong>就近原则</strong>的方式来查找变量最终的值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span> </span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;22&#x27;</span></span><br><span class="language-javascript">        <span class="hljs-title function_">fn2</span>()</span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> a = <span class="hljs-number">3</span></span><br><span class="language-javascript">            <span class="hljs-title function_">fn3</span>()</span><br><span class="language-javascript">            <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn3</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">let</span> a=<span class="hljs-number">4</span></span><br><span class="language-javascript">                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(a)</span><br><span class="language-javascript">                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(b)</span><br><span class="language-javascript">            &#125; </span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125; </span><br><span class="language-javascript">    <span class="hljs-title function_">fn1</span>()   </span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出为：4 22</p><p><strong>匿名函数：</strong></p><p>将匿名函数赋值给一个变量，并且通过变量名称进行调用</p><p>语法：<code>let fn = function()&#123;&#125;</code></p><p>调用：<code>fn()</code></p><p>立即执行函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;123&quot;</span>)&#125;)()； <span class="hljs-comment">// 方法1 </span></span><br><span class="language-javascript">    (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;456&quot;</span>)&#125;())； <span class="hljs-comment">// 方法2</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意: 多个立即执行函数要用<code>;</code> 隔开，要不然会报错</p><ul><li>立即执行函数可以防止变量污染</li><li>立即执行函数无需另外调用，立即执行</li><li>多个立即执行函数之间用分号隔开</li></ul><p>案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">switchSecond</span>(<span class="hljs-params">i</span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-keyword">let</span> hour=i/<span class="hljs-number">3600</span></span><br><span class="language-javascript">       <span class="hljs-keyword">let</span> min=i/<span class="hljs-number">60</span>%<span class="hljs-number">60</span></span><br><span class="language-javascript">       <span class="hljs-keyword">let</span> sec=i%<span class="hljs-number">60</span></span><br><span class="language-javascript">       <span class="hljs-keyword">let</span> args=[<span class="hljs-built_in">parseInt</span>(hour),<span class="hljs-built_in">parseInt</span>(min),<span class="hljs-built_in">parseInt</span>(sec)]</span><br><span class="language-javascript">       <span class="hljs-keyword">return</span> args</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">   <span class="hljs-keyword">let</span> sec = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入想转换的秒&quot;</span>)</span><br><span class="language-javascript">   <span class="hljs-keyword">let</span> args=<span class="hljs-title function_">switchSecond</span>(sec)</span><br><span class="language-javascript">   <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`&lt;div&gt;把秒数转换成几小时几分零几秒&lt;br&gt;&lt;span&gt;<span class="hljs-subst">$&#123;sec&#125;</span>秒转换后是<span class="hljs-subst">$&#123;args[<span class="hljs-number">0</span>]&#125;</span>小时<span class="hljs-subst">$&#123;args[<span class="hljs-number">1</span>]&#125;</span>分钟<span class="hljs-subst">$&#123;args[<span class="hljs-number">2</span>]&#125;</span>秒&lt;span&gt;&lt;div&gt;`</span>)     </span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 01</title>
    <link href="/2022/08/03/JavaScript/"/>
    <url>/2022/08/03/JavaScript/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="JavaScript-基础-第一天"><a href="#JavaScript-基础-第一天" class="headerlink" title="JavaScript 基础 - 第一天"></a>JavaScript 基础 - 第一天</h2><h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><blockquote><p>JavaScript是一门编程语言，HTML和CSS是标记语言。</p></blockquote><p>编程语言分为三大类：机器语言，汇编语言和高级语言。</p><ul><li>机器语言是计算机可以直接识别的语言，汇编语言和机器语言实质上是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，容易识别和记忆。</li><li>高级语言包括了很多编程语言，常用的有C语言、C++、Java、C#、Js等。</li></ul><p>标记语言不用于向计算机发出指令，常用于格式化和链接。标记语言的存在是用来被读取的，他是被动的。</p><blockquote><p>⌘+B    打开/关闭导航栏</p><p>⌥+⇧+光标选中    多行选择</p></blockquote><p><strong>浏览器执行JS：</strong></p><p>浏览器分成两部分：渲染引擎和JS引擎</p><ul><li>渲染引擎：用来解析HTML和CSS，俗称内核。</li><li>JS引擎：也叫JS解释器，用来读取网页中的JS代码，对其处理后运行。</li></ul><p>浏览器本身并不会执行JS代码，而是由JS引擎转化为二进制的机器语言，由计算机来运行。</p><p><strong>JS组成：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208051409617.png" alt="image-20220803182235562" style="zoom:50%;"></p><ul><li><p>ECMAScript：规定了js基础语法核心知识。</p><ul><li>比如：变量、分支语句、循环语句、对象等等</li></ul></li><li><p>Web APIs :</p><ul><li>DOM 操作文档，比如对页面元素进行移动、大小、添加删除等操作</li><li>BOM 操作浏览器，比如页面弹窗，检测窗口宽度、存储数据到浏览器等等</li></ul></li></ul><p><strong>JS作用：</strong></p><ul><li>网页特效 (监听用户的一些行为让网页作出对应的反馈) </li><li>表单验证 (针对表单数据的合法性进行判断)</li><li>数据交互 (获取后台的数据, 渲染到前端)</li><li>服务端编程 (node.js)</li></ul><p><strong>JS是一门解释性语言：</strong></p><p>计算机无法直接理解除了机器语言以外的语言，所以需要把程序语言翻译成机器语言的工具，即翻译器。</p><ul><li>翻译器翻译的方式有两种：一个是编译，另外一个是解释。</li><li>两种方式之间的区别在于翻译的时间点不用</li><li>编译器是在代码执行之前进行编译，生成中间代码文件</li><li>解释器是在运行时进行即时解释，边解释边执行</li></ul><h4 id="1-1-引入方式"><a href="#1-1-引入方式" class="headerlink" title="1.1 引入方式"></a>1.1 引入方式</h4><p>JavaScript有三种引入方式，类似CSS：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208031829931.png" alt="image-20220803182955896"></p><p><strong>行内形式</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;小明明&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;真棒&#x27;)&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>可以将单行或少量JS代码写在HTML标签的事件属性中，如:onclick</li><li>注意但双引号的使用：在HTML中推荐使用双引号，JS中推荐使用单引号</li><li>后面vue框架会用这种模式</li></ul><h5 id="内嵌形式"><a href="#内嵌形式" class="headerlink" title="内嵌形式"></a>内嵌形式</h5><p>直接写在html文件里，用<code>script</code>标签包住 </p><p><strong>规范</strong>：<code>script</code>标签写在<code>body</code>上面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 内联形式：通过 script 标签包裹 JavaScript 代码 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello,JavaScript！&#x27;</span>);</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>我们将 <code>&lt;script&gt;</code>放在HTML文件的底部附近的原因是浏览器会按照代码在文件中的顺序加载 HTML。 </p><p>如果先加载的 JavaScript 期望修改其下方的 HTML，那么它可能由于 HTML 尚未被加载而失效。 因此，将 JavaScript 代码放在 HTML页面的底部附近通常是最好的策略。</p></blockquote><h5 id="外部形式"><a href="#外部形式" class="headerlink" title="外部形式"></a>外部形式</h5><p>一般将 JavaScript 代码写在独立的以 .js 结尾的文件中，然后通过 <code>script</code> 标签的 <code>src</code> 属性引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// demo.js</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;Hello,JavaScript！&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;demo.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果 <code>script</code> 标签使用 <code>src</code> 属性引入了某 <code>.js</code> 文件，那么标签的代码会被忽略，如下代码所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;demo.js&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 此处的代码会被忽略掉！！！！</span></span><br><span class="language-javascript">  <span class="hljs-title function_">alert</span>(<span class="hljs-number">666</span>);  </span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>外部JavaScript会使代码更加有序，更易于复用，且没有了脚本的混合，HTML 也会更加易读，因此这是个好的习惯。</p></blockquote><h4 id="1-2-注释和结束符"><a href="#1-2-注释和结束符" class="headerlink" title="1.2 注释和结束符"></a>1.2 注释和结束符</h4><h5 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h5><p>使用 <code>//</code> 注释单行代码</p><h5 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h5><p>使用 <code>/* */</code> 注释多行代码</p><p><strong>注：编辑器中单行注释的快捷键为 <code>ctrl + /</code></strong>，多行注释为<code>shift+alt+A</code></p><h5 id="结束符"><a href="#结束符" class="headerlink" title="结束符"></a>结束符</h5><p>在 JavaScript 中 <code>;</code> 代表一段代码的结束，多数情况下可以省略 <code>;</code> 使用回车（enter）替代。</p><p>JavaScript 跟 HTML 和 CSS 一样，会忽略【一些】空白符，但是换行符（回车）会被识别成结束符 <code>;</code>，因此在实际开发中有许多人主张书写 JavaScript 代码时省略结束符 <code>;</code></p><p><strong>但为了风格统一，要写结束符就每句都写，要么每句都不写(按照团队要求)</strong></p><h4 id="1-3-输入和输出"><a href="#1-3-输入和输出" class="headerlink" title="1.3 输入和输出"></a>1.3 输入和输出</h4><p>输出和输入也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程。</p><h5 id="输出语法"><a href="#输出语法" class="headerlink" title="输出语法"></a>输出语法</h5><p>JavaScript 可以接收用户的输入，然后再将输入的结果输出：</p><ul><li><code>alert()</code>浏览器弹出警示框</li><li><code>document.wirte()</code>浏览器页面显示，如果输出的内容写的是标签，也会被解析成网页元素</li><li><code>console.log()</code>控制台输出语法，程序员调试使用</li></ul><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>显示一个对话框，向 <code>prompt()</code> 输入任意内容显示在对话框中，用来提示用户输入文字：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span><br><span class="language-javascript">    <span class="hljs-comment">// 1. 输入的任意数字，都会以弹窗形式展示</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;要输出的内容&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;要输出的内容&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 2. 以弹窗形式提示用户输入姓名，注意这里的文字使用英文的引号</span></span><br><span class="language-javascript">    <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入您的姓名:&#x27;</span>);</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h3><p>变量是程序在内存中申请的一块用来存放数据的空间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// x 符号代表了 5 这个数值</span></span><br><span class="language-javascript">  x = <span class="hljs-number">5</span>;</span><br><span class="language-javascript">  <span class="hljs-comment">// y 符号代表了 6 这个数值</span></span><br><span class="language-javascript">  y = <span class="hljs-number">6</span>;</span><br><span class="language-javascript">    </span><br><span class="language-javascript">  <span class="hljs-comment">//举例： 在 JavaScript 中使用变量可以将某个数据（数值）记录下来！</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 将用户输入的内容保存在 num 这个变量（容器）中</span></span><br><span class="language-javascript">  num = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入一数字!&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 通过 num 变量（容器）将用户输入的内容输出出来</span></span><br><span class="language-javascript">  <span class="hljs-title function_">alert</span>(num);</span><br><span class="language-javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(num);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-声明和赋值"><a href="#2-1-声明和赋值" class="headerlink" title="2.1 声明和赋值"></a>2.1 声明和赋值</h4><p>要想使用变量，首先需要创建变量(专业说法: 声明变量)</p><h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><p>声明(定义)变量有两部分构成：声明关键字<code>let</code>、变量名（标识）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span><br><span class="language-javascript">    <span class="hljs-comment">// let 变量名</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 声明(定义)变量有两部分构成：声明关键字、变量名（标识）</span></span><br><span class="language-javascript">    <span class="hljs-comment">// let 即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语</span></span><br><span class="language-javascript">    <span class="hljs-comment">// age 即变量的名称，也叫标识符</span></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> age;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>let</code> 和 <code>var</code> (variable变量的意思)都是 JavaScript 中的声明变量的关键字，使用关键字声明变量后，计算机会自动为变量分配内存空间，使用变量名来对内存进行访问，推荐使用 <code>let</code> 声明变量！！！</p><blockquote><p>注意：let 不允许多次声明一个变量。</p><p>​            未赋值变量输出为underfined</p><p>​            未声明但赋值的变量依然可以使用</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208042043742.png" alt="image-20220804204345709"></p><h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><p>声明（定义）变量相当于创造了一个空的“容器”，通过赋值向这个容器中添加数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span><br><span class="language-javascript">  <span class="hljs-comment">// 声明(定义)变量有两部分构成：声明关键字、变量名（标识）</span></span><br><span class="language-javascript">  <span class="hljs-comment">// let 即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语</span></span><br><span class="language-javascript">  <span class="hljs-comment">// age 即变量的名称，也叫标识符</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> age;</span><br><span class="language-javascript">  <span class="hljs-comment">// 赋值，将 18 这个数据存入了 age 这个“容器”中</span></span><br><span class="language-javascript">  age = <span class="hljs-number">18</span>;</span><br><span class="language-javascript">  <span class="hljs-comment">// 这样 age 的值就成了 18</span></span><br><span class="language-javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(age);</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-comment">// 也可以声明和赋值同时进行</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world!&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-title function_">alert</span>(str);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-2-关键字"><a href="#2-2-关键字" class="headerlink" title="2.2 关键字"></a>2.2 关键字</h4><p>JavaScript 使用专门的关键字 <code>let</code> 和 <code>var</code> 来声明（定义）变量，在使用时需要注意一些细节：</p><p>以下是使用 <code>let</code> 时的注意事项：</p><ol><li>允许声明和赋值同时进行</li><li>不允许重复声明</li><li>允许同时声明多个变量并赋值</li><li>JavaScript 中内置的一些关键字不能被当做变量名</li></ol><p>以下是使用 <code>var</code> 时的注意事项：</p><ol><li>允许声明和赋值同时进行</li><li>允许重复声明</li><li>允许同时声明多个变量并赋值</li></ol><p>大部分情况使用 <code>let</code> 和 <code>var</code> 区别不大，但是 <code>let</code> 相较 <code>var</code> 更严谨，因此推荐使用 <code>let</code>，后期会更进一步介绍二者间的区别。</p><h4 id="2-3-变量名命名规则"><a href="#2-3-变量名命名规则" class="headerlink" title="2.3 变量名命名规则"></a>2.3 变量名命名规则</h4><p>关于变量的名称（标识符）有一系列的规则需要遵守：</p><ol><li>只能是字母、数字、下划线、$，且不能以数字开头</li><li><strong>字母区分大小写</strong>，如 Age 和 age 是不同的变量</li><li>JavaScript 内部已占用用单词（关键字或保留字）不允许使用</li><li>尽量保证变量具有一定的语义，见字知义，遵守小驼峰命名法</li></ol><p>注：所谓关键字是指 JavaScript 内部使用的词语，如 <code>let</code> 和<code>var</code>，保留字是指 JavaScript 内部目前没有使用的词语，但是将来可能会使用词语。</p><h4 id="2-4-变量扩展——数组"><a href="#2-4-变量扩展——数组" class="headerlink" title="2.4 变量扩展——数组"></a>2.4 变量扩展——数组</h4><p>数组(Array)可以按顺序保存多个数据</p><ul><li>数组是按顺序保存，所以每个数据都有自己的编号</li><li>数组可以存储任意类型的数据</li></ul><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">let names = [&#x27;xm&#x27;,&#x27;ed&#x27;,&#x27;gfb&#x27;,fs]<br></code></pre></td></tr></table></figure><h3 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h3><p>给数据分类是为了更加充分和高效的利用内存，也更加方便程序员的使用数据。</p><p><strong>JavaScript是一种弱类型或者说动态语言</strong>，这意味着不用提前声明变量的类型，在程序运行过程中，类型会根据定义的值被JS引擎自动确定。</p><p>注：通过 typeof 关键字检测数据类型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span><br><span class="language-javascript">    <span class="hljs-comment">// 检测 1 是什么类型数据，结果为 number</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">1</span>);</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JS拥有动态类型，意味着变量的类型是可以改变的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">var x = 6;//x为数字<br>var x = &#x27;Bill&#x27;//x为字符串<br></code></pre></td></tr></table></figure><p>JS数据类型整体分为两大类：</p><ul><li>基本数据类型( Number , String , Boolean , Underfined , Null )</li><li>引用数据类型( object对象, function函数，array数组 )</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208042156147.png" alt="image-20220804215613113"></p><h4 id="3-1-数值类型"><a href="#3-1-数值类型" class="headerlink" title="3.1 数值类型"></a>3.1 数值类型</h4><p>即我们数学中学习到的数字，可以是整数、小数、正数、负数、特殊类型</p><p>JavaScript 中的数值类型与数学中的数字是一样的，分为正数、负数、小数等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> num1 = <span class="hljs-number">3.14</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> num2 = <span class="hljs-number">0xd3</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span>)<span class="hljs-comment">//最大数值</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span>)<span class="hljs-comment">//最小数值</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Infinity</span>)<span class="hljs-comment">//无穷大</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(-<span class="hljs-title class_">Infinity</span>)<span class="hljs-comment">//无穷小</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span>)<span class="hljs-comment">//Not A Number非数值，eg.&#x27;pink&#x27;-100</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>isNaN()这个方法用来判断是否为非数字，返回值为true或者false。</p></blockquote><h4 id="3-2-字符串类型"><a href="#3-2-字符串类型" class="headerlink" title="3.2 字符串类型"></a>3.2 字符串类型</h4><p>通过单引号（ <code>&#39;&#39;</code>） 、双引号（ <code>&quot;&quot;</code>）或反引号包裹的数据都叫字符串，单引号和双引号没有本质上的区别，推荐使用单引号。</p><p>注意事项：</p><ol><li><p>无论单引号或是双引号必须成对使用</p></li><li><p><strong>单引号/双引号可以互相嵌套，但是不以自已嵌套自已</strong>，要么外单内双，要么内单外双</p></li><li><p>必要时可以使用转义符 <code>\</code>，输出单引号或双引号</p><p>| 转义符 | 解释说明                 |<br>| ——— | ———————————— |<br>| <code>\n</code>   | 换行符，n是newline的意思 |<br>| <code>\\</code>   | \                        |<br>| <code>\&#39;</code>   | ‘’                       |<br>| <code>\&quot;</code>   | “”                       |<br>| <code>\t</code>   | Tab 缩进                 |<br>| <code>\b</code>   | Blank 空格               |</p></li></ol><p><strong>模版字符串：</strong></p><p>作用：</p><ol><li>拼接字符串和变量</li><li>如果不用它就要一直用“+”拼接，很麻烦</li></ol><p>语法：</p><ol><li>在英文输入模式下按键盘的tab键上方那个键(1左边那个键) </li><li>内容拼接变量时，用${}包住变量</li></ol><h4 id="3-3-布尔类型"><a href="#3-3-布尔类型" class="headerlink" title="3.3 布尔类型"></a>3.3 布尔类型</h4><p>布尔类型数据有两个固定的值 <code>true</code> 和 <code>false</code>，表示肯定的数据用 <code>true</code>，表示否定的数据用 <code>false</code>。</p><p>布尔类型和数字类型相加的时候，<code>true</code>的值为1，<code>false</code>的值为0。</p><h4 id="3-4-undefined"><a href="#3-4-undefined" class="headerlink" title="3.4 undefined"></a>3.4 undefined</h4><p>未定义是比较特殊的类型，只有一个值 undefined，只声明变量，不赋值的情况下，变量的默认值为 undefined，一般很少【直接】为某个变量赋值为 undefined。</p><p><strong>注：JavaScript 中变量的值决定了变量的数据类型。</strong></p><p><strong>工作中的使用场景:</strong></p><p>我们开发中经常声明一个变量，等待传送过来的数据。</p><p>如果我们不知道这个数据是否传递过来，此时我们可以通过检测这个变量是不是undefined，就判断用户是否有数据传递过来。</p><h4 id="3-5-null空类型"><a href="#3-5-null空类型" class="headerlink" title="3.5 null空类型"></a>3.5 null空类型</h4><p><strong>null</strong> <strong>和</strong> <strong>undefined</strong> <strong>区别:</strong></p><ol><li>undefined 表示没有赋值</li><li>null 表示赋值了，但是内容为空</li></ol><p><strong>null</strong> <strong>开发中的使用场景:</strong></p><ul><li>官方解释:把 null 作为尚未创建的对象</li><li>大白话: 将来有个变量里面存放的是一个对象，但是对象还没创建好，可以先给个null</li></ul><h3 id="四、类型转换"><a href="#四、类型转换" class="headerlink" title="四、类型转换"></a>四、类型转换</h3><blockquote><p>理解弱类型语言的特征，掌握显式类型转换的方法</p></blockquote><p>JavaScript是弱数据类型：JavaScript也不知道变量到底属于那种数据类型，只有赋值了才清楚。</p><p>坑：使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算。</p><p>在 JavaScript 中数据被分成了不同的类型，如数值、字符串、布尔值、undefined，在实际编程的过程中，不同数据类型之间存在着转换的关系。</p><h4 id="4-1-隐式转换"><a href="#4-1-隐式转换" class="headerlink" title="4.1 隐式转换"></a>4.1 隐式转换</h4><ul><li>+号两边只要有一个是字符串，都会把另外一个转成字符串</li><li>除了+以外的算术运算符 比如 - * / 等都会把数据转成数字类型</li><li>+号作为正号解析可以转换成Number</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208050128502.png" alt="image-20220805012849467"></p><p>某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> num = <span class="hljs-number">13</span>; <span class="hljs-comment">// 数值</span></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> num2 = <span class="hljs-string">&#x27;2&#x27;</span>; <span class="hljs-comment">// 字符串</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 结果为 132</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 原因是将数值 num 转换成了字符串，相当于 &#x27;13&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 然后 + 将两个字符串拼接到了一起</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num + num2);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 结果为 11</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 原因是将字符串 num2 转换成了数值，相当于 2</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 然后数值 13 减去 数值 2</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num - num2);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> a = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入一个数字&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> b = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请再输入一个数字&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title function_">alert</span>(a + b);</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注：数据类型的隐式转换是 JavaScript 的特征，后续学习中还会遇到，目前先需要理解什么是隐式转换。</p><h4 id="4-2显式转换"><a href="#4-2显式转换" class="headerlink" title="4.2显式转换"></a>4.2显式转换</h4><p>编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。</p><h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><p>通过 <code>Number</code> 显示转换成数值类型，当转换失败时结果为 <code>NaN</code>（Not a Number）即不是一个数字。 </p><ul><li>Number(数据) <ul><li>转成数字类型</li><li>如果字符串内容里有非数字，转换失败时结果为 NaN(Not a Number)即不是一个数字 </li><li>NaN也是number类型的数据，代表非数字</li></ul></li><li><p>parseInt(数据)</p><ul><li>只保留整数</li></ul></li><li><p>parseFloat(数据) </p><ul><li>可以保留小数</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> t = <span class="hljs-string">&#x27;12&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> f = <span class="hljs-number">8</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 显式将字符串 12 转换成数值 12</span></span><br><span class="language-javascript">    t = <span class="hljs-title class_">Number</span>(t);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 检测转换后的类型</span></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(typeof t);</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t + f); <span class="hljs-comment">// 结果为 20</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 并不是所有的值都可以被转成数值类型</span></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-comment">// 将 hello 转成数值是不现实的，当无法转换成</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 数值时，得到的结果为 NaN （Not a Number）</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(str));</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> num = <span class="hljs-number">3.14</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-title class_">Number</span>(num))</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-built_in">parseInt</span>(num))</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-built_in">parseFloat</span>(num))</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h5><p>转换为字符型：</p><ul><li>String(数据)</li><li>变量.toString(进制)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> num = <span class="hljs-title class_">String</span>(<span class="hljs-number">163</span>)</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> num)</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>产品经理Axure</title>
    <link href="/2022/07/26/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86Axure/"/>
    <url>/2022/07/26/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86Axure/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="产品微课"><a href="#产品微课" class="headerlink" title="产品微课"></a>产品微课</h1><h2 id="1-产品经理工作内容"><a href="#1-产品经理工作内容" class="headerlink" title="1. 产品经理工作内容"></a>1. 产品经理工作内容</h2><p><strong>初级产品经理</strong></p><ul><li><p>接需求、画原型、写文档; </p></li><li><p>开会、开会、开会;</p><ul><li><strong>如果你的文档或者需求没有传达清楚，会这样:</strong> 收到设计师、前端、研发、测试的抱怨或投诉(你这需求怎么老 是在变…具体需求到底是什么样子的，能不能一次性说清楚) ;</li></ul></li></ul><p><strong>高级产品经理</strong></p><ol><li>带产品团队、培训新人; </li><li>规划产品发展路线;</li><li>参与设计商业模式;</li><li>负责公司的业务板块; </li></ol><p><strong>产品经理分类</strong></p><ol><li>产品经理分类1：<ol><li>B(Business)端产品经理：重功能；</li><li>C(Customer)端产品经理：重体验；</li></ol></li><li>产品经理分类2：<ol><li>前台产品经理：重体验；</li><li>后台产品经理：重逻辑；</li></ol></li><li>产品经理分类3：<ol><li>APP端产品经理；</li><li>WEB端产品经理；</li><li>PC端产品经理；</li><li>区别：不同的交互思想，不同的设计规范；</li></ol></li></ol><h2 id="2-产品经理的日常产出物"><a href="#2-产品经理的日常产出物" class="headerlink" title="2. 产品经理的日常产出物"></a>2. 产品经理的日常产出物</h2><ol><li><p>产品经理的日常五类产出物：</p><ol><li><p>流程图；</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207261940177.png" alt="image-20220726192518946"></p></li><li><p>产品结构图；</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207261941069.png" alt="image-20220726194158039"></p></li><li><p>竞品分析文档；</p><ol><li>竞品的分类;</li><li>竞品的选择;</li><li>竞品信息的采集;</li><li>竞品分析文档的撰写;</li></ol></li><li><p>需求列表；</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207261944263.png" alt="image-20220726194415238"></p><ol><li>原型；</li></ol></li></ol><h2 id="3-流程图介绍及分类"><a href="#3-流程图介绍及分类" class="headerlink" title="3. 流程图介绍及分类"></a>3. 流程图介绍及分类</h2><ol><li><p>流程图的三种分类：</p><ol><li><p>业务流程图；</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207261945226.png" alt="image-20220726194506186"></p></li><li><p>页面流程图；</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207261945752.png" alt="image-20220726194527721"></p></li><li><p>数据流程图；（泳道图）</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207261946518.png" alt="image-20220726194603486"></p></li></ol></li><li><p>流程图注意事项：</p><ol><li>流程图有开始和结束；</li><li>注意，不能出现交叉线；</li><li>不同的操作使用不同的图形；</li><li>出现判定时，一定有是和否两种情况；</li></ol></li><li><p>Process on流程图快捷键</p><p><strong>通用</strong></p><p>|   键位   |                            功能                            |<br>| :———: | :————————————————————————————: |<br>|   Alt    |            按住Alt，通过数据可以对页面进行拖动             |<br>|   Ctrl   | 按住Ctrl，点击一个图形，将其添加到选择图形中，或者从中移除 |<br>|    L     |                          插入连线                          |<br>| Alt+(+/) |                       视图放大或缩小                       |<br>|    T     |                          插入文本                          |<br>|    I     |                          插入图片                          |</p><p><strong>图形被选中时</strong></p><p>| 箭头 (←↑↓→)            | 将选中图形向左、向上、向下、向右移动 |<br>| ——————————— | —————————————————— |<br>| Ctrl+Shift+B           | 格式刷                               |<br>| 调整图形大小时按住Ctrl | 调整图形大小，并且约束比例           |<br>| Ctrl+D                 | 复用                                 |<br>| Ctrl+[                 | 将选中的图形置于底层                 |<br>| Ctrl+shift+]           | 将选中的图形上移一层                 |<br>| Ctrl+shift+[           | 将选中的图形下移一层                 |<br>| Ctrl+L                 | 锁定选中的图形                       |<br>| Ctrl+shift+L           | 将选中的图形解锁                     |<br>| Ctrl+G                 | 组合选中的图形                       |<br>| Ctrl+shift+G           | 将选中的图形取消组合                 |</p></li></ol><h2 id="4-原型的概念及分类"><a href="#4-原型的概念及分类" class="headerlink" title="4. 原型的概念及分类"></a>4. 原型的概念及分类</h2><ol><li><p>三种原型：</p><ol><li><p>草图原型：手绘图稿，修改方便，规划的早期使用;</p></li><li><p>低保真原型：简单交互，无设计图，无需配色，黑白灰即可，产品经理做产品规划及评审的阶段使用;</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207262005346.png" alt="image-20220726200544323"></p></li><li><p>高保真原型：复杂交互，有设计图，需要有图片设计功底，做公开演示时候常用。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207262006901.png" alt="image-20220726200620876"></p></li></ol></li><li><p>Axure简介：用于快速制作原型的软件，它在无需编码的情况下构建低、高保真的原型，只需拖、拉、编辑即可完成;</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">原型:<br>介绍：用线条、图形描绘出的产品框架，也称线框图，是需求和功能的<br>具体化表象;<br>作用：1、因为原型是需求和功能的具体化表象，所以原型可以辅助产品经理 与领导、UI、和技术进行沟通; 2、因为原型相对于手稿而言，信息含量更丰富。<br></code></pre></td></tr></table></figure></li></ol><ol><li>对产品经理的要求：使用Axure制作低保真原型；</li></ol><h2 id="5-Axure常用功能介绍"><a href="#5-Axure常用功能介绍" class="headerlink" title="5. Axure常用功能介绍"></a>5. Axure常用功能介绍</h2><p><strong>鼠标操作</strong></p><ol><li>选择：与“相交选中”相比，建议大家都使用“包含选中”——选择范围更为精确，不容易误操作；</li><li>缩放：按住shift键，可以实现等比例缩放；</li><li>对齐、分布：快速实现页面布局；</li></ol><p><strong>演示操作</strong></p><ol><li><p>预览：产品经理跟项目组同事演示原型时使用；<strong>预览原型时，点击站点导航处的小箭头，可以看到所有带交互的元件</strong></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207272048443.png" alt="产品必会的30个Axure使用技巧"></p></li><li><p>发布：产品经理将原型文件共享给项目组同事时，可以使用；</p><ol><li>发布功能中，可以设置预览选项：发布 → 预览选项 → 配置 → 标志；</li></ol></li><li><p>共享：需要登录个人账号之后使用；</p><ol><li>作用：给面试官发原型；或者，当你不想给别人发源文件，但是又需要共享原型的时候，可以使用；</li></ol></li><li><p>拖动页面名称</p><p>鼠标选择左侧画板里的页面名称，直接拖入画布里，会出现页面名称的按钮框，可以用来做流程图，点击页面名称按钮框，会直接跳转到对应页面。</p></li></ol><h2 id="6-产品结构图"><a href="#6-产品结构图" class="headerlink" title="6. 产品结构图"></a>6. 产品结构图</h2><p><strong>分类</strong></p><ul><li><p>产品功能结构图:专注在功能模块，再逐级延展;</p></li><li><p>产品信息结构图:产品需要承载的信息;</p></li><li><p>产品结构图:功能与信息的集合，将功能和信息呈现在不同的页面;</p></li></ul><h3 id="产品功能结构图"><a href="#产品功能结构图" class="headerlink" title="产品功能结构图"></a><strong>产品功能结构图</strong></h3><ol><li>功能结构图，侧重点在于功能；就是将产品功能按照从属关系，绘制出来。</li><li>制作方法：<ol><li>先根据产品的一级页面(比如微信有四个:微信、通讯录、发现、我)找出产品主功能模块，然后按照层级归属关系详叙该功能模块提供的下一级功能模块或功能;</li><li><strong>在描述一个功能名称的时候，建议使用“动词+名词”的方式，这种描述方式更容易被大家所理解。</strong> 例如:将“名字”改为“设置名字”或者“查看并设置名字”;</li></ol></li><li>适用场景：<ol><li>在产品规划初期，考虑产品功能细节时使用；</li></ol></li><li>示例：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207271201015.png" alt="image-20220727120148978"></li></ol><h3 id="产品信息结构图"><a href="#产品信息结构图" class="headerlink" title="产品信息结构图"></a>产品信息结构图</h3><ol><li><p>概念：指脱离产品的实际页面，将产品的<strong>数据</strong>抽象出来，组合分类的图表;</p></li><li><p>作用：</p><ul><li><p>帮助梳理复杂内容的信息组成，避免信息内容在展示过程中出现遗漏、混乱、重复; </p></li><li><p>作为开发工程师建立数据库的参考依据; </p></li><li><p>信息结构图主要适用于产品信息构成比较复杂需要考虑优化的情况，如内容型产品 (博客、web门户网站等)，产品的信息结构对于用户体验就十分重要，需要用信息结 构图作为工具进行分析思考;</p></li></ul></li></ol><ol><li>示例：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207271208238.png" alt="image-20220727120806199"></li></ol><h3 id="产品结构图："><a href="#产品结构图：" class="headerlink" title="产品结构图："></a><strong>产品结构图：</strong></h3><ul><li><p>概念:产品结构图是综合展示产品信息和功能逻辑的图表，简单说产品结构图就是产品原型的简化表达。</p></li><li><p>作用:</p><ul><li>它能够在前期的需求评审中或其他类似场景中作为产品原型的替代; </li><li>其实现成本低，能够快速对产品功能结构进行增、删、改操作，减少PM在这个过程中的实现成本;</li></ul></li><li><p>方法:功能 + 信息;先列出一级页面，再列出页面中的功能和信息，逐级展开;</p></li><li><p>注意:</p><ul><li>重点功能和页面，重点制作，层级尽量深;</li><li><p>结构层级尽量细致;</p></li><li><p>产品经理一定要会制作产品结构图；信息结构图，以了解为主，如果需要制作，更多的是考虑产品中的信息字段；</p></li></ul></li><li><p>结构图和原型的关系</p><ul><li><strong>先有结构图，后有原型</strong></li></ul></li><li><p>产品结构图的使用场景：</p><ol><li>做产品规划时使用，通过结果图梳理产品框架，再进行产品设计；</li><li>竞品分析时，也需要制作产品结构图；</li></ol></li><li><p>Xmind软件使用：建议记住常用操作的快捷键；</p><p>| 快捷键（Mac）        | 描述（以下的文件，都指的是Xmind文件） |<br>| —————————— | ——————————————————- |<br>| Command + N          | 建立新的文件                          |<br>| Command + O          | 打开文件                              |<br>| Command + S          | 保存当前文件                          |<br>| Command +  Shift + S | 保存全部文件                          |<br>| Command + W          | 关闭当前文件                          |<br>| Command +  Shift + W | 关闭全部文件                          |<br>| Command + Z          | 返回上一步（撤销）                    |<br>| Command + Y          | 重做                                  |<br>| Command + X          | 剪切                                  |<br>| Command + C          | 复制                                  |<br>| Command + V          | 粘贴                                  |<br>| Delete               | 删除                                  |<br>| Command + A          | 选择全部节点                          |<br>| Command +  Shift + A | 选择同级节点                          |<br>| Command + Alt  + A   | 选择子节点                            |<br>| Command + +          | 放大                                  |<br>| Command + -          | 缩小                                  |<br>| Command + =          | 正常大小                              |<br>| Command + ]          | 插入摘要                              |<br>| Enter                | 在下方添加同级别的节点                |<br>| Tab                  | 添加子节点                            |<br>| Shift + Enter        | 在上方添加同级别的节点                |<br>| Command +  Enter     | 添加当前节点的父节点                  |<br>| Command + I          | 插入图片                              |<br>| Command +  Shift + H | 插入超链接                            |<br>| Command + B          | 添加外框                              |<br>| Command + L          | 添加关联                              |<br>| F2                   | 编辑节点内容                          |<br>| F3                   | 给当前节点添加标签                    |<br>| F4                   | 给当前节点添加备注                    |<br>| +                    | 展开当前节点                          |<br>| -                    | 收缩当前节点                          |<br>| *                    | 展开所有节点                          |</p></li></ul><h2 id="7-Axure基本操作"><a href="#7-Axure基本操作" class="headerlink" title="7. Axure基本操作"></a>7. Axure基本操作</h2><div class="table-container"><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>⌘+Enter</td><td>添加新界面</td></tr><tr><td>⇧+上下左右键</td><td>一次调整十个像素</td></tr><tr><td>⌃多选</td><td>可以选中多个组件</td></tr><tr><td>⇧</td><td>等比例缩放</td></tr><tr><td>双击</td><td>编辑文字</td></tr></tbody></table></div><p><strong>矩形和图片</strong></p><ol><li>矩形的圆角设置：<ol><li>拖动矩形元件左上方的黄色小三角；</li><li>在“检视 - 样式 - 圆角半径”中进行设置；</li></ol></li><li>图片的导入：<ol><li>原尺寸导入图片：当图片元件的四角为黄色的小正方形时，导入图片为原尺寸；</li><li>根据给定尺寸导入图片：当图片元件的四角为白色的小正方形时，导入的图片会根据给定尺寸进行压缩；</li></ol></li></ol><p><strong>文本框</strong></p><ol><li>文本框：<ol><li>注意，可以设置文本类型，以及边框的可见性、提示文字的隐藏触发；</li><li>拖拽文本框元件后，右侧面板里可选择不同的文本框类型，选择不同的类型可以达到不同的效果。如：<ol><li>密码格式：输入的内容会被隐藏</li><li>数字格式：只能输入数字</li><li>文件格式：可以选择文件</li><li>日期格式：可以直接选择日期</li></ol></li><li>另外，文本框里的预置文字，可以直接在右侧“提示文字”框输入。</li></ol></li><li>下拉框：<ol><li>可以批量设置选项；</li></ol></li><li>单选、复选：<ol><li>如果要制作单选的效果，需要设置单选按钮组（选中全部的选项，右键，选择“设置单选按钮组”）；</li></ol></li></ol><p><strong>页面快照</strong></p><p>拖动页面快照到画布里，选择对应的页面，会出现页面预览，点击可进入对应页面。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207272101441.png" alt="产品必会的30个Axure使用技巧"></p><p><strong>常用交互</strong></p><ol><li><p>鼠标悬停、鼠标按下、选中、禁用：</p><ol><li>检视 - 属性 - 形状 - 交互样式设置；</li><li>选中：为了设置选中的交互效果，要先设置选中的效果，再添加选中的交互事件；</li><li>当我们需要给某个元件添加交互动作时，需要给元件命名；</li></ol></li><li><p>设置toggle效果——<strong>实现点击时显示，再次点击时隐藏</strong></p><ol><li><p>检视 - 属性 - 交互 - 鼠标单击时 - 选中 - true下拉框改为toggle就可以；</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207272102075.png" alt="产品必会的30个Axure使用技巧"></p></li></ol></li><li><p><strong>一个元件上添加多个事件</strong></p><p>同一个元件会出现多种 case，如点击登录按钮后出现的多种情况。虽然可以通过添加条件判断来做区分，但是一般比较费时。不那么严格的情况下，我们可以将多个事件添加同一个元件上，对事件进行命名来区分。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207272044206.png" alt="产品必会的30个Axure使用技巧"></p></li><li><p><strong>按住 Ctrl，将鼠标放在元件的边缘，移动鼠标，就可以旋转部件</strong></p></li></ol><p><strong>元件库和母版</strong></p><ol><li><p>元件库、母版最大的作用：</p><ol><li><p>极大的提高原型制作效率；</p></li><li><p>最好的元件库，都是自己做的；</p></li><li><p><strong>在网站上找Icon</strong></p><p>搜索自己需要的Icon类型，点击复制SVG，粘贴进Axure面板里，点击鼠标右键，选择“转化成矢量图”，就可以对Icon进行颜色的填充与修改了。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207272145020.png" alt="产品必会的30个Axure使用技巧"></p></li></ol></li><li><p><strong>重复的元件可以转化成母版</strong></p><ul><li><p>使用到母版元件一样的元件时，直接在母版区拖进画布使用。</p></li><li><p>双击母版元件，就会进入到母版编辑窗口，修改后的元件会同步到所有母版元件。</p></li></ul><p><strong>注意：</strong></p><ul><li>使用母版元件时，元件里所有的样式和交互都是一样的。实际工作中，肯定存在不同交互，这时可以<strong>“点击鼠标右键——脱离母版”，</strong>然后对这个元件单独操作。</li><li>不要把元件过多的组合变成母板，元件组合越是越多，越可能需要在母版的元件上做修改。</li></ul></li></ol><p><strong>常见的原型规范</strong></p><ol><li><p>在企业中制作原型时，只制作iOS端原型；</p><p>web 原型大小：1440×900/1200×900，app 原型尺寸：375×667</p></li><li><p>产品经理在制作原型时，需要遵循的规范（移动端）：</p><ol><li>手机框大小：375*667px；<ol><li>某些页面比较长，比如说淘宝首页，这个时候，可以忽略667的限制；</li></ol></li><li>状态栏，高度20px；</li><li>导航栏，高度44px；</li><li>标签栏，高度49px；字体大小10，图标大小25*25；</li><li>一级按钮，高度40px；</li><li>推荐材料《iOS交互设计规范》；</li></ol></li></ol><p><strong>页面流程图、泳道图</strong></p><ol><li>使用Axure可以制作页面流程图；</li><li>使用Axure可以制作泳道图；</li></ol><p><strong>动态面板</strong>——固定到浏览器的某个位置</p><p>比如：将弹窗在屏幕中间显示、导航固定在顶部。都可以通过固定到浏览器实现。</p><p>步骤如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207272047039.png" alt="产品必会的30个Axure使用技巧"></p><h2 id="8-Axure交互操作"><a href="#8-Axure交互操作" class="headerlink" title="8. Axure交互操作"></a>8. Axure交互操作</h2><p>用axure做交互设计主要需理解它的两个方面逻辑：即<strong>事件与动作。</strong></p><p><strong>事件：即触发机制。也就是说，在用户做什么行为的时候，触发了后面所设置的一系列动作。</strong>要想做好AXURE的交互设计，必须需要熟练掌握axure都有哪些交互事件。只有灵活的应用这些事件，才可能快速灵活的掌握原型。这些事件，大部分是针对鼠标的动作。另外有一些是针对元件的状态和键盘产生的动作。</p><p>axure的所有交互设计，都是通过这个逻辑来完成的:</p><p>设置事件 $\rightarrow$添加动作$\rightarrow$设置动作的具体选项</p><p>设置了事件后，必须要设定对应的动作。如果有多个动作，则需要排列好所有已加入的动作。<strong>动作一共分为五大类，即：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207271853062.png" alt="image-20220727185344990"></p><p>这里面用的最多的动作，主要就是链接类和元件类。其中又数以下几个用的频率最高，基本上常用的原型中的交互，80%以上用的最多的就是以下三种的组合应用：</p><ul><li><p><strong>打开链接</strong></p></li><li><p><strong>显示/隐藏</strong></p></li><li><p><strong>设置面板状态</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>产品经理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>产品经理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习第四周</title>
    <link href="/2022/07/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E5%91%A8/"/>
    <url>/2022/07/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E5%91%A8/</url>
    
    <content type="html"><![CDATA[<hr><p>上篇主要介绍了贝叶斯分类器，从贝叶斯公式到贝叶斯决策论，再到通过极大似然法估计类条件概率，贝叶斯分类器的训练就是参数估计的过程。朴素贝叶斯则是“属性条件独立性假设”下的特例，它避免了假设属性联合分布过于经验性和训练集不足引起参数估计较大偏差两个大问题，最后介绍的拉普拉斯修正将概率值进行平滑处理。本篇将介绍另一个当选为数据挖掘十大算法之一的<strong>EM算法</strong>。</p><h1 id="8、EM算法"><a href="#8、EM算法" class="headerlink" title="8、EM算法"></a><strong>8、EM算法</strong></h1><p>EM（Expectation-Maximization）算法是一种常用的估计参数隐变量的利器，也称为“期望最大算法”，是数据挖掘的十大经典算法之一。EM算法主要应用于训练集样本不完整即存在隐变量时的情形（例如某个属性值未知），通过其独特的“两步走”策略能较好地估计出隐变量的值。</p><h2 id="8-1-EM算法思想"><a href="#8-1-EM算法思想" class="headerlink" title="8.1 EM算法思想"></a><strong>8.1 EM算法思想</strong></h2><p>EM是一种迭代式的方法，它的基本思想就是：若样本服从的分布参数θ已知，则可以根据已观测到的训练样本推断出隐变量Z的期望值（E步），若Z的值已知则运用最大似然法估计出新的θ值（M步）。重复这个过程直到Z和θ值不再发生变化。</p><p>简单来讲：假设我们想估计A和B这两个参数，在开始状态下二者都是未知的，但如果知道了A的信息就可以得到B的信息，反过来知道了B也就得到了A。可以考虑首先赋予A某种初值，以此得到B的估计值，然后从B的当前值出发，重新估计A的取值，这个过程一直持续到收敛为止。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843bf53eb2.png" alt="1.png"></p><p>现在再来回想聚类的代表算法K-Means：【首先随机选择类中心=&gt;将样本点划分到类簇中=&gt;重新计算类中心=&gt;不断迭代直至收敛】，不难发现这个过程和EM迭代的方法极其相似，事实上，若将样本的类别看做为“隐变量”（latent variable）Z，类中心看作样本的分布参数θ，K-Means就是通过EM算法来进行迭代的，与我们这里不同的是，K-Means的目标是最小化样本点到其对应类中心的距离和，上述为极大化似然函数。</p><h2 id="8-2-EM算法数学推导"><a href="#8-2-EM算法数学推导" class="headerlink" title="8.2 EM算法数学推导"></a><strong>8.2 EM算法数学推导</strong></h2><p>在上篇极大似然法中，当样本属性值都已知时，我们很容易通过极大化对数似然，接着对每个参数求偏导计算出参数的值。但当存在隐变量时，就无法直接求解，此时我们通常最大化已观察数据的对数“边际似然”（marginal likelihood）。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843bfd84d2.png" alt="2.png"></p><p>这时候，通过边缘似然将隐变量Z引入进来，对于参数估计，现在与最大似然不同的只是似然函数式中多了一个未知的变量Z，也就是说我们的目标是找到适合的θ和Z让L(θ)最大，这样我们也可以分别对未知的θ和Z求偏导，再令其等于0。</p><p>然而观察上式可以发现，和的对数（ln(x1+x2+x3)）求导十分复杂，那能否通过变换上式得到一种求导简单的新表达式呢？这时候 Jensen不等式就派上用场了，先回顾一下高等数学凸函数的内容：</p><p><strong>Jensen’s inequality</strong>：过一个凸函数上任意两点所作割线一定在这两点间的函数图象的上方。理解起来也十分简单，对于凸函数f(x)’’&gt;0，即曲线的变化率是越来越大单调递增的，所以函数越到后面增长越厉害，这样在一个区间下，函数的均值就会大一些了。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843c064c72.png" alt="3.png"></p><p>因为ln(*)函数为凹函数，故可以将上式“和的对数”变为“对数的和”，这样就很容易求导了。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843c3490ad.png" alt="4.png"></p><p>接着求解Qi和θ：首先固定θ（初始值），通过求解Qi使得J（θ，Q）在θ处与L（θ）相等，即求出L（θ）的下界；然后再固定Qi，调整θ，最大化下界J（θ，Q）。不断重复两个步骤直到稳定。通过jensen不等式的性质，Qi的计算公式实际上就是后验概率：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843c21276c.png" alt="5.png"></p><p>通过数学公式的推导，简单来理解这一过程：固定θ计算Q的过程就是在建立L（θ）的下界，即通过jenson不等式得到的下界（E步）；固定Q计算θ则是使得下界极大化（M步），从而不断推高边缘似然L（θ）。从而循序渐进地计算出L（θ）取得极大值时隐变量Z的估计值。</p><p>EM算法也可以看作一种“坐标下降法”，首先固定一个值，对另外一个值求极值，不断重复直到收敛。这时候也许大家就有疑问，问什么不直接这两个家伙求偏导用梯度下降呢？这时候就是坐标下降的优势，有些特殊的函数，例如曲线函数z=y^2+x^2+x^2y+xy+…，无法直接求导，这时如果先固定其中的一个变量，再对另一个变量求极值，则变得可行。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843c34e7ff.png" alt="6.png"></p><h2 id="8-3-EM算法流程"><a href="#8-3-EM算法流程" class="headerlink" title="8.3 EM算法流程"></a><strong>8.3 EM算法流程</strong></h2><p>看完数学推导，算法的流程也就十分简单了，这里有两个版本，版本一来自西瓜书，周天使的介绍十分简洁；版本二来自于大牛的博客。结合着数学推导，自认为版本二更具有逻辑性，两者唯一的区别就在于版本二多出了红框的部分，这里我也没得到答案，欢迎骚扰讨论~</p><p><strong>版本一：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843c0e19db.png" alt="7.png"></p><p><strong>版本二：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843c34775b.png" alt="8.png"></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习第三周</title>
    <link href="/2022/07/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%91%A8/"/>
    <url>/2022/07/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%91%A8/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="7、贝叶斯分类器"><a href="#7、贝叶斯分类器" class="headerlink" title="7、贝叶斯分类器"></a><strong>7、贝叶斯分类器</strong></h1><p>贝叶斯分类器是一种概率框架下的统计学习分类器，对分类任务而言，假设在相关概率都已知的情况下，贝叶斯分类器考虑如何基于这些概率为样本判定最优的类标。在开始介绍贝叶斯决策论之前，我们首先来回顾下概率论基础知识：</p><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p><strong>一、全概率公式&amp;贝叶斯公式</strong></p><p>在介绍先验、后验概率之前我们先来复习一下全概率公式和贝叶斯公式</p><p><strong>全概率公式：</strong>设事件$B_1,B_2,…,B_n$构成一个完备事件组，即它们两两不相容，和为全集且$P(B_i)&gt;0$ ，则对任一事件$A$有：</p><script type="math/tex; mode=display">P(A)=\sum^n_{i=1}P(B_i)P(A|B_i)</script><p>可以看出，全概率公式是“由因推果”的思想，当知道某件事的原因后，推断由某个原因导致这件事发生的概率为多少。</p><p><strong>贝叶斯公式：</strong>符号定义与全概率公式相同，则：</p><script type="math/tex; mode=display">P(B_i|A)=\frac{P(B_i)P(A|B_i)}{P(A)}=\frac{P(B_i)P(A|B_i)}{\sum^n_{i=1}P(B_i)P(A|B_i)}</script><p>可以看出，贝叶斯公式是“由果溯因”的思想，当知道某件事的结果后，由结果推断这件事是由各个原因导致的概率为多少。</p><p><strong>二、先验概率&amp;后验概率</strong></p><p><strong>先验概率(prior probability)：</strong>指根据以往经验和分析。在实验或采样前就可以得到的概率。</p><p><strong>后验概率(posterior probability)：</strong>指某件事已经发生，想要计算这件事发生的原因是由某个因素引起的概率。</p><p>可以看出，先验概率就是事先可估计的概率分布，而后验概率类似贝叶斯公式“由果溯因”的思想。下面我们通过PRML(Pattern Recognition and Machine Learning)这本书中的例子来理解一下上面的定义。</p><p>假设我们现在有两个盒子，分别为红色和蓝色。在红色盒子中放着2个苹果和6个橙子，在蓝色盒子中放着1个橙子和3个苹果，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-15d6cca9e407d3bfa11404a6169821cd_r.jpg" alt="preview"></p><p>图中绿色表示苹果，橙色代表橙子。假设我们每次实验的时候会随机从某个盒子里挑出一个水果，随机变量B(box)表示挑出的是哪个盒子，并且P(B=blue) = 0.6(蓝色盒子被选中的概率)，P(B=red) = 0.4(红色盒子被选中的概率)。随机变量F(fruit)表示挑中的是哪种水果，F的取值为”a (apple)”和”o (orange)”。</p><p>现在假设我们已经得知某次实验中挑出的水果是orange，那么这个orange是从红色盒子里挑出的概率是多大呢？依据贝叶斯公式有：</p><script type="math/tex; mode=display">P(B=red|F=o)=\frac{P(F=o|B=red)P(B=red)}{P(F=o)}=\frac{3}{4}\times \frac{4}{10}\times \frac{20}{9}=\frac{2}{3}</script><p>同时，由概率的加法规则我们可以得到：</p><script type="math/tex; mode=display">P(B=blue|F=o)=1-\frac{2}{3}=\frac{1}{3}</script><p>在上面的计算过程中，我们将$P(B=red)$或者说 $P(B)$称为先验概率(prior probability)，因为我们在得到F是“a”或者“o”之前，就可以得到 $P(B)$。同理，将$P(B=red|F=o)$和$P(=blue|F=o)$称为后验概率，因为我们在完整的一次实验之后也就是得到了F的具体取值之后才能得到这个概率。</p><h2 id="7-1-贝叶斯决策论"><a href="#7-1-贝叶斯决策论" class="headerlink" title="7.1 贝叶斯决策论"></a><strong>7.1 贝叶斯决策论</strong></h2><p>在机器学习训练模型的过程中，往往我们都试图去优化一个风险函数，因此在概率框架下我们也可以为贝叶斯定义“<strong>条件风险</strong>”(conditional risk)。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd15db94-20220704215035193.png" alt="2.png"></p><p>我们的任务就是寻找一个判定准则最小化所有样本的条件风险总和，因此就有了<strong>贝叶斯判定准则</strong>(Bayes decision rule):为最小化总体风险，只需在每个样本上选择那个使得条件风险最小的类标。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd308600.png" alt="3.png"></p><p>若损失函数$λ$取0-1损失，则有：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220714170548970.png" alt="image-20220714170548970"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd37c502.png" alt="4.png"></p><p>即对于每个样本$x$，选择其后验概率$P(c | x)$最大所对应的类标，能使得总体风险函数最小，从而将原问题转化为估计后验概率$P(c | x)$。一般这里有两种策略来对后验概率进行估计：</p><pre><code class="hljs">* 判别式模型：直接对 P(c | x)进行建模求解。例我们前面所介绍的决策树、神经网络、SVM都是属于判别式模型。* 生成式模型：通过先对联合分布P(x,c)建模，从而进一步求解 P(c | x)。</code></pre><p>贝叶斯分类器就属于生成式模型，基于贝叶斯公式对后验概率$P(c | x) $进行一项神奇的变换，巴拉拉能量…. $P(c | x)$变身：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd501ad3.png" alt="5.png"></p><p>对于给定的样本$x，P(x)$与类标无关，$P(c)$称为类先验概率，$p(x | c )$称为类条件概率。这时估计后验概率$P(c | x)$就变成为估计类先验概率和类条件概率的问题。</p><p>对于类先验概率$P(c)，p(c)$就是样本空间中各类样本所占的比例，根据大数定理(当样本足够多时，频率趋于稳定等于其概率)，这样当训练样本充足时，$p(c)$可以使用各类出现的频率来代替。因此只剩下类条件概率$p(x | c )$，它表达的意思是在类别$c$中出现$x$的概率，它涉及到属性的联合概率问题，若只有一个离散属性还好，当属性多时采用频率估计起来就十分困难，因此这里一般采用极大似然法进行估计。</p><h2 id="7-2-极大似然法"><a href="#7-2-极大似然法" class="headerlink" title="7.2 极大似然法"></a><strong>7.2 极大似然法</strong></h2><p>极大似然估计(Maximum Likelihood Estimation，简称MLE)，是一种根据数据采样来估计概率分布的经典方法。常用的策略是先假定总体具有某种确定的概率分布，再基于训练样本对概率分布的参数进行估计。运用到类条件概率p(x | c )中，假设p(x | c )服从一个参数为θ的分布，问题就变为根据已知的训练样本来估计θ。极大似然法的核心思想就是：估计出的参数使得已知样本出现的概率最大，即使得训练数据的似然最大。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd70fb73.png" alt="7.png"></p><p>所以，贝叶斯分类器的训练过程就是参数估计。总结最大似然法估计参数的过程，一般分为以下四个步骤：</p><pre><code class="hljs">* 1.写出似然函数；* 2.对似然函数取对数，并整理；* 3.求导数，令偏导数为0，得到似然方程组；* 4.解似然方程组，得到所有参数即为所求。</code></pre><p>例如：假设样本属性都是连续值，p(x | c )服从一个多维高斯分布，则通过MLE计算出的参数刚好分别为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd705729-20220704215050820.png" alt="8.png"></p><p>上述结果看起来十分合乎实际，但是采用最大似然法估计参数的效果很大程度上依赖于作出的假设是否合理，是否符合潜在的真实数据分布。这就需要大量的经验知识，搞统计越来越值钱也是这个道理，大牛们掐指一算比我们搬砖几天更有效果。</p><h2 id="7-3-朴素贝叶斯分类器"><a href="#7-3-朴素贝叶斯分类器" class="headerlink" title="7.3 朴素贝叶斯分类器"></a><strong>7.3 朴素贝叶斯分类器</strong></h2><p>不难看出：原始的贝叶斯分类器最大的问题在于联合概率密度函数的估计，首先需要根据经验来假设联合概率分布，其次当属性很多时，训练样本往往覆盖不够，参数的估计会出现很大的偏差。为了避免这个问题，朴素贝叶斯分类器(naive Bayes classifier)采用了“属性条件独立性假设”，即样本数据的所有属性之间相互独立。这样类条件概率p(x | c )可以改写为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd55e102.png" alt="9.png"></p><p>这样，为每个样本估计类条件概率变成为每个样本的每个属性估计类条件概率。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd6678cd.png" alt="10.png"></p><p>相比原始贝叶斯分类器，朴素贝叶斯分类器基于单个的属性计算类条件概率更加容易操作，需要注意的是：若某个属性值在训练集中和某个类别没有一起出现过，这样会抹掉其它的属性信息，因为该样本的类条件概率被计算为0。因此在估计概率值时，常常用进行平滑(smoothing)处理，拉普拉斯修正(Laplacian correction)就是其中的一种经典方法，具体计算方法如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fe54aaed.png" alt="11.png"></p><p>当训练集越大时，拉普拉斯修正引入的影响越来越小。对于贝叶斯分类器，模型的训练就是参数估计，因此可以事先将所有的概率储存好，当有新样本需要判定时，直接查表计算即可。</p><p>针对朴素贝叶斯，人们觉得它too sample，sometimes too naive！因此又提出了半朴素的贝叶斯分类器，具体有SPODE、TAN、贝叶斯网络等来刻画属性之间的依赖关系，此处不进行深入，等哪天和贝叶斯邂逅了再回来讨论。在此鼎鼎大名的贝叶斯介绍完毕，下一篇将介绍这一章剩下的内容—EM算法，朴素贝叶斯和EM算法同为数据挖掘的十大经典算法，想着还是单独介绍吧~</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS布局</title>
    <link href="/2022/06/30/CSS%E5%B8%83%E5%B1%80/"/>
    <url>/2022/06/30/CSS%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h1><p><a class="btn" href="url" title="title">text</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端&amp;CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS基础</title>
    <link href="/2022/06/30/CSS/"/>
    <url>/2022/06/30/CSS/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.  概述"></a>1.  概述</h2><p>==CSS 是一门语言，用于控制网页表现。==我们之前介绍过W3C标准。W3C标准规定了网页是由以下组成：</p><ul><li>结构：HTML</li><li>表现：CSS</li><li>行为：JavaScript</li></ul><p>CSS也有一个专业的名字：==Cascading Style Sheet（层叠样式表）。==</p><p>如下面的代码， <code>style</code> 标签中定义的就是css代码。该代码描述了将 div 标签的内容的字体颜色设置为 红色。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello CSS~<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-CSS导入方式"><a href="#2-CSS导入方式" class="headerlink" title="2.  CSS导入方式"></a>2.  CSS导入方式</h2><p>css 导入方式其实就是 css 代码和 html 代码的结合方式。CSS 导入 HTML有三种方式：</p><ul><li><p>内联样式：在标签内部使用style属性，属性值是css属性键值对</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span>&gt;</span>Hello CSS<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>给方式只能作用在这一个标签上，如果其他的标签也想使用同样的样式，那就需要在其他标签上写上相同的样式。复用性太差。</p></blockquote></li><li><p>内部样式：定义<code>&lt;style&gt;</code>标签，在标签内部定义css样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>这种方式可以做到在该页面中复用。</p></blockquote></li><li><p>外部样式：定义link标签，引入外部的css文件</p><p>编写一个css文件。名为：demo.css，内容如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>在html中引入 css 文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>  <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;demo.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>这种方式可以在多个页面进行复用。其他的页面想使用同样的样式，只需要使用 <code>link</code> 标签引入该css文件。</p></blockquote></li></ul><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">span</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../css/demo.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span>&gt;</span>hello css<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello css <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello css<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>引入方式</th><th>书写位置</th><th>作用范围</th><th>使用场景</th></tr></thead><tbody><tr><td>内联式</td><td>CSS写在style标签中</td><td>当前页面</td><td>小案例</td></tr><tr><td>外联式</td><td>CSS写在单独的css文件中，通过link标签引入</td><td>多个页面</td><td>项目中</td></tr><tr><td>行内式</td><td>CSS写在标签的style属性中</td><td>当前标签</td><td>配合js使用</td></tr></tbody></table></div><h2 id="3-css-选择器"><a href="#3-css-选择器" class="headerlink" title="3.  css 选择器"></a>3.  css 选择器</h2><h4 id="3-1-CSS选择器介绍"><a href="#3-1-CSS选择器介绍" class="headerlink" title="3.1    CSS选择器介绍"></a>3.1    CSS选择器介绍</h4><p>➢ 选择器的作用:</p><ul><li>选择页面中对应的标签(找她)，方便后续设置样式(改她)</li></ul><p>➢ 注意点:</p><ol><li>标签选择器选择的是一类标签，而不是单独某一个</li><li>标签选择器无论嵌套关系有多深，都能找到对应的标签</li></ol><p>css 选择器就是选取需设置样式的元素（标签），比如如下css代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码中的 <code>div</code> 就是 css 中的<strong>选择器</strong>。</p><p>下面讲四种选择器：</p><ol><li><p>元素选择器</p><p>格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">元素名称&#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">div &#123;<br>color:red<br>&#125;  /*该代码表示将页面中所有的div标签的内容的颜色设置为红色*/<br></code></pre></td></tr></table></figure></li><li><p>id选择器：通过id属性值，找到页面中带有这个id属性值的标签，设置样式</p><p>格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#id</span>属性值&#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure><p>例子：</p><p>html代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>hello css2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#name</span>&#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<span class="hljs-comment">/*该代码表示将页面中所有的id属性值是 name 的标签的内容的颜色设置为红色*/</span><br></code></pre></td></tr></table></figure><p>➢ 注意点:</p><ol><li>所有标签上都有id属性</li><li>id属性值类似于身份证号码，<strong><u>在一个页面中是唯一的，不可重复的!</u></strong> </li><li>一个标签上只能有一个id属性值</li><li>一个id选择器只能选中一个标签        </li></ol></li></ol><p>​                3. 类选择器：通过类名，找到页面中所有带有这个类名的标签，设置样式</p><p>格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.class</span>属性值&#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure><p>例子：</p><p>html代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls&quot;</span>&gt;</span><br>  hello css3<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br><span class="hljs-selector-class">.cls</span>&#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br>&lt;/style&gt;<span class="hljs-comment">/*该代码表示将页面中所有的class属性值是 cls 的标签的内容的颜色设置为红色*/</span><br></code></pre></td></tr></table></figure><p>➢ 注意点:</p><ol><li>所有标签上都有class属性，class属性的属性值称为类名(类似于名字)</li><li>类名可以由数字、字母、下划线、中划线组成，但不能以数字或者中划线开头 </li><li>一个标签可以同时有多个类名，类名之间以空格隔开</li><li>类名可以重复，一个类选择器可以同时选中多个标签</li></ol><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-id">#name</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: blue;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.cls</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: pink;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>div2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls&quot;</span>&gt;</span>div3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls&quot;</span>&gt;</span>span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>补充：类与id的区别</strong></p><p>​                ➢ class类名与id属性值的区别</p><ul><li><p>class类名相当于姓名，可以重复，一个标签可以同时有多个class类名</p></li><li><p>id属性值相当于身份证号码，不可重复，一个标签只能有一个id属性值</p></li></ul><p>  ➢ 类选择器与id选择器的区别</p><ul><li><p>类选择器以 <strong>.</strong> 开头</p></li><li><p>id选择器以 <strong>#</strong> 开头</p></li></ul><p>  ➢ 实际开发的情况</p><ul><li>类选择器用的最多</li><li>id一般配合js使用，除非特殊情况，否则不要使用id设置样式</li><li>实际开发中会遇到<strong>冗余代码的抽取</strong> (可以将一些公共的代码抽取到一个公共的类中去)</li></ul><p>​                4.    <strong>通配符选择器</strong></p><p>​    ➢ 结构：<strong>*</strong> { css属性名:属性值; }</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">*&#123;<br><span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;<br><span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    ➢ 作用：找到页面中所有的标签，设置样式</p><p>​    ➢ 注意点：</p><ol><li>开发中使用极少，只会在极特殊情况下才会用到</li><li>可能会用于去除标签默认的margin和padding</li></ol><h4 id="3-2-复合选择器"><a href="#3-2-复合选择器" class="headerlink" title="3.2    复合选择器"></a>3.2    复合选择器</h4><ol><li><p>后代选择器：选择器1 选择器2 {}</p><ul><li>在选择器1所找到标签的后代(儿子、孙子、重孙子…)中，找到满足选择器2的标签，设置样式</li><li>后代选择器中，选择器与选择器之前通过 空格 隔开</li></ul></li><li><p>子代选择器：选择器1 &gt; 选择器2 {}</p><ul><li>在选择器1所找到标签的子代(儿子)中，找到满足选择器2的标签，设置样式</li><li>子代只包括儿子</li></ul></li><li><p>并集选择器：选择器1， 选择器2 {}</p><ul><li>找到 选择器1 和 选择器2 选中的标签，设置样式</li><li>并集选择器中的每组选择器通常一行写一个，提高代码的可读性</li></ul></li><li><p>交集选择器：选择器1选择器2{}</p><ul><li>(既又原则)找到页面中 <strong>既</strong> 能被选择器1选中，<strong>又</strong> 能被选择器2选中的标签，设置样式</li><li>交集选择器中的选择器之间是紧挨着的，没有东西分隔</li><li>交集选择器中如果有标签选择器，标签选择器必须写在最前面</li></ul></li><li><p>hover伪类选择器：选择器:hover{}</p><ul><li>作用：选中鼠标<strong>悬停</strong>在元素上的<strong>状态</strong>，设置样式</li><li>伪类选择器选中的元素的<strong>某种状态</strong></li></ul></li><li><p>Emmet语法：通过简写语法，快速生成代码</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630205721152.png" alt="image-20220630205721152"></p></li></ol><p>总结：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630205845231.png" alt="image-20220630205845231"></p><h2 id="4-字体和文本样式"><a href="#4-字体和文本样式" class="headerlink" title="4.    字体和文本样式"></a>4.    <strong>字体和文本样式</strong></h2><h3 id="4-1-字体样式"><a href="#4-1-字体样式" class="headerlink" title="4.1    字体样式"></a>4.1    字体样式</h3><ul><li><p>字体大小:font-size</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">*&#123;<br><span class="hljs-attribute">font-size</span>:<span class="hljs-number">16px</span>//谷歌浏览器默认文字大小是<span class="hljs-number">16px</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>字体粗细:font-weight </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">font-weight</span>:normal;//关键字取值<br><span class="hljs-attribute">font-weight</span>:bold;//关键字取值<br><span class="hljs-attribute">font-weight</span>:<span class="hljs-number">400</span>;//正常<br><span class="hljs-attribute">font-weight</span>:<span class="hljs-number">700</span>;//加粗<br>&#125;<br></code></pre></td></tr></table></figure><p>纯数字取值为100-900的整百数。</p><p>​            ➢ 注意点:</p><ol><li><ul><li>不是所有字体都提供了九种粗细，因此部分取值页面中无变化</li><li>实际开发中以:正常、加粗两种取值使用最多。</li></ul></li></ol></li><li><p>字体样式:font-style</p><ul><li>取值:<ul><li>正常(默认值):normal</li><li>倾斜:italic</li></ul></li></ul></li><li><p>字体类型:font-family </p><ul><li><p>常见取值：具体字体1,具体字体2,具体字体3,具体字体4,…,字体系列</p><ul><li>从左往右按照顺序查找，如果电脑中未安装该字体，则显示下一个字体</li><li>如果都不支持，此时会根据操作系统，显示最后字体系列的默认字体</li><li>如果字体名称中存在多个单词，推荐使用引号包裹</li><li>最后一项字体系列不需要引号包裹</li></ul></li><li><p>常见字体系列</p><p>➢ <strong>无衬线字体</strong>(sans-serif)</p><ol><li><p>特点:文字笔画粗细均匀，并且首尾无装饰 </p></li><li><p>场景:网页中大多采用无衬线字体</p></li><li><p>常见该系列字体:黑体、Arial</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630191140059.png" alt="image-20220630191140059"></p></li></ol><p>➢ <strong>衬线字体</strong>(serif)</p><ol><li><p>特点:文字笔画粗细不均，并且首尾有笔锋装饰</p></li><li><p>场景:报刊书籍中应用广泛</p></li><li><p>常见该系列字体:宋体、Times New Roman</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630191309645.png" alt="image-20220630191309645"></p></li></ol><p>➢ <strong>等宽字体</strong>(monospace)</p><ol><li><p>特点:每个字母或文字的宽度相等</p></li><li><p>场景:一般用于程序代码编写，有利于代码的阅读和编写</p></li><li><p>常见该系列字体:Consolas、fira code</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630191338758.png" alt="image-20220630191338758"></p></li></ol></li></ul></li><li><p>字体类型:font属性连写</p><ul><li>取值：font : style weight size family;</li><li>只能省略前两个，如果省略了相当于设置了默认值</li><li>如果需要同时设置单独和连写形式，单独的只能写在连写的下面或里面</li></ul></li></ul><p><strong>样式的层叠问题</strong></p><p>➢ 问题:</p><ul><li>给同一个标签设置了相同的样式，此时浏览器会如何渲染呢?</li></ul><p>➢ 结果:</p><ul><li>如果给同一个标签设置了相同的属性，此时样式会层叠(覆盖)，写在最下面的会生效</li></ul><h3 id="4-2-文本样式"><a href="#4-2-文本样式" class="headerlink" title="4.2    文本样式"></a>4.2    文本样式</h3><ol><li><p>文本缩进:text-indent</p><p>取值：</p><ul><li>数字+px</li><li>数字+em（推荐:1em = 当前标签的font-size的大小）</li></ul></li><li><p>文本水平对齐方式:text-align</p><p>取值：left（左对齐）、center（居中对齐）、right（右对齐）</p><p>注意：如果需要让文本水平居中，<code>text-align：center</code>属性需要给文本所在标签(文本的父元素)设置 </p><p>text-align : center 能让哪些元素水平居中? </p><ul><li><p>文本</p></li><li><p>span标签、a标签</p></li><li>input标签、img标签</li></ul></li><li><p>文本修饰:text-decoration</p><p>开发中会使用 <code>text-decoration : none ;</code>清除<code>a</code>标签默认的下划线</p><p>取值：</p><ol><li>underline下划线</li><li>Line-through删除线</li><li>overline上划线</li><li>None无装饰线</li></ol></li></ol><h3 id="4-3-line-height行高"><a href="#4-3-line-height行高" class="headerlink" title="4.3    line-height行高"></a>4.3    line-height行高</h3><ul><li>➢  作用:控制一行的上下行间距</li><li>➢  属性名:<code>line-height</code></li><li>➢  取值:<ul><li>数字+px</li><li>倍数(当前标签font-size的倍数)</li></ul></li><li>➢  应用:<ol><li>让单行文本垂直居中可以设置 <code>line-height : 文字父元素高度</code></li><li>网页精准布局时，会设置<code>line-height : 1</code> 可以取消上下间距</li></ol></li><li>➢  行高与font连写的注意点:<ul><li>如果同时设置了行高和font连写，注意覆盖问题</li><li>font : style weight size/line-height family ;</li></ul></li></ul><h4 id="标签水平居中方法"><a href="#标签水平居中方法" class="headerlink" title="标签水平居中方法"></a>标签水平居中方法</h4><p>➢ 如果需要让div、p、h(大盒子)水平居中? </p><ul><li>可以通过<code>margin : 0 auto ;</code>实现</li></ul><p>➢ 注意点:</p><ol><li>如果需要让 div、p、h(大盒子) 水平居中，直接给当前元素本身设置即可</li><li><code>margin:0 auto</code> 一般针对于固定宽度的盒子，如果大盒子没有设置宽度，此时会默认占满父元素的宽度</li></ol><h3 id="4-4-Chrome浏览器提示工具"><a href="#4-4-Chrome浏览器提示工具" class="headerlink" title="4.4    Chrome浏览器提示工具"></a>4.4    Chrome浏览器提示工具</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630200307488.png" alt="image-20220630200307488"></p><h2 id="5-背景相关属性"><a href="#5-背景相关属性" class="headerlink" title="5.    背景相关属性"></a>5.    背景相关属性</h2><h4 id="5-5-1-背景颜色"><a href="#5-5-1-背景颜色" class="headerlink" title="5.5.1    背景颜色"></a>5.5.1    背景颜色</h4><p><strong>颜色常见取值：</strong></p><p>➢ 属性名:</p><ul><li><p>如:文字颜色:color</p></li><li><p>如:背景颜色:background-color</p></li></ul><p>➢ 属性值:</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630200501828.png" alt="image-20220630200501828"></p><p>1:完全不透明，0:完全透明，.5半透明</p><ul><li>背景颜色默认值是<strong>透明</strong>: rgba(0,0,0,0) 、transparent</li><li>背景颜色不会影响盒子大小，并且还能看清盒子的大小和位置，一般在布局中会习惯先给盒子设置背景颜色</li></ul><h4 id="5-5-2-背景图片"><a href="#5-5-2-背景图片" class="headerlink" title="5.5.2    背景图片"></a>5.5.2    背景图片</h4><p>取值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;图片的路径&#x27;</span>);<br></code></pre></td></tr></table></figure><p>➢ 注意点:</p><ul><li>背景图片中url中可以省略引号</li><li>背景图片默认是在水平和垂直方向平铺的</li><li>背景图片仅仅是指给盒子起到装饰效果，类似于背景颜色，是不能撑开盒子</li></ul><h4 id="5-5-3-背景平铺"><a href="#5-5-3-背景平铺" class="headerlink" title="5.5.3    背景平铺"></a>5.5.3    背景平铺</h4><p>属性名：<code>background-repeat</code></p><p>取值：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630210700177.png" alt="image-20220630210700177"></p><h4 id="5-5-4-背景位置"><a href="#5-5-4-背景位置" class="headerlink" title="5.5.4    背景位置"></a>5.5.4    背景位置</h4><p>属性名：<code>background-position:水平方向位置 垂直方向位置</code></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630210907348.png" alt="image-20220630210907348"></p><ul><li>方位名词取值和坐标取值可以混使用，第一个取值表示水平，第二个取值表示垂直</li></ul><h4 id="5-5-5-背景相关属性连写"><a href="#5-5-5-背景相关属性连写" class="headerlink" title="5.5.5    背景相关属性连写"></a>5.5.5    背景相关属性连写</h4><p>➢  属性名:<code>background</code></p><p>➢  属性值:</p><ul><li>单个属性值的合写，取值之间以空格隔开 </li></ul><p>➢ 书写顺序:</p><ul><li>推荐:<code>background:color image repeat position</code></li></ul><p>➢  省略问题:</p><ul><li>可以按照需求省略</li><li>特殊情况:在pc端，如果盒子大小和背景图片大小一样，此时可以直接写 <code>background:url()</code></li></ul><p>➢  注意点</p><ul><li>如果需要设置单独的样式和连写<ul><li>要么把单独的样式写在连写的下面</li><li>要么把单独的样式写在连写的里面</li></ul></li></ul><p><strong><code>img</code>标签和背景图片的区别：</strong></p><p>➢ 需求:需要在网页中展示一张图片的效果? </p><p>➢ 方法一:直接写上img标签即可</p><ul><li>img标签是一个标签，不设置宽高默认会以原尺寸显示 </li></ul><p>➢ 方法二:div标签 + 背景图片</p><ul><li>需要设置div的宽高，因为背景图片只是装饰的CSS样式，不能撑开div标签</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端&amp;CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML</title>
    <link href="/2022/06/29/HTML/"/>
    <url>/2022/06/29/HTML/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.  介绍"></a>1.  介绍</h2><p>HTML 是一门语言，所有的网页都是用HTML 这门语言编写出来，HTML也有专业的解释：</p><p>==HTML(HyperText Markup Language)：超文本标记语言：==</p><ul><li><p>超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容</p><p>如我们看到的一些页面，我们除了能看到一些文字，同时也有大量的图片展示；有些网页也有视频，音频等。这种展示效果超越了文本展示的限制。</p></li><li><p>标记语言：由标签构成的语言</p><p>之前学习的XML就是标记语言，由一个一个的标签组成，HTML 也是由标签组成 。我们在浏览器页面右键可以查看页面的源代码。</p></li></ul><p>这些标签不像XML那样可以自定义，==HTML中的标签都是预定义好的，运行在浏览器上并由浏览器解析，==然后展示出对应的效果。</p><p>简单的给大家聊一下开发流程：</p><p>以后我们是通过Java程序从数据库中查询出来数据，然后交给页面进行展示，这样用户就能通过在浏览器通过页面看到数据。</p><p>==W3C标准：==</p><p>W3C是万维网联盟，这个组成是用来定义标准的。他们规定了一个网页是由三部分组成，分别是：</p><ul><li>结构：对应的是 HTML 语言</li><li>表现：对应的是 CSS 语言</li><li>行为：对应的是 JavaScript 语言</li></ul><p>HTML定义页面的整体结构；CSS是用来美化页面，让页面看起来更加美观；JavaScript可以使网页动起来，比如轮播图也就是多张图片自动的进行切换等效果。</p><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.  快速入门"></a>2.  快速入门</h2><p>使用VS Code来编写网页源代码，创建网页的步骤：</p><ul><li><p>新建文件，后缀名改为 .html</p></li><li><p>编写 HTML 结构标签</p><p>HTML 是由一个一个的标签组成的，但是它也用于表示结构的标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>html标签:网页的整体</li><li>head标签:网页的头部</li><li>body标签:网页的身体</li><li>title标签:网页的标题</li></ul></li></ul><h4 id="VS-Code的基本快捷键："><a href="#VS-Code的基本快捷键：" class="headerlink" title="VS Code的基本快捷键："></a>VS Code的基本快捷键：</h4><ol><li><p>快速生成标签:需要生成标签的首字母 + tab</p></li><li><p>保存文件:⌘ + s</p></li><li><p>注释：⌘+/</p></li><li><p>换行：⌘+回车键</p></li><li><p>复制本行：⇧+⌥+上下方向键</p></li><li><p>快速复制一整行:⌘ + c</p><p>快速粘贴一整行:⌘ + v</p><p>快速删除(剪切)一整行:⌘ + x</p></li><li><p>快速查看网页效果:右击 → Open in Default Browser</p><ul><li>快捷键:⌘+O，⌘+L</li><li>注意:<strong>必须安装了**</strong>open in browser<strong> </strong>插件**</li></ul></li><li><p>快速生成结构标签:! + tab</p><ul><li>注意1:!必须是英文的，中文!无效</li><li>注意2:必须保证当前文件后缀名是.html，否则无效</li><li>VS Code自动生成的骨架多了其他标签，之后会介绍</li></ul></li></ol><p>==总结：==</p><ul><li><p>HTML 文件以.htm或.html为扩展名</p></li><li><p>HTML 结构标签</p></li><li><p>HTML 标签不区分大小写</p><p>如 <code>font</code> 写成 <code>Font</code> 也是一样可以展示出对应的效果的。</p></li><li><p>HTML 标签属性值 单双引皆可</p><p>如color属性值使用双引号也是可以的。<font color="red"></font> </p></li><li><p>HTML 语法松散</p><p>比如 font 标签不加结束标签也是可以展示出效果的。但是建议同学们在写的时候还是不要这样做，严格按照要求去写。</p></li></ul><h2 id="3-基础标签"><a href="#3-基础标签" class="headerlink" title="3.  基础标签"></a>3.  基础标签</h2><p>基础标签就是一些和文字相关的标签，接下来我们挨个进行讲解：</p><h3 id="3-1-基础标签"><a href="#3-1-基础标签" class="headerlink" title="3.1    基础标签"></a>3.1    基础标签</h3><div class="table-container"><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;h1&gt;  ~  &lt;h6&gt;</td><td>定义标题，h1最大，h6最小</td></tr><tr><td>&lt;font&gt;</td><td>定义文本的字体、字体尺寸、字体颜色</td></tr><tr><td>&lt;b&gt;、<strong></strong></td><td>加粗</td></tr><tr><td>&lt;i&gt;、<em></em></td><td>倾斜</td></tr><tr><td>&lt;u&gt;、<ins></ins></td><td>下划线</td></tr><tr><td><s>、<del></del></s></td><td>删除线</td></tr><tr><td>&lt;center&gt;</td><td>居中</td></tr><tr><td>&lt;p&gt;</td><td>段落</td></tr><tr><td>&lt;br&gt;</td><td>文本换行</td></tr><tr><td>&lt;hr&gt;</td><td>定义水平线</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>HTML 原代码</th><th>显示结果</th><th>描述</th></tr></thead><tbody><tr><td>\&lt;</td><td>&lt;</td><td>小于号或显示标记</td></tr><tr><td>\&amp;gt ;</td><td>&gt;</td><td>大于号或显示标记</td></tr><tr><td>\&amp;</td><td>&amp;</td><td>可用于显示其它特殊字符</td></tr><tr><td>\&quot;</td><td>“</td><td>引号</td></tr><tr><td>\&reg;</td><td>®</td><td>已注册</td></tr><tr><td>\&copy;</td><td>©</td><td>版权</td></tr><tr><td>\&trade;</td><td>™</td><td>商标</td></tr><tr><td>\&nbsp;</td><td></td><td>不断行的空白</td></tr></tbody></table></div><h3 id="3-2-字体标签"><a href="#3-2-字体标签" class="headerlink" title="3.2  字体标签"></a>3.2  字体标签</h3><p>font：字体标签</p><ul><li><p>face 属性：用来设置字体。如 “楷体”、”宋体”等</p></li><li><p>color 属性：设置文字颜色。颜色有三种表示方式</p><ul><li><p><strong>英文单词</strong>：red,pink,blue…</p></li><li><p><strong>rgb(值1,值2,值3)</strong>：值的取值范围：0~255  </p><p>此种方式也就是三原色（红绿蓝）设置方式。 例如： rgb(255,0,0)。</p><p>这种书写起来比较麻烦，一般不用。</p></li><li><p><strong>#值1值2值3</strong>：值的范围：00~FF</p><p>这种方式是rgb方式的简化写法，以后基本都用此方式。</p><p>值1表示红色的范围，值2表示绿色的范围，值3表示蓝色范围。例如： #ff0000</p></li></ul></li><li><p>size 属性：设置文字大小</p></li></ul><p>代码演示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;楷体&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;#ff0000&quot;</span>&gt;</span>传智教育<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>==注意：==</p><p>font 标签已经不建议使用了，以后如果要改变文字字体，大小，颜色可以使用 CSS 进行设置。</p></blockquote><h2 id="4-图片、音频、视频标签"><a href="#4-图片、音频、视频标签" class="headerlink" title="4.  图片、音频、视频标签"></a>4.  图片、音频、视频标签</h2><ul><li><p>img：定义图片</p><ul><li><p>src：规定显示图像的 URL（统一资源定位符）</p></li><li><p>Alt：替换文本，当图片加载失败时显示</p></li><li><p>height：图像的高度</p></li><li><p>width：图像的宽度</p></li><li><p>title：当鼠标悬停时显示的文本</p></li></ul></li><li><p>audio：定义音频。支持的音频格式：MP3、WAV、OGG </p><ul><li>src：规定音频的 URL</li><li>controls：显示播放控件</li></ul></li><li>video：定义视频。支持的音频格式：MP4, WebM、OGG<ul><li>src：规定视频的 URL</li><li>controls：显示播放控件</li><li>Autoplay：自动播放</li><li>loop：循环播放</li></ul></li></ul><p><strong>尺寸单位：</strong></p><p>height属性和width属性有两种设置方式：</p><ul><li>像素：单位是px</li><li>百分比。占父标签的百分比。例如宽度设置为 50%，意思就是占它的父标签宽度的一般（50%）</li><li>如果只设置二者中的一个，会自动设置等比例缩放</li></ul><p><strong>资源路径：</strong></p><p>图片，音频，视频标签都有src属性，而src是用来指定对应的图片，音频，视频文件的路径。此处的图片，音频，视频就称为资源。资源路径有如下两种设置方式：</p><ul><li><p>绝对路径：完整路径</p><p>这里的绝对路径是网络中的绝对路径。 格式为： 协议://ip地址:端口号/资源名称。</p><p>如：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">&lt;img src=<span class="hljs-string">&quot;https://th.bing.com/th/id/R33674725d9ae34f86e3835ae30b20afe?rik=Pb3C9e5%2b%2b3a9Vw&amp;riu=http%3a%2f%2fwww.desktx.com%2fd%2ffile%2fwallpaper%2fscenery%2f20180626%2f4c8157d07c14a30fd76f9bc110b1314e.jpg&amp;ehk=9tpmnrrRNi0eBGq3CnhwvuU8PPmKuy1Yma0zL%2ba14T0%3d&amp;risl=&amp;pid=ImgRaw&quot;</span> width=<span class="hljs-string">&quot;300&quot;</span> height=<span class="hljs-string">&quot;400&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>这里src属性的值就是网络中的绝对路径。</p></li><li><p>相对路径：相对位置关系</p><p>找页面和其他资源的相对路径。</p><blockquote><p>./    表示当前路径</p><p>../   表示上一级路径</p><p>../../   表示上两级路径</p></blockquote></li></ul><h2 id="5-超链接标签"><a href="#5-超链接标签" class="headerlink" title="5.  超链接标签"></a>5.  超链接标签</h2><p>➢ 显示特点:</p><ul><li>a标签默认文字有下划线</li><li>a标签从未点击过，默认文字显示蓝色</li><li>a标签点击过之后，文字显示为紫色(清除浏览器历史记录可恢复蓝色)</li></ul><p><code>a</code> 标签属性：</p><ul><li><p>href：指定目标网页路径</p><ul><li><p>外部链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;www.baidu.com&#x27;</span>&gt;</span>百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>内部链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;./target.html&#x27;</span>&gt;</span>jump<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>target：指定打开资源的方式</p><ul><li>_self：默认值，在当前页面打开，覆盖原网页</li><li>_blank：在新窗口中跳转，保留原网页</li></ul></li></ul><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.itcast.cn&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_self&quot;</span>&gt;</span>点我有惊喜<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>空链接(拓展补充)</p><p> ➢ 代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;#&#x27;</span>&gt;</span>空链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>➢ 功能:</p><ul><li>点击之后回到网页顶部</li><li>开发中不确定该链接最终跳转位置，用空链接占个位置</li></ul><h2 id="6-列表标签"><a href="#6-列表标签" class="headerlink" title="6.  列表标签"></a>6.  列表标签</h2><p>HTML 中列表定义如下：</p><div class="table-container"><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;ol&gt;</td><td>定义有序列表</td></tr><tr><td>&lt;ul&gt;</td><td>定义无序列表</td></tr><tr><td>&lt;li&gt;</td><td>定义列表项</td></tr></tbody></table></div><ul><li>type：设置符号的类型</li><li>ul和ol标签中只允许嵌套li标签</li><li>li标签中可以嵌套任意内容</li></ul><p>自定义列表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">标签名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">dl</td><td style="text-align:center">表示整体，用于包裹dt和dd</td></tr><tr><td style="text-align:center">dt</td><td style="text-align:center">表示列表主题</td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">表示每一项内容</td></tr></tbody></table></div><ul><li><p>dl标签中只允许嵌套dt/dd标签</p></li><li><p>dt/dd标签中可以嵌套任意内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>主题<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>第一行<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>第二行<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>第三行<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220629170316314.png" alt="image-20220629170316314"></p></li></ul><ul><li>有序列表中的 <code>type</code> 属性用来指定标记的标号的类型（数字、字母、罗马数字等）</li></ul><ul><li>无序列表中的 <code>type</code> 属性用来指定标记的形状</li></ul><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;A&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>咖啡<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>茶<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>牛奶<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;circle&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>咖啡<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>茶<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>牛奶<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="7-表格标签"><a href="#7-表格标签" class="headerlink" title="7.  表格标签"></a>7.  表格标签</h2><p>表格可以使用如下标签定义</p><ul><li><p>table ：定义表格</p><ul><li><p>border：规定表格边框的宽度</p></li><li><p>width ：规定表格的宽度</p></li><li><p>cellpadding：定义内容和单元格的距离</p></li><li><p>cellspacing：规定单元格之间的空白，如果指定为0，则单元格的线会合为一条。</p></li></ul></li><li><p>tr ：定义行</p><ul><li>align：定义表格行的内容对齐方式</li><li>bgcolor：背景色</li></ul></li><li><p>td ：定义单元格</p><ul><li><p>rowspan：规定单元格可纵跨的行数，即宽几格</p></li><li><p>colspan：规定单元格可横跨的列数，即长几格</p></li><li><p>bgcolor：背景色</p></li></ul></li><li>th：定义表头单元格，通常用于表格第一行，默认内部文字加粗并居中显示</li><li>caption：表示表格整体大标题，默认在表格整体顶部居中加粗显示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220629170618484.png" alt="image-20220629170618484" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220629194844009.png" alt="image-20220629194844009"></p><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>序号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>品牌logo<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>品牌名称<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>企业名称<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>010<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/三只松鼠.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>三只松鼠<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>三只松鼠<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>009<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/优衣库.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>优衣库<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>优衣库<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>008<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/小米.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>小米<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>小米科技有限公司<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630165613904.png" alt="image-20220630165613904"></p><p>作业效果：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630165809961.png" alt="image-20220630165809961"></p><p>代码实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500px&quot;</span> <span class="hljs-attr">cellpading</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>优秀学生信息表格<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;60px&quot;</span>&gt;</span>年级<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>学号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>班级<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100px&quot;</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>高三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>赵四<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>120<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>三年三班<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>110<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>三年二班<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;40px&quot;</span>&gt;</span>评语<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>你们都很优秀<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span>        <br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="8-布局标签"><a href="#8-布局标签" class="headerlink" title="8.  布局标签"></a>8.  布局标签</h2><p>没有语义的布局标签；<code>div</code>和<code>span</code></p><p><code>div</code>标签在浏览器上会有换行的效果，而 <code>span</code> 标签在浏览器上没有换行效果。</p><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>语义化标签：</p><ul><li>header:网页头部</li><li>nav:网页导航</li><li>footer:网页底部</li><li>aside:网页侧边栏</li><li>section:网页区块</li><li>article:网页文章</li></ul><p>对应的部署位置：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630161910453.png" alt="image-20220630161910453"></p><h2 id="9-表单标签"><a href="#9-表单标签" class="headerlink" title="9.  表单标签"></a>9.  表单标签</h2><p>表单标签效果大家其实都不陌生，像登陆页面、注册页面等都是表单。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220629194955811.png" alt="image-20220629194955811" style="zoom:50%;"></p><p>像这样的表单就是用来采集用户输入的数据，然后将数据发送到服务端，服务端会对数据库进行操作，比如注册就是将数据保存到数据库中，而登陆就是根据用户名和密码进行数据库的查询操作。</p><p>表单是很重要的标签，需要大家重点来学习。</p><h3 id="9-1-表单标签概述"><a href="#9-1-表单标签概述" class="headerlink" title="9.1  表单标签概述"></a>9.1  表单标签概述</h3><blockquote><p>表单：在网页中主要负责数据采集功能，使用<form>标签定义表单</form></p><p>表单项(元素)：不同类型的 input 元素、下拉列表、文本域等</p></blockquote><p><code>form</code> 是表单标签，它在页面上没有任何展示的效果。需要借助于表单项标签来展示不同的效果。</p><h3 id="9-2-form标签属性"><a href="#9-2-form标签属性" class="headerlink" title="9.2  form标签属性"></a>9.2  form标签属性</h3><ul><li><p><strong>action：规定当提交表单时向何处发送表单数据，该属性值就是URL</strong></p><p>以后会将数据提交到服务端，该属性需要书写服务端的URL。而今天我们可以书写 <code>#</code> ，表示提交到当前页面来看效果。</p></li><li><p><strong>method ：规定用于发送表单数据的方式</strong></p><p>method取值有如下两种：</p><ul><li>get：默认值。如果不设置method属性则默认就是该值<ul><li>请求参数会拼接在URL后边</li><li>url的长度有限制 4KB</li></ul></li><li>post：<ul><li>浏览器会将数据放到http请求消息体中</li><li>请求参数无限制的</li></ul></li></ul></li></ul><h3 id="9-3-代码演示"><a href="#9-3-代码演示" class="headerlink" title="9.3  代码演示"></a>9.3  代码演示</h3><p>由于表单标签在页面上没有任何展示的效果，所以在演示的过程是会先使用 <code>input</code> 这个表单项标签展示输入框效果。</p><p>从效果可以看到页面有一个输入框，用户可以在数据框中输入自己想输入的内容，点击提交按钮以后会将数据发送到服务端，当然现在肯定不能实现。现在我们可以将 <code>form</code> 标签的 <code>action</code> 属性值设置为 <code>#</code> ，将其将数据提交到当前页面。还需要注意一点，要想提交数据，<code>input</code> 输入框必须设置 <code>name</code> 属性。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们可以看到在浏览器的地址栏的URL后拼接了我们提交的数据。<code>username</code> 就是输入框 <code>name</code> 属性值，而 <code>hehe</code> 就是我们在输入框输入的内容。</p><h2 id="10-表单项标签"><a href="#10-表单项标签" class="headerlink" title="10.  表单项标签"></a>10.  表单项标签</h2><p>表单项标签有很多，不同的表单项标签有不同的展示效果。表单项标签可以分为以下三个：</p><p><code>&lt;input&gt;</code>：表单项，通过<code>type</code>属性控制输入形式</p><p><code>name</code>属性：当前控件的含义，提交之后可以告诉后端发送过去的数据是什么含义</p><p><code>value</code>属性：当前控件的值，用于提交选项</p><p><code>input</code> 标签有个 <code>type</code> 属性。 <code>type</code> 属性的取值不同，展示的效果也不一样：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630144931962.png" alt="image-20220630144931962"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630145614571.png" alt="image-20220630145614571"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 昵称：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br>              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mima&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 性别：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span> =<span class="hljs-string">&quot;男&quot;</span>&gt;</span>男<br>                      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;女&quot;</span> <span class="hljs-attr">checked</span>&gt;</span>女<br>              <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">checked</span>&gt;</span>敲代码<br>                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span>熬夜<br>                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span>掉头发<br>              <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;普通按钮&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>&lt;select&gt;</code>：定义下拉列表，\<option> 定义列表项 </option></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;BeiJing&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;shanghai&quot;</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;GuangZhou&quot;</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><code>&lt;textarea&gt;</code>：文本域</p><p>它可以输入多行文本，而 <code>input</code> 数据框只能输入一行文本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;desc&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>==注意：==</p><ul><li>以上标签项的内容要想提交，必须得定义 <code>name</code> 属性。</li><li>每一个标签都有id属性，id属性值是唯一的标识。</li><li>单选框、复选框、下拉列表需要使用 <code>value</code> 属性指定提交的值。</li></ul></blockquote><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>密码：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>        性别：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>        爱好：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span> 旅游<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span> 电影<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span> 游戏<br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>        头像：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>        城市:<br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;shanghai&quot;</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>        个人描述：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;desc&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;免费注册&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;重置&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;一个按钮&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在浏览器的效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630155359721.png" alt="image-20220630155359721" style="zoom:50%;"></p><p>图中的文字内容都以<code>label</code>的形式给出，换行用<code>&lt;br&gt;</code>。</p><p><strong>label标签</strong></p><p>场景：常用于绑定内容与表单标签的关系</p><p>标签名：<code>label</code></p><p>使用方法1:</p><ol><li><p>使用<code>label</code>标签把内容(如:文本)包裹起来 </p></li><li><p>在表单<code>input</code>标签上添加<code>id</code>属性，对应<code>label</code>标签中的<code>for</code>属性</p></li><li><p>在<code>label</code>标签的<code>for</code>属性中设置对应的<code>id</code>属性值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p>使用方法2:</p><ol><li><p>直接使用<code>label</code>标签，把内容(如:文本)和表单标签一起包裹起来 </p></li><li><p>需要把<code>label</code>标签的<code>for</code>属性删除即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>text<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="11-转义字符"><a href="#11-转义字符" class="headerlink" title="11.    转义字符"></a>11.    转义字符</h2><p> 场景:在网页中展示特殊符号效果时，需要使用字符实体替代 </p><p>结构:<code>&amp;字符对应英文;</code></p><p>常见字符实体：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630162334944.png" alt="image-20220630162334944"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端&amp;HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Day01</title>
    <link href="/2022/06/28/Python%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
    <url>/2022/06/28/Python%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="第-1-章-起步"><a href="#第-1-章-起步" class="headerlink" title="第 1 章    起步"></a>第 1 章    起步</h3><ul><li>查看python版本<code>python3 -V</code></li><li><p>退出Python并返回到终端窗口， <code>Ctrl + D</code>或执行命令<code>exit()</code></p></li><li><p>文件名使用小写字母，并用下划线代替空格，因为Python采用了这些命名约定</p></li><li><p>⌘+B运行程序</p></li></ul><h3 id="第-2-章-变量和简单数据类型"><a href="#第-2-章-变量和简单数据类型" class="headerlink" title="第 2 章　变量和简单数据类型"></a>第 2 章　变量和简单数据类型</h3><p>Python只记录变量的<strong>最新值</strong>。</p><p>变量名只能包含<strong>字母（最好是小写）、数字和下划线</strong>。</p><p><strong>变量是标签：</strong></p><p>变量常被描述为可用于存储值的盒子。变量是可以赋给值的标签，也可以说变量指向特定的值。</p><p><strong>字符串就是一系列字符：</strong></p><p>在Python中，用<strong>引号括起的都是字符串</strong>。</p><p><strong>字符串的大小写方法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;ada lovelace&quot;</span> <br><span class="hljs-built_in">print</span>(name.title())//首字母大写<br><span class="hljs-built_in">print</span>(name.upper())//全部大写<br><span class="hljs-built_in">print</span>(name.lower())//全部小写<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Ada Lovelace</span><br><span class="hljs-attribute">ADA LOVELACE </span><br><span class="hljs-attribute">ada lovelace</span><br></code></pre></td></tr></table></figure><p><strong>在字符串中使用变量：</strong></p><p><strong>在字符串中插入变量的值，可在前引号前加上字母f</strong> ，再将要插入的变量放在花括号内，f是format（设置格式）的简写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">first_name=<span class="hljs-string">&quot;ada&quot;</span><br>last_name=<span class="hljs-string">&quot;lovelace&quot;</span><br>full_name=<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;first_name&#125;</span> <span class="hljs-subst">&#123;last_name&#125;</span>&quot;</span><br><span class="hljs-built_in">print</span>(full_name)<br></code></pre></td></tr></table></figure><p>练习2-3：个性化消息 　</p><p>用变量表示一个人的名字，并向其显示一 条消息。显示的消息应非常简单，下面是一个例子。</p><p>Hello Eric, would you like to learn some Python today?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name=<span class="hljs-string">&quot;eric&quot;</span><br>word=<span class="hljs-string">f&quot;Hello <span class="hljs-subst">&#123;name&#125;</span>, would you like to learn some Python today?&quot;</span><br><span class="hljs-built_in">print</span>(word)<br></code></pre></td></tr></table></figure><p><strong>制表符或换行符：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">制表符</th><th style="text-align:center">\t</th></tr></thead><tbody><tr><td style="text-align:center">换行符</td><td style="text-align:center">\n</td></tr><tr><td style="text-align:center">换行后添加一个制表符</td><td style="text-align:center">\n\t</td></tr></tbody></table></div><p><strong>删除空白：</strong></p><p>去掉字符串右边空白，使用方法rstrip() ，左边空白使用lstrip()，去掉全部空白使用strip()。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>favorite_language = <span class="hljs-string">&#x27;python &#x27;</span> <br><span class="hljs-meta">&gt;&gt;&gt; </span>favorite_language<br><span class="hljs-string">&#x27;python &#x27;</span> <br><span class="hljs-meta">&gt;&gt;&gt; </span>favorite_language.rstrip()<br><span class="hljs-string">&#x27;python&#x27;</span> <br><span class="hljs-meta">&gt;&gt;&gt; </span>favorite_language<br><span class="hljs-string">&#x27;python &#x27;</span><br></code></pre></td></tr></table></figure><p>对变量favorite_language 调用方法rstrip() 后，多余的空格被删除了。但这种删除只是暂时的，接下来再次询问favorite_language 的值时，你会发现这个字符串与输入时一样，依然包含多余的空白。</p><p><strong>要永久删除这个字符串中的空白，必须将删除操作的结果关联到变量：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>favorite_language = <span class="hljs-string">&#x27;python &#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>favorite_language = favorite_language.rstrip() &gt;&gt;&gt; favorite_language <span class="hljs-string">&#x27;python&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>整数</strong></p><ul><li><p>在Python中，可对整数执行加（+ ）减（- ）乘（* ）除（/ ）运算。</p></li><li><p>用两个乘号表示乘方运算。</p></li><li><p>Python支持运算次序。</p></li></ul><p><strong>浮点数</strong></p><p>Python将所有带小数点的数称为浮点数 。</p><p>从很大程度上说，使用浮点数时无须考虑其行为。你只需输入要使用的数，Python通常会按你期望的方式处理它们，但需要注意的是，结果包含的小数位数可能是不确定的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">0.2</span>+<span class="hljs-number">0.1</span><br><span class="hljs-number">0.30000000000000004</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">3</span>*<span class="hljs-number">0.1</span><br><span class="hljs-number">0.30000000000000004</span><br></code></pre></td></tr></table></figure><p><strong>整数和浮点数</strong></p><ul><li>将任意两个数相除时，结果总是浮点数，即便这两个数都是整数且能整除。</li><li>在其他任何运算中，如果一个操作数是整数，另一个操作数是浮点数， 结果也总是浮点数。</li></ul><p><strong>数中的下划线</strong></p><p>书写很大的数时，可使用下划线将其中的数字分组，使其更清晰易读：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>universe_age = <span class="hljs-number">14_000_000_000</span><br></code></pre></td></tr></table></figure><p>当你打印这种使用下划线定义的数时，Python不会打印其中的下划线：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(universe_age) <span class="hljs-number">14000000000</span><br></code></pre></td></tr></table></figure><p><strong>在一行内同时给多个变量赋值：</strong></p><p>例如，下面演示了如何将变量x 、y 和z 都初始化为零：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x,y,z=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-built_in">print</span>(y)<br><span class="hljs-built_in">print</span>(z)<br></code></pre></td></tr></table></figure><p>Python将<strong>按顺序将每个值赋给对应的变量。只要变量和值的个数相同，Python就能正确地将它们关联起来。</strong></p><p><strong>常量类似于变量：</strong></p><p><strong>其值在程序的整个生命周期内保持不变</strong>。Python没有内置的常量类型，但Python程序员会使用全大写来指出应将某个变量视为常量，其值应始终不变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">MAX_CONNECTIONS = <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><p><u>在代码中，要指出某个特定的变量视为常量，可将其字母全部大写。</u></p><p>在Python中，注释用井号（# ）标识。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 向大家问好。 </span><br></code></pre></td></tr></table></figure><h3 id="第-3-章-列表简介"><a href="#第-3-章-列表简介" class="headerlink" title="第 3 章　列表简介"></a>第 3 章　列表简介</h3><p>列表由一系列按特定顺序排列的元素组成。通常给列表指定一个表示复数的名称（如letters 、digits 或names ）。在Python中，用方括号<code>[]</code>表示列表，并用逗号分隔其中的元素。下面是一个简单的列表示例，其中包含几种自行车：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">bicycles = [<span class="hljs-string">&#x27;trek&#x27;</span>, <span class="hljs-string">&#x27;cannondale&#x27;</span>, <span class="hljs-string">&#x27;redline&#x27;</span>, <span class="hljs-string">&#x27;specialized&#x27;</span>]<br></code></pre></td></tr></table></figure><p>Python将打印列表的固定格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">&#x27;trek&#x27;</span>, <span class="hljs-string">&#x27;cannondale&#x27;</span>, <span class="hljs-string">&#x27;redline&#x27;</span>, <span class="hljs-string">&#x27;specialized&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong>访问列表元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(bicycles[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><p><strong>索引从0而不是1开始</strong></p><p>Python为访问最后一个列表元素提供了一种特殊语法。<strong>通过将索引指定为-1 ，可让Python返回最后一个列表元素：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">bicycles = [<span class="hljs-string">&#x27;trek&#x27;</span>, <span class="hljs-string">&#x27;cannondale&#x27;</span>, <span class="hljs-string">&#x27;redline&#x27;</span>, <span class="hljs-string">&#x27;specialized&#x27;</span>] <br><span class="hljs-built_in">print</span>(bicycles[-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>这段代码返回’specialized’ 。</p><p>这种语法很有用，因为你经常需要在不知道列表长度的情况下访问最后的元素。这种约定也适用于其他负数索引。例如，索引-2 返回倒数第二个列表元素，索引-3 返回倒数第三个列表元素，依此类推。</p><p><strong>元素增删改查：</strong></p><p>1）<strong>在列表末尾添加元素append() </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">motorcycles = [<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br>motorcycles.append(<span class="hljs-string">&#x27;ducati&#x27;</span>) <br><span class="hljs-built_in">print</span>(motorcycles)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-symbol">&#x27;honda</span>&#x27;, <span class="hljs-symbol">&#x27;yamaha</span>&#x27;, <span class="hljs-symbol">&#x27;suzuki</span>&#x27;, <span class="hljs-symbol">&#x27;ducati</span>&#x27;]<br></code></pre></td></tr></table></figure><p>方法append() 让动态地创建列表易如反掌。</p><p>例如，你可以先创建 一个空列表，再使用一系列函数调用append() 来添加元素。</p><p>2）<strong>使用方法insert() 可在列表的任何位置添加新元素</strong>，为此，你需要指定新元素的索引和值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">motorcycles = [<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br>motorcycles.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;ducati&#x27;</span>) <br></code></pre></td></tr></table></figure><p>方法 insert() 在索引0 处添加空间，并将值’ducati’ 存储到这个地 方。这种操作将列表中既有的每个元素都右移一个位置。</p><p>3）<strong>使用del 语句删除元素</strong></p><p>如果知道要删除的元素在列表中的位置，可使用del 语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> motorcycles[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>4）<strong>使用方法pop() 删除末尾元素</strong></p><p>方法pop() 删除列表末尾的元素，并让你能够接着使用它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">motorcycles = [<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br>last_owned = motorcycles.pop() <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The last motorcycle I owned was a <span class="hljs-subst">&#123;last_owned.title()&#125;</span>.&quot;</span>)<br></code></pre></td></tr></table></figure><p>5）弹出列表中任何位置处的元素</p><p>可以使用pop() 来删除列表中任意位置的元素，只需在圆括号中指定要删除元素的索引即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">first_owned = motorcycles.pop(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>6）根据值删除元素</p><p>有时候，你不知道要从列表中删除的值所处的位置。如果只知道要 删除的元素的值，可使用方法remove() 。</p><p>例如，假设要从列表motorcycles 中删除值’ducati’ 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">motorcycles.remove(<span class="hljs-string">&#x27;ducati&#x27;</span>) <br></code></pre></td></tr></table></figure><p>注意：方法remove() 只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来确保将每个值都删除。</p><p><strong>列表排序：</strong></p><p>按字母顺序<strong>永久</strong>排列<code>sort()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cars.sort()<br></code></pre></td></tr></table></figure><p>列表顺序被永久改变，<strong>再也无法恢复到原来的排列顺序</strong>。</p><p>按与字母顺序相反的顺序排列列表元素，只需向<code>sort()</code>方法传递参数<code>reverse=True</code> 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cars.sort(reverse=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>列表<strong>临时</strong>排序<code>sorted</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">cars = [<span class="hljs-string">&#x27;bmw&#x27;</span>, <span class="hljs-string">&#x27;audi&#x27;</span>, <span class="hljs-string">&#x27;toyota&#x27;</span>, <span class="hljs-string">&#x27;subaru&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(cars))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(cars,reverse=<span class="hljs-literal">True</span>))<br></code></pre></td></tr></table></figure><p><strong>反转列表reverse()</strong> </p><p>永久性地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，只需对列表再次调用reverse() 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cars.reverse() <br></code></pre></td></tr></table></figure><p><strong>len() 获取列表长度</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">len</span>(cars)<br></code></pre></td></tr></table></figure><h3 id="第-4-章-操作列表"><a href="#第-4-章-操作列表" class="headerlink" title="第 4 章　操作列表"></a>第 4 章　操作列表</h3><p><strong>遍历整个列表：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">magicians = [<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;david&#x27;</span>, <span class="hljs-string">&#x27;carolina&#x27;</span>]<br><span class="hljs-keyword">for</span> magician <span class="hljs-keyword">in</span> magicians:<br><span class="hljs-built_in">print</span>(magician)<br></code></pre></td></tr></table></figure><p><strong>使用函数range()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>):<br><span class="hljs-built_in">print</span>(value)<br></code></pre></td></tr></table></figure><p>在这个示例中，range() 只打印数1～4。</p><p><u>这是编程语言中常见的差一行为的结果</u>。函数range() 让Python从指定的第一个值开始数， 并在到达你指定的第二个值时停止。因为它在第二个值处停止，所以输出不包含该值（这里为5）。</p><p>要打印数1～5，需要使用range(1,6) 。</p><p><strong>使用range() 创建数字列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)) <br><span class="hljs-built_in">print</span>(numbers)<br></code></pre></td></tr></table></figure><p><strong>使用函数range() 时，还可指定步长</strong>。为此，可给这个函数指定第 三个参数，Python将根据这个步长来生成数。</p><p>例如，下面的代码打印1～10的偶数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">even_numbers = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>)) <br><span class="hljs-built_in">print</span>(even_numbers)<br></code></pre></td></tr></table></figure><p>下面的代码演示了如何将前10个整数的平方加入一个列表中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">squares=[]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>):<br>squares.append(i**<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(squares)<br></code></pre></td></tr></table></figure><p><strong>最大值、最小值和总和：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]<br>&gt;&gt;&gt; min(digits)<br>0<br>&gt;&gt;&gt; max(digits)<br>9<br>&gt;&gt;&gt; <span class="hljs-built_in">sum</span>(digits)<br>45<br></code></pre></td></tr></table></figure><p><strong>列表解析：</strong></p><p>列表解析将for循环和创建新元素的代码合并成一行，并自动附加新元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">squares=[i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>)]<br><span class="hljs-built_in">print</span>(squares)<br></code></pre></td></tr></table></figure><p>要使用这种语法，首先指定一个描述性的列表名，如squares 。然后定义一个表达式，用于生成要存储到列表中的值。接下来，编写一个for 循环，用于给表达式提供值。</p><p><strong>元素切片：</strong></p><p>要创建切片，指定要使用的第一个元素和最后一个元素的索引。 与函数range() 一样，Python在到达第二个索引之前的元素后停止。要输出列表中的前三个元素，需要指定索引0和3，这将返回索引为0、1和2的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">players = [<span class="hljs-string">&#x27;charles&#x27;</span>, <span class="hljs-string">&#x27;martina&#x27;</span>, <span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;florence&#x27;</span>, <span class="hljs-string">&#x27;eli&#x27;</span>]<br><span class="hljs-built_in">print</span>(players[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p>如果没有指定第一个索引，Python将自动从列表开头开始。要让切片终止于列表末尾，也可使用类似的语法。</p><p>注意 　可在表示切片的方括号内指定第三个值为步长。</p><p><strong>遍历切片</strong></p><p>如果要遍历列表的部分元素，可在for循环中使用切片。下面的示例遍历前三名队员，并打印他们的名字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">players = [<span class="hljs-string">&#x27;charles&#x27;</span>, <span class="hljs-string">&#x27;martina&#x27;</span>, <span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;florence&#x27;</span>, <span class="hljs-string">&#x27;eli&#x27;</span>]<br><span class="hljs-keyword">for</span> player <span class="hljs-keyword">in</span> players[:<span class="hljs-number">3</span>]:<br><span class="hljs-built_in">print</span>(player.title())<br></code></pre></td></tr></table></figure><p><strong>复制列表</strong></p><p>要复制列表，可创建一个包含整个列表的切片，方法是同时省略起 始索引和终止索引（[:] ）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_foods = [<span class="hljs-string">&#x27;pizza&#x27;</span>, <span class="hljs-string">&#x27;falafel&#x27;</span>, <span class="hljs-string">&#x27;carrot cake&#x27;</span>] <br>friend_foods = my_foods[:]<br></code></pre></td></tr></table></figure><p>如果直接用=赋值，相当于赋的指针，两个指针仍然指向同一个变量。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven&amp;Mabtis</title>
    <link href="/2022/06/25/Maven-Mabtis/"/>
    <url>/2022/06/25/Maven-Mabtis/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="Maven-amp-MyBatis"><a href="#Maven-amp-MyBatis" class="headerlink" title="Maven&amp;MyBatis"></a>Maven&amp;MyBatis</h1><h2 id="1-Maven"><a href="#1-Maven" class="headerlink" title="1.Maven"></a>1.Maven</h2><p>Maven是专门用于管理和构建Java项目的工具，它的主要功能有：</p><ul><li><p>提供了一套标准化的项目结构</p></li><li><p>提供了一套标准化的构建流程（编译，测试，打包，发布……）</p></li><li><p>提供了一套依赖管理机制</p></li></ul><p><strong>标准化的项目结构：</strong></p><p>项目结构我们都知道，每一个开发工具（IDE）都有自己不同的项目结构，它们互相之间不通用。我再eclipse中创建的目录，无法在idea中进行使用，这就造成了很大的不方便。</p><p>而Maven提供了一套标准化的项目结构，所有的IDE使用Maven构建的项目完全一样，所以IDE创建的Maven项目可以通用。如下图右边就是Maven构建的项目结构。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623155158400.png" alt="image-20220623155158400"></p><p><strong>标准化的构建流程：</strong></p><p>我们开发一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。</p><p><strong>依赖管理：</strong></p><p>依赖管理其实就是管理你项目所依赖的第三方资源（jar包、插件）。如之前我们项目中需要使用JDBC和Druid的话，就需要去网上下载对应的依赖包，复制到项目中，还要将jar包加入工作环境这一系列的操作。如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623155540981.png" alt="image-20220623155540981"></p><p>而Maven使用标准的 ==坐标== 配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623155827703.png" alt="image-20220623155827703"></p><p>如上图右边所示就是mysql驱动包的坐标，在项目中只需要写这段配置，其他都不需要我们担心，Maven都帮我们进行操作了。</p><p>市面上有很多构建工具，而Maven依旧还是主流构建工具。</p><h3 id="1-1-Maven简介"><a href="#1-1-Maven简介" class="headerlink" title="1.1  Maven简介"></a>1.1  Maven简介</h3><blockquote><p>==Apache Maven== 是一个项目管理和构建==工具==，它基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。</p><p>官网 ：<a href="http://maven.apache.org/">http://maven.apache.org/</a> </p></blockquote><p>通过上面的描述大家只需要知道Maven是一个工具即可。Apache 是一个开源组织，将来我们会学习很多Apache提供的项目。</p><h4 id="1-1-1-Maven模型"><a href="#1-1-1-Maven模型" class="headerlink" title="1.1.1  Maven模型"></a>1.1.1  Maven模型</h4><ul><li>项目对象模型 (Project Object Model)</li><li>依赖管理模型(Dependency)</li><li>插件(Plugin)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623160058779.png" alt="image-20220623160058779"></p><p>如上图所示就是Maven的模型，紫色框框起来的部分是用来完成 <code>标准化构建流程</code> 。如我们需要编译，Maven提供了一个编译插件供我们使用，我们需要打包，Maven就提供了一个打包插件提供我们使用等。</p><p>项目对象模型就是将我们自己抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623160434238.png" alt="image-20220623160434238"></p><p>依赖管理模型则是使用坐标来描述当前项目依赖哪儿些第三方jar包，上述Maven模型图中还有一部分是仓库。如何理解仓库呢？</p><h4 id="1-1-2-仓库"><a href="#1-1-2-仓库" class="headerlink" title="1.1.2  仓库"></a>1.1.2  仓库</h4><p>大家想想这样的场景，我们创建Maven项目，在项目中使用坐标来指定项目的依赖，那么依赖的jar包到底存储在什么地方呢？其实依赖jar包是存储在我们的本地仓库中。而项目运行时从本地仓库中拿需要的依赖jar包。</p><p><strong>仓库分类：</strong></p><ul><li><p>本地仓库：自己计算机上的一个目录</p></li><li><p>中央仓库：由Maven团队维护的全球唯一的仓库</p><ul><li>地址： <a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></li></ul></li><li><p>远程仓库(私服)：一般由公司团队搭建的私有仓库</p><p>今天我们只学习远程仓库的使用，并不会搭建。</p></li></ul><p>当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包：</p><ul><li><p>如果有，则在项目直接引用;</p></li><li><p>如果没有，则去中央仓库中下载对应的jar包到本地仓库。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623160547513.png" alt="image-20220623160547513"></p><p>如果还可以搭建远程仓库，将来jar包的查找顺序则变为：</p><blockquote><p>本地仓库 —&gt; 远程仓库—&gt; 中央仓库</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623160614307.png" alt="image-20220623160614307"></p><h3 id="1-2-Maven安装配置"><a href="#1-2-Maven安装配置" class="headerlink" title="1.2  Maven安装配置"></a>1.2  Maven安装配置</h3><ul><li><p>解压 apache-maven-3.6.1.rar 既安装完成</p><blockquote><p>建议解压缩到没有中文、特殊字符的路径下。如课程中解压缩到 <code>D:\software</code> 下。</p></blockquote><p>解压缩后的目录结构如下：</p><ul><li>bin目录 ： 存放的是可执行命令。mvn 命令重点关注。</li><li>conf目录 ：存放Maven的配置文件。<code>settings.xml</code> 配置文件后期需要修改。</li><li>lib目录 ：存放Maven依赖的jar包。Maven也是使用java开发的，所以它也依赖其他的jar包。</li></ul></li><li><p>配置环境变量 MAVEN_HOME 为安装路径的bin目录</p><p><code>此电脑</code> 右键  —&gt;  <code>高级系统设置</code>  —&gt;  <code>高级</code>  —&gt;  <code>环境变量</code></p><p>在系统变量处新建一个变量 <code>MAVEN_HOME</code></p><p>在 <code>Path</code> 中进行配置</p><p>打开命令提示符输入mvn -version进行验证，出现success表示安装成功</p></li><li><p>配置本地仓库</p><p>修改 conf/settings.xml 中的 <localRepository> 为一个指定目录作为本地仓库，用来存储jar包。</localRepository></p></li><li><p>配置阿里云私服</p><p>中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。</p><p>修改 conf/settings.xml 中的 <mirrors>标签，为其添加如下子标签：</mirrors></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>          <br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="1-3-Maven基本使用"><a href="#1-3-Maven基本使用" class="headerlink" title="1.3  Maven基本使用"></a>1.3  Maven基本使用</h3><h4 id="1-3-1-Maven-常用命令"><a href="#1-3-1-Maven-常用命令" class="headerlink" title="1.3.1  Maven 常用命令"></a>1.3.1  Maven 常用命令</h4><blockquote><ul><li><p>compile ：编译</p></li><li><p>clean：清理</p></li><li><p>test：测试</p></li><li><p>package：打包</p></li><li><p>install：安装</p></li></ul></blockquote><h4 id="1-3-2-Maven-生命周期"><a href="#1-3-2-Maven-生命周期" class="headerlink" title="1.3.2  Maven 生命周期"></a>1.3.2  Maven 生命周期</h4><p>Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件</p><p>Maven 对项目构建的生命周期划分为3套：</p><ul><li>clean ：清理工作。</li><li>default ：核心工作，例如编译，测试，打包，安装等。</li><li>site ： 产生报告，发布站点等。这套声明周期一般不会使用。</li></ul><p>同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。例如默认（default）生命周期如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623160943179.png" alt="image-20220623160943179"></p><p>当我们执行 <code>install</code>（安装）命令时，它会先执行 <code>compile</code>命令，再执行 <code>test</code> 命令，再执行 <code>package</code> 命令，最后执行 <code>install</code> 命令。</p><p>当我们执行 <code>package</code> （打包）命令时，它会先执行 <code>compile</code> 命令，再执行 <code>test</code> 命令，最后执行 <code>package</code> 命令。</p><p>默认的生命周期也有对应的很多命令，其他的一般都不会使用，我们只关注常用的。</p><h3 id="1-4-IDEA使用Maven"><a href="#1-4-IDEA使用Maven" class="headerlink" title="1.4  IDEA使用Maven"></a>1.4  IDEA使用Maven</h3><p>以后开发中我们肯定会在高级开发工具中使用Maven管理项目，而我们常用的高级开发工具是IDEA，所以接下来我们会讲解Maven在IDEA中的使用。</p><h4 id="1-4-1-Maven-坐标详解"><a href="#1-4-1-Maven-坐标详解" class="headerlink" title="1.4.1  Maven 坐标详解"></a>1.4.1  Maven 坐标详解</h4><p><strong>什么是坐标？</strong></p><ul><li>Maven 中的坐标是==资源的唯一标识==</li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul><p><strong>Maven 坐标主要组成</strong></p><ul><li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</li><li>artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）</li><li>version：定义当前项目版本号</li></ul><p>如下图就是使用坐标表示一个项目：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623161206142.png" alt="image-20220623161206142"></p><blockquote><p>==注意：==</p><ul><li>上面所说的资源可以是插件、依赖、当前项目。</li><li>我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。</li></ul></blockquote><h4 id="1-4-2-IDEA-导入-Maven项目"><a href="#1-4-2-IDEA-导入-Maven项目" class="headerlink" title="1.4.2  IDEA 导入 Maven项目"></a>1.4.2  IDEA 导入 Maven项目</h4><p>大家在学习时可能需要看老师的代码，当然也就需要将老师的代码导入到自己的IDEA中。我们可以通过以下步骤进行项目的导入：</p><ul><li><p>选择右侧Maven面板，点击 + 号</p></li><li><p>选中对应项目的pom.xml文件，双击即可</p></li><li><p>如果没有Maven面板，选择</p><p>View —&gt; Appearance —&gt; Tool Window Bars</p></li></ul><p><strong>配置 Maven-Helper 插件</strong> </p><ul><li><p>选择 IDEA中 File —&gt; Settings</p></li><li><p>选择 Plugins</p></li><li><p>搜索 Maven，选择第一个 Maven Helper，点击Install安装，弹出面板中点击Accept</p></li><li><p>重启 IDEA</p></li></ul><p>安装完该插件后可以通过 选中项目右键进行相关命令操作。</p><h3 id="1-5-依赖管理"><a href="#1-5-依赖管理" class="headerlink" title="1.5  依赖管理"></a>1.5  依赖管理</h3><h4 id="1-5-1-使用坐标引入jar包"><a href="#1-5-1-使用坐标引入jar包" class="headerlink" title="1.5.1  使用坐标引入jar包"></a>1.5.1  使用坐标引入jar包</h4><p><strong>使用坐标引入jar包的步骤：</strong></p><ul><li><p>在项目的 pom.xml 中编写 <dependencies> 标签</dependencies></p></li><li><p>在 <dependencies> 标签中 使用 <dependency> 引入坐标</dependency></dependencies></p></li><li><p>定义坐标的 groupId，artifactId，version</p></li><li><p>点击刷新按钮，使坐标生效</p></li></ul><blockquote><p> 注意：</p><ul><li>具体的坐标我们可以到如下网站进行搜索</li><li><a href="https://mvnrepository.com/">https://mvnrepository.com/</a></li></ul></blockquote><p>==<strong>快捷方式导入jar包的坐标：</strong>==</p><p>每次需要引入jar包，都去对应的网站进行搜索是比较麻烦的，接下来给大家介绍一种快捷引入坐标的方式</p><ul><li><p>在 pom.xml 中 按 alt + insert，选择 Dependency</p></li><li><p>在弹出的面板中搜索对应坐标，然后双击选中对应坐标</p></li><li><p>点击刷新按钮，使坐标生效</p></li></ul><p><strong>自动导入设置：</strong></p><p>上面每次操作都需要点击刷新按钮，让引入的坐标生效。当然我们也可以通过设置让其自动完成</p><ul><li><p>选择 IDEA中 File —&gt; Settings</p></li><li><p>在弹出的面板中找到 Build Tools</p></li><li><p>选择 Any changes，点击 ok 即可生效</p></li></ul><h4 id="1-5-2-依赖范围"><a href="#1-5-2-依赖范围" class="headerlink" title="1.5.2  依赖范围"></a>1.5.2  依赖范围</h4><p>通过设置坐标的依赖范围(scope)，可以设置对应jar包的作用范围：编译环境、测试环境、运行环境。</p><p>如下图所示给 <code>junit</code> 依赖通过 <code>scope</code> 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623161514148.png" alt="image-20220623161514148"></p><p>那么 <code>scope</code> 都可以有哪些取值呢？</p><div class="table-container"><table><thead><tr><th><strong>依赖范围</strong></th><th>编译classpath</th><th>测试classpath</th><th>运行classpath</th><th>例子</th></tr></thead><tbody><tr><td><strong>compile</strong></td><td>Y</td><td>Y</td><td>Y</td><td>logback</td></tr><tr><td><strong>test</strong></td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td><strong>provided</strong></td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td><strong>runtime</strong></td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr><tr><td><strong>system</strong></td><td>Y</td><td>Y</td><td>-</td><td>存储在本地的jar包</td></tr></tbody></table></div><ul><li>compile ：作用于编译环境、测试环境、运行环境。</li><li>test ： 作用于测试环境。典型的就是Junit坐标，以后使用Junit时，都会将scope指定为该值</li><li>provided ：作用于编译环境、测试环境。我们后面会学习 <code>servlet-api</code> ，在使用它时，必须将 <code>scope</code> 设置为该值，不然运行时就会报错</li><li>runtime  ： 作用于测试环境、运行环境。jdbc驱动一般将 <code>scope</code> 设置为该值，当然不设置也没有任何问题 </li></ul><blockquote><p>注意：</p><ul><li>如果引入坐标不指定 <code>scope</code> 标签时，默认就是 compile  值。以后大部分jar包都是使用默认值。</li></ul></blockquote><h2 id="2-Mybatis"><a href="#2-Mybatis" class="headerlink" title="2.Mybatis"></a>2.Mybatis</h2><h3 id="2-1-Mybatis概述"><a href="#2-1-Mybatis概述" class="headerlink" title="2.1  Mybatis概述"></a>2.1  Mybatis概述</h3><h4 id="2-1-1-Mybatis概念"><a href="#2-1-1-Mybatis概念" class="headerlink" title="2.1.1  Mybatis概念"></a>2.1.1  Mybatis概念</h4><blockquote><ul><li><p>MyBatis 是一款优秀的==持久层框架==，用于简化 JDBC 开发</p></li><li><p>MyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github</p></li><li><p>官网：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a> </p></li></ul></blockquote><p><strong>持久层：</strong></p><ul><li><p>负责将数据到保存到数据库的那一层代码。</p><p>以后开发我们会将操作数据库的Java代码作为持久层。而Mybatis就是对jdbc代码进行了封装。</p></li><li><p>JavaEE三层架构：表现层、业务层、持久层</p><p>三层架构在后期会给大家进行讲解，今天先简单的了解下即可。</p></li></ul><p><strong>框架：</strong></p><ul><li>框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型</li><li>在框架的基础之上构建软件编写更加高效、规范、通用、可扩展</li></ul><p>举例给大家简单的解释一下什么是半成品软件。大家小时候应该在公园见过给石膏娃娃涂鸦，石膏娃娃就是一个半成品。你可以在这个半成品的基础上进行不同颜色的涂鸦。</p><p>了解了什么是Mybatis后，接下来说说以前 <code>JDBC代码</code> 的缺点以及Mybatis又是如何解决的。</p><h4 id="2-1-2-JDBC-缺点"><a href="#2-1-2-JDBC-缺点" class="headerlink" title="2.1.2  JDBC 缺点"></a>2.1.2  JDBC 缺点</h4><p>下面是 JDBC 代码，我们通过该代码分析都存在什么缺点：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623161819227.png" alt="image-20220623161819227"></p><ul><li><p>硬编码</p><ul><li><p>注册驱动、获取连接</p><p>上图标1的代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要将Mysql数据库换成其他的关系型数据库的话，这四个地方都需要修改，如果放在此处就意味着要修改我们的源代码。</p></li><li><p>SQL语句</p><p>上图标2的代码。如果表结构发生变化，SQL语句就要进行更改。这也不方便后期的维护。</p></li></ul></li><li><p>操作繁琐</p><ul><li><p>手动设置参数</p></li><li><p>手动封装结果集</p><p>上图标4的代码是对查询到的数据进行封装，而这部分代码是没有什么技术含量，而且特别耗费时间的。</p></li></ul></li></ul><h4 id="2-1-3-Mybatis-优化"><a href="#2-1-3-Mybatis-优化" class="headerlink" title="2.1.3  Mybatis 优化"></a>2.1.3  Mybatis 优化</h4><ul><li>硬编码可以配置到==配置文件==</li><li>操作繁琐的地方mybatis都==自动完成==</li></ul><p>如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623161927456.png" alt="image-20220623161927456"></p><h3 id="2-2-Mybatis快速入门"><a href="#2-2-Mybatis快速入门" class="headerlink" title="2.2  Mybatis快速入门"></a>2.2  Mybatis快速入门</h3><p><strong>需求：查询user表中所有的数据</strong></p><ul><li><p>创建user表，添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database mybatis;<br>use mybatis;<br><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> tb_user;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_user(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>username <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>password <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>),<br>addr <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_user <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_user <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;234&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-string">&#x27;天津&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_user <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-string">&#x27;11&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;西安&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>创建模块，导入坐标</p><p>在创建好的模块中的 pom.xml 配置文件中添加依赖的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mybatis 依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--mysql 驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.46<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--junit 单元测试--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 添加slf4j日志api --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 添加logback-classic依赖 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 添加logback-core依赖 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：需要在项目的 resources 目录下创建logback的配置文件</p></li><li><p>编写 MyBatis 核心配置文件 — &gt; 替换连接信息 解决硬编码问题</p><p>在模块下的 resources 目录下创建mybatis的配置文件 <code>mybatis-config.xml</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.itheima.pojo&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--数据库连接信息--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--数据库连接信息--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--加载sql映射文件--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;UserMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写 SQL 映射文件 —&gt; 统一管理sql语句，解决硬编码问题</p><p>在模块的 <code>resources</code> 目录下创建映射配置文件 <code>UserMapper.xml</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.User&quot;</span>&gt;</span><br>        select * from tb_user;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编码</p><ul><li><p>在 <code>com.itheima.pojo</code> 包下创建 User类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> String gender;<br>    <span class="hljs-keyword">private</span> String addr;<br>    <br>    <span class="hljs-comment">//省略了 setter 和 getter</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 <code>com.itheima</code> 包下编写 MybatisDemo 测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//1. 加载mybatis的核心配置文件，获取 SqlSessionFactory</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br><br>        <span class="hljs-comment">//2. 获取SqlSession对象，用它来执行sql</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>        <span class="hljs-comment">//3. 执行sql</span><br>        List&lt;User&gt; users = sqlSession.selectList(<span class="hljs-string">&quot;test.selectAll&quot;</span>); <span class="hljs-comment">//参数是一个字符串，该字符串必须是映射配置文件的namespace.id</span><br>        System.out.println(users);<br>        <span class="hljs-comment">//4. 释放资源</span><br>        sqlSession.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p><strong>解决SQL映射文件的警告提示：</strong></p><p>在入门案例映射配置文件中存在报红的情况。问题如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624131703334.png" alt="image-20220624131703334"></p><ul><li>产生的原因：Idea和数据库没有建立连接，不识别表信息。但是大家一定要记住，它并不影响程序的执行。</li><li>解决方式：在Idea中配置MySQL数据库连接。</li></ul><p>IDEA中配置MySQL数据库连接</p><ul><li><p>点击IDEA右边框的 <code>Database</code> ，在展开的界面点击 <code>+</code> 选择 <code>Data Source</code> ，再选择 <code>MySQL</code></p></li><li><p>在弹出的界面进行基本信息的填写</p></li><li><p>点击完成后就能看到数据库界面</p><p>而此界面就和 <code>navicat</code> 工具一样可以进行数据库的操作。也可以编写SQL语句</p></li></ul><h3 id="2-3-Mapper代理开发"><a href="#2-3-Mapper代理开发" class="headerlink" title="2.3  Mapper代理开发"></a>2.3  Mapper代理开发</h3><h4 id="2-3-1-Mapper代理开发概述"><a href="#2-3-1-Mapper代理开发概述" class="headerlink" title="2.3.1  Mapper代理开发概述"></a>2.3.1  Mapper代理开发概述</h4><p>之前我们写的代码是基本使用方式，它也存在硬编码的问题，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624131830769.png" alt="image-20220624131830769"></p><p>这里调用 <code>selectList()</code> 方法传递的参数是映射配置文件中的 namespace.id值。这样写也不便于后期的维护。如果使用 Mapper 代理方式（如下图）则不存在硬编码问题。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624134743717.png" alt="image-20220624134743717"></p><p>通过上面的描述可以看出 Mapper 代理方式的目的：</p><ul><li>解决原生方式中的硬编码</li><li>简化后期执行SQL</li></ul><p>Mybatis 官网也是推荐使用 Mapper 代理的方式。</p><h4 id="2-3-2-使用Mapper代理要求"><a href="#2-3-2-使用Mapper代理要求" class="headerlink" title="2.3.2  使用Mapper代理要求"></a>2.3.2  使用Mapper代理要求</h4><p>使用Mapper代理方式，必须满足以下要求：</p><ul><li><p>定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624135545113.png" alt="image-20220624135545113" style="zoom:50%;"></p></li><li><p>设置SQL映射文件的namespace属性为Mapper接口全限定名</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624135611903.png" alt="image-20220624135611903"></p></li><li><p>在 Mapper 接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624135757618.png" alt="image-20220624135757618"></p></li></ul><h4 id="2-3-3-案例代码实现"><a href="#2-3-3-案例代码实现" class="headerlink" title="2.3.3  案例代码实现"></a>2.3.3  案例代码实现</h4><ul><li><p>在 <code>com.itheima.mapper</code> 包下创建 UserMapper接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    List&lt;User&gt; <span class="hljs-title function_">selectAll</span><span class="hljs-params">()</span>;<br>    User <span class="hljs-title function_">selectById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 <code>resources</code> 下创建 <code>com/itheima/mapper</code> 目录，并在该目录下创建 UserMapper.xml 映射配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    namespace:名称空间。必须是对应接口的全限定名</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.User&quot;</span>&gt;</span><br>        select *<br>        from tb_user;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在 <code>com.itheima</code> 包下创建 MybatisDemo2 测试类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Mybatis 代理开发</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisDemo2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">//1. 加载mybatis的核心配置文件，获取 SqlSessionFactory</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br><br>        <span class="hljs-comment">//2. 获取SqlSession对象，用它来执行sql</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>        <span class="hljs-comment">//3. 执行sql</span><br>        <span class="hljs-comment">//3.1 获取UserMapper接口的代理对象</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        List&lt;User&gt; users = userMapper.selectAll();<br><br>        System.out.println(users);<br>        <span class="hljs-comment">//4. 释放资源</span><br>        sqlSession.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>==注意：==</p><p>如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载。也就是将核心配置文件的加载映射配置文件的配置修改为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--加载sql映射文件--&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;--&gt;</span><br>    <span class="hljs-comment">&lt;!--Mapper代理方式--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.itheima.mapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-4-核心配置文件"><a href="#2-4-核心配置文件" class="headerlink" title="2.4  核心配置文件"></a>2.4  核心配置文件</h3><p>核心配置文件中现有的配置之前已经给大家进行了解释，而核心配置文件中还可以配置很多内容。我们可以通过查询官网看可以配置的内容</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624140201708.png" alt="image-20220624140201708"></p><p>接下来我们先对里面的一些配置进行讲解。</p><h4 id="2-4-1-多环境配置"><a href="#2-4-1-多环境配置" class="headerlink" title="2.4.1  多环境配置"></a>2.4.1  多环境配置</h4><p>在核心配置文件的 <code>environments</code> 标签中其实是可以配置多个 <code>environment</code> ，使用 <code>id</code> 给每段环境起名，在 <code>environments</code> 中使用 <code>default=&#39;环境id&#39;</code> 来指定使用哪段配置。我们一般就配置一个 <code>environment</code> 即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--数据库连接信息--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--数据库连接信息--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-4-2-类型别名"><a href="#2-4-2-类型别名" class="headerlink" title="2.4.2  类型别名"></a>2.4.2  类型别名</h4><p>在映射配置文件中的 <code>resultType</code> 属性需要配置数据封装的类型（类的全限定名）。而每次这样写是特别麻烦的，Mybatis 提供了 <code>类型别名</code>(typeAliases) 可以简化这部分的书写。</p><p>首先需要现在核心配置文件中配置类型别名，也就意味着给pojo包下所有的类起了别名（别名就是类名），不区分大小写。内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--name属性的值是实体类所在包--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.itheima.pojo&quot;</span>/&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过上述的配置，我们就可以简化映射配置文件中 <code>resultType</code> 属性值的编写</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>        select * from tb_user;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="Mybatis练习"><a href="#Mybatis练习" class="headerlink" title="Mybatis练习"></a>Mybatis练习</h1><p><strong>目标</strong></p><blockquote><ul><li>能够使用映射配置文件实现CRUD操作</li><li>能够使用注解实现CRUD操作</li></ul></blockquote><h2 id="1-配置文件实现CRUD"><a href="#1-配置文件实现CRUD" class="headerlink" title="1.配置文件实现CRUD"></a>1.配置文件实现CRUD</h2><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624145701637.png" alt="image-20220624145701637"></p><p>如上图所示产品原型，里面包含了品牌数据的 <code>查询</code> 、<code>按条件查询</code>、<code>添加</code>、<code>删除</code>、<code>批量删除</code>、<code>修改</code> 等功能，而这些功能其实就是对数据库表中的数据进行CRUD操作。接下来我们就使用Mybatis完成品牌数据的增删改查操作。以下是我们要完成功能列表：</p><blockquote><ul><li>查询<ul><li>查询所有数据</li><li>查询详情</li><li>条件查询</li></ul></li><li>添加</li><li>修改<ul><li>修改全部字段</li><li>修改动态字段</li></ul></li><li>删除<ul><li>删除一个</li><li>批量删除</li></ul></li></ul></blockquote><p>我们先将必要的环境准备一下。</p><h3 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1  环境准备"></a>1.1  环境准备</h3><ul><li><p>数据库表（tb_brand）及数据准备</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除tb_brand表</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> tb_brand;<br><span class="hljs-comment">-- 创建tb_brand表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_brand<br>(<br>    <span class="hljs-comment">-- id 主键</span><br>    id           <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    <span class="hljs-comment">-- 品牌名称</span><br>    brand_name   <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-comment">-- 企业名称</span><br>    company_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-comment">-- 排序字段</span><br>    ordered      <span class="hljs-type">int</span>,<br>    <span class="hljs-comment">-- 描述信息</span><br>    description  <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>    <span class="hljs-comment">-- 状态：0：禁用  1：启用</span><br>    status       <span class="hljs-type">int</span><br>);<br><span class="hljs-comment">-- 添加数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_brand (brand_name, company_name, ordered, description, status)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;三只松鼠&#x27;</span>, <span class="hljs-string">&#x27;三只松鼠股份有限公司&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;好吃不上火&#x27;</span>, <span class="hljs-number">0</span>),<br>       (<span class="hljs-string">&#x27;华为&#x27;</span>, <span class="hljs-string">&#x27;华为技术有限公司&#x27;</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#x27;</span>, <span class="hljs-number">1</span>),<br>       (<span class="hljs-string">&#x27;小米&#x27;</span>, <span class="hljs-string">&#x27;小米科技有限公司&#x27;</span>, <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;are you ok&#x27;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p>实体类 Brand</p><p>在 <code>com.itheima.pojo</code> 包下创建 Brand 实体类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Brand</span> &#123;<br>    <span class="hljs-comment">// id 主键</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-comment">// 品牌名称</span><br>    <span class="hljs-keyword">private</span> String brandName;<br>    <span class="hljs-comment">// 企业名称</span><br>    <span class="hljs-keyword">private</span> String companyName;<br>    <span class="hljs-comment">// 排序字段</span><br>    <span class="hljs-keyword">private</span> Integer ordered;<br>    <span class="hljs-comment">// 描述信息</span><br>    <span class="hljs-keyword">private</span> String description;<br>    <span class="hljs-comment">// 状态：0：禁用  1：启用</span><br>    <span class="hljs-keyword">private</span> Integer status;<br>    <br>    <span class="hljs-comment">//省略 setter and getter。自己写时要补全这部分代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写测试用例</p><p>测试代码需要在 <code>test/java</code> 目录下创建包及测试用例。项目结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624151011848.png" alt="image-20220624151011848" style="zoom:50%;"></p></li><li><p>安装 MyBatisX 插件</p><ul><li><p>MybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。</p></li><li><p>主要功能</p><ul><li>XML映射配置文件 和 接口方法 间相互跳转</li><li>根据接口方法生成 statement </li></ul></li><li><p>安装方式</p><p>在IDEA内安装。</p><blockquote><p>注意：安装完毕后需要重启IDEA</p></blockquote></li><li><p>插件效果</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624151214375.png" alt="image-20220624151214375"></p><p>红色头绳的表示映射配置文件，蓝色头绳的表示mapper接口。在mapper接口点击红色头绳的小鸟图标会自动跳转到对应的映射配置文件，在映射配置文件中点击蓝色头绳的小鸟图标会自动跳转到对应的mapper接口。也可以在mapper接口中定义方法，自动生成映射配置文件中的 <code>statement</code> ，如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624151250630.png" alt="image-20220624151250630"></p></li></ul></li></ul><h3 id="1-2-查询所有数据"><a href="#1-2-查询所有数据" class="headerlink" title="1.2  查询所有数据"></a>1.2  查询所有数据</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624161818058.png" alt="image-20220624161818058"></p><p>如上图所示就页面上展示的数据，而这些数据需要从数据库进行查询。接下来我们就来讲查询所有数据功能，而实现该功能我们分以下步骤进行实现：</p><ul><li><p>编写接口方法：Mapper接口</p><ul><li><p>参数：无</p><p>查询所有数据功能是不需要根据任何条件进行查询的，所以此方法不需要参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Brand&gt; <span class="hljs-title function_">selectAll</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li><li><p>结果：List<Brand></Brand></p><p>我们会将查询出来的每一条数据封装成一个 <code>Brand</code> 对象，而多条数据封装多个 <code>Brand</code> 对象，需要将这些对象封装到List集合中返回。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;brand&quot;</span>&gt;</span><br>select *<br>        from tb_brand;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>执行方法、测试</p></li></ul></li></ul><h4 id="1-2-1-编写接口方法"><a href="#1-2-1-编写接口方法" class="headerlink" title="1.2.1  编写接口方法"></a>1.2.1  编写接口方法</h4><p>在 <code>com.itheima.mapper</code> 包写创建名为 <code>BrandMapper</code> 的接口。并在该接口中定义 <code>List&lt;Brand&gt; selectAll()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BrandMapper</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询所有</span><br><span class="hljs-comment">     */</span><br>    List&lt;Brand&gt; <span class="hljs-title function_">selectAll</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-2-编写SQL语句"><a href="#1-2-2-编写SQL语句" class="headerlink" title="1.2.2  编写SQL语句"></a>1.2.2  编写SQL语句</h4><p>在 <code>reources</code> 下创建 <code>com/itheima/mapper</code> 目录结构，并在该目录下创建名为 <code>BrandMapper.xml</code> 的映射配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mapper.BrandMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;brand&quot;</span>&gt;</span><br>        select *<br>        from tb_brand;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-2-3-编写测试方法"><a href="#1-2-3-编写测试方法" class="headerlink" title="1.2.3  编写测试方法"></a>1.2.3  编写测试方法</h4><p>在 <code>MybatisTest</code> 类中编写测试查询所有的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br><br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br><br>    <span class="hljs-comment">//4. 执行方法</span><br>    List&lt;Brand&gt; brands = brandMapper.selectAll();<br>    System.out.println(brands);<br><br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：现在我们感觉测试这部分代码写起来特别麻烦，我们可以先忍忍。以后我们只会写上面的第3步的代码，其他的都不需要我们来完成。</p></blockquote><p>执行测试方法结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624163322311.png" alt="image-20220624163322311"></p><p>从上面结果我们看到了问题，有些数据封装成功了，而有些数据并没有封装成功。为什么这样呢？</p><p>这个问题可以通过两种方式进行解决：</p><ul><li>给字段起别名</li><li>使用resultMap定义字段和属性的映射关系</li></ul><h4 id="1-2-4-起别名解决上述问题"><a href="#1-2-4-起别名解决上述问题" class="headerlink" title="1.2.4  起别名解决上述问题"></a>1.2.4  起别名解决上述问题</h4><p>从上面结果可以看到 <code>brandName</code> 和 <code>companyName</code> 这两个属性的数据没有封装成功，查询 实体类 和 表中的字段 发现，在实体类中属性名是 <code>brandName</code> 和 <code>companyName</code> ，而表中的字段名为 <code>brand_name</code> 和 <code>company_name</code>，如下图所示 。那么我们只需要保持这两部分的名称一致这个问题就迎刃而解。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624164419703.png" alt="image-20220624164419703"></p><p>我们可以在写sql语句时给这两个字段起别名，将别名定义成和属性名一致即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;brand&quot;</span>&gt;</span><br>    select<br>    id, brand_name as brandName, company_name as companyName, ordered, description, status<br>    from tb_brand;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>而上面的SQL语句中的字段列表书写麻烦，如果表中还有更多的字段，同时其他的功能也需要查询这些字段时就显得我们的代码不够精炼。Mybatis提供了<code>sql</code> 片段可以提高sql的复用性。</p><p><strong>SQL片段：</strong></p><ul><li><p>将需要复用的SQL片段抽取到 <code>sql</code> 标签中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;brand_column&quot;</span>&gt;</span><br>id, brand_name as brandName, company_name as companyName, ordered, description, status<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><p>id属性值是唯一标识，引用时也是通过该值进行引用。</p></li><li><p>在原sql语句中进行引用</p><p>使用 <code>include</code> 标签引用上述的 SQL 片段，而 <code>refid</code> 指定上述 SQL 片段的id值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;brand&quot;</span>&gt;</span><br>    select<br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;brand_column&quot;</span> /&gt;</span><br>    from tb_brand;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="1-2-5-使用resultMap解决上述问题"><a href="#1-2-5-使用resultMap解决上述问题" class="headerlink" title="1.2.5  使用resultMap解决上述问题"></a>1.2.5  使用resultMap解决上述问题</h4><p>起别名 + sql片段的方式可以解决上述问题，但是它也存在问题。如果还有功能只需要查询部分字段，而不是查询所有字段，那么我们就需要再定义一个 SQL 片段，这就显得不是那么灵活。</p><p>那么我们也可以使用resultMap来定义字段和属性的映射关系的方式解决上述问题。</p><ul><li><p>在映射配置文件中使用resultMap定义 字段 和 属性 的映射关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;brand&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            id：完成主键字段的映射</span><br><span class="hljs-comment">                column：表的列名</span><br><span class="hljs-comment">                property：实体类的属性名</span><br><span class="hljs-comment">            result：完成一般字段的映射</span><br><span class="hljs-comment">                column：表的列名</span><br><span class="hljs-comment">                property：实体类的属性名</span><br><span class="hljs-comment">        --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;brand_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;brandName&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;company_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;companyName&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：在上面只需要定义 字段名 和 属性名 不一样的映射，而一样的则不需要专门定义出来。</p></blockquote></li><li><p>SQL语句正常编写</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="1-2-6-小结"><a href="#1-2-6-小结" class="headerlink" title="1.2.6  小结"></a>1.2.6  小结</h4><p>实体类属性名 和 数据库表列名 不一致，不能自动封装数据</p><ul><li>==起别名：==在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样<ul><li>可以定义 <sql>片段，提升复用性 </sql></li><li>缺点：不灵活</li></ul></li><li>==resultMap：==定义<resultMap> 完成不一致的属性名和列名的映射<ul><li>定义<code>&lt;resultMap&gt;</code>标签</li><li>在<code>&lt;select&gt;</code>标签中，使用<resultMap> 属性替换<resultType> 属性</resultType></resultMap></li></ul></resultMap></li></ul><p>而我们最终选择使用 resultMap的方式。查询映射配置文件中查询所有的 statement 书写如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;brand&quot;</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            id：完成主键字段的映射</span><br><span class="hljs-comment">                column：表的列名</span><br><span class="hljs-comment">                property：实体类的属性名</span><br><span class="hljs-comment">            result：完成一般字段的映射</span><br><span class="hljs-comment">                column：表的列名</span><br><span class="hljs-comment">                property：实体类的属性名</span><br><span class="hljs-comment">        --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;brand_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;brandName&quot;</span>/&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;company_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;companyName&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-3-查询详情"><a href="#1-3-查询详情" class="headerlink" title="1.3  查询详情"></a>1.3  查询详情</h3><p>有些数据的属性比较多，在页面表格中无法全部实现，而只会显示部分，而其他属性数据的查询可以通过 <code>查看详情</code> 来进行查询，如上图所示。</p><p>查看详情功能实现步骤：</p><ul><li><p>编写接口方法：Mapper接口</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624201503587.png" alt="image-20220624201503587"></p><ul><li><p>参数：id</p><p>查看详情就是查询某一行数据，所以需要根据id进行查询。而id以后是由页面传递过来。</p></li><li><p>结果：Brand</p><p>根据id查询出来的数据只要一条，而将一条数据封装成一个Brand对象即可</p></li></ul></li><li><p>编写SQL语句：SQL映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>        select *<br>        from tb_brand<br>        where id<br>         &lt;![CDATA[<br>            &lt;<br>         ]]&gt;<br>         #&#123;id&#125;;<br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ul><li>执行方法、进行测试</li></ul><h4 id="1-3-1-编写接口方法"><a href="#1-3-1-编写接口方法" class="headerlink" title="1.3.1  编写接口方法"></a>1.3.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义根据id查询数据的方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 查看详情：根据Id查询</span><br><span class="hljs-comment">  */</span><br>Brand <span class="hljs-title function_">selectById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-3-2-编写SQL语句"><a href="#1-3-2-编写SQL语句" class="headerlink" title="1.3.2  编写SQL语句"></a>1.3.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写 <code>statement</code>，使用 <code>resultMap</code> 而不是使用 <code>resultType</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand where id = #&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：上述SQL中的 #{id}先这样写，一会我们再详细讲解</p></blockquote><h4 id="1-3-3-编写测试方法"><a href="#1-3-3-编写测试方法" class="headerlink" title="1.3.3  编写测试方法"></a>1.3.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//接收参数，该id以后需要传递过来</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br><br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br><br>    <span class="hljs-comment">//4. 执行方法</span><br>    <span class="hljs-type">Brand</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> brandMapper.selectById(id);<br>    System.out.println(brand);<br><br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行测试方法结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625114451200.png" alt="image-20220625114451200"></p><h4 id="1-3-4-参数占位符"><a href="#1-3-4-参数占位符" class="headerlink" title="1.3.4  参数占位符"></a>1.3.4  参数占位符</h4><p>查询到的结果很好理解就是id为1的这行数据。而这里我们需要看控制台显示的SQL语句，能看到使用？进行占位。说明我们在映射配置文件中的写的 <code>#&#123;id&#125;</code> 最终会被？进行占位。接下来我们就聊聊映射配置文件中的参数占位符。</p><p>mybatis提供了两种参数占位符：</p><ul><li><p>#{} ：执行SQL时，会将 #{} 占位符替换为？，将来自动设置参数值。从上述例子可以看出使用#{} 底层使用的是 <code>PreparedStatement</code></p></li><li><p>${} ：拼接SQL。底层使用的是 <code>Statement</code>，会存在SQL注入问题。如下图将 映射配置文件中的#{} 替换成 ${} 来看效果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand where id = $&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>重新运行查看结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625114522829.png" alt="image-20220625114522829"></p></li></ul><blockquote><p>===注意：从上面两个例子可以看出，以后开发我们使用 #{} 参数占位符。==</p></blockquote><h4 id="1-3-5-parameterType使用"><a href="#1-3-5-parameterType使用" class="headerlink" title="1.3.5  parameterType使用"></a>1.3.5  parameterType使用</h4><p>对于<strong>有参数的mapper接口方法</strong>，我们在映射配置文件中应该配置 <code>ParameterType</code> 来指定参数类型。只不过该属性都可以省略。如下图：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand where id = $&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-3-6-SQL语句中特殊字段处理"><a href="#1-3-6-SQL语句中特殊字段处理" class="headerlink" title="1.3.6  SQL语句中特殊字段处理"></a>1.3.6  SQL语句中特殊字段处理</h4><p>以后肯定会在SQL语句中写一下特殊字符，比如某一个字段大于某个值。但遇到非转义的字符就会出现报错，因为映射配置文件是xml类型的问题，而 &gt; &lt; 等这些字符在xml中有特殊含义，所以此时我们需要将这些符号进行转义，可以使用以下两种方式进行转义</p><ul><li><p>转义字符</p><p><code>&amp;lt;</code> 就是 <code>&lt;</code> 的转义字符。</p></li><li><p>&lt;![CDATA[内容]]&gt;</p><p>打一个CD回车，会自动出现该格式内容，将需要转义的字符直接打在里面即可。</p><p>字符较少用第一种，字符较多用第二种。</p></li></ul><h3 id="1-4-多条件查询"><a href="#1-4-多条件查询" class="headerlink" title="1.4  多条件查询"></a>1.4  多条件查询</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625114559067.png" alt="image-20220625114559067"></p><p>我们经常会遇到如上图所示的多条件查询，将多条件查询的结果展示在下方的数据列表中。而我们做这个功能需要分析最终的SQL语句应该是什么样，思考两个问题</p><ul><li>条件表达式怎么写</li><li>多个条件表达式如何连接</li></ul><p>条件字段 <code>企业名称</code>  和 <code>品牌名称</code> 需要进行模糊查询，所以条件应该是：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625114642572.png" alt="image-20220625114642572"></p><p>简单的分析后，我们来看功能实现的步骤：</p><ul><li>编写接口方法<ul><li>参数：所有查询条件</li><li>结果：List<Brand></Brand></li></ul></li><li><p>在映射配置文件中编写SQL语句</p></li><li><p>编写测试方法并执行</p></li></ul><h4 id="1-4-1-编写接口方法"><a href="#1-4-1-编写接口方法" class="headerlink" title="1.4.1  编写接口方法"></a>1.4.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义多条件查询的方法。</p><p>而该功能有三个参数，我们就需要考虑定义接口时，参数应该如何定义。Mybatis针对多参数有多种实现</p><ul><li><p>使用 <code>@Param(&quot;参数名称&quot;)</code> 标记每一个参数，在映射配置文件中就需要使用 <code>#&#123;参数名称&#125;</code> 进行占位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Brand&gt; <span class="hljs-title function_">selectByCondition</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;status&quot;)</span> <span class="hljs-type">int</span> status, <span class="hljs-meta">@Param(&quot;companyName&quot;)</span> String companyName,<span class="hljs-meta">@Param(&quot;brandName&quot;)</span> String brandName)</span>;<br></code></pre></td></tr></table></figure></li><li><p>将多个参数封装成一个 实体对象 ，将该实体对象作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，==里面的内容必须和实体类属性名保持一致==。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Brand&gt; <span class="hljs-title function_">selectByCondition</span><span class="hljs-params">(Brand brand)</span>;<br></code></pre></td></tr></table></figure></li><li><p>将多个参数封装到map集合中，将map集合作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，==里面的内容必须和map集合中键的名称一致==。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">List&lt;Brand&gt; selectByCondition(<span class="hljs-built_in">Map</span> <span class="hljs-built_in">map</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="1-4-2-编写SQL语句"><a href="#1-4-2-编写SQL语句" class="headerlink" title="1.4.2  编写SQL语句"></a>1.4.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写 <code>statement</code>，使用 <code>resultMap</code> 而不是使用 <code>resultType</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByCondition&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand<br>    where status = #&#123;status&#125;<br>    and company_name like #&#123;companyName&#125;<br>    and brand_name like #&#123;brandName&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-4-3-编写测试方法"><a href="#1-4-3-编写测试方法" class="headerlink" title="1.4.3  编写测试方法"></a>1.4.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectByCondition</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//接收参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;华为&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;华为&quot;</span>;<br><br>    <span class="hljs-comment">// 处理参数</span><br>    companyName = <span class="hljs-string">&quot;%&quot;</span> + companyName + <span class="hljs-string">&quot;%&quot;</span>;<br>    brandName = <span class="hljs-string">&quot;%&quot;</span> + brandName + <span class="hljs-string">&quot;%&quot;</span>;<br><br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br><br>    <span class="hljs-comment">//4. 执行方法</span><br><span class="hljs-comment">//方式一 ：接口方法参数使用 @Param 方式调用的方法</span><br>    <span class="hljs-comment">//List&lt;Brand&gt; brands = brandMapper.selectByCondition(status, companyName, brandName);</span><br>    <span class="hljs-comment">//方式二 ：接口方法参数是 实体类对象 方式调用的方法</span><br>     <span class="hljs-comment">//封装对象</span><br>    <span class="hljs-comment">/* Brand brand = new Brand();</span><br><span class="hljs-comment">        brand.setStatus(status);</span><br><span class="hljs-comment">        brand.setCompanyName(companyName);</span><br><span class="hljs-comment">        brand.setBrandName(brandName);*/</span><br>    <br>    <span class="hljs-comment">//List&lt;Brand&gt; brands = brandMapper.selectByCondition(brand);</span><br>    <br>    <span class="hljs-comment">//方式三 ：接口方法参数是 map集合对象 方式调用的方法</span><br>    <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    map.put(<span class="hljs-string">&quot;status&quot;</span> , status);<br>    map.put(<span class="hljs-string">&quot;companyName&quot;</span>, companyName);<br>    map.put(<span class="hljs-string">&quot;brandName&quot;</span> , brandName);<br>    List&lt;Brand&gt; brands = brandMapper.selectByCondition(map);<br>    System.out.println(brands);<br><br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-4-动态SQL"><a href="#1-4-4-动态SQL" class="headerlink" title="1.4.4  动态SQL"></a>1.4.4  动态SQL</h4><p>上述功能实现存在很大的问题。用户在输入条件时，肯定不会所有的条件都填写，这个时候我们的SQL语句就不能那样写的</p><p>例如用户只输入 当前状态 时，SQL语句就是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_brand <span class="hljs-keyword">where</span> status <span class="hljs-operator">=</span> #&#123;status&#125;<br></code></pre></td></tr></table></figure><p>而用户如果只输入企业名称时，SQL语句就是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_brand <span class="hljs-keyword">where</span> company_name <span class="hljs-keyword">like</span> #&#123;companName&#125;<br></code></pre></td></tr></table></figure><p>而用户如果输入了 <code>当前状态</code> 和 <code>企业名称</code> 时，SQL语句又不一样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_brand <span class="hljs-keyword">where</span> status <span class="hljs-operator">=</span> #&#123;status&#125; <span class="hljs-keyword">and</span> company_name <span class="hljs-keyword">like</span> #&#123;companName&#125;<br></code></pre></td></tr></table></figure><p>针对上述的需要，Mybatis对动态SQL有很强大的支撑：</p><blockquote><ul><li><p>if</p></li><li><p>choose (when, otherwise)</p></li><li><p>trim (where, set)</p></li><li><p>foreach</p></li></ul></blockquote><p>我们先学习 if 标签和 where 标签：</p><ul><li><p>if 标签：条件判断</p><ul><li>test 属性：逻辑表达式</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByCondition&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand<br>    where 1=1<br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><br>            and status = #&#123;status&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span><br>            and company_name like #&#123;companyName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;brandName != null and brandName != &#x27;&#x27; &quot;</span>&gt;</span><br>            and brand_name like #&#123;brandName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如上的这种SQL语句就会根据传递的参数值进行动态的拼接。如果此时status和companyName有值那么就会值拼接这两个条件。</p><p>执行结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625114904988.png" alt="image-20220625114904988"></p><p>但是它也存在问题，如果此时给的参数值是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><span class="hljs-comment">// map.put(&quot;status&quot; , status);</span><br>map.put(<span class="hljs-string">&quot;companyName&quot;</span>, companyName);<br>map.put(<span class="hljs-string">&quot;brandName&quot;</span> , brandName);<br></code></pre></td></tr></table></figure><p>拼接的SQL语句就变成了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_brand <span class="hljs-keyword">where</span> <span class="hljs-keyword">and</span> company_name <span class="hljs-keyword">like</span> ? <span class="hljs-keyword">and</span> brand_name <span class="hljs-keyword">like</span> ?<br></code></pre></td></tr></table></figure><p>而上面的语句中 where 关键后直接跟 and 关键字，这就是一条错误的SQL语句。这个就可以使用 where 标签解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from tb_brand where 1=1 and company_name like ? and brand_name like ?<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>where 标签</p><ul><li>作用：<ul><li>替换where关键字</li><li>会动态的去掉第一个条件前的 and </li><li>如果所有的参数没有值则不加where关键字</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByCondition&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><br>            and status = #&#123;status&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span><br>            and company_name like #&#123;companyName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;brandName != null and brandName != &#x27;&#x27; &quot;</span>&gt;</span><br>            and brand_name like #&#123;brandName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：需要给每个条件前都加上 and 关键字。</p></blockquote></li></ul><h3 id="1-5-单个条件（动态SQL）"><a href="#1-5-单个条件（动态SQL）" class="headerlink" title="1.5 单个条件（动态SQL）"></a>1.5 单个条件（动态SQL）</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625114932820.png" alt="image-20220625114932820"></p><p>如上图所示，在查询时只能选择 <code>品牌名称</code>、<code>当前状态</code>、<code>企业名称</code> 这三个条件中的一个，但是用户到底选择哪儿一个，我们并不能确定。这种就属于单个条件的动态SQL语句。 </p><p>这种需求需要使用到  <code>choose（when，otherwise）标签</code>  实现，  而 <code>choose</code> 标签类似于Java 中的switch语句，<code>when</code> 标签类似于Java 中的case语句，<code>otherwise</code> 标签类似于Java 中的default语句。</p><p>通过一个案例来使用这些标签</p><h4 id="1-5-1-编写接口方法"><a href="#1-5-1-编写接口方法" class="headerlink" title="1.5.1  编写接口方法"></a>1.5.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义单条件查询的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 单条件动态查询</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> brand</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">  */</span><br>List&lt;Brand&gt; <span class="hljs-title function_">selectByConditionSingle</span><span class="hljs-params">(Brand brand)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-5-2-编写SQL语句"><a href="#1-5-2-编写SQL语句" class="headerlink" title="1.5.2  编写SQL语句"></a>1.5.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写 <code>statement</code>，使用 <code>resultMap</code> 而不是使用 <code>resultType</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByConditionSingle&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><span class="hljs-comment">&lt;!--相当于switch--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--相当于case--&gt;</span><br>                status = #&#123;status&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span><span class="hljs-comment">&lt;!--相当于case--&gt;</span><br>                company_name like #&#123;companyName&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--相当于case--&gt;</span><br>                brand_name like #&#123;brandName&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>如果不加where标签，当无参数传入的时候，会出现语法错误，需要加上一个<otherwise> 1=1来作为默认值。</otherwise></li></ul><h4 id="1-5-3-编写测试方法"><a href="#1-5-3-编写测试方法" class="headerlink" title="1.5.3  编写测试方法"></a>1.5.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectByConditionSingle</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//接收参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;华为&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;华为&quot;</span>;<br><br>    <span class="hljs-comment">// 处理参数</span><br>    companyName = <span class="hljs-string">&quot;%&quot;</span> + companyName + <span class="hljs-string">&quot;%&quot;</span>;<br>    brandName = <span class="hljs-string">&quot;%&quot;</span> + brandName + <span class="hljs-string">&quot;%&quot;</span>;<br><br>    <span class="hljs-comment">//封装对象</span><br>    <span class="hljs-type">Brand</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Brand</span>();<br>    <span class="hljs-comment">//brand.setStatus(status);</span><br>    brand.setCompanyName(companyName);<br>    <span class="hljs-comment">//brand.setBrandName(brandName);</span><br><br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br>    <span class="hljs-comment">//4. 执行方法</span><br>    List&lt;Brand&gt; brands = brandMapper.selectByConditionSingle(brand);<br>    System.out.println(brands);<br><br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行测试方法结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625115019803-20220625190611225.png" alt></p><h3 id="1-6-添加数据"><a href="#1-6-添加数据" class="headerlink" title="1.6  添加数据"></a>1.6  添加数据</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625115056454.png" alt="image-20220625115056454"></p><p>如上图是我们平时在添加数据时展示的页面，而我们在该页面输入想要的数据后添加 <code>提交</code> 按钮，就会将这些数据添加到数据库中。接下来我们就来实现添加数据的操作。</p><ul><li><p>编写接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Brand brand)</span>;<br></code></pre></td></tr></table></figure><p>参数：除了id之外的所有的数据。id对应的是表中主键值，而主键我们是 ==自动增长== 生成的。</p></li><li><p>编写SQL语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span><br>    insert into tb_brand (brand_name, company_name, ordered, description, status)<br>    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ul><li>编写测试方法并执行</li></ul><p>明确了该功能实现的步骤后，接下来我们进行具体的操作。</p><h4 id="1-6-1-编写接口方法"><a href="#1-6-1-编写接口方法" class="headerlink" title="1.6.1  编写接口方法"></a>1.6.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义添加方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 添加</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Brand brand)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-6-2-编写SQL语句"><a href="#1-6-2-编写SQL语句" class="headerlink" title="1.6.2  编写SQL语句"></a>1.6.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写添加数据的 <code>statement</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span><br>    insert into tb_brand (brand_name, company_name, ordered, description, status)<br>    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-6-3-编写测试方法"><a href="#1-6-3-编写测试方法" class="headerlink" title="1.6.3  编写测试方法"></a>1.6.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAdd</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//接收参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;波导手机&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;波导&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">description</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;手机中的战斗机&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ordered</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-comment">//封装对象</span><br>    <span class="hljs-type">Brand</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Brand</span>();<br>    brand.setStatus(status);<br>    brand.setCompanyName(companyName);<br>    brand.setBrandName(brandName);<br>    brand.setDescription(description);<br>    brand.setOrdered(ordered);<br><br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>    <span class="hljs-comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true); //设置自动提交事务，这种情况不需要手动提交事务了</span><br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br>    <span class="hljs-comment">//4. 执行方法</span><br>    brandMapper.add(brand);<br>    <span class="hljs-comment">//提交事务</span><br>    sqlSession.commit();<br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625115255092.png" alt="image-20220625115255092"></p><h4 id="1-6-4-添加-主键返回"><a href="#1-6-4-添加-主键返回" class="headerlink" title="1.6.4  添加-主键返回"></a>1.6.4  添加-主键返回</h4><p>在数据添加成功后，有时候需要获取插入数据库数据的主键（主键是自增长）。</p><p>比如：添加订单和订单项，一个订单对应多个订单项，并通过主键对两个表进行绑定。</p><p>订单数据存储在订单表中，订单项存储在订单项表中。</p><ul><li><p>添加订单数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addOrder&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    insert into tb_brand (brand_name, company_name, ordered, description, status)<br>    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>添加订单项数据，订单项中需要设置所属订单的id</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addOrder&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    insert into tb_brand (brand_name, company_name, ordered, description, status)<br>    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>明白了什么时候 <code>主键返回</code> 。接下来我们简单模拟一下，在添加完数据后打印id属性值，能打印出来说明已经获取到了。</p><p>我们将上面添加品牌数据的案例中映射配置文件里 <code>statement</code> 进行修改，如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    insert into tb_brand (brand_name, company_name, ordered, description, status)<br>    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>在 insert 标签上添加如下属性：</p><ul><li>useGeneratedKeys：是够获取自动增长的主键值。true表示获取</li><li>keyProperty  ：指定将获取到的主键值封装到哪个属性里</li></ul></blockquote><h3 id="1-7-修改"><a href="#1-7-修改" class="headerlink" title="1.7  修改"></a>1.7  修改</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625120113867.png" alt="image-20220625120113867"></p><p>如图所示是修改页面，用户在该页面书写需要修改的数据，点击 <code>提交</code> 按钮，就会将数据库中对应的数据进行修改。注意一点，如果哪个输入框没有输入内容，我们是将表中数据对应字段值替换为空白还是保留字段之前的值？答案肯定是保留之前的数据。</p><p>接下来我们就具体来实现</p><h4 id="1-7-1-编写接口方法"><a href="#1-7-1-编写接口方法" class="headerlink" title="1.7.1  编写接口方法"></a>1.7.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义修改方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 修改</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Brand brand)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>上述方法参数 Brand 就是封装了需要修改的数据，而id肯定是有数据的，这也是和添加方法的区别。</p></blockquote><h4 id="1-7-2-编写SQL语句"><a href="#1-7-2-编写SQL语句" class="headerlink" title="1.7.2  编写SQL语句"></a>1.7.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写修改数据的 <code>statement</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><br>    update tb_brand<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span><br>            brand_name = #&#123;brandName&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;companyName != null and companyName != &#x27;&#x27;&quot;</span>&gt;</span><br>            company_name = #&#123;companyName&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ordered != null&quot;</span>&gt;</span><br>            ordered = #&#123;ordered&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;description != null and description != &#x27;&#x27;&quot;</span>&gt;</span><br>            description = #&#123;description&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><br>            status = #&#123;status&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where id = #&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><em>set</em> 标签可以用于动态包含需要更新的列，忽略其它不更新的列。</p><p>并且可以动态识别“，”，自动修改sql语法错误。</p></blockquote><h4 id="1-7-3-编写测试方法"><a href="#1-7-3-编写测试方法" class="headerlink" title="1.7.3  编写测试方法"></a>1.7.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//接收参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;波导手机&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;波导&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">description</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;波导手机,手机中的战斗机&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ordered</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><br>    <span class="hljs-comment">//封装对象</span><br>    <span class="hljs-type">Brand</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Brand</span>();<br>    brand.setStatus(status);<br>    <span class="hljs-comment">//        brand.setCompanyName(companyName);</span><br>    <span class="hljs-comment">//        brand.setBrandName(brandName);</span><br>    <span class="hljs-comment">//        brand.setDescription(description);</span><br>    <span class="hljs-comment">//        brand.setOrdered(ordered);</span><br>    brand.setId(id);<br><br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>    <span class="hljs-comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br>    <span class="hljs-comment">//4. 执行方法</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> brandMapper.update(brand);<br>    System.out.println(count);<br>    <span class="hljs-comment">//提交事务</span><br>    sqlSession.commit();<br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行测试方法结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625120806918.png" alt="image-20220625120806918"></p><p>从结果中SQL语句可以看出，只修改了 <code>status</code>  字段值，因为我们给的数据中只给Brand实体对象的 <code>status</code> 属性设置值了。这就是 <code>set</code> 标签的作用。</p><h3 id="1-8-删除一行数据"><a href="#1-8-删除一行数据" class="headerlink" title="1.8  删除一行数据"></a>1.8  删除一行数据</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625120834937.png" alt="image-20220625120834937"></p><p>如上图所示，每行数据后面都有一个 <code>删除</code> 按钮，当用户点击了该按钮，就会将改行数据删除掉。那我们就需要思考，这种删除是根据什么进行删除呢？是通过主键id删除，因为id是表中数据的唯一标识。</p><p>接下来就来实现该功能。</p><h4 id="1-8-1-编写接口方法"><a href="#1-8-1-编写接口方法" class="headerlink" title="1.8.1  编写接口方法"></a>1.8.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义根据id删除方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 根据id删除</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-8-2-编写SQL语句"><a href="#1-8-2-编写SQL语句" class="headerlink" title="1.8.2  编写SQL语句"></a>1.8.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写删除一行数据的 <code>statement</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span>&gt;</span><br>    delete from tb_brand where id = #&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-8-3-编写测试方法"><a href="#1-8-3-编写测试方法" class="headerlink" title="1.8.3  编写测试方法"></a>1.8.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//接收参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>    <span class="hljs-comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br>    <span class="hljs-comment">//4. 执行方法</span><br>    brandMapper.deleteById(id);<br>    <span class="hljs-comment">//提交事务</span><br>    sqlSession.commit();<br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行过程只要没报错，直接到数据库查询数据是否还存在。</p><h3 id="1-9-批量删除"><a href="#1-9-批量删除" class="headerlink" title="1.9  批量删除"></a>1.9  批量删除</h3><p>用户可以选择多条数据，然后点击上面的 <code>删除</code> 按钮，就会删除数据库中对应的多行数据。</p><h4 id="1-9-1-编写接口方法"><a href="#1-9-1-编写接口方法" class="headerlink" title="1.9.1  编写接口方法"></a>1.9.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义删除多行数据的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 批量删除</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteByIds</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ids)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>参数是一个数组，数组中存储的是多条数据的id</p></blockquote><h4 id="1-9-2-编写SQL语句"><a href="#1-9-2-编写SQL语句" class="headerlink" title="1.9.2  编写SQL语句"></a>1.9.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写删除多条数据的 <code>statement</code>。</p><p>编写SQL时需要<strong>遍历数组</strong>来拼接SQL语句。Mybatis 提供了 <code>foreach</code> 标签供我们使用。</p><p><strong>foreach 标签</strong></p><p>用来迭代任何可迭代的对象（如数组，集合）。</p><ul><li><p>collection 属性：</p><ul><li><p>mybatis会将数组参数，封装为一个Map集合。</p><ul><li><p>默认：array = 数组，固定搭配</p></li><li><p>使用@Param注解改变map集合的默认key的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteByIds</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ids&quot;)</span> <span class="hljs-type">int</span>[] ids)</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>item 属性：本次迭代获取到的元素。</p></li><li><p>separator 属性：集合项迭代之间的分隔符。<code>foreach</code> 标签不会错误地添加多余的分隔符。也就是最后一次迭代不会加分隔符。</p></li><li><p>open 属性：该属性值是在拼接SQL语句之前拼接的语句，只会拼接一次</p></li><li><p>close 属性：该属性值是在拼接SQL语句拼接后拼接的语句，只会拼接一次</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">![](https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625115019803-20220625190611225.png)<span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByIds&quot;</span>&gt;</span><br>    delete from tb_brand where id<br>    in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;array&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    ;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>假如数组中的id数据是{1,2,3}，那么拼接后的sql语句就是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> tb_brand <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></blockquote><h4 id="1-9-3-编写测试方法"><a href="#1-9-3-编写测试方法" class="headerlink" title="1.9.3  编写测试方法"></a>1.9.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteByIds</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//接收参数</span><br>    <span class="hljs-type">int</span>[] ids = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br><br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>    <span class="hljs-comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br>    <span class="hljs-comment">//4. 执行方法</span><br>    brandMapper.deleteByIds(ids);<br>    <span class="hljs-comment">//提交事务</span><br>    sqlSession.commit();<br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-10-Mybatis参数传递"><a href="#1-10-Mybatis参数传递" class="headerlink" title="1.10  Mybatis参数传递"></a>1.10  Mybatis参数传递</h3><p>Mybatis 接口方法中可以接收各种各样的参数，如下：</p><ul><li><p>多个参数：封装为Map集合</p><p>Map.put(“arg0”,参数值1);</p><p>Map.put(“arg1”,参数值2);</p></li><li><p>单个参数：单个参数又可以是如下类型</p><ul><li>POJO 类型</li><li>Map 集合类型</li><li>Collection 集合类型</li><li>List 集合类型</li><li>Array 类型</li><li>其他类型</li></ul></li></ul><h4 id="1-10-1-多个参数"><a href="#1-10-1-多个参数" class="headerlink" title="1.10.1  多个参数"></a>1.10.1  多个参数</h4><p>如下面的代码，就是接收两个参数，而接收多个参数需要使用 <code>@Param</code> 注解，那么为什么要加该注解呢？这个问题要弄明白就必须来研究Mybatis 底层对于这些参数是如何处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String username,<span class="hljs-meta">@Param(&quot;password&quot;)</span> String password)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>select *<br>    from tb_user<br>    where <br>    username=#&#123;username&#125;<br>    and password=#&#123;password&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们在接口方法中定义多个参数，Mybatis 会将这些参数封装成 Map 集合对象，值就是参数值，而键在没有使用 <code>@Param</code> 注解时有以下命名规则：</p><ul><li><p>以 arg 开头  ：第一个参数就叫 arg0，第二个参数就叫 arg1，以此类推。如：</p><blockquote><p>map.put(“arg0”，参数值1);</p><p>map.put(“arg1”，参数值2);</p></blockquote></li><li><p>以 param 开头 ： 第一个参数就叫 param1，第二个参数就叫 param2，依次类推。如：</p><blockquote><p>map.put(“param1”，参数值1);</p><p>map.put(“param2”，参数值2);</p></blockquote></li></ul><p><strong>代码验证：</strong></p><ul><li><p>在 <code>UserMapper</code> 接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User <span class="hljs-title function_">select</span><span class="hljs-params">(String username,String password)</span>;<br></code></pre></td></tr></table></figure></li><li><p>在 <code>UserMapper.xml</code> 映射配置文件中定义SQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>select *<br>    from tb_user<br>    where <br>    username=#&#123;arg0&#125;<br>    and password=#&#123;arg1&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>select *<br>    from tb_user<br>    where <br>    username=#&#123;param1&#125;<br>    and password=#&#123;param2&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>运行代码结果如下</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625122349015.png" alt="image-20220625122349015"></p><p>在映射配合文件的SQL语句中使用用 <code>arg</code> 开头的和 <code>param</code> 书写，代码的可读性会变的特别差，此时可以使用 <code>@Param</code> 注解。</p></li></ul><p>在接口方法参数上使用 <code>@Param</code> 注解，Mybatis 会将 <code>arg</code> 开头的键名替换为对应注解的属性值。</p><p><strong>代码验证：</strong></p><ul><li><p>在 <code>UserMapper</code> 接口中定义如下方法，在 <code>username</code> 参数前加上 <code>@Param</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String username, String password)</span>;<br></code></pre></td></tr></table></figure><p>Mybatis 在封装 Map 集合时，键名就会变成如下：</p><blockquote><p>map.put(“username”，参数值1);</p><p>map.put(“arg1”，参数值2);</p><p>map.put(“param1”，参数值1);</p><p>map.put(“param2”，参数值2);</p></blockquote></li><li><p>在 <code>UserMapper.xml</code> 映射配置文件中定义SQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>select *<br>    from tb_user<br>    where <br>    username=#&#123;username&#125;<br>    and password=#&#123;param2&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>运行程序结果没有报错。而如果将 <code>#&#123;&#125;</code> 中的 <code>username</code> 还是写成  <code>arg0</code> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>select *<br>    from tb_user<br>    where <br>    username=#&#123;arg0&#125;<br>    and password=#&#123;param2&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>运行程序则可以看到错误</p></li></ul><p>==结论：以后接口参数是多个时，在每个参数上都使用 <code>@Param</code> 注解。这样代码的可读性更高。==</p><h4 id="1-10-2-单个参数"><a href="#1-10-2-单个参数" class="headerlink" title="1.10.2  单个参数"></a>1.10.2  单个参数</h4><ul><li><p>POJO 类型</p><p>直接使用。要求 <code>属性名</code> 和 <code>参数占位符名称</code> 一致</p></li><li><p>Map 集合类型</p><p>直接使用。要求 <code>map集合的键名</code> 和 <code>参数占位符名称</code> 一致</p></li><li><p>Collection 集合类型</p><p>Mybatis 会将集合封装到 map 集合中，如下：</p><blockquote><p>map.put(“arg0”，collection集合);</p><p>map.put(“collection”，collection集合;</p></blockquote><p>==可以使用 <code>@Param</code> 注解替换map集合中默认的 arg 键名。==</p></li><li><p>List 集合类型</p><p>Mybatis 会将集合封装到 map 集合中，如下：</p><blockquote><p>map.put(“arg0”，list集合);</p><p>map.put(“collection”，list集合);</p><p>map.put(“list”，list集合);</p></blockquote><p>==可以使用 <code>@Param</code> 注解替换map集合中默认的 arg 键名。==</p></li><li><p>Array 类型</p><p>Mybatis 会将集合封装到 map 集合中，如下：</p><blockquote><p>map.put(“arg0”，数组);</p><p>map.put(“array”，数组);</p></blockquote><p>==可以使用 <code>@Param</code> 注解替换map集合中默认的 arg 键名。==</p></li><li><p>其他类型</p><p>比如int类型，<code>参数占位符名称</code> 叫什么都可以。尽量做到见名知意</p></li></ul><h2 id="2-注解实现CRUD"><a href="#2-注解实现CRUD" class="headerlink" title="2.注解实现CRUD"></a>2.注解实现CRUD</h2><p>使用注解开发会比配置文件开发更加方便。官方建议简单sql语句用注解，复杂sql语句用xml，如下就是使用注解进行开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(value = &quot;select * from tb_user where id = #&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>==注意：==</p><ul><li>注解是用来替换映射配置文件方式配置的，所以使用了注解，就不需要再映射配置文件中书写对应的 <code>statement</code></li></ul></blockquote><p>Mybatis 针对 CURD 操作都提供了对应的注解，已经做到见名知意。如下：</p><ul><li>查询 ：@Select</li><li>添加 ：@Insert</li><li>修改 ：@Update</li><li>删除 ：@Delete</li></ul><p>接下来我们做一个案例来使用 Mybatis 的注解开发</p><p><strong>代码实现：</strong></p><ul><li><p>将之前案例中 <code>UserMapper.xml</code> 中的 根据id查询数据 的 <code>statement</code> 注释掉</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625122837575.png" alt="image-20220625122837575"></p></li><li><p>在 <code>UserMapper</code> 接口的 <code>selectById</code> 方法上添加注解</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625123001529.png" alt="image-20220625123001529"></p></li><li><p>运行测试程序也能正常查询到数据</p></li></ul><p>我们课程上只演示这一个查询的注解开发，其他的同学们下来可以自己实现，都是比较简单。</p><p>==注意：==在官方文档中 <code>入门</code> 中有这样的一段话：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625123028441.png" alt="image-20220625123028441"></p><p>所以，==注解完成简单功能，配置文件完成复杂功能。==</p><p>而我们之前写的动态 SQL 就是复杂的功能，如果用注解使用的话，就需要使用到 Mybatis 提供的SQL构建器来完成，而对应的代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625123108905.png" alt="image-20220625123108905"></p><p>上述代码将java代码和SQL语句融到了一块，使得代码的可读性大幅度降低。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC</title>
    <link href="/2022/06/25/JDBC/"/>
    <url>/2022/06/25/JDBC/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="1-JDBC概述"><a href="#1-JDBC概述" class="headerlink" title="1.JDBC概述"></a>1.JDBC概述</h2><p>在开发中我们使用的是java语言，那么势必要通过java语言操作数据库中的数据。这就是接下来要学习的JDBC。</p><h3 id="1-1-JDBC概念"><a href="#1-1-JDBC概念" class="headerlink" title="1.1  JDBC概念"></a>1.1  JDBC概念</h3><blockquote><p>JDBC   就是使用Java语言操作关系型数据库的一套API</p><p>全称：( Java DataBase Connectivity ) Java 数据库连接</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622201049290.png" alt="image-20220622201049290"></p><p>我们开发的同一套Java代码是无法操作不同的关系型数据库，因为每一个关系型数据库的底层实现细节都不一样。如果这样，问题就很大了，在公司中可以在开发阶段使用的是MySQL数据库，而上线时公司最终选用oracle数据库，我们就需要对代码进行大批量修改，这显然并不是我们想看到的。<u>我们要做到的是同一套Java代码操作不同的关系型数据库，而此时sun公司就指定了一套标准接口（JDBC）</u>，JDBC中定义了所有操作关系型数据库的规则。众所周知接口是无法直接使用的，我们需要使用接口的实现类，而这套实现类（称之为：驱动）就由各自的数据库厂商给出。</p><h3 id="1-2-JDBC本质"><a href="#1-2-JDBC本质" class="headerlink" title="1.2  JDBC本质"></a>1.2  JDBC本质</h3><ul><li>官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口</li><li>各个数据库厂商去实现这套接口，提供数据库驱动jar包</li><li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类</li></ul><h3 id="1-3-JDBC好处"><a href="#1-3-JDBC好处" class="headerlink" title="1.3  JDBC好处"></a>1.3  JDBC好处</h3><ul><li>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发</li><li>可随时替换底层数据库，访问数据库的Java代码基本不变</li></ul><p>以后编写操作数据库的代码只需要面向JDBC（接口），操作哪儿个关系型数据库就需要导入该数据库的驱动包，如需要操作MySQL数据库，就需要再项目中导入MySQL数据库的驱动包。如下图就是MySQL驱动包</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622201530771.png" alt="image-20220622201530771"></p><h2 id="2-JDBC快速入门"><a href="#2-JDBC快速入门" class="headerlink" title="2.JDBC快速入门"></a>2.JDBC快速入门</h2><p>先来看看通过Java操作数据库的流程</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622201600057.png" alt="image-20220622201600057" style="zoom:50%;"></p><p>第一步：编写Java代码</p><p>第二步：Java代码将SQL发送到MySQL服务端</p><p>第三步：MySQL服务端接收到SQL语句并执行该SQL语句</p><p>第四步：将SQL语句执行的结果返回给Java代码</p><h3 id="2-1-编写代码步骤"><a href="#2-1-编写代码步骤" class="headerlink" title="2.1  编写代码步骤"></a>2.1  编写代码步骤</h3><ul><li><p>创建工程，导入驱动jar包</p></li><li><p>注册驱动</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br></code></pre></td></tr></table></figure></li><li><p>获取连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Connection conn <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br></code></pre></td></tr></table></figure><p>Java代码需要发送SQL给MySQL服务端，就需要先建立连接</p></li><li><p>定义SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">String <span class="hljs-keyword">sql</span> <span class="hljs-operator">=</span>  “<span class="hljs-keyword">update</span>…” ;<br></code></pre></td></tr></table></figure></li><li><p>获取执行SQL对象</p><p>执行SQL语句需要SQL执行对象，而这个执行对象就是Statement对象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Statement stmt <span class="hljs-operator">=</span> conn.createStatement();<br></code></pre></td></tr></table></figure></li><li><p>执行SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">stmt.executeUpdate(<span class="hljs-keyword">sql</span>);  <br></code></pre></td></tr></table></figure></li><li><p>处理返回结果</p></li><li><p>释放资源</p></li></ul><h3 id="2-2-具体操作"><a href="#2-2-具体操作" class="headerlink" title="2.2  具体操作"></a>2.2  具体操作</h3><ul><li><p>创建新的空的项目</p></li><li><p>定义项目的名称，并指定位置</p></li><li><p>对项目进行设置，JDK版本、编译版本</p></li><li><p>创建模块，指定模块的名称及位置</p></li><li><p>导入驱动包</p><p>将mysql的驱动包放在模块下的lib目录（随意命名）下，并将该jar包添加为库文件</p></li><li><p>在添加为库文件的时候，有如下三个选项</p><ul><li>Global Library  ： 全局有效</li><li>Project Library :   项目有效</li><li>Module Library ： 模块有效</li></ul></li><li><p>在src下创建类</p></li><li><p>编写代码如下</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDBC快速入门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1. 注册驱动</span><br>        <span class="hljs-comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br>        <span class="hljs-comment">//2. 获取连接</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/db1&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>        <span class="hljs-comment">//3. 定义sql</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = 2000 where id = 1&quot;</span>;<br>        <span class="hljs-comment">//4. 获取执行sql的对象 Statement</span><br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br>        <span class="hljs-comment">//5. 执行sql</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql);<span class="hljs-comment">//受影响的行数</span><br>        <span class="hljs-comment">//6. 处理结果</span><br>        System.out.println(count);<br>        <span class="hljs-comment">//7. 释放资源</span><br>        stmt.close();<br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-JDBC-API详解"><a href="#3-JDBC-API详解" class="headerlink" title="3.JDBC API详解"></a>3.JDBC API详解</h2><h3 id="3-1-DriverManager"><a href="#3-1-DriverManager" class="headerlink" title="3.1  DriverManager"></a>3.1  DriverManager</h3><p>DriverManager（驱动管理类）作用：</p><ul><li><p>注册驱动</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622202121538.png" alt="image-20220622202121538"></p><p>registerDriver方法是用于注册驱动的，但是我们之前做的入门案例并不是这样写的。而是如下实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br></code></pre></td></tr></table></figure><p>我们查询MySQL提供的Driver类，看它是如何实现的，源码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622202228288.png" alt="image-20220622202228288"></p><p>在该类中的静态代码块中已经执行了 <code>DriverManager</code> 对象的 <code>registerDriver()</code> 方法进行驱动的注册了，那么我们只需要加载 <code>Driver</code> 类，该静态代码块就会执行。而 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code> 就可以加载 <code>Driver</code> 类。</p><blockquote><p>==提示：==</p><ul><li>MySQL 5之后的驱动包，可以省略注册驱动的步骤</li><li>自动加载jar包中META-INF/services/java.sql.Driver文件中的驱动类</li></ul></blockquote></li><li><p>获取数据库连接</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622202410055.png" alt="image-20220622202410055"></p><p>参数说明：</p><ul><li><p>url ： 连接路径</p><blockquote><p>语法：jdbc:mysql://ip地址(域名):端口号/数据库名称?参数键值对1&amp;参数键值对2…</p><p>示例：jdbc:mysql://127.0.0.1:3306/db1</p><p>==细节：==</p><ul><li><p>如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称?参数键值对</p></li><li><p>配置 useSSL=false 参数，禁用安全连接方式，解决警告提示</p></li></ul></blockquote></li><li><p>user ：用户名</p></li><li><p>poassword ：密码</p></li></ul></li></ul><h3 id="3-2-Connection"><a href="#3-2-Connection" class="headerlink" title="3.2  Connection"></a>3.2  Connection</h3><p>Connection（数据库连接对象）作用：</p><ul><li>获取执行 SQL 的对象</li><li>管理事务</li></ul><h4 id="3-2-1-获取执行对象"><a href="#3-2-1-获取执行对象" class="headerlink" title="3.2.1  获取执行对象"></a>3.2.1  获取执行对象</h4><ul><li><p>普通执行SQL对象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Statement createStatement()<br></code></pre></td></tr></table></figure><p>入门案例中就是通过该方法获取的执行对象。</p></li><li><p>预编译SQL的执行SQL对象：防止SQL注入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">PreparedStatement  prepareStatement(<span class="hljs-keyword">sql</span>)<br></code></pre></td></tr></table></figure><p>通过这种方式获取的 <code>PreparedStatement</code> SQL语句执行对象是我们一会重点要进行讲解的，它可以防止SQL注入。</p></li><li><p>执行存储过程的对象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">CallableStatement prepareCall(<span class="hljs-keyword">sql</span>)<br></code></pre></td></tr></table></figure><p>通过这种方式获取的 <code>CallableStatement</code> 执行对象是用来执行存储过程的，而存储过程在MySQL中不常用，所以这个我们将不进行讲解。</p></li></ul><h4 id="3-2-2-事务管理"><a href="#3-2-2-事务管理" class="headerlink" title="3.2.2  事务管理"></a>3.2.2  事务管理</h4><p>先回顾一下MySQL事务管理的操作：</p><ul><li>开启事务 ： BEGIN; 或者 START TRANSACTION;</li><li>提交事务 ： COMMIT;</li><li>回滚事务 ： ROLLBACK;</li></ul><blockquote><p>MySQL默认是自动提交事务</p></blockquote><p>接下来学习JDBC事务管理的方法。</p><p>Connection几口中定义了3个对应的方法：</p><ul><li><p>开启事务</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622203024093.png" alt="image-20220622203024093"></p><p>参与autoCommit 表示是否自动提交事务，true表示自动提交事务，false表示手动提交事务。而开启事务需要将该参数设为为false。</p></li><li><p>提交事务</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622203126286.png" alt="image-20220622203126286"></p></li><li><p>回滚事务</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622203144676.png" alt="image-20220622203144676"></p></li></ul><p>具体代码实现如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDBC API 详解：Connection</span><br><span class="hljs-comment"> */</span><br>public class JDBCDemo3_Connection &#123;<br><br>    public <span class="hljs-keyword">static</span> void main(String[] args) throws Exception &#123;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1.</span> 注册驱动<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2.</span> 获取连接：如果连接的是本机mysql并且端口是默认的 <span class="hljs-number">3306</span> 可以简化书写<br>        String url <span class="hljs-operator">=</span> &quot;jdbc:mysql:///db1?useSSL=false&quot;;<br>        String username <span class="hljs-operator">=</span> &quot;root&quot;;<br>        String password <span class="hljs-operator">=</span> &quot;1234&quot;;<br>        Connection conn <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">3.</span> 定义<span class="hljs-keyword">sql</span><br>        String sql1 <span class="hljs-operator">=</span> &quot;update account set money = 3000 where id = 1&quot;;<br>        String sql2 <span class="hljs-operator">=</span> &quot;update account set money = 3000 where id = 2&quot;;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">4.</span> 获取执行<span class="hljs-keyword">sql</span>的对象 Statement<br>        Statement stmt <span class="hljs-operator">=</span> conn.createStatement();<br><br>        try &#123;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>开启事务<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br>            conn.setAutoCommit(<span class="hljs-literal">false</span>);<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">5.</span> 执行<span class="hljs-keyword">sql</span><br>            <span class="hljs-type">int</span> count1 <span class="hljs-operator">=</span> stmt.executeUpdate(sql1);<span class="hljs-operator">/</span><span class="hljs-operator">/</span>受影响的行数<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">6.</span> 处理结果<br>            System.out.println(count1);<br>            <span class="hljs-type">int</span> i <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-operator">/</span><span class="hljs-number">0</span>;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">5.</span> 执行<span class="hljs-keyword">sql</span><br>            <span class="hljs-type">int</span> count2 <span class="hljs-operator">=</span> stmt.executeUpdate(sql2);<span class="hljs-operator">/</span><span class="hljs-operator">/</span>受影响的行数<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">6.</span> 处理结果<br>            System.out.println(count2);<br><br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>提交事务<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>程序运行到此处，说明没有出现任何问题，则需求提交事务<br>            conn.commit();<br>        &#125; catch (Exception e) &#123;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>回滚事务<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>程序在出现异常时会执行到这个地方，此时就需要回滚事务<br>            conn.rollback();<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">7.</span> 释放资源<br>        stmt.close();<br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-Statement"><a href="#3-3-Statement" class="headerlink" title="3.3  Statement"></a>3.3  Statement</h3><h4 id="3-3-1-概述"><a href="#3-3-1-概述" class="headerlink" title="3.3.1  概述"></a>3.3.1  概述</h4><p>Statement对象的作用就是用来执行SQL语句。而针对不同类型的SQL语句使用的方法也不一样。</p><ul><li><p>执行DDL、DML语句</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622203316093.png" alt="image-20220622203316093"></p></li><li><p>执行DQL语句</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622203332042.png" alt="image-20220622203332042"></p><p>该方法涉及到了 <code>ResultSet</code> 对象，而这个对象我们还没有学习，一会再重点讲解。</p></li></ul><h4 id="3-3-2-代码实现"><a href="#3-3-2-代码实现" class="headerlink" title="3.3.2  代码实现"></a>3.3.2  代码实现</h4><ul><li><p>执行DML语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 执行DML语句</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDML</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>    <span class="hljs-comment">//1. 注册驱动</span><br>    <span class="hljs-comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br>    <span class="hljs-comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>    <span class="hljs-comment">//3. 定义sql</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = 3000 where id = 1&quot;</span>;<br>    <span class="hljs-comment">//4. 获取执行sql的对象 Statement</span><br>    <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br>    <span class="hljs-comment">//5. 执行sql</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql);<span class="hljs-comment">//执行完DML语句，受影响的行数</span><br>    <span class="hljs-comment">//6. 处理结果</span><br>    <span class="hljs-comment">//System.out.println(count);</span><br>    <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;修改成功~&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;修改失败~&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//7. 释放资源</span><br>    stmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>执行DDL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 执行DDL语句</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDDL</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>    <span class="hljs-comment">//1. 注册驱动</span><br>    <span class="hljs-comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br>    <span class="hljs-comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>    <span class="hljs-comment">//3. 定义sql</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;drop database db2&quot;</span>;<br>    <span class="hljs-comment">//4. 获取执行sql的对象 Statement</span><br>    <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br>    <span class="hljs-comment">//5. 执行sql</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql);<span class="hljs-comment">//执行完DDL语句，可能是0</span><br>    <span class="hljs-comment">//6. 处理结果</span><br>    System.out.println(count);<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    stmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>以后开发很少使用java代码操作DDL语句</li></ul></blockquote></li></ul><h3 id="3-4-ResultSet"><a href="#3-4-ResultSet" class="headerlink" title="3.4  ResultSet"></a>3.4  ResultSet</h3><h4 id="3-4-1-概述"><a href="#3-4-1-概述" class="headerlink" title="3.4.1  概述"></a>3.4.1  概述</h4><p>ResultSet（结果集对象）作用：</p><ul><li>==封装了SQL查询语句的结果。==</li></ul><p>而执行了DQL语句后就会返回该对象，对应执行DQL语句的方法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ResultSet  executeQuery(<span class="hljs-keyword">sql</span>)：执行DQL 语句，返回ResultSet 对象<br></code></pre></td></tr></table></figure><p>那么我们就需要从 <code>ResultSet</code> 对象中获取我们想要的数据。<code>ResultSet</code> 对象提供了操作查询结果数据的方法，如下：</p><blockquote><p>boolean  next()</p><ul><li>将光标从当前位置向前移动一行 </li><li>判断当前行是否为有效行</li></ul><p>方法返回值说明：</p><ul><li>true  ： 有效航，当前行有数据</li><li>false ： 无效行，当前行没有数据</li></ul><p>xxx  getXxx(参数)：获取数据</p><ul><li>xxx : 数据类型；如： int getInt(参数) ；String getString(参数)</li><li>参数<ul><li>int类型的参数：列的编号，从1开始</li><li>String类型的参数： 列的名称 </li></ul></li></ul></blockquote><p>如下图为执行SQL语句后的结果</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622204148614.png" alt="image-20220622204148614"></p><p>一开始光标指定于第一行前，如图所示红色箭头指向于表头行。当我们调用了 <code>next()</code> 方法后，光标就下移到第一行数据，并且方法返回true，此时就可以通过 <code>getInt(&quot;id&quot;)</code> 获取当前行id字段的值，也可以通过 <code>getString(&quot;name&quot;)</code> 获取当前行name字段的值。如果想获取下一行的数据，继续调用 <code>next()</code>  方法，以此类推。</p><h4 id="3-4-2-代码实现"><a href="#3-4-2-代码实现" class="headerlink" title="3.4.2  代码实现"></a>3.4.2  代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 执行DQL</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testResultSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>    <span class="hljs-comment">//1. 注册驱动</span><br>    <span class="hljs-comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br>    <span class="hljs-comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>    <span class="hljs-comment">//3. 定义sql</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from account&quot;</span>;<br>    <span class="hljs-comment">//4. 获取statement对象</span><br>    <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br>    <span class="hljs-comment">//5. 执行sql</span><br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(sql);<br>    <span class="hljs-comment">//6. 处理结果， 遍历rs中的所有数据</span><br>    <span class="hljs-comment">/* // 6.1 光标向下移动一行，并且判断当前行是否有数据</span><br><span class="hljs-comment">        while (rs.next())&#123;</span><br><span class="hljs-comment">            //6.2 获取数据  getXxx()</span><br><span class="hljs-comment">            int id = rs.getInt(1);</span><br><span class="hljs-comment">            String name = rs.getString(2);</span><br><span class="hljs-comment">            double money = rs.getDouble(3);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            System.out.println(id);</span><br><span class="hljs-comment">            System.out.println(name);</span><br><span class="hljs-comment">            System.out.println(money);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            System.out.println(&quot;--------------&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        &#125;*/</span><br>    <span class="hljs-comment">// 6.1 光标向下移动一行，并且判断当前行是否有数据</span><br>    <span class="hljs-keyword">while</span> (rs.next())&#123;<br>        <span class="hljs-comment">//6.2 获取数据  getXxx()</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-type">double</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> rs.getDouble(<span class="hljs-string">&quot;money&quot;</span>);<br><br>        System.out.println(id);<br>        System.out.println(name);<br>        System.out.println(money);<br><br>        System.out.println(<span class="hljs-string">&quot;--------------&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    rs.close();<br>    stmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-案例"><a href="#3-5-案例" class="headerlink" title="3.5  案例"></a>3.5  案例</h3><ul><li><p>需求：查询account账户表数据，封装为Account对象中，并且存储到ArrayList集合中</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622205059589.png" alt="image-20220622205059589"></p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 查询account账户表数据，封装为Account对象中，并且存储到ArrayList集合中</span><br><span class="hljs-comment">  * 1. 定义实体类Account</span><br><span class="hljs-comment">  * 2. 查询数据，封装到Account对象中</span><br><span class="hljs-comment">  * 3. 将Account对象存入ArrayList集合中</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testResultSet2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>    <span class="hljs-comment">//1. 注册驱动</span><br>    <span class="hljs-comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br>    <span class="hljs-comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br><br>    <span class="hljs-comment">//3. 定义sql</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from account&quot;</span>;<br><br>    <span class="hljs-comment">//4. 获取statement对象</span><br>    <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br><br>    <span class="hljs-comment">//5. 执行sql</span><br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(sql);<br><br>    <span class="hljs-comment">// 创建集合</span><br>    List&lt;Account&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>   <br>    <span class="hljs-comment">// 6.1 光标向下移动一行，并且判断当前行是否有数据</span><br>    <span class="hljs-keyword">while</span> (rs.next())&#123;<br>        <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br><br>        <span class="hljs-comment">//6.2 获取数据  getXxx()</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-type">double</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> rs.getDouble(<span class="hljs-string">&quot;money&quot;</span>);<br><br>        <span class="hljs-comment">//赋值</span><br>        account.setId(id);<br>        account.setName(name);<br>        account.setMoney(money);<br><br>        <span class="hljs-comment">// 存入集合</span><br>        list.add(account);<br>    &#125;<br><br>    System.out.println(list);<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    rs.close();<br>    stmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-6-PreparedStatement"><a href="#3-6-PreparedStatement" class="headerlink" title="3.6  PreparedStatement"></a>3.6  PreparedStatement</h3><blockquote><p>PreparedStatement作用：</p><ul><li>预编译SQL语句并执行：预防SQL注入问题</li></ul></blockquote><p>对上面的作用中SQL注入问题大家肯定不理解。那我们先对SQL注入进行说明.</p><h4 id="3-6-1-SQL注入"><a href="#3-6-1-SQL注入" class="headerlink" title="3.6.1  SQL注入"></a>3.6.1  SQL注入</h4><blockquote><p>SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p></blockquote><p>在今天资料下的 <code>day03-JDBC\资料\2. sql注入演示</code> 中修改 <code>application.properties</code> 文件中的用户名和密码，文件内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">1234</span><br></code></pre></td></tr></table></figure><p>在登陆数据库时，用户名随意写，密码写成 <code>&#39; or &#39;1&#39; =&#39;1</code></p><p>在逻辑判断时，会将输入的密码与数据库中存储的密码进行比对，相同则为true，不同登录失败，但如果密码写成上述形式，则逻辑判断永远为true，数据库就产生了安全漏洞。</p><p>当然现在市面上的系统都不会存在这种问题了，所以大家也不要尝试用这种方式去试其他的系统。</p><p>那么该如何解决呢？这里就可以将SQL执行对象 <code>Statement</code> 换成 <code>PreparedStatement</code> 对象。</p><h4 id="3-6-2-代码模拟SQL注入问题"><a href="#3-6-2-代码模拟SQL注入问题" class="headerlink" title="3.6.2  代码模拟SQL注入问题"></a>3.6.2  代码模拟SQL注入问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLogin</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>    <span class="hljs-comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br><br>    <span class="hljs-comment">// 接收用户输入 用户名和密码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sjdljfld&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from tb_user where username = &#x27;&quot;</span>+name+<span class="hljs-string">&quot;&#x27; and password = &#x27;&quot;</span>+pwd+<span class="hljs-string">&quot;&#x27;&quot;</span>;<br>    <span class="hljs-comment">// 获取stmt对象</span><br>    <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br>    <span class="hljs-comment">// 执行sql</span><br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(sql);<br>    <span class="hljs-comment">// 判断登录是否成功</span><br>    <span class="hljs-keyword">if</span>(rs.next())&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录成功~&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录失败~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    rs.close();<br>    stmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码是将用户名和密码拼接到sql语句中，拼接后的sql语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;sjdljfld&#x27;</span> <span class="hljs-keyword">and</span> password <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure><p>从上面语句可以看出条件 <code>username = &#39;sjdljfld&#39; and password = &#39;&#39;</code> 不管是否满足，而 <code>or</code> 后面的 <code>&#39;1&#39; = &#39;1&#39;</code> 是始终满足的，最终条件是成立的，就可以正常的进行登陆了。</p><p>接下来我们来学习PreparedStatement对象.</p><h4 id="3-6-3-PreparedStatement概述"><a href="#3-6-3-PreparedStatement概述" class="headerlink" title="3.6.3  PreparedStatement概述"></a>3.6.3  PreparedStatement概述</h4><blockquote><p>PreparedStatement作用：</p><ul><li>预编译SQL语句并执行：预防SQL注入问题</li></ul></blockquote><ul><li><p>获取 PreparedStatement 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SQL语句中的参数值，使用？占位符替代</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from user where username = ? and password = ?&quot;</span>;<br><span class="hljs-comment">// 通过Connection对象获取，并传入对应的sql语句</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br></code></pre></td></tr></table></figure></li><li><p>设置参数值</p><p>==上面的sql语句中参数使用 ? 进行占位，在之前肯定要设置这些 ?  的值。==</p><blockquote><p>PreparedStatement对象：setXxx(参数1，参数2)：给 ? 赋值</p><ul><li><p>Xxx：数据类型 ； 如 setInt (参数1，参数2)</p></li><li><p>参数：</p><ul><li><p>参数1： ？的位置编号，从1 开始</p></li><li><p>参数2： ？的值</p></li></ul></li></ul></blockquote></li><li><p>执行SQL语句</p><blockquote><p>executeUpdate();  执行DDL语句和DML语句（增删改）</p><p>executeQuery();  执行DQL语句（查询）</p><p>==注意：==</p><ul><li>调用这两个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了。</li></ul></blockquote></li></ul><h4 id="3-6-4-使用PreparedStatement改进"><a href="#3-6-4-使用PreparedStatement改进" class="headerlink" title="3.6.4  使用PreparedStatement改进"></a>3.6.4  使用PreparedStatement改进</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPreparedStatement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>    <span class="hljs-comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br><br>    <span class="hljs-comment">// 接收用户输入 用户名和密码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;<br><br>    <span class="hljs-comment">// 定义sql</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from tb_user where username = ? and password = ?&quot;</span>;<br>    <span class="hljs-comment">// 获取pstmt对象</span><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>    <span class="hljs-comment">// 设置？的值</span><br>    pstmt.setString(<span class="hljs-number">1</span>,name);<br>    pstmt.setString(<span class="hljs-number">2</span>,pwd);<br>    <span class="hljs-comment">// 执行sql</span><br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> pstmt.executeQuery();<br>    <span class="hljs-comment">// 判断登录是否成功</span><br>    <span class="hljs-keyword">if</span>(rs.next())&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录成功~&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录失败~&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//7. 释放资源</span><br>    rs.close();<br>    pstmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行上面语句就可以发现不会出现SQL注入漏洞问题了。那么PreparedStatement又是如何解决的呢？它是将特殊字符进行了转义，转义的SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;sjdljfld&#x27;</span> <span class="hljs-keyword">and</span> password <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;\&#x27;</span><span class="hljs-keyword">or</span> \<span class="hljs-string">&#x27;1\&#x27;</span> <span class="hljs-operator">=</span> \<span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="3-6-5-PreparedStatement原理"><a href="#3-6-5-PreparedStatement原理" class="headerlink" title="3.6.5  PreparedStatement原理"></a>3.6.5  PreparedStatement原理</h4><blockquote><p>PreparedStatement 好处：</p><ul><li>预编译SQL，性能更高</li><li>防止SQL注入：==将敏感字符进行转义==</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623130238598.png" alt="image-20220623130238598"></p><p>Java代码操作数据库流程如图所示：</p><ul><li><p>将sql语句发送到MySQL服务器端</p></li><li><p>MySQL服务端会对sql语句进行如下操作</p><ul><li><p>检查SQL语句</p><p>检查SQL语句的语法是否正确。</p></li><li><p>编译SQL语句。将SQL语句编译成可执行的函数。</p><p>检查SQL和编译SQL花费的时间比执行SQL的时间还要长。如果我们只是重新设置参数，那么检查SQL语句和编译SQL语句将不需要重复执行。这样就提高了性能。</p></li><li><p>执行SQL语句</p></li></ul></li></ul><p>接下来我们通过查询日志来看一下原理。</p><ul><li><p>开启预编译功能</p><p>在代码中编写url时需要加上以下参数。而我们之前根本就没有开启预编译功能，只是解决了SQL注入漏洞。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">useServerPrepStmts<span class="hljs-operator">=</span><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>配置MySQL执行日志（重启mysql服务后生效）</p><p>在mysql配置文件（my.ini）中添加如下配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">log-output</span>=FILE<br><span class="hljs-attr">general-log</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">general_log_file</span>=<span class="hljs-string">&quot;D:\mysql.log&quot;</span><br><span class="hljs-attr">slow-query-log</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">slow_query_log_file</span>=<span class="hljs-string">&quot;D:\mysql_slow.log&quot;</span><br><span class="hljs-attr">long_query_time</span>=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>java测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * PreparedStatement原理</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">   */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPreparedStatement2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br><br>    <span class="hljs-comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span><br>    <span class="hljs-comment">// useServerPrepStmts=true 参数开启预编译功能</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br><br>    <span class="hljs-comment">// 接收用户输入 用户名和密码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;<br><br>    <span class="hljs-comment">// 定义sql</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from tb_user where username = ? and password = ?&quot;</span>;<br><br>    <span class="hljs-comment">// 获取pstmt对象</span><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br><br>    Thread.sleep(<span class="hljs-number">10000</span>);<br>    <span class="hljs-comment">// 设置？的值</span><br>    pstmt.setString(<span class="hljs-number">1</span>,name);<br>    pstmt.setString(<span class="hljs-number">2</span>,pwd);<br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 执行sql</span><br>    rs = pstmt.executeQuery();<br><br>    <span class="hljs-comment">// 设置？的值</span><br>    pstmt.setString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;aaa&quot;</span>);<br>    pstmt.setString(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;bbb&quot;</span>);<br>    <span class="hljs-comment">// 执行sql</span><br>    rs = pstmt.executeQuery();<br><br>    <span class="hljs-comment">// 判断登录是否成功</span><br>    <span class="hljs-keyword">if</span>(rs.next())&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录成功~&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录失败~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    rs.close();<br>    pstmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>执行SQL语句，查看 <code>D:\mysql.log</code> 日志如下:</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623130459944.png" alt="image-20220623130459944"></p><p>上图中第三行中的 <code>Prepare</code> 是对SQL语句进行预编译。第四行和第五行是执行了两次SQL语句，而第二次执行前并没有对SQL进行预编译。</p></li></ul><blockquote><p>==小结：==</p><ul><li>在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）</li><li>执行时就不用再进行这些步骤了，速度更快</li><li>如果sql模板一样，则只需要进行一次检查、编译</li></ul></blockquote><h2 id="4-数据库连接池"><a href="#4-数据库连接池" class="headerlink" title="4.数据库连接池"></a>4.数据库连接池</h2><h3 id="4-1-数据库连接池简介"><a href="#4-1-数据库连接池简介" class="headerlink" title="4.1  数据库连接池简介"></a>4.1  数据库连接池简介</h3><blockquote><ul><li><p>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</p></li><li><p>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；</p></li><li><p>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</p></li><li>好处<ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul></li></ul></blockquote><p>之前我们代码中使用连接是没有使用都创建一个Connection对象，使用完毕就会将其销毁。这样重复创建销毁的过程是特别耗费计算机的性能的及消耗时间的。</p><p>而数据库使用了数据库连接池后，就能达到Connection对象的复用，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623130721912.png" alt="image-20220623130721912"></p><p>连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以起到资源重用，也节省了频繁创建连接销毁连接所花费的时间，从而提升了系统响应的速度。</p><h3 id="4-2-数据库连接池实现"><a href="#4-2-数据库连接池实现" class="headerlink" title="4.2  数据库连接池实现"></a>4.2  数据库连接池实现</h3><ul><li><p>标准接口：==DataSource==</p><p>官方(SUN) 提供的数据库连接池标准接口，由第三方组织实现此接口。该接口提供了获取连接的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p>那么以后就不需要通过 <code>DriverManager</code> 对象获取 <code>Connection</code> 对象，而是通过连接池（DataSource）获取 <code>Connection</code> 对象。</p></li><li><p>常见的数据库连接池</p><ul><li>DBCP</li><li>C3P0</li><li>Druid</li></ul><p>我们现在使用更多的是Druid，它的性能比其他两个会好一些。</p></li><li><p>Druid（德鲁伊）</p><ul><li><p>Druid连接池是阿里巴巴开源的数据库连接池项目 </p></li><li><p>功能强大，性能优秀，是Java语言最好的数据库连接池之一</p></li></ul></li></ul><h3 id="4-3-Driud使用"><a href="#4-3-Driud使用" class="headerlink" title="4.3  Driud使用"></a>4.3  Driud使用</h3><blockquote><ul><li>导入jar包 druid-1.1.12.jar</li><li>定义配置文件</li><li>加载配置文件</li><li>获取数据库连接池对象</li><li>获取连接</li></ul></blockquote><p>现在通过代码实现，首先需要先将druid的jar包放到项目下的lib下并添加为库文件</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623152049955.png" alt="image-20220623152049955"></p><p>项目结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623152109789.png" alt="image-20220623152109789"></p><p>编写配置文件如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driverClassName</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true</span><br><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">password</span>=<span class="hljs-string">1234</span><br><span class="hljs-comment"># 初始化连接数量</span><br><span class="hljs-attr">initialSize</span>=<span class="hljs-string">5</span><br><span class="hljs-comment"># 最大连接数</span><br><span class="hljs-attr">maxActive</span>=<span class="hljs-string">10</span><br><span class="hljs-comment"># 最大等待时间</span><br><span class="hljs-attr">maxWait</span>=<span class="hljs-string">3000</span><br></code></pre></td></tr></table></figure><p>使用druid的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Druid数据库连接池演示</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DruidDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1.导入jar包</span><br>        <span class="hljs-comment">//2.定义配置文件</span><br>        <span class="hljs-comment">//3. 加载配置文件</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jdbc-demo/src/druid.properties&quot;</span>));<br>        <span class="hljs-comment">//4. 获取连接池对象</span><br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);<br><br>        <span class="hljs-comment">//5. 获取数据库连接 Connection</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        System.out.println(connection); <span class="hljs-comment">//获取到了连接后就可以继续做其他操作了</span><br><br>        <span class="hljs-comment">//System.out.println(System.getProperty(&quot;user.dir&quot;));</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-JDBC练习"><a href="#5-JDBC练习" class="headerlink" title="5.JDBC练习"></a>5.JDBC练习</h2><h3 id="5-1-需求"><a href="#5-1-需求" class="headerlink" title="5.1  需求"></a>5.1  需求</h3><p>完成商品品牌数据的增删改查操作</p><ul><li>查询：查询所有数据</li><li>添加：添加品牌</li><li>修改：根据id修改</li><li>删除：根据id删除</li></ul><h3 id="5-2-案例实现"><a href="#5-2-案例实现" class="headerlink" title="5.2  案例实现"></a>5.2  案例实现</h3><h4 id="5-2-1-环境准备"><a href="#5-2-1-环境准备" class="headerlink" title="5.2.1  环境准备"></a>5.2.1  环境准备</h4><ul><li><p>数据库表 <code>tb_brand</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除tb_brand表</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> tb_brand;<br><span class="hljs-comment">-- 创建tb_brand表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_brand (<br>    <span class="hljs-comment">-- id 主键</span><br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    <span class="hljs-comment">-- 品牌名称</span><br>    brand_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-comment">-- 企业名称</span><br>    company_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-comment">-- 排序字段</span><br>    ordered <span class="hljs-type">int</span>,<br>    <span class="hljs-comment">-- 描述信息</span><br>    description <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>    <span class="hljs-comment">-- 状态：0：禁用  1：启用</span><br>    status <span class="hljs-type">int</span><br>);<br><span class="hljs-comment">-- 添加数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_brand (brand_name, company_name, ordered, description, status)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;三只松鼠&#x27;</span>, <span class="hljs-string">&#x27;三只松鼠股份有限公司&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;好吃不上火&#x27;</span>, <span class="hljs-number">0</span>),<br>       (<span class="hljs-string">&#x27;华为&#x27;</span>, <span class="hljs-string">&#x27;华为技术有限公司&#x27;</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#x27;</span>, <span class="hljs-number">1</span>),<br>       (<span class="hljs-string">&#x27;小米&#x27;</span>, <span class="hljs-string">&#x27;小米科技有限公司&#x27;</span>, <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;are you ok&#x27;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p>在pojo包下实体类 Brand</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 品牌</span><br><span class="hljs-comment"> * alt + 鼠标左键：整列编辑</span><br><span class="hljs-comment"> * 在实体类中，基本数据类型建议使用其对应的包装类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Brand</span> &#123;<br>    <span class="hljs-comment">// id 主键</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-comment">// 品牌名称</span><br>    <span class="hljs-keyword">private</span> String brandName;<br>    <span class="hljs-comment">// 企业名称</span><br>    <span class="hljs-keyword">private</span> String companyName;<br>    <span class="hljs-comment">// 排序字段</span><br>    <span class="hljs-keyword">private</span> Integer ordered;<br>    <span class="hljs-comment">// 描述信息</span><br>    <span class="hljs-keyword">private</span> String description;<br>    <span class="hljs-comment">// 状态：0：禁用  1：启用</span><br>    <span class="hljs-keyword">private</span> Integer status;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBrandName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> brandName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBrandName</span><span class="hljs-params">(String brandName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.brandName = brandName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCompanyName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> companyName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCompanyName</span><span class="hljs-params">(String companyName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.companyName = companyName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getOrdered</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ordered;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOrdered</span><span class="hljs-params">(Integer ordered)</span> &#123;<br>        <span class="hljs-built_in">this</span>.ordered = ordered;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> description;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDescription</span><span class="hljs-params">(String description)</span> &#123;<br>        <span class="hljs-built_in">this</span>.description = description;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getStatus</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStatus</span><span class="hljs-params">(Integer status)</span> &#123;<br>        <span class="hljs-built_in">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Brand&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, brandName=&#x27;&quot;</span> + brandName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, companyName=&#x27;&quot;</span> + companyName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, ordered=&quot;</span> + ordered +<br>                <span class="hljs-string">&quot;, description=&#x27;&quot;</span> + description + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, status=&quot;</span> + status +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="5-2-2-查询所有"><a href="#5-2-2-查询所有" class="headerlink" title="5.2.2  查询所有"></a>5.2.2  查询所有</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 查询所有</span><br><span class="hljs-comment">   * 1. SQL：select * from tb_brand;</span><br><span class="hljs-comment">   * 2. 参数：不需要</span><br><span class="hljs-comment">   * 3. 结果：List&lt;Brand&gt;</span><br><span class="hljs-comment">   */</span><br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//1. 获取Connection</span><br>    <span class="hljs-comment">//3. 加载配置文件</span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jdbc-demo/src/druid.properties&quot;</span>));<br>    <span class="hljs-comment">//4. 获取连接池对象</span><br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);<br><br>    <span class="hljs-comment">//5. 获取数据库连接 Connection</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>    <span class="hljs-comment">//2. 定义SQL</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from tb_brand;&quot;</span>;<br>    <span class="hljs-comment">//3. 获取pstmt对象</span><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>    <span class="hljs-comment">//4. 设置参数</span><br>    <span class="hljs-comment">//5. 执行SQL</span><br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> pstmt.executeQuery();<br>    <span class="hljs-comment">//6. 处理结果 List&lt;Brand&gt; 封装Brand对象，装载List集合</span><br>    <span class="hljs-type">Brand</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    List&lt;Brand&gt; brands = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (rs.next())&#123;<br>        <span class="hljs-comment">//获取数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;brand_name&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;company_name&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ordered</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;ordered&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">description</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;description&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;status&quot;</span>);<br>        <span class="hljs-comment">//封装Brand对象</span><br>        brand = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Brand</span>();<br>        brand.setId(id);<br>        brand.setBrandName(brandName);<br>        brand.setCompanyName(companyName);<br>        brand.setOrdered(ordered);<br>        brand.setDescription(description);<br>        brand.setStatus(status);<br><br>        <span class="hljs-comment">//装载集合</span><br>        brands.add(brand);<br>    &#125;<br>    System.out.println(brands);<br>    <span class="hljs-comment">//7. 释放资源</span><br>    rs.close();<br>    pstmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-3-添加数据"><a href="#5-2-3-添加数据" class="headerlink" title="5.2.3  添加数据"></a>5.2.3  添加数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 添加</span><br><span class="hljs-comment">  * 1. SQL：insert into tb_brand(brand_name, company_name, ordered, description, status) values(?,?,?,?,?);</span><br><span class="hljs-comment">  * 2. 参数：需要，除了id之外的所有参数信息</span><br><span class="hljs-comment">  * 3. 结果：boolean</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAdd</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 接收页面提交的参数</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;香飘飘&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;香飘飘&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ordered</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">description</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;绕地球一圈&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//1. 获取Connection</span><br>    <span class="hljs-comment">//3. 加载配置文件</span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jdbc-demo/src/druid.properties&quot;</span>));<br>    <span class="hljs-comment">//4. 获取连接池对象</span><br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);<br>    <span class="hljs-comment">//5. 获取数据库连接 Connection</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>    <span class="hljs-comment">//2. 定义SQL</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into tb_brand(brand_name, company_name, ordered, description, status) values(?,?,?,?,?);&quot;</span>;<br>    <span class="hljs-comment">//3. 获取pstmt对象</span><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>    <span class="hljs-comment">//4. 设置参数</span><br>    pstmt.setString(<span class="hljs-number">1</span>,brandName);<br>    pstmt.setString(<span class="hljs-number">2</span>,companyName);<br>    pstmt.setInt(<span class="hljs-number">3</span>,ordered);<br>    pstmt.setString(<span class="hljs-number">4</span>,description);<br>    pstmt.setInt(<span class="hljs-number">5</span>,status);<br><br>    <span class="hljs-comment">//5. 执行SQL</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> pstmt.executeUpdate(); <span class="hljs-comment">// 影响的行数</span><br>    <span class="hljs-comment">//6. 处理结果</span><br>    System.out.println(count &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    pstmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-4-修改数据"><a href="#5-2-4-修改数据" class="headerlink" title="5.2.4  修改数据"></a>5.2.4  修改数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 修改</span><br><span class="hljs-comment">  * 1. SQL：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     update tb_brand</span><br><span class="hljs-comment">         set brand_name  = ?,</span><br><span class="hljs-comment">         company_name= ?,</span><br><span class="hljs-comment">         ordered     = ?,</span><br><span class="hljs-comment">         description = ?,</span><br><span class="hljs-comment">         status      = ?</span><br><span class="hljs-comment">     where id = ?</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   * 2. 参数：需要，所有数据</span><br><span class="hljs-comment">   * 3. 结果：boolean</span><br><span class="hljs-comment">   */</span><br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 接收页面提交的参数</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;香飘飘&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;香飘飘&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ordered</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">description</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;绕地球三圈&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">//1. 获取Connection</span><br>    <span class="hljs-comment">//3. 加载配置文件</span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jdbc-demo/src/druid.properties&quot;</span>));<br>    <span class="hljs-comment">//4. 获取连接池对象</span><br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);<br>    <span class="hljs-comment">//5. 获取数据库连接 Connection</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>    <span class="hljs-comment">//2. 定义SQL</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; update tb_brand\n&quot;</span> +<br>        <span class="hljs-string">&quot;         set brand_name  = ?,\n&quot;</span> +<br>        <span class="hljs-string">&quot;         company_name= ?,\n&quot;</span> +<br>        <span class="hljs-string">&quot;         ordered     = ?,\n&quot;</span> +<br>        <span class="hljs-string">&quot;         description = ?,\n&quot;</span> +<br>        <span class="hljs-string">&quot;         status      = ?\n&quot;</span> +<br>        <span class="hljs-string">&quot;     where id = ?&quot;</span>;<br><br>    <span class="hljs-comment">//3. 获取pstmt对象</span><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br><br>    <span class="hljs-comment">//4. 设置参数</span><br>    pstmt.setString(<span class="hljs-number">1</span>,brandName);<br>    pstmt.setString(<span class="hljs-number">2</span>,companyName);<br>    pstmt.setInt(<span class="hljs-number">3</span>,ordered);<br>    pstmt.setString(<span class="hljs-number">4</span>,description);<br>    pstmt.setInt(<span class="hljs-number">5</span>,status);<br>    pstmt.setInt(<span class="hljs-number">6</span>,id);<br><br>    <span class="hljs-comment">//5. 执行SQL</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> pstmt.executeUpdate(); <span class="hljs-comment">// 影响的行数</span><br>    <span class="hljs-comment">//6. 处理结果</span><br>    System.out.println(count &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    pstmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-5-删除数据"><a href="#5-2-5-删除数据" class="headerlink" title="5.2.5  删除数据"></a>5.2.5  删除数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 删除</span><br><span class="hljs-comment">  * 1. SQL：</span><br><span class="hljs-comment">            delete from tb_brand where id = ?</span><br><span class="hljs-comment">  * 2. 参数：需要，id</span><br><span class="hljs-comment">  * 3. 结果：boolean</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 接收页面提交的参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">//1. 获取Connection</span><br>    <span class="hljs-comment">//3. 加载配置文件</span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jdbc-demo/src/druid.properties&quot;</span>));<br>    <span class="hljs-comment">//4. 获取连接池对象</span><br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);<br>    <span class="hljs-comment">//5. 获取数据库连接 Connection</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>    <span class="hljs-comment">//2. 定义SQL</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; delete from tb_brand where id = ?&quot;</span>;<br>    <span class="hljs-comment">//3. 获取pstmt对象</span><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>    <span class="hljs-comment">//4. 设置参数</span><br>    pstmt.setInt(<span class="hljs-number">1</span>,id);<br>    <span class="hljs-comment">//5. 执行SQL</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> pstmt.executeUpdate(); <span class="hljs-comment">// 影响的行数</span><br>    <span class="hljs-comment">//6. 处理结果</span><br>    System.out.println(count &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    pstmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb&amp;Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习第二周</title>
    <link href="/2022/06/24/week02/"/>
    <url>/2022/06/24/week02/</url>
    
    <content type="html"><![CDATA[<hr><p>上篇主要介绍和讨论了线性模型。首先从最简单的最小二乘法开始，讨论输入属性有一个和多个的情形，接着通过广义线性模型延伸开来，将预测连续值的回归问题转化为分类问题，从而引入了对数几率回归，最后线性判别分析LDA将样本点进行投影，多分类问题实质上通过划分的方法转化为多个二分类问题进行求解。本篇将讨论另一种被广泛使用的分类算法—决策树（Decision Tree）。</p><h1 id="4、决策树"><a href="#4、决策树" class="headerlink" title="4、决策树"></a><strong>4、决策树</strong></h1><h2 id="4-1-决策树基本概念"><a href="#4-1-决策树基本概念" class="headerlink" title="4.1 决策树基本概念"></a><strong>4.1 决策树基本概念</strong></h2><p>决策树是一种机器学习的方法。决策树的生成算法有ID3, C4.5和C5.0等。决策树是一种树形结构，其中每个内部节点表示一个属性上的判断，每个分支代表一个判断结果的输出，最后每个叶节点代表一种分类结果。</p><p>决策树是一种十分常用的分类方法，需要监管学习，监管学习就是给出一堆样本，每个样本都有一组属性和一个分类结果，也就是分类结果已知，那么通过学习这些样本得到一个决策树，这个决策树能够对新的数据给出正确的分类。这里通过一个简单的例子来说明决策树的构成思路：</p><p>给出如下的一组数据，一共有十个样本（学生数量），每个样本有分数，出勤率，回答问题次数，作业提交率四个属性，最后判断这些学生是否是好学生。最后一列给出了人工分类结果。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-ed38beb4538a90f2b961233b18acc1ca_1440w.jpg" alt="img"></p><p>然后用这一组附带分类结果的样本可以训练出多种多样的决策树，这里为了简化过程，我们假设决策树为二叉树，且类似于下图：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-ff4fe0d16ec17c5520837b3aad52ed54_1440w.jpg" alt="img"></p><p>通过学习上表的数据，可以设置A，B，C，D，E的具体值，而A，B，C，D，E则称为阈值。当然也可以有和上图完全不同的树形，比如下图这种的：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-8f6407e5ab5a58b2913aef6a332090f6_1440w.jpg" alt="img"></p><p>所以决策树的生成主要分以下两步，这两步通常通过学习已经知道分类结果的样本来实现。</p><ol><li><p>节点的分裂：一般当一个节点所代表的属性无法给出判断时，则选择将这一节点分成2个子节点（如果不是二叉树的情况会分成n个子节点）。</p></li><li><p>阈值的确定：选择适当的阈值使得分类错误率最小 （Training Error）。</p></li></ol><p>在上图的决策树中，决策过程的每一次判定都是对某一属性的“测试”，决策最终结论则对应最终的判定结果。一般一颗决策树包含：一个根节点、若干个内部节点和若干个叶子节点，易知：</p><pre><code class="hljs">* 每个非叶节点表示一个特征属性测试。* 每个分支代表这个特征属性在某个值域上的输出。* 每个叶子节点存放一个类别。* 每个节点包含的样本集合通过属性测试被划分到子节点中，根节点包含样本全集。</code></pre><h2 id="4-2-决策树的构造"><a href="#4-2-决策树的构造" class="headerlink" title="4.2 决策树的构造"></a><strong>4.2 决策树的构造</strong></h2><p>决策树的构造是一个递归的过程，有三种情形会导致递归返回：</p><p>(1) 当前结点包含的样本<u>全属于同一类别</u>，这时直接将该节点标记为叶节点，并设为相应的类别；</p><p>(2) 当前属性集为空，或是所有样本在所有属性上取值相同，无法划分，这时将该节点标记为叶节点，并将其类别设为该节点所含样本最多的类别；</p><p>(3) 当前结点包含的样本集合为空，不能划分，这时也将该节点标记为叶节点，并将其类别设为父节点中所含样本最多的类别。算法的基本流程如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ecc27fe-20220625223316135.png" alt="2.png" style="zoom:150%;"></p><p>举个例子，首先将所有数据点分成两组，将相似的数据点分在一组，然后在每个组内重复二进制分割过程，以此来生成决策树。生成结果是，每个后续的叶子节点将具有更少但更同质的数据点。决策树的基础是通过树中的不同路径隔离出“幸存者”群体，属于这些路径的任何人都将被预测为可能的“幸存者”。</p><p>重复划分数据以获得同质数据组的过程被称为递归分区。它仅涉及两个步骤，如下面所示：</p><p>步骤1：识别将数据点分解成最均匀的两个组的二分问题。</p><p>步骤2：对于每个叶节点重复步骤1，直到达到终止标准。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//u=468529240,2161184244&amp;fm=173&amp;s=798C34720B2341205AD514DA0000E0B1&amp;w=640&amp;h=311&amp;img.jpeg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//u=1283713208,3337743947&amp;fm=173&amp;s=4DAA307203BA5021424100DA0000E0B2&amp;w=640&amp;h=311&amp;img.jpeg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//u=91869356,1158323049&amp;fm=173&amp;s=4DA834720372582208F02DDA000050B2&amp;w=640&amp;h=311&amp;img.jpeg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//u=93050560,1795077123&amp;fm=173&amp;s=4DA830720332582358F5B0CA000050B2&amp;w=640&amp;h=311&amp;img.jpeg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//u=1741801751,280438553&amp;fm=173&amp;s=5DA830728BAA500B18E4D5CA0000E0B2&amp;w=640&amp;h=311&amp;img.jpeg" alt="img"></p><p>有各种可能的终止标准：</p><p>- 当叶子节点的数据点都是相同的预测类别/值时终止</p><p>- 当叶片节点包含的数据点少于五个时终止</p><p>- 当进一步的分支在超出最小阈值范围的情况下也无法提高同质性时终止</p><p>使用交叉验证来选择终止标准，以确保决策树可以为新数据绘制准确的预测路径。</p><p>决策树应用广泛，可以处理关于分类分组（例如男性与女性），也可以处理连续值问题（例如收入）。如果问题是连续值问题，它可以将结果分为几组，例如比较“高于平均水平”和“低于平均值”的不同值。</p><p>在标准决策树中，可能的答案只能有2个，例如“是”或“否”。如果想测试三个或更多的答案（“是”，“否”，“有时”），可以给树添加更多分支，如下图，在“是”和“不是”的二分支延伸出一个“有时”和“否”的分支。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//u=628979622,698225812&amp;fm=173&amp;s=05A87C32099ED4C80A692CDA000080B1&amp;w=543&amp;h=409&amp;img.jpeg" alt="img"></p><p>可以看出：决策树学习的关键在于如何选择划分属性，不同的划分属性得出不同的分支结构，从而影响整颗决策树的性能。属性划分的目标是让各个划分出来的子节点尽可能地“纯”，即属于同一类别。因此下面便是介绍量化纯度的具体方法，决策树最常用的算法有三种：ID3，C4.5和CART。</p><h3 id="4-2-1-ID3算法"><a href="#4-2-1-ID3算法" class="headerlink" title="4.2.1 ID3算法"></a><strong>4.2.1 ID3算法</strong></h3><p>ID3算法由==增熵（Entropy）原理==来决定哪个做父节点，哪个节点需要分裂。对于一组数据，熵越小说明分类结果越好。熵定义如下：</p><script type="math/tex; mode=display">Entropy＝- sum [p(x_i) * log2(P(x_i) ]</script><p>其中$p(x_i) $为$x_i$出现的概率。假如是2分类问题，当A类和B类各占50%的时候，</p><script type="math/tex; mode=display">Entropy = - （0.5*log_2( 0.5)+0.5*log_2( 0.5))= 1</script><p>当只有A类，或只有B类的时候，</p><script type="math/tex; mode=display">Entropy= - （1*log_2( 1）+0）=0</script><p>综上，使用信息增益为准则来选择划分属性，“==信息熵==”(information entropy)是度量样本结合纯度的常用指标，假定当前样本集合$D$中第$k$类样本所占比例为$p_k$，则样本集合$D$的信息熵定义为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ec515a5-20220625223524206.png" alt="3.png">因为$log_21=0$，易知只有一个类别时，信息熵为0，纯度最高。</p><p>所以当$Entropy$最大为1的时候，是分类效果最差的状态，当它最小为0的时候，是完全分类的状态。因为熵等于零是理想状态，一般实际情况下，熵介于0和1之间。</p><p>熵的不断最小化，实际上就是提高分类正确率的过程。</p><p>比如上表中的4个属性：单一地通过以下语句分类：</p><ol><li><p>分数小于70为【不是好学生】：分错1个</p></li><li><p>出勤率大于70为【好学生】：分错3个</p></li><li><p>问题回答次数大于9为【好学生】：分错2个</p></li><li><p>作业提交率大于80%为【好学生】：分错2个</p></li></ol><p>最后发现分数小于70为【不是好学生】这条分错最少，也就是熵最小，所以应该选择这条为父节点进行树的生成，当然分数也可以选择大于71，大于72等等，出勤率也可以选择小于60，65等等，总之会有很多类似上述1~4的条件，最后选择分类错最少即熵最小的那个条件。而当分裂父节点时道理也一样，分裂有很多选择，针对每一个选择，与分裂前的分类错误率比较，留下那个提高最大的选择，即熵减最大的选择。</p><p>假定通过属性划分样本集$D$，产生了$V$个分支节点，$D^v$表示其中第$v$个分支节点，易知：分支节点包含的样本数越多，表示该分支节点的影响力越大。故可以计算出划分后相比原始数据集$D$获得的“信息增益”（information gain）。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ec3e067.png" alt="4.png"></p><p>信息增益越大，表示使用该属性划分样本集$D$的效果越好，因此ID3算法在递归过程中，每次选择==最大信息增益的属性==作为当前的划分属性。</p><h3 id="4-2-2-C4-5算法"><a href="#4-2-2-C4-5算法" class="headerlink" title="4.2.2 C4.5算法"></a><strong>4.2.2 C4.5算法</strong></h3><p>通过对ID3的学习，可以知道ID3存在一个问题，那就是越细小的分割分类错误率越小，所以ID3会越分越细，比如以第一个属性为例：设阈值小于70可将样本分为2组，但是分错了1个。如果设阈值小于70，再加上阈值等于95，那么分错率降到了0，但是这种分割显然只对训练数据有用，对于新的数据没有意义，这就是所说的过度学习（Overfitting）。</p><p>分割太细了，训练数据的分类可以达到0错误率，但是因为新的数据和训练数据不同，所以面对新的数据分错率反倒上升了。决策树是通过分析训练数据，得到数据的统计信息，而不是专为训练数据量身定做。</p><p>就比如给人做衣服，叫来10个人做参考，做出一件10个人都能穿的衣服，然后叫来另外5个和前面10个人身高差不多的，这件衣服也能穿。但是当你为10个人每人做一件正好合身的衣服，那么这10件衣服除了那个量身定做的人，别人都穿不了。</p><p>所以为了避免分割太细，c4.5对ID3进行了改进，C4.5中，优化项要除以分割太细的代价，这个比值叫做==信息增益率==，显然<u>分割太细分母增加，信息增益率会降低。除此之外，其他的原理和ID3相同</u>。</p><p>首先使用ID3算法计算出信息增益高于平均水平的候选属性，接着C4.5计算这些候选属性的增益率，增益率定义为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ec69647.png" alt="5.png"></p><h3 id="4-2-3-CART算法"><a href="#4-2-3-CART算法" class="headerlink" title="4.2.3 CART算法"></a><strong>4.2.3 CART算法</strong></h3><p>CART是一个二叉树，也是回归树，同时也是分类树，CART的构成简单明了。CART只能将一个父节点分为2个子节点。CART用GINI指数来决定如何分裂：</p><p>GINI指数：总体内包含的类别越杂乱，GINI指数就越大（跟熵的概念很相似）。</p><p>a. 比如出勤率大于70%这个条件将训练数据分成两组：大于70%里面有两类：【好学生】和【不是好学生】，而小于等于70%里也有两类：【好学生】和【不是好学生】。</p><p>b. 如果用分数小于70分来分：则小于70分只有【不是好学生】一类，而大于等于70分有【好学生】和【不是好学生】两类。</p><p>比较a和b，发现b的凌乱程度比a要小，即GINI指数b比a小，所以选择b的方案。以此为例，将所有条件列出来，选择GINI指数最小的方案，这个和熵的概念很类似。基尼指数定义如下：</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec5a2ff.png" alt="6.png"></p><p>进而，使用属性α划分后的基尼指数为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ec62eaf.png" alt="7.png"></p><p>CART还是一个回归树，回归解析用来决定分布是否终止。理想地说每一个叶节点里都只有一个类别时分类应该停止，但是很多数据并不容易完全划分，或者完全划分需要很多次分裂，必然造成很长的运行时间，所以CART可以对每个叶节点里的数据分析其均值方差，当方差小于一定值可以终止分裂，以换取计算成本的降低。</p><p>CART和ID3一样，存在偏向细小分割，即过度学习（过度拟合的问题），为了解决这一问题，需要对特别长的树进行剪枝处理，直接剪掉。</p><p>以上的决策树训练的时候，一般会采取Cross-Validation法：比如一共有10组数据：</p><p>第一次. 1到9做训练数据， 10做测试数据</p><p>第二次. 2到10做训练数据，1做测试数据</p><p>第三次. 1，3到10做训练数据，2做测试数据，以此类推</p><p>做10次，然后大平均错误率。这样称为 10 folds Cross-Validation。</p><p>比如 3 folds Cross-Validation 指的是数据分3份，2份做训练，1份做测试。</p><h2 id="4-3-剪枝处理"><a href="#4-3-剪枝处理" class="headerlink" title="4.3 剪枝处理"></a><strong>4.3 剪枝处理</strong></h2><p>从决策树的构造流程中我们可以直观地看出：不管怎么样的训练集，决策树总是能很好地将各个类别分离开来，这时就会遇到之前提到过的问题：过拟合（overfitting），即太依赖于训=练样本。剪枝（pruning）则是决策树算法对付过拟合的主要手段，剪枝的策略有两种如下：</p><pre><code class="hljs">* 预剪枝（prepruning）：在构造的过程中先评估，再考虑是否分支。* 后剪枝（post-pruning）：在构造好一颗完整的决策树后，自底向上，评估分支的必要性。</code></pre><p>评估指的是性能度量，即决策树的泛化性能。之前提到：可以使用测试集作为学习器泛化性能的近似，因此可以将数据集划分为训练集和测试集。</p><p>预剪枝表示在构造数的过程中，对一个节点考虑是否分支时，首先计算决策树不分支时在测试集上的性能，再计算分支之后的性能，若分支对性能没有提升，则选择不分支（即剪枝）。</p><p>后剪枝则表示在构造好一颗完整的决策树后，从最下面的节点开始，考虑该节点分支对模型的性能是否有提升，若无则剪枝，即将该节点标记为叶子节点，类别标记为其包含样本最多的类别。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ec80d34.png" alt="8.png"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ec9e330.png" alt="9.png"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ec9d497.png" alt="10.png"></p><p>上图分别表示不剪枝处理的决策树、预剪枝决策树和后剪枝决策树。预剪枝处理使得决策树的很多分支被剪掉，因此大大降低了训练时间开销，同时降低了过拟合的风险，但另一方面由于剪枝同时剪掉了当前节点后续子节点的分支，因此预剪枝“贪心”的本质阻止了分支的展开，<u>在一定程度上带来了欠拟合的风险</u>。而后剪枝则通常保留了更多的分支，因此==采用后剪枝策略的决策树性能往往优于预剪枝==，但其自底向上遍历了所有节点，并计算性能，训练时间开销相比预剪枝大大提升。</p><h2 id="4-4-连续值与缺失值处理"><a href="#4-4-连续值与缺失值处理" class="headerlink" title="4.4 连续值与缺失值处理"></a><strong>4.4 连续值与缺失值处理</strong></h2><p>对于连续值的属性，若每个取值作为一个分支则显得不可行，因此需要进行离散化处理，常用的方法为二分法，基本思想为：给定样本集D与连续属性α，二分法试图找到一个划分点$t$将样本集$D$在属性$α$上分为$≤t$与$＞t$。</p><pre><code class="hljs">* 首先将α的所有取值按升序排列，所有相邻属性的均值作为候选划分点（n-1个，n为α所有的取值数目）。* 计算每一个划分点划分集合D（即划分为两个分支）后的信息增益。* 选择最大信息增益的划分点作为最优划分点。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72a0968fad.png" alt="11.png"></p><p>现实中常会遇到不完整的样本，即某些属性值缺失。有时若简单采取剔除，则会造成大量的信息浪费，因此在属性值缺失的情况下需要解决两个问题：</p><ol><li>如何选择划分属性。</li><li>给定划分属性，若某样本在该属性上缺失值，如何划分到具体的分支上。</li></ol><p>假定为样本集中的每一个样本都赋予一个权重，根节点中的权重初始化为1，则定义：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72a098f3be.png" alt="12.png"></p><p>对于（1）：通过在样本集$D$中选取在属性$α$上没有缺失值的样本子集，计算在该样本子集上的信息增益，最终的信息增益等于该样本子集划分后信息增益乘以样本子集占样本集的比重。即：</p><p><img src="https://i.loli.net/2018/10/17/5bc72a096ccc3.png" alt="13.png"></p><p>对于（2）：若该样本子集在属性α上的值缺失，则将该样本以不同的权重（即每个分支所含样本比例）划入到所有分支节点中。该样本在分支节点中的权重变为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72a093ed3c.png" alt="14.png"></p><p>​    </p><p>比较常用的决策树有ID3，C4.5和CART（Classification And Regression Tree），CART的分类效果一般优于其他决策树。下面介绍具体步骤。</p><p>ID3: 由增熵（Entropy）原理来决定那个做父节点，那个节点需要分裂。对于一组数据，熵越小说明分类结果越好。熵定义如下：</p><p>Entropy＝- sum [p(x_i) <em> </em>log*2(P(x_i) ]</p><p>其中p(x_i) 为x_i出现的概率。假如是2分类问题，当A类和B类各占50%的时候，</p><p>Entropy = - （0.5<em>log_2( 0.5)+0.5</em>log_2( 0.5))= 1</p><p>当只有A类，或只有B类的时候，</p><p>Entropy= - （1*log_2( 1）+0）=0</p><p>所以当Entropy最大为1的时候，是分类效果最差的状态，当它最小为0的时候，是完全分类的状态。因为熵等于零是理想状态，一般实际情况下，熵介于0和1之间。</p><p>熵的不断最小化，实际上就是提高分类正确率的过程。</p><p>比如上表中的4个属性：单一地通过以下语句分类：</p><p>\1. 分数小于70为【不是好学生】：分错1个</p><p>\2. 出勤率大于70为【好学生】：分错3个</p><p>\3. 问题回答次数大于9为【好学生】：分错2个</p><p>\4. 作业提交率大于80%为【好学生】：分错2个</p><p>最后发现 分数小于70为【不是好学生】这条分错最少，也就是熵最小，所以应该选择这条为父节点进行树的生成，当然分数也可以选择大于71，大于72等等，出勤率也可以选择小于60，65等等，总之会有很多类似上述1~4的条件，最后选择分类错最少即熵最小的那个条件。而当分裂父节点时道理也一样，分裂有很多选择，针对每一个选择，与分裂前的分类错误率比较，留下那个提高最大的选择，即熵减最大的选择。</p><p>C4.5：通过对ID3的学习，可以知道ID3存在一个问题，那就是越细小的分割分类错误率越小，所以ID3会越分越细，比如以第一个属性为例：设阈值小于70可将样本分为2组，但是分错了1个。如果设阈值小于70，再加上阈值等于95，那么分错率降到了0，但是这种分割显然只对训练数据有用，对于新的数据没有意义，这就是所说的过度学习（Overfitting）。</p><p>分割太细了，训练数据的分类可以达到0错误率，但是因为新的数据和训练数据不同，所以面对新的数据分错率反倒上升了。决策树是通过分析训练数据，得到数据的统计信息，而不是专为训练数据量身定做。</p><p>就比如给男人做衣服，叫来10个人做参考，做出一件10个人都能穿的衣服，然后叫来另外5个和前面10个人身高差不多的，这件衣服也能穿。但是当你为10个人每人做一件正好合身的衣服，那么这10件衣服除了那个量身定做的人，别人都穿不了。</p><p>所以为了避免分割太细，c4.5对ID3进行了改进，C4.5中，优化项要除以分割太细的代价，这个比值叫做信息增益率，显然分割太细分母增加，信息增益率会降低。除此之外，其他的原理和ID3相同。</p><p>CART：分类回归树</p><p>CART是一个二叉树，也是回归树，同时也是分类树，CART的构成简单明了。</p><p>CART只能将一个父节点分为2个子节点。CART用GINI指数来决定如何分裂：GINI指数：总体内包含的类别越杂乱，GINI指数就越大（跟熵的概念很相似）。</p><p>a. 比如出勤率大于70%这个条件将训练数据分成两组：大于70%里面有两类：【好学生】和【不是好学生】，而小于等于70%里也有两类：【好学生】和【不是好学生】。</p><p>b. 如果用分数小于70分来分：则小于70分只有【不是好学生】一类，而大于等于70分有【好学生】和【不是好学生】两类。</p><p>比较a和b，发现b的凌乱程度比a要小，即GINI指数b比a小，所以选择b的方案。以此为例，将所有条件列出来，选择GINI指数最小的方案，这个和熵的概念很类似。</p><p>CART还是一个回归树，回归解析用来决定分布是否终止。理想地说每一个叶节点里都只有一个类别时分类应该停止，但是很多数据并不容易完全划分，或者完全划分需要很多次分裂，必然造成很长的运行时间，所以CART可以对每个叶节点里的数据分析其均值方差，当方差小于一定值可以终止分裂，以换取计算成本的降低。</p><p>CART和ID3一样，存在偏向细小分割，即过度学习（过度拟合的问题），为了解决这一问题，对特别长的树进行剪枝处理，直接剪掉。</p><p>以上的决策树训练的时候，一般会采取Cross-Validation法：比如一共有10组数据：</p><p>第一次. 1到9做训练数据， 10做测试数据</p><p>第二次. 2到10做训练数据，1做测试数据</p><p>第三次. 1，3到10做训练数据，2做测试数据，以此类推</p><p>做10次，然后大平均错误率。这样称为 10 folds Cross-Validation。</p><p>比如 3 folds Cross-Validation 指的是数据分3份，2份做训练，1份做测试。</p><h2 id="4-5章节汇总"><a href="#4-5章节汇总" class="headerlink" title="4.5章节汇总"></a>4.5章节汇总</h2><p><strong>一、决策树学习的 3 个步骤：</strong></p><p><strong>1.特征选择</strong></p><p>特征选择决定了使用哪些特征来做判断。在训练数据集中，每个样本的属性可能有很多个，不同属性的作用有大有小。因而特征选择的作用就是筛选出跟分类结果相关性较高的特征，也就是分类能力较强的特征。</p><p>在特征选择中通常使用的准则是：信息增益。</p><p><strong>2.决策树生成</strong></p><p>选择好特征后，就从根节点触发，对节点计算所有特征的信息增益，选择信息增益最大的特征作为节点特征，根据该特征的不同取值建立子节点；对每个子节点使用相同的方式生成新的子节点，直到信息增益很小或者没有特征可以选择为止。</p><p><strong>3.决策树剪枝</strong></p><p>剪枝的主要目的是对抗「过拟合」，通过主动去掉部分分支来降低过拟合的风险。</p><p><strong>二、3种典型的决策树算法</strong></p><p><strong>ID3 算法</strong></p><p>ID3 是最早提出的决策树算法，他就是利用信息增益来选择特征的。</p><p><strong>C4.5 算法</strong></p><p>他是 ID3 的改进版，他不是直接使用信息增益，而是引入“信息增益比”指标作为特征的选择依据。</p><p><strong>CART（Classification and Regression Tree）</strong></p><p>这种算法即可以用于分类，也可以用于回归问题。CART 算法使用了基尼系数取代了信息熵模型。</p><p>三、决策树的优缺点</p><p><strong>优点</strong></p><ul><li>决策树易于理解和解释，可以可视化分析，容易提取出规则；</li><li>可以同时处理标称型和数值型数据；</li><li>比较适合处理有缺失属性的样本；</li><li>能够处理不相关的特征；</li><li>测试数据集时，运行速度比较快；</li><li>在相对短的时间内能够对大型数据源做出可行且效果良好的结果。</li></ul><p><strong>缺点</strong></p><ul><li>容易发生过拟合（随机森林可以很大程度上减少过拟合）；</li><li>容易忽略数据集中属性的相互关联；</li><li>对于那些各类别样本数量不一致的数据，在决策树中，进行属性划分时，不同的判定准则会带来不同的属性选择倾向；信息增益准则对可取数目较多的属性有所偏好（典型代表ID3算法），而增益率准则（CART）则对可取数目较少的属性有所偏好，但CART进行属性划分时候不再简单地直接利用增益率尽心划分，而是采用一种启发式规则）（只要是使用了信息增益，都有这个缺点，如RF）。</li><li>ID3算法计算信息增益时结果偏向数值比较多的特征。</li></ul><p>四、使用限制</p><p>在开始时使用最合适的二分问题分割数据可能不会得到最准确的预测。有时，最初使用没那么有效的分割可能会得到更好的预测。</p><p>为了解决这个问题，我们可以选择组合不同的二分问题来生成多个树，然后使用这些树的聚合来进行预测。这种技术即随机森林。或者，不是随机地组合二分问题，而是策略性地选择，使得每个随后的树的预测精度逐渐增加。然后，取所有树的加权平均预测值。这种技术称为梯度提升决策树。</p><p>虽然随机森林和梯度提升决策树更能产生准确的预测，但其复杂性使得解决方案难以可视化。因此，它们通常被称为“黑匣子”。另一方面，决策树的预测结果可以使用树形图来检查。了解哪些预测因素是重要的，使我们能够制定更有针对性的干预措施。</p><p>五、拓展阅读</p><p><a href="https://blog.csdn.net/jiaoyangwm/article/details/79525237">机器学习实战之决策树</a></p><p><a href="https://mp.weixin.qq.com/s/U62UCAM7rJWfbsyVdhs6-A">决策树和随机森林</a></p><p><a href="https://www.jianshu.com/p/655d8e555494">决策树算法的代码实现</a></p><p>上篇主要讨论了决策树算法。首先从决策树的基本概念出发，引出决策树基于树形结构进行决策，进一步介绍了构造决策树的递归流程以及其递归终止条件，在递归的过程中，划分属性的选择起到了关键作用，因此紧接着讨论了三种评估属性划分效果的经典算法，介绍了剪枝策略来解决原生决策树容易产生的过拟合问题，最后简述了属性连续值/缺失值的处理方法。本篇将讨论现阶段十分热门的另一个经典监督学习算法—神经网络（neural network）。</p><h1 id="5、神经网络"><a href="#5、神经网络" class="headerlink" title="5、神经网络"></a><strong>5、神经网络</strong></h1><p>神经网络的特征就是可以从数据中学习。所谓“从数据中学习”，是指可以由数据自动决定权重参数的值。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-b3388d6a10215958ada3df82d0a61587_r.jpg" alt="preview"></p><p>神经网络的优点是对所有的问题都可以用同样的流程来解决。比如，不管要求解的问题是识别物，还是识别狗，抑或是识别人脸，神经网络都是通过不断地学习所提供的数据，尝试发现待求解的问题的模式。也就是说，与待处理的问题无关，神经网络可以将数据直接作为原始数据，进行“端对端”的学习。</p><blockquote><p>神经网络最重要的用途是分类，为了让大家对分类有个直观的认识，咱们先看几个例子：</p><p>垃圾邮件识别：现在有一封电子邮件，把出现在里面的所有词汇提取出来，送进一个机器里，机器需要判断这封邮件是否是垃圾邮件。<br>疾病判断：病人到医院去做了一大堆肝功、尿检测验，把测验结果送进一个机器里，机器需要判断这个病人是否得病，得的什么病。<br>猫狗分类：有一大堆猫、狗照片，把每一张照片送进一个机器里，机器需要判断这幅照片里的东西是猫还是狗。</p></blockquote><p>向上例这种能自动对输入的东西进行分类的机器，就叫做分类器。</p><p>分类器的输入是一个数值向量，叫做特征(向量)。在第一个例子里，分类器的输入是一堆0、1值，表示字典里的每一个词是否在邮件中出现，比如向量(1，1……)就表示这封邮件里只出现了两个词abandon和abnormal;第二个例子里，分类器的输入是一堆化验指标；第三个例子里，分类器的输入是照片，假如每一张照片都是320<em>240像素的红绿蓝三通道彩色照片，那么分类器的输入就是一个长度为320</em>240*3=230400的向量。</p><p>分类器的输出也是数值。第一个例子中，输出1表示邮件是垃圾邮件，输出0则说明邮件是正常邮件；第二个例子中，输出0表示健康，输出1表示有甲肝Q，输出2表示有乙肝，输出3表示有饼干等等；第三个例子中，输出0表示图片中是狗，输出1表示是猫。</p><p>分类器的目标就是让正确分类的比例尽可能高。一般我们需要首先收集一些样本，人为标记上正确分类结果，然后用这些标记好的数据训练分类器，训练好的分类器就可以在新来的特征向量上工作了。</p><h2 id="5-1-神经元模型"><a href="#5-1-神经元模型" class="headerlink" title="5.1 神经元模型"></a><strong>5.1 神经元模型</strong></h2><h3 id="5-1-1-基本概念"><a href="#5-1-1-基本概念" class="headerlink" title="5.1.1 基本概念"></a>5.1.1 基本概念</h3><p>假设分类器的输入是通过某种途径获得的两个值，输出是0和1，比如分别代表猫和狗。现在有一些样本:<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220626144159265.png" alt="image-20220626144159265"></p><p>最简单地把这两组特征向量分开的方法当然是在两组数据中间画一条竖直线。直线左边是狗，右边是猫，分类器就完成了。以后来了新的向量，凡是落在直线左边的都是狗，落在右边的都是猫。</p><p>一条直线把平面一分为二，一个平面把三维空间一分为二，一个$n-1$维超平面把$n$维空间一分为二，两边分属不同的两类，这种分类器就叫做神经元。</p><p>大家都知道平面上的直线方程是$ax+by+c=0$，等式左边大于零和小于零分别表示点$(x,y)$在直线的一侧还是另一侧，把这个式子推广到n维空间里，直线的高维形式称为超平面，它的方程是:</p><script type="math/tex; mode=display">h=a_1x_1+a_2x_2+...+a_nx_n+a_0</script><p>神经元就是当$h$大于0时输出1，$h$小干0时输出0这么一个模型，它的实质就是把特征空间一切两半，认为两瓣分别属两个类。这个模型有点像人脑中的神经元：从多个感受器接受电信号$x_1,x_2,…,x_n$进行处理(加权相加再偏移一点，即判断输入是否在某条直线$h=0$的一侧)，发出电信号(在正确的那侧发出1.否则不发信号，可以认为是发出0)，这就是它叫神经元的原因。</p><p>当然，上述一条竖直线能分开两类只是我们假设的理想情况，在实际训练神经元的时候，我们并不知道特征是怎么抱团的。神经元有一种学习方法称为Hebb算法：</p><p>先随机选一条直线/平面/超平面，然后把样本一个个拿过来，如果这条直线分错了，说明这个点分错边了，就稍微把直线移动一点，让它靠近这个样本，争取跨过这个样本，让它跑到直线正确的一侧；如果直线分对了，它就暂时停下不动。因此训练神经元的过程就是这条直线不断在跳舞，最终跳到两个类之间的竖直线位置。</p><p>“M-P神经元模型”正是对这一结构进行了抽象，也称“阈值逻辑单元“。</p><p>神经元树突对应于输入部分，每个神经元收到n个其他神经元传递过来的输入信号，这些信号通过带权重的连接传递给细胞体，这些权重又称为连接权（connection weight）。细胞体分为两部分，前一部分计算总输入值（即输入信号的加权和，或者说累积电平），后一部分先计算总输入值与该神经元阈值的差值，然后通过激活函数（activation function）的处理，产生输出从轴突传送给其它神经元。M-P神经元模型如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb7be44-20220626183521735.png" alt="2.png"></p><p>与线性分类十分相似，神经元模型最理想的激活函数也是阶跃函数，即将神经元输入值与阈值的差值映射为输出值1或0，若差值大于零输出1，对应兴奋；若差值小于零则输出0，对应抑制。但阶跃函数不连续，不光滑，故在M-P神经元模型中，也采用Sigmoid函数来近似， Sigmoid函数将较大范围内变化的输入值挤压到 (0,1) 输出值范围内，所以也称为挤压函数（squashing function）。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb40dc5.png" alt="3.png"></p><p>将多个神经元按一定的层次结构连接起来，就得到了神经网络。它是一种包含多个参数的模型，比方说10个神经元两两连接，则有100个参数需要学习（每个神经元有9个连接权以及1个阈值），若将每个神经元都看作一个函数，则整个神经网络就是由这些函数相互嵌套而成。</p><p>总结来说，它的作用就是<u>接受其他多个神经元传入的信号，然后将这些信号汇总成总信号，对比总信号与阈值，如果超过阈值，则产生兴奋信号并输出出去，如果低于阈值，则处于抑制状态。</u></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast.png" alt="这里写图片描述"></p><p>Inputs：输入。</p><p>Weights：权值，权重。</p><p>Bias：偏置，或者称为阈值(Threshold)。</p><p>Activationfunction：激活函数。</p><p>需要掌握的线性代数基础知识：</p><p><a href="https://richyoungcrew.blog.csdn.net/article/details/124108851?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-124108851-blog-83628080.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-124108851-blog-83628080.pc_relevant_paycolumn_v3&amp;utm_relevant_index=2">特征值的通俗解释</a></p><p><a href="https://www.zhihu.com/question/20501504/answer/174887899">人类语言讲述相似矩阵</a></p><p><strong>输入</strong>的是特征向量，通过对其的学习，可以得知，特征向量代表的是变化的方向。或者说，是最能代表这个事物的特征的方向。</p><p>人有性别，身高，手，脚，五官等。电脑有屏幕，键盘，CPU，GPU等。速度有方向。颜色有种类。</p><p>特别是速度的方向，需要找到的是速度改变最大（增加或减少）的方向。（所以后面要求导数）</p><p><strong>权重</strong>就是特征值，输入是特征向量，权重和它相乘，对应的就是特征值。权重有正有负，加强或抑制，同特征值一样。权重的绝对值大小，代表了输入信号对神经元的影响的大小。正如上面的例子，输入一张图片，判断是是猫还是犬。第一层输入的有毛发，爪子，牙齿类型等。第二层有头部，腹部，腿部等。</p><p>牙齿对腿部的影响就会比较小啊，牙齿和腿部之间的权重的绝对值就会小一些，诸如此类。</p><p>我们要割一刀，得有割的角度和方向，而权重，就负责调整方向，这和特征向量的方向是两回事。$n$维空间中，乘以权重就好像是在不断的扭曲空间（空间变换），使不同类别的事物被扭曲到不同的一侧，来找到一个合适的$n−1$维超平面。</p><p><strong>偏置（阈值）</strong>:上面的神经元的图示，我们总是减去 $θ$，说得通俗点，要证明$a&gt;b$可以证明$a − b &gt; 0$。</p><p><a href="https://zhuanlan.zhihu.com/p/25279356">激活函数的作用</a></p><h3 id="5-1-2-神经网络缺点"><a href="#5-1-2-神经网络缺点" class="headerlink" title="5.1.2 神经网络缺点"></a>5.1.2 神经网络缺点</h3><p>MP神经元有几个显著缺点。首先它把直线一侧变为0，另一侧变为1，这东西不可微，不利于数学分析。人们用一个和0-1阶跃函数类似但是更平滑的函数Sigmoid函数来代替它（Sigmoid函数自带一个尺度参数，可以控制神经元对离超平面距离不同的点的响应，这里忽略它），从此神经网络的训练就可以用梯度下降法来构造了，这就是有名的<strong>反向传播算法</strong>。<br>神经元的另一个缺点是：它只能切一刀！你给我说说一刀怎么能把下面这两类分开吧。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220626145728717.png" alt="image-20220626145728717"></p><p>解决办法是多层神经网络，底层神经元的输出是高层神经元的输入。我们可以在中间横着砍一刀，竖着砍一刀，然后把左上和右下的部分合在一起，与右上的左下部分分开；也可以围着左上角的边沿砍10刀把这一部分先挖出来，然后和右下角合并。</p><p>每砍一刀，其实就是使用了一个神经元，把不同砍下的半平面做交、并等运算，就是把这些神经元的输出当作输入，后面再连接一个神经元。这个例子中特征的形状称为异或，这种情况一个神经元搞不定，但是两层神经元就能正确对其进行分类。</p><p>只要你能砍足够多刀，把结果拼在一起，什么奇怪形状的边界神经网络都能够表示，所以说神经网络在理论上可以表示很复杂的函数/空间分布。但是真实的神经网络是否能摆动到正确的位置还要看网络初始值设置、样本容量和分布。</p><p>神经网络神奇的地方在于它的每一个组件非常简单——把空间切一刀+某种激活函数（0-1阶跃、sigmoid、max-pooling），但是可以一层一层级联。输入向量连到许多神经元上，这些神经元的输出又连到一堆神经元上，这一过程可以重复很多次。这和人脑中的神经元很相似：每一个神经元都有一些神经元作为其输入，又是另一些神经元的输入，数值向量就像是电信号，在不同神经元之间传导，每一个神经元只有满足了某种条件才会发射信号到下一层神经元。</p><p>神经网络的训练依靠反向传播算法：最开始输入层输入特征向量，网络层层计算获得输出，输出层发现输出和正确的类号不一样，这时它就让最后一层神经元进行参数调整，最后一层神经元不仅自己调整参数，还会勒令连接它的倒数第二层神经元调整，层层往回退着调整。经过调整的网络会在样本上继续测试，如果输出还是老分错，继续来一轮回退调整，直到网络输出满意为止。</p><p>神经网络举例：</p><p>第一层神经元主要负责识别颜色和简单纹理</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//cbd8ee99581d1a2e22dca8b0e67f84b3_1440w.jpg" alt="img"></p><p>第二层的一些神经元可以识别更加细化的纹理，比如布纹、刻度、叶纹。<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//78fd60058ceabf34d3936ac8fe618c77_1440w.jpg" alt="img"></p><p>第三层的一些神经元负责感受黑夜里的黄色烛光、鸡蛋黄、高光。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//aae832d13b33f15ba97c358fdf7319d2_1440w.jpg" alt="img"></p><p>第四层的一些神经元负责识别萌狗的脸、<a href="https://www.zhihu.com/search?q=七星瓢虫&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A36429105}">七星瓢虫</a>和一堆圆形物体的存在。<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//04468c646e0d456b0fd4772d4e2a993b_1440w.jpg" alt="img"></p><p>第五层的一些神经元可以识别出花、圆形屋顶、键盘、鸟、黑眼圈动物。<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//ab6984020030ff15f9ddb3eb716c7da6_1440w.jpg" alt="img"></p><h2 id="5-2-感知机与多层网络"><a href="#5-2-感知机与多层网络" class="headerlink" title="5.2 感知机与多层网络"></a><strong>5.2 感知机与多层网络</strong></h2><h3 id="5-2-1-什么是感知机"><a href="#5-2-1-什么是感知机" class="headerlink" title="5.2.1 什么是感知机"></a>5.2.1 什么是感知机</h3><p>感知机（Perceptron）是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别。其学习旨在求出将训练数据进行线性划分的分离超平面，为此，导入基于误分类的损失函数，利用<strong>梯度下降法</strong>对损失函数进行极小化，求得感知机模型。它是神经网络与支持向量机的基础。</p><p><strong>感知机的数学定义：</strong> 假设输入空间(特征空间)是 $X\subseteq R^n$ ，输出空间是 y={+1, -1}。输入表示实例的特征向量，对应于输入空间(特征空间)的点；输出 $y\in Y$表示实例的类别。由输入空间到输出空间的如下函数：</p><script type="math/tex; mode=display">f(x)=sign(w\cdot x+b)</script><p>称为感知机。其中$w$和$b$为感知机模型参数，$w\subseteq R^n$ 叫做权值(weight)或权值向量(weight vector)，$b\in R$ 叫作偏置(bias)， $w\cdot x$表示$w$ 和 $x$​的内积。sign是符号函数，即：</p><script type="math/tex; mode=display">sign(x) = \begin{cases}+1, & x\geq 0\\-1, & x<0\end{cases}</script><p><strong>感知机的几何解释：</strong>感知机的几何解释是线性方程：$w\cdot x+b=0$，对应与特征空间$R^n$中的一个超平面$S$，其中$w$是从超平面的法向量，$b$是超平面的截距。</p><p>这个超平面将特征空间划分为两个部分。位于两部分的点(特征向量)分别被分为<strong>正、负两类</strong>。</p><p>因此，超平面S成为分离超平面(separating hyperplane)。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220626164153663.png" alt="image-20220626164153663"></p><p>给定训练集，则感知机的$n+1$个参数（$n$个权重$+1$个阈值）都可以通过学习得到。阈值$\theta$可以看作一个输入值固定为-1的哑结点，权重为$ω_n+1$，即假设有一个固定输入$x_{n+1}=-1$的输入层神经元，其对应的权重为$ω_n+1$，这样就把权重和阈值统一为权重的学习了。简单感知机的结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb3fdf0.png" alt="4.png"></p><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626205116065.png" alt="这里写图片描述"></p><p>该感知器具有两个输入神经元，一个输出神经元。<br>我们知道该模型是可以做与或非运算的。这是因为如果我们要做与或非运算，那么对于输入$x_1,x_2$来说，其取值只能是0或1，而我们的输出</p><script type="math/tex; mode=display">y=f(\sum^2_{i=1}w_ix_i-\theta)</script><p>如果要做与运算，那令阈值$w1=1，w2=1$，$\theta=2$，则只有在$x_1=1，x_2=1$的时候才能激活输出层神经元，输出1，其余情况均输出0。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626211107613.png" alt="这里写图片描述"></p><p>同样，如果做或运算，那令阈值$w_1=1，w_2=1，\theta=1$，则只要有一个输入$x_i=1$，即可激活输出神经元，输出1。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626211115436.png" alt="这里写图片描述"></p><p>如果对$x_1$做非运算，那么可以令阈值$w_1=-0.6，w_2=0，\theta=-0.5$，则如果$x_1=1，x_2=0$，总输入为-0.6，小于阈值，输出0，如果$x_1=0，x_2=0$，总输入为0，大于阈值，输出1。这里的激活函数为阶跃函数。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626211124168.png" alt="这里写图片描述"></p><p>经过观察，可以发现，对于只有输入层与输出层的感知机模型，其只能对线性数据进行划分，对于如下图的异或模型，其实无法准确划分的。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626211325553.png" alt="这里写图片描述"></p><p>因为任何一条线都无法将$(1，0)，(0，1)$划为一类，$(0，0)，(1，1)$划为一类。<br>但如果是两层网络（这里的两层指的是隐层与输出层，因为只有这两层中的节点是有激活函数的），在隐层有两个节点，那么此时就可以得到两条线性函数，再在输出节点汇总之后，将会得到由两条直线围成的一个面，这时就可以成功的将异或问题解决。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626211551053.png" alt="这里写图片描述"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626211600985.png" alt="这里写图片描述"></p><p>因此我们可以看到，随着网络深度的增加，每一层节点个数的增加，都可以加强网络的表达能力，网络的复杂度越高，其表示能力就越强，也就可以表达更复杂的模型。</p><p>通过上面你的示例，我们也可以看到，对网络的学习其实主要是对网络中各个节点之间的连接权值和阈值的学习，即寻找最优的连接权值和阈值从而使得该模型可以达到最优（一般是局部最优）。</p><h3 id="5-2-2-感知机的学习策略"><a href="#5-2-2-感知机的学习策略" class="headerlink" title="5.2.2 感知机的学习策略"></a>5.2.2 感知机的学习策略</h3><p><strong>感知机的线性可分性</strong>：</p><p>能够将数据集的正实例点和负实例点完全正确地划分到超平面的两侧，即对所有的$y_i=+1$的实例$i$，有$w\cdot x_i+b&gt;0$，对所有的$y_i=-1$的实例$i$，有$w\cdot x_i+b&lt;0$，则称数据集为<strong>线性可分数据集(linearly separable data set)</strong>； 否则，数据集线性不可分。</p><p><strong>感知机权重的学习规则：</strong></p><p>对于训练样本$(x，y)$，当该样本进入感知机学习后，会产生一个输出值，若该输出值与样本的真实标记不一致，则感知机会对权重进行调整，若激活函数为阶跃函数，则调整的方法为（基于梯度下降法）：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb3ba63-20220626183500252.png" alt="5.png"></p><p>其中 $η∈(0，1)$称为学习率，可以看出感知机是通过逐个样本输入来更新权重，首先设定好初始权重（一般为随机），逐个地输入样本数据，若输出值与真实标记相同则继续输入下一个样本，若不一致则更新权重，然后再重新逐个检验，直到每个样本数据的输出值都与真实标记相同。容易看出：感知机模型总是能将训练数据的每一个样本都预测正确，和决策树模型总是能将所有训练数据都分开一样，感知机模型很容易产生过拟合问题。</p><p><strong>感知机的权重更新公式</strong>：</p><script type="math/tex; mode=display">w_i\leftarrow w_i+\Delta w_i</script><script type="math/tex; mode=display">\Delta w_i=\eta(y-\hat{y})x_i</script><p>如果预测正确，感知机不发生变化；否则，根据错误程度来调整参数。感知机只有一层功能神经元，学习能力有限，只能解决线性可分问题。</p><p>经证明：若两类模式是<strong>线性可分</strong>的（存在一个超平面能将它们分开），则感知机一定会收敛；否则感知机将会发生振荡。</p><p>使用多层功能神经元，可解决非线性可分问题。隐含层hidden layer：位于输出层和输入层之间的层。</p><p>多层前馈神经网络multi-layer feedforward neural networks：相邻层全连接，同层无连接，不存在跨层连接。多层神经网络的拓扑结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb58ec6-20220626183453242.png" alt="6.png"></p><p>在神经网络中，隐层和输出层的神经元都是具有激活函数的功能神经元。只需包含一个隐层便可以称为多层神经网络，常用的神经网络称为“多层前馈神经网络”（multi-layer feedforward neural network），该结构满足以下几个特点：</p><pre><code class="hljs">* 每层神经元与下一层神经元之间完全互连* 神经元之间不存在同层连接* 神经元之间不存在跨层连接</code></pre><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb47ff8-20220626183449784.png" alt="7.png"></p><p>根据上面的特点可以得知：这里的“前馈”指的是网络拓扑结构中不存在”环”或”回路”，而不是指该网络只能向前传播而不能向后传播（下节中的BP神经网络正是基于前馈神经网络而增加了反馈调节机制）。</p><p>神经网络的学习过程就是根据训练数据来调整神经元之间的“连接权”以及每个神经元的阈值，换句话说：神经网络所学习到的东西都蕴含在网络的连接权与阈值中。</p><h2 id="5-3-BP神经网络算法"><a href="#5-3-BP神经网络算法" class="headerlink" title="5.3 BP神经网络算法"></a><strong>5.3 BP神经网络算法</strong></h2><p>由上面可以得知：神经网络的学习主要蕴含在权重和阈值中，多层网络使用上面简单感知机的权重调整规则显然不够用了，BP神经网络算法即误差逆传播算法（error BackPropagation）正是为学习多层前馈神经网络而设计，BP神经网络算法是迄今为止最成功的的神经网络学习算法。</p><p>一般而言，只需包含一个足够多神经元的隐层，就能以任意精度逼近任意复杂度的连续函数[Hornik et al.,1989]，故下面以训练单隐层的前馈神经网络为例，介绍BP神经网络的算法思想。</p><p>多层前馈(BP)神经网络：<br>相邻两层是全连接，而层内是没有连接的，跨层之间也没有连接：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626212100699.png" alt="这里写图片描述"></p><p>上图为一个单隐层前馈神经网络的拓扑结构，BP神经网络算法也使用<a href="https://baike.baidu.com/item/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/4864937?fr=aladdin">梯度下降法（gradient descent）</a>，以单个样本的均方误差的负梯度方向对权重进行调节。</p><p>在给定训练数据集的情况下，可以构建一个神经网络来对这些数据进行拟合。</p><p>构建过程主要分为2步：1）前向传播 2）反向求导。</p><p>在前向传播过程中，由输入层向前传送，给定权值和bias矩阵，可以得到给定样本对应的预测值（激活值）；在反向求导过程，通过样本预测值与样本真实值之间的误差来不断修正网络参数，直至收敛。</p><p>可以看出：BP算法首先将误差反向传播给隐层神经元，调节隐层到输出层的连接权重与输出层神经元的阈值；接着根据隐含层神经元的均方误差，来调节输入层到隐含层的连接权值与隐含层神经元的阈值。BP算法基本的推导过程与感知机的推导过程原理是相同的，下面给出调整隐含层到输出层的权重调整规则的推导过程：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb86229-20220626190803201.png" alt="9.png"></p><p>学习率$η∈(0，1)$控制着沿反梯度方向下降的步长，若步长太大则下降太快容易产生震荡，若步长太小则收敛速度太慢，一般地常把$η$设置为0.1，有时更新权重时会将输出层与隐含层设置为不同的学习率。BP算法的基本流程如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb59e99.png" alt="10.png"></p><p>BP算法的更新规则是基于每个样本的预测值与真实类标的均方误差来进行权值调节，即<u>BP算法每次更新只针对于单个样例</u>。需要注意的是：BP算法的最终目标是要最小化整个训练集$D$上的累积误差，即：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72ce222a96.png" alt="11.png"></p><p>如果<u>基于累积误差最小化的更新规则</u>，则得到了累积误差逆传播算法（accumulated error backpropagation），即每次读取全部的数据集一遍，进行一轮学习，从而基于当前的累积误差进行权值调整，因此参数更新的频率相比标准BP算法低了很多，但在很多任务中，尤其是<u>在数据量很大的时候，往往标准BP算法会获得较好的结果</u>。另外对于如何设置隐层神经元个数的问题，至今仍然没有好的解决方案，常使用“试错法”进行调整。</p><p>前面提到，BP神经网络强大的学习能力常常容易造成过拟合问题，有以下两种策略来缓解BP网络的过拟合问题：</p><ul><li>早停：将数据分为训练集与测试集，训练集用于学习，测试集用于评估性能，若在训练过程中，训练集的累积误差降低，而测试集的累积误差升高，则停止训练。</li><li>引入正则化（regularization）：基本思想是在累积误差函数中增加一个用于描述网络复杂度的部分，例如所有权值与阈值的平方和，其中$λ∈(0,1)$用于对累积经验误差与网络复杂度这两项进行折中，常通过交叉验证法来估计。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72ce227ff1.png" alt="12.png"></p><p>拓展阅读：</p><p><a href="https://blog.csdn.net/as091313/article/details/79080583">BP神经网络</a></p><h2 id="5-4-全局最小与局部最小"><a href="#5-4-全局最小与局部最小" class="headerlink" title="5.4 全局最小与局部最小"></a><strong>5.4 全局最小与局部最小</strong></h2><p>模型学习的过程实质上就是一个寻找最优参数的过程，例如BP算法试图通过最速下降来寻找使得累积经验误差最小的权值与阈值，在谈到最优时，一般会提到局部极小（local minimum）和全局最小（global minimum）。</p><pre><code class="hljs">* 局部极小解：参数空间中的某个点，其邻域点的误差函数值均不小于该点的误差函数值。* 全局最小解：参数空间中的某个点，所有其他点的误差函数值均不小于该点的误差函数值。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72ce2803dc.png" alt="13.png"></p><p>要成为局部极小点，只要满足该点在参数空间中的梯度为零。局部极小可以有多个，而全局最小只有一个。全局最小一定是局部极小，但局部最小却不一定是全局最小。显然在很多机器学习算法中，都试图找到目标函数的全局最小。梯度下降法的主要思想就是沿着负梯度方向去搜索最优解，负梯度方向是函数值下降最快的方向，若迭代到某处的梯度为0，则表示达到一个局部最小，参数更新停止。</p><p>因此在现实任务中，通常使用以下策略尽可能地去接近全局最小：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">* 以多组不同参数值初始化多个神经网络，按标准方法训练，迭代停止后，取其中误差最小的解作为最终参数。<br>* 使用“模拟退火”技术，这里不做具体介绍。<br>* 使用随机梯度下降，即在计算梯度时加入了随机因素，使得在局部最小时，计算的梯度仍可能不为0，从而迭代可以继续进行。<br>* 遗传算法genetic algorithm<br>上述技术大多是启发式，理论上尚缺乏保障。<br></code></pre></td></tr></table></figure><h2 id="5-5其他常见神经网络"><a href="#5-5其他常见神经网络" class="headerlink" title="5.5其他常见神经网络"></a>5.5其他常见神经网络</h2><h3 id="5-5-1RBF网络"><a href="#5-5-1RBF网络" class="headerlink" title="5.5.1RBF网络"></a>5.5.1RBF网络</h3><p>RBF（Radial Basis Function径向基函数）网络：一种单隐层前馈神经网络，它使用径向基函数作为隐层神经元的激活函数，而输出层是对隐层神经单元输出的线性组合。</p><p>RBF网络训练过程：1.确定神经元中心，常用随机采样、聚类等；2.利用BP算法来确定参数。</p><h3 id="5-5-2-ART网络"><a href="#5-5-2-ART网络" class="headerlink" title="5.5.2 ART网络"></a>5.5.2 ART网络</h3><p>竞争型学习competitive learning：一种常用的无监督策略，网络的输出神经元互相竞争，每一时刻只有一个竞争获胜的神经元被激活，其他神经元被抑制。又称”胜者通吃“</p><p>ART（Adaptive Resonance Theory自适应谐振理论）网络是竞争型学习的重要代表，该网络由比较层、识别层、识别阈值、重置模块构成。其中，比较层负责接收输入样本并将其传递给识别层神经元，识别层每个神经元对应一个模式类，神经元数目可在训练过程中动态增加以增加新的模式类。</p><p>ART比较好地缓解了竞争学习中的”可塑性-稳定性窘境“，可塑性是指神经网络学习新知识的能力，稳定性是指神经网络在学习新知识时要保持对旧知识的记忆。ART网络可以进行增量学习incremental learning或在线学习online learning。</p><p>增量学习：在学得模型之后，再接收到训练样例时，只需要根据新样例对模型进行更新，不必重新训练整个模型，并且先前学习的有效信息不会被”冲掉“。<br>在线学习：每获得一个新样例就进行一次模型更新，在线学习是增量学习的一个特例。</p><h3 id="5-5-3-SOM网络"><a href="#5-5-3-SOM网络" class="headerlink" title="5.5.3 SOM网络"></a>5.5.3 SOM网络</h3><p>SOM（Self-Organizing Map自组织映射）网络，是一种竞争型学习的无监督神经网络，它能将高维输入数据映射到低维空间中（通常为二维），同时保持数据再高维空间中的拓扑结构，即在高维空间中相似的样本点会被映射到网络输出层中邻近的神经元。</p><h3 id="5-5-4-级联相关网络"><a href="#5-5-4-级联相关网络" class="headerlink" title="5.5.4 级联相关网络"></a>5.5.4 级联相关网络</h3><p>结构自适应网络：不仅将参数作为学习目标，并且将网络的结构也作为学习的目标之一。</p><p>级联相关（Cascade-Correlation）网络，是结构自适应网络的一种重要代表。级联是指建立层次连接的层次结构，在开始训练时网络只有输入层和输出层，处于最小拓扑结构，随着训练进行，新的隐层神经元逐渐加入，从而创建起层级结构，当新的隐层神经元加入时，其输入端连接权值是冻结固定的。相关是指通关最大化新神经元的输出与网络误差之间的相关性来训练相关的参数。</p><p>与一般的神经网络相比，级联相关网络无需设置网络层数、隐层神经元数目，且训练速度快，但是在数据较小时容易过拟合。</p><h3 id="5-5-5-Elman网络"><a href="#5-5-5-Elman网络" class="headerlink" title="5.5.5 Elman网络"></a>5.5.5 Elman网络</h3><p>递归神经网络recurrent neural networks：允许出现环形结构，从而让一些神经元的输出反馈回来作为输入信号。这样的结构与信息反馈过程，使得网络在$t$时刻的输出状态不仅与$t$时刻的输入有关，还与$t-1$时刻的网络状态有关，从而能处理与时间有关的动态变化。</p><p>Elman网络是最常用的递归神经网络之一，其结构如下。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODg5MzQy,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><h3 id="5-5-6-Boltzmann机"><a href="#5-5-6-Boltzmann机" class="headerlink" title="5.5.6 Boltzmann机"></a>5.5.6 Boltzmann机</h3><p>Boltzmann机是一种基于能量的模型，神经元分为两层：显层和隐层，显层用于表示数据的输入和输出，隐层被理解为数据的内在表达。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODg5MzQy,size_16,color_FFFFFF,t_70-20220627210733876.png" alt="在这里插入图片描述"></p><p>标准Boltzmann机是一个全连接图，训练网络的复杂度很高，这使其难以用于解决现实任务，现实常采用受限Boltzmann机。</p><p>受限Boltzmann机常采用对比散度（Contrastive Divergence，简称CD）来进行训练。</p><h2 id="5-6-深度学习"><a href="#5-6-深度学习" class="headerlink" title="5.6 深度学习"></a><strong>5.6 深度学习</strong></h2><p>理论上，参数越多的模型复杂度越高，容量就越大，这意味着它可以完成更为复杂的任务，但一般情况下，复杂模型的训练效率低，易陷入过拟合。计算能力的大幅度提升可以缓解训练过程的低效性，训练数据的大幅增加可降低过拟合风险。</p><p>单隐层的前馈神经网络已具有很强大的学习能力，但从模型的复杂度来看，增加隐层的数目显然比增加隐层的神经元数目更有效。</p><p>多层神经网络难以直接用经典算法进行训练，因为误差在多隐层内逆传播时，往往会发散而不能收敛到稳定状态。</p><p>那要怎么有效地训练多隐层神经网络呢？一般来说有以下两种方法：</p><ul><li><p>无监督逐层训练（unsupervised layer-wise training）：每次训练一层隐节点，把上一层隐节点的输出当作输入来训练，本层隐结点训练好后，输出再作为下一层的输入来训练，这称为预训练（pre-training）。全部预训练完成后，再对整个网络进行微调（fine-tuning）训练。一个典型例子就是深度信念网络（deep belief network，简称DBN）。这种做法其实可以视为把大量的参数进行分组，对每组先找到局部看起来比较好的设置，然后再基于这些局部较优的结果联合起来进行全局寻优。这在利用了模型大量参数提供的自由度的同时，有效地节省了训练开销，</p></li><li><p>权共享（weight sharing）：令同一层神经元使用完全相同的连接权，典型的例子是卷积神经网络（Convolutional Neural Network，简称CNN）。这样做可以大大减少需要训练的参数数目。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72ce28d756.png" alt="14.png"></p><p>深度学习，通过多层处理，逐渐将初始的底层特征表示转化为高层特征表示，用简单模型即可完成复杂的任务。深度学习可理解为特征学习（feature learning）或表示学习（representation learning）。</p><p>无论是DBN还是CNN，都是通过多个隐层来把与输出目标联系不大的初始输入转化为与输出目标更加密切的表示，使原来只通过单层映射难以完成的任务变为可能。即通过多层处理，逐渐将初始的“低层”特征表示转化为“高层”特征表示，从而使得最后可以用简单的模型来完成复杂的学习任务。</p><p>传统任务中，样本的特征需要人类专家来设计，这称为特征工程（feature engineering）。特征好坏对泛化性能有至关重要的影响。而深度学习为全自动数据分析带来了可能，可以自动产生更好的特征。</p><h1 id="6、支持向量机"><a href="#6、支持向量机" class="headerlink" title="6、支持向量机"></a><strong>6、支持向量机</strong></h1><p>支持向量机（Support Vector Machine），简称SVM，是一种经典的二分类模型，属于监督学习算法。</p><p>支持向量机可能是最流行和最受关注的机器学习算法之一，它是一种经典的二分类模型，基本模型定义为特征空间中最大间隔的线性分类器，其学习的优化目标便是间隔最大化，因此支持向量机本身可以转化为一个凸二次规划求解的问题。</p><p><a href="https://so.csdn.net/so/search?q=支持向量机&amp;spm=1001.2101.3001.7020">支持向量机</a>可以说是数学推导过程最复杂的<a href="https://blog.csdn.net/v_JULY_v/article/details/7624837?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165635027116782248597637%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165635027116782248597637&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-7624837-null-null.142^v24^control,157^v15^new_3&amp;utm_term=%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA&amp;spm=1018.2226.3001.4187">算法</a>，<a href="https://blog.csdn.net/weixin_55858423/article/details/119080443?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-119080443-blog-90678747.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-119080443-blog-90678747.pc_relevant_antiscanv2&amp;utm_relevant_index=6">具体推导过程</a>。</p><p><a href="https://blog.csdn.net/lzx159951/article/details/106692871?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165635027116782248597637%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165635027116782248597637&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-106692871-null-null.142^v24^control,157^v15^new_3&amp;utm_term=%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA&amp;spm=1018.2226.3001.4187">参考源代码解析</a></p><h2 id="6-1-函数间隔与几何间隔"><a href="#6-1-函数间隔与几何间隔" class="headerlink" title="6.1 函数间隔与几何间隔"></a><strong>6.1 函数间隔与几何间隔</strong></h2><blockquote><p>支持向量机的目标是确定一个对样本的分类结果最鲁棒的线性<a href="https://so.csdn.net/so/search?q=分类器&amp;spm=1001.2101.3001.7020">分类器</a>，即找到一个具有最大间隔的划分超平面。为此以间隔为优化目标，可将其转化为一个凸二次规划问题。</p></blockquote><p>对于二分类问题，其基本思想就是基于训练集$D$在样本空间中找到一个用来划分的超平面，将不同类别的样本分开。</p><p>但仅仅是将样本分开的话，那么我们可能可以找到许多个划分超平面。如图所示，从几何意义易知，粗线对训练样本局部的扰动的“容忍性”最好（其他的超平面训练样本很容易越界，考虑到噪声等因素，其分类结果很不稳定），也是最鲁棒的（即当新的数据点加入时，超平面对这些点的适应性最强，出错的可能性最小）。于是粗线也就是我们想要的最优划分超平面。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWNoZW5zdXl1,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>我们知道最优划分超平面应该满足超平面同时离两个不同类的样本尽量远这一条件，以下是为了量化“尽量远”进行的概念引申：</p><p><strong>超平面方程</strong>：样本空间中，用来描述超平面的线性方程为：</p><script type="math/tex; mode=display">w^Tx+b=0</script><p>其中$w=(w_1;w_2;…;w_d)$为法向量，决定了超平面的方向；$b$为位移项，决定了超平面与原点之间的距离。</p><p><strong>点到超平面的距离</strong>：样本空间中任意点$x$到超平面$(w,b)$的距离为：</p><script type="math/tex; mode=display">r=\frac{|w^Tx+b|}{||w||}</script><p><strong>约束条件</strong>：假设超平面$(w，b)$能将训练样本正确分类，即对于$(x_i,y_i)\in D$，若$y_i=+1$，则有$w^Tx_i+b&gt;0$；若$y_i=-1$，则有$w^Tx_i+b&lt;0$​，令</p><script type="math/tex; mode=display">\begin{cases}w^Tx_i+b\geq+1, & y_i=+1\\w^Tx_i+b\leq-1, &  y_i=-1\end{cases}</script><p>为超平面将训练样本正确分类的约束条件。</p><h3 id="6-1-1-函数间隔"><a href="#6-1-1-函数间隔" class="headerlink" title="6.1.1 函数间隔"></a><strong>6.1.1 函数间隔</strong></h3><p>假设最合适的分类超平面已找到，如前所述，分类超平面的方程即为：$f(x)=w^Tx+b=0$，也就是说超平面上的点都符合该方程式。</p><p><strong>函数间隔</strong>的定义为：</p><script type="math/tex; mode=display">\hat{\gamma}=yf(x)=y(w^Tx+b)</script><p>而超平面$(w,b)$关于所有样本点$(x_i，y_i)$的函数间隔最小值则为超平面在训练数据集$T$​上的函数间隔：</p><script type="math/tex; mode=display">\hat{\gamma}=min\hat{\gamma},\ (i=1,...,n)</script><p>可以看出：这样定义的函数间隔在处理SVM上会有问题，当超平面的两个参数$w$和$b$同比例改变时，函数间隔也会跟着改变，但是实际上超平面还是原来的超平面，并没有变化。例如：$w_1x_1+w_2x_2+w_3x_3+b=0$其实等价于$2w_1x_1+2w_2x_2+2w_3x_3+2b=0$，但计算的函数间隔却翻了一倍。从而引出了能真正度量点到超平面距离的概念——几何间隔（geometrical margin）。</p><h3 id="6-1-2-几何间隔"><a href="#6-1-2-几何间隔" class="headerlink" title="6.1.2 几何间隔"></a><strong>6.1.2 几何间隔</strong></h3><p><strong>几何间隔</strong>代表的则是数据点到超平面的真实距离，对于超平面$w’x+b=0$，$w$代表的是该超平面的法向量，设$x$为超平面外一点在法向量$w$方向上的投影点，$x$与超平面的距离为$\gamma$，则有：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f697d499.png" alt="5.png"></p><p>为了得到$\gamma$的绝对值，令$\gamma$呈上其对应的类别$y$，即可得到几何间隔的定义：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f696fd10.png" alt="6.png"></p><p>从上述定义可以看出：实质上函数间隔就是$|w’x+b|$，而几何间隔就是函数间隔除以$||w||$，直观来讲就是点到超平面的距离。</p><h2 id="6-2-最大间隔与支持向量"><a href="#6-2-最大间隔与支持向量" class="headerlink" title="6.2 最大间隔与支持向量"></a><strong>6.2 最大间隔与支持向量</strong></h2><p>SVM之所以叫支持向量机，因为其核心理念是：支持向量样本会对识别的问题起关键性作用。那什么是支持向量（Support <a href="https://so.csdn.net/so/search?q=vector&amp;spm=1001.2101.3001.7020">vector</a>）呢？支持向量也就是离分类超平面（Hyper plane）最近的样本点。</p><p>如下图所示，有两类样本数据（橙色和蓝色的小圆点），中间的红线是分类超平面，两条虚线上的点（橙色圆点3个和蓝色圆点2个）是距离超平面最近的点，这些点即为<strong>支持向量</strong>。简单地说，作为支持向量的样本点<strong>非常非常重要</strong>，以至于其他的样本点可以视而不见。而这个分类超平面正是SVM分类器，通过这个分类超平面实现对样本数据一分为二。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzYzMDMy,size_16,color_FFFFFF,t_70-20220628001505170.png" alt="在这里插入图片描述"></p><p>如何找到最合适的分类超平面？依据的原则就是间隔最大化。</p><p>所谓间隔最大化，说的是分类超平面跟两类数据的间隔要尽可能大（即远离两边数据），这就要提到我们前面说到的公平原则。“三八线”要划在课桌正中间，不偏向任何一方，才能保证双方利益最大化。对于分类超平面来说，也就是要位于两类数据的正中间，不偏向任何一类，才能保证离两边数据都尽可能远，从而实现间隔最大化。</p><p>如左下图所示，有两类样本数据（分别用橙色和蓝色的小圆圈表示），我们可通过红色或蓝色两条直线（L1或L2）将这两类样本数据分开。事实上，我们还可以画出很多条直线将两类样本分开，也就是说，存在有多个可行的线性分类器能将两类样本分类。SVM的最终目标是：以间隔最大化为原则找到最合适的那个分类器。<br><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzYzMDMy,size_16,color_FFFFFF,t_70-20220628001732659.png" alt="在这里插入图片描述"></p><p>从直观上看，图中蓝线L2偏向了橙色数据一方，有失<strong>公平原则</strong>，因而不是我们要找的理想的分类器。红线L1则较注重公平，不偏向任何一类数据，从而能较好地确保离两类数据都尽可能远，实现间隔最大化，这样的分类超平面具有更好的泛化性能，分类更加准确，正是我们要找的最合适的分类器。</p><p>我们注意到，图中两条虚线（S1和S2）上的圆点数据即为支持向量（Support vector），它们距离分类超平面最近。现在<u>我们仅保留这些支持向量数据点进行分析</u>（右上图），可以看出两条虚线之间的间隔距离为$\gamma$。依据公平原则，支持向量到分类超平面的距离则为$\gamma /2$，这个值即为分类间隔。间隔最大化，就是最大化这个值$\gamma /2$。</p><p><u>由此可以看出，分类间隔值$\gamma /2$只与支持向量数据点有关，与其他非支持向量数据点无关。</u>这也正好诠释了我们在文中开头说到的：SVM的核心理念是支持向量样本会对识别的问题起关键性作用。也就是说，分类超平面的确定仅取决于支持向量。</p><p>对于给定的训练样本，首先要找到距离分类超平面最近的点（支持向量），再通过最大化这些点之间的间隔来求解。</p><p>通过前面的分析可知：函数间隔不适合用来最大化间隔，因此这里我们要找的最大间隔指的是几何间隔。</p><p>为便于计算，位于分类超平面两侧的数据计算的数值分别取1或-1，以将数据分两类，这两类数据通常也称为正、负样本数据。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzYzMDMy,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>两类数据的函数方程式即为：</p><script type="math/tex; mode=display">正样本：f(x)=w^Tx+b=1\\负样本：f(x)=w^Tx+b=-1</script><p>也就是说任何属于正样本类的数据$x$带入方程式得到的结果$y$计算取值都为1，即$y=1$；任何属于负样本类的数据$x$带入方程式得到的结果$y$计算取值都为-1，即$y=-1$​。</p><p>两个不同类别的支持向量分别到超平面的距离之和</p><script type="math/tex; mode=display">\gamma=\frac{2}{||w||}</script><p>推导过程：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWNoZW5zdXl1,size_16,color_FFFFFF,t_70-20220627230850969.png" alt="在这里插入图片描述"></p><p>于是，最优划分超平面即对应最大间隔的划分超平面，也就是找到满足约束条件的 $w$ 和 $b$ 使得$γ$​ 最大，即：</p><script type="math/tex; mode=display">max_{w,b} \frac{2}{||w||}\\s.t.\ y_i(w^Tx_i+b)\geq1,\ i=1,2,...,m</script><p>最大化$||w||^{-1}$等驾驭最小化$||w||^2$，于是上述条件可重写为：</p><script type="math/tex; mode=display">max_{w,b} \frac{1}{2}||w||^2\\s.t.\ y_i(w^Tx_i+b)\geq1,\ i=1,2,...,m</script><p><img src="https://i.loli.net/2018/10/17/5bc72f6a838c4.png" alt="9.png"></p><p>这里解释一下为什么要用$||w||^2$：由约束条件可知将不会存在错误分类的样本，即不存在欠拟合的问题；那么，上式的优化目标可进一步解释为“最小化$\frac{1}{2}||w||^2$则相当于寻找最不可能过拟合的分类超平面”，为了防止过拟合引入了正则化，即在最小化目标函数中加入分类器的所有参数的模值的平方（不含位移项$b$）。</p><h2 id="6-3-从原始优化问题到对偶问题"><a href="#6-3-从原始优化问题到对偶问题" class="headerlink" title="6.3 从原始优化问题到对偶问题"></a><strong>6.3 从原始优化问题到对偶问题</strong></h2><blockquote><p>对于上述目标函数，接下来我们将采用拉格朗日乘子法得到其对偶问题。由于该对偶问题又为二次规划问题，故采用了SMO算法对其进行求解。</p></blockquote><h3 id="6-3-1-转换对偶问题"><a href="#6-3-1-转换对偶问题" class="headerlink" title="6.3.1 转换对偶问题"></a>6.3.1 转换对偶问题</h3><p>对于上述得到的目标函数，将原来的目标函数转化为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f6978cbb.png" alt="10.png"></p><p>即变为了一个带约束的凸二次规划问题，按书上所说可以使用现成的优化计算包（QP优化包）求解，但由于SVM的特殊性，一般我们将原问题变换为它的<strong>对偶问题</strong>，接着再对其对偶问题进行求解。为什么通过对偶问题进行求解，有下面两个原因：</p><pre><code class="hljs">* 一是因为使用对偶问题更容易求解；* 二是因为通过对偶问题求解出现了向量内积的形式，从而能更加自然地引出核函数。</code></pre><p>以下是拉格朗日乘子法求得其对偶问题的基本步骤：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//20190530105244927.png" alt></p><p>对偶问题，顾名思义，可以理解成优化等价的问题，更一般地，是将一个原始目标函数的最小化转化为它的对偶函数最大化的问题。</p><p>对于当前的优化问题，按照上面的步骤，首先我们写出它的朗格朗日函数：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f9332be7.png" alt="11.png"></p><p>上式很容易验证：当其中有一个约束条件不满足时，$L$的最大值为 ∞（只需令其对应的$α$为 $∞$即可）；当所有约束条件都满足时，$L$的最大值为$1/2||w||^2$（此时令所有的$α$为0），因此实际上原问题等价于：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f93321c5.png" alt="12.png"></p><p>由于这个的求解问题不好做，因此一般我们将最小和最大的位置交换一下（需满足KKT条件） ，变成原问题的对偶问题：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f9330967.png" alt="13.png"></p><p>这样就将原问题的求最小变成了对偶问题求最大（用对偶这个词还是很形象），接下来便可以先求$L$对$w$和$b$的极小，再求$L$对$α$的极大。</p><p>（1）首先求$L$对$w$和$b$的极小，分别求$L$关于$w$和$b$的偏导，可以得出：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f9333e66.png" alt="14.png"></p><p>将上述结果代入$L$得到：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f935ae21.png" alt="15.png"></p><p>推导过程：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWNoZW5zdXl1,size_16,color_FFFFFF,t_70-20220628004324967.png" alt="在这里插入图片描述"></p><p>（2）接着$L$关于$α$极大求解$α$。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f9338a9d.png" alt="16.png"></p><p>（3）最后便可以根据求解出的$α$，计算出$w$和$b$，从而得到分类超平面函数。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f93419ca.png" alt="17.png"></p><p>在对新的点进行预测时，实际上就是将数据点$x$代入分类函数$f(x)=w’x+b$中，若$f(x)&gt;0$，则为正类，$f(x)&lt;0$，则为负类，根据前面推导得出的$w$与$b$，分类函数如下所示，此时便出现了上面所提到的内积形式。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f9353166.png" alt="18.png"></p><p>这里实际上只需计算新样本与支持向量的内积，因为对于非支持向量的数据点，其对应的拉格朗日乘子一定为0，根据最优化理论（K-T条件），即要求：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//20190530120814493.png" alt="在这里插入图片描述"></p><p>注：KKT条件主要包含三大部分：<br>①：拉格朗日乘子$≥ 0$<br>②：原问题的约束条件<br>③：拉格朗日函数中的拉格朗日乘子项$= 0 $</p><p>因此，根据以上KKT条件，我们可以对$\alpha_i$的取值进行讨论，并得出支持向量机一个重要结论：==训练完成后，大部分的训练样本都不需要保留，最终模型仅与支持向量有关。==</p><p>对于不等式约束$y(w’x+b)-1≥0$，满足：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f933c947.png" alt="19.png">        </p><h3 id="6-3-2-求解对偶问题"><a href="#6-3-2-求解对偶问题" class="headerlink" title="6.3.2 求解对偶问题"></a>6.3.2 求解对偶问题</h3><p><a href="https://blog.csdn.net/shichensuyu/article/details/90678747">SMO推导过程</a></p><h2 id="6-4-核函数"><a href="#6-4-核函数" class="headerlink" title="6.4 核函数"></a><strong>6.4 核函数</strong></h2><blockquote><p>前三节是在样本在其原始样本空间线性可分的假设下进行讨论的，本节针对原始样本空间线性不可分的问题，基于==有限维原始样本空间一定存在一个高维特征空间使样本线性可分==这一定理，引出了原始空间和特征空间的桥梁——核函数的相关概念，并强调==核函数的选择是支持向量机的最大变数。==</p></blockquote><p>将样本从原始样本空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分，令$\phi(x)$表示将$x$​映射后的特征向量，则在特征空间中划分超平面所对应的模型可表示为：</p><script type="math/tex; mode=display">f(x)=w^T\phi(x)+b</script><p>按照同样的方法，先写出新目标函数的拉格朗日函数，接着写出其对偶问题，求$L$关于$w$和$b$的极大，最后运用SOM求解$α$。可以得出：</p><p>（1）原对偶问题变为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730cc68b3b.png" alt="21.png"></p><p>（2）原分类函数变为：<br>​    <img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730cc1b673.png" alt="22.png"></p><p>求解的过程中，只涉及到了高维特征空间中的内积运算，由于特征空间的维数可能会非常大，例如：若原始空间为二维，映射后的特征空间为5维，若原始空间为三维，映射后的特征空间将是19维，之后甚至可能出现无穷维，根本无法进行内积运算了，此时便引出了<strong>核函数</strong>（Kernel）的概念。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730cc49adc.png" alt="23.png"></p><p>因此，核函数可以直接计算隐式映射到高维特征空间后的向量内积，而不需要显式地写出映射后的结果，它虽然完成了将特征从低维到高维的转换，但最终却是在低维空间中完成向量内积计算，与高维特征空间中的计算等效<strong>（低维计算，高维表现）</strong>，从而避免了直接在高维空间无法计算的问题。引入核函数后，原来的对偶问题与分类函数则变为：</p><p>（1）对偶问题：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730cc173b2.png" alt="24.png"></p><p>（2）分类函数：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730cc05959.png" alt="25.png"></p><p>因此，在线性不可分问题中，==核函数的选择成了支持向量机的最大变数==，若选择了不合适的核函数，则意味着将样本映射到了一个不合适的特征空间，则极可能导致性能不佳。同时，核函数需要满足以下这个必要条件：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730ccc468c.png" alt="26.png"></p><p>注：</p><ul><li>半正定矩阵：设$A$为实对称矩阵，若对于每个非零向量$X$，都有$X^TAX\geq0$，则称$A$为半正定矩阵，$X^TAX$为半正定二次型。</li></ul><p>由该定理可以看出，核矩阵是实对称矩阵，==只要一个对称函数对应的核矩阵半正定，它就可以作为核函数==。</p><p>由于核函数的构造十分困难，通常我们都是从一些常用的核函数中选择，下面列出了几种常用的核函数：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730ccc541a.png" alt="27.png"></p><h2 id="6-5-软间隔支持向量机"><a href="#6-5-软间隔支持向量机" class="headerlink" title="6.5 软间隔支持向量机"></a><strong>6.5 软间隔支持向量机</strong></h2><blockquote><p>前面的内容都是基于理论进行的推导，但在现实情况下我们很难确定合适的核函数对样本进行完美分类，故提出了软间隔的概念，允许有尽可能少的样本不满足约束条件。于是在前面的基础上，模型加入了对各个样本松弛变量的考量，并采用6.3节的方法进行求解。</p></blockquote><p>前面的讨论中，我们主要解决了两个问题：当数据线性可分时，直接使用最大间隔的超平面划分；当数据线性不可分时，则通过核函数将数据映射到高维特征空间，使之线性可分。然而在现实问题中，对于某些情形还是很难处理，例如数据中有<strong>噪声</strong>的情形，噪声数据（<strong>outlier</strong>）本身就偏离了正常位置，但是在前面的SVM模型中，我们要求所有的样本数据都必须满足约束，如果不要这些噪声数据还好，当加入这些outlier后导致划分超平面被挤歪了，如下图所示，对支持向量机的泛化性能造成很大的影响。</p><p><img src="https://i.loli.net/2018/10/17/5bc730ccce68e.png" alt="28.png"></p><p>为了解决这一问题，我们需要允许某一些数据点不满足约束，即可以在一定程度上偏移超平面，同时使得不满足约束的数据点尽可能少，这便引出了<strong>“软间隔”支持向量机</strong>的概念</p><pre><code class="hljs">* 允许某些数据点不满足约束y(w&#39;x+b)≥1；* 同时又使得不满足约束的样本尽可能少。</code></pre><p>这样优化目标变为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730cc6c9fe.png" alt="29.png"></p><p>如同阶跃函数，0/1损失函数虽然表示效果最好，但是数学性质不佳。因此常用其它函数作为“替代损失函数”。</p><p><img src="https://i.loli.net/2018/10/17/5bc730cc5e5a9.png" alt="30.png"></p><p>支持向量机中的损失函数为<strong>hinge损失</strong>，引入<strong>“松弛变量”</strong>，目标函数与约束条件可以写为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc7317aa3411.png" alt="31.png"></p><p>其中$C$为一个参数，控制着目标函数与新引入正则项之间的权重，这样显然每个样本数据都有一个对应的松弛变量，用以表示该样本不满足约束的程度，将新的目标函数转化为拉格朗日函数得到：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc7317a4c96e.png" alt="32.png"></p><p>按照与之前相同的方法，先让$L$求关于$w$，$b$以及松弛变量的极小，再使用SMO求出$α$，有：</p><p><img src="https://i.loli.net/2018/10/17/5bc7317a6dff2.png" alt="33.png"></p><p>将$w$代入$L$化简，便得到其对偶问题：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc7317ab6646.png" alt="34.png"></p><p>对于软间隔支持向量机，KKT条件要求：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//20190530210442677.png" alt="在这里插入图片描述"></p><p>推导过程：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWNoZW5zdXl1,size_16,color_FFFFFF,t_70-20220628011444870.png" alt="在这里插入图片描述"></p><p>由上图的推导可以看出，软间隔支持向量机的最终模型仅与支持向量有关，即通过hinge损失函数仍保持了稀疏性。</p><p>将“软间隔”下产生的对偶问题与原对偶问题对比可以发现：新的对偶问题只是约束条件中的$α$多出了一个上限$C$，其它的完全相同，因此在引入核函数处理线性不可分问题时，便能使用与“硬间隔”支持向量机完全相同的方法。</p><p>——在此SVM就介绍完毕。</p><h2 id="6-6-SVM优缺点"><a href="#6-6-SVM优缺点" class="headerlink" title="6.6 SVM优缺点"></a>6.6 SVM优缺点</h2><p><strong>优点</strong></p><ul><li>可以解决高维问题，即大型特征空间；</li><li>解决小样本下机器学习问题；</li><li>能够处理非线性特征的相互作用；</li><li>无局部极小值问题；（相对于神经网络等算法）</li><li>无需依赖整个数据；</li><li>泛化能力比较强；</li></ul><p><strong>缺点</strong></p><ul><li>当观测样本很多时，效率并不是很高；</li><li>对非线性问题没有通用解决方案，有时候很难找到一个合适的核函数；</li><li>对于核函数的高维映射解释力不强，尤其是径向基函数；</li><li>常规SVM只支持二分类；</li><li><strong>对缺失数据敏感；</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql语句</title>
    <link href="/2022/06/22/Mysql%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/06/22/Mysql%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="MySQL-语法"><a href="#MySQL-语法" class="headerlink" title="MySQL 语法"></a>MySQL 语法</h1><h2 id="1-Mysql基础"><a href="#1-Mysql基础" class="headerlink" title="1.Mysql基础"></a>1.Mysql基础</h2><h4 id="MySQL登录"><a href="#MySQL登录" class="headerlink" title="MySQL登录"></a>MySQL登录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@host]# mysql -u root -p<br>Enter password:******<br></code></pre></td></tr></table></figure><h4 id="退出MySQL"><a href="#退出MySQL" class="headerlink" title="退出MySQL"></a>退出MySQL</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; exit<br>Bye<br></code></pre></td></tr></table></figure><h3 id="1-1-MySQL-数据库操作"><a href="#1-1-MySQL-数据库操作" class="headerlink" title="1.1 MySQL 数据库操作"></a>1.1 MySQL 数据库操作</h3><h4 id="查询所有的数据库"><a href="#查询所有的数据库" class="headerlink" title="查询所有的数据库"></a>查询所有的数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW DATABASES;<br></code></pre></td></tr></table></figure><h4 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use 数据库名称;<br></code></pre></td></tr></table></figure><h4 id="查看当前使用的数据库"><a href="#查看当前使用的数据库" class="headerlink" title="查看当前使用的数据库"></a>查看当前使用的数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select database();<br></code></pre></td></tr></table></figure><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE 数据库名;<br>CREATE DATABASE IF NOT EXISTS 数据库名称;<br></code></pre></td></tr></table></figure><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database &lt;数据库名&gt;;<br>DROP DATABASE IF EXISTS 数据库名称;<br></code></pre></td></tr></table></figure><h3 id="1-2-MySQL-数据类型"><a href="#1-2-MySQL-数据类型" class="headerlink" title="1.2 MySQL 数据类型"></a>1.2 MySQL 数据类型</h3><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小</th><th style="text-align:center">范围（有符号）</th><th style="text-align:center">范围（无符号）</th><th>用途</th></tr></thead><tbody><tr><td style="text-align:center">TINYINT</td><td style="text-align:center">1 Bytes</td><td style="text-align:center">(-128，127)</td><td style="text-align:center">(0，255)</td><td>小整数值</td></tr><tr><td style="text-align:center">SMALLINT</td><td style="text-align:center">2 Bytes</td><td style="text-align:center">(-32 768，32 767)</td><td style="text-align:center">(0，65 535)</td><td>大整数值</td></tr><tr><td style="text-align:center">MEDIUMINT</td><td style="text-align:center">3 Bytes</td><td style="text-align:center">(-8 388 608，8 388 607)</td><td style="text-align:center">(0，16 777 215)</td><td>大整数值</td></tr><tr><td style="text-align:center">INT或INTEGER</td><td style="text-align:center">4 Bytes</td><td style="text-align:center">(-2 147 483 648，2 147 483 647)</td><td style="text-align:center">(0，4 294 967 295)</td><td>大整数值</td></tr><tr><td style="text-align:center">BIGINT</td><td style="text-align:center">8 Bytes</td><td style="text-align:center">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td style="text-align:center">(0，18 446 744 073 709 551 615)</td><td>极大整数值</td></tr><tr><td style="text-align:center">FLOAT</td><td style="text-align:center">4 Bytes</td><td style="text-align:center">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td style="text-align:center">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td>单精度 浮点数值</td></tr><tr><td style="text-align:center">DOUBLE</td><td style="text-align:center">8 Bytes</td><td style="text-align:center">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align:center">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>双精度 浮点数值</td></tr><tr><td style="text-align:center">DECIMAL</td><td style="text-align:center">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td style="text-align:center">依赖于M和D的值</td><td style="text-align:center">依赖于M和D的值</td><td>小数值</td></tr></tbody></table></div><h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p><p>TIMESTAMP类型有专有的自动更新特性。</p><div class="table-container"><table><thead><tr><th>类型</th><th>大小 ( bytes)</th><th>范围</th><th>格式</th><th>用途</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01/9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>‘-838:59:59’/‘838:59:59’</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901/2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00/9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td>YYYYMMDD HHMMSS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table></div><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><div class="table-container"><table><thead><tr><th>类型</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table></div><h3 id="1-3-MySQL数据表操作"><a href="#1-3-MySQL数据表操作" class="headerlink" title="1.3 MySQL数据表操作"></a>1.3 MySQL数据表操作</h3><h4 id="查询当前数据库下所有表名称"><a href="#查询当前数据库下所有表名称" class="headerlink" title="查询当前数据库下所有表名称"></a>查询当前数据库下所有表名称</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TABLES;<br></code></pre></td></tr></table></figure><h4 id="查询表结构（即表的所有列名及其数据类型）"><a href="#查询表结构（即表的所有列名及其数据类型）" class="headerlink" title="查询表结构（即表的所有列名及其数据类型）"></a>查询表结构（即表的所有列名及其数据类型）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESC 表名称;<br></code></pre></td></tr></table></figure><h4 id="创建Table"><a href="#创建Table" class="headerlink" title="创建Table"></a>创建Table</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名 ( <br>  字段名1 数据类型1, <br>  字段名2 数据类型2,<br>  ...<br>字段名n 数据类型n );<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table tb_user (<br>    id int,<br>    username varchar(20),<br>    password varchar(32)<br>);<br></code></pre></td></tr></table></figure><h4 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TABLE table_name ;<br>DROP TABLE IF EXISTS 表名;<br></code></pre></td></tr></table></figure><h4 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 改表名 --<br>ALTER TABLE 表名 RENAME TO 新的表名;<br>-- 将表名student修改为stu<br>alter table student rename to stu;<br><br>-- 加一列 --<br>ALTER TABLE 表名 ADD 列名 数据类型;<br>-- 给stu表添加一列address，该字段类型是varchar(50) alter table stu add address varchar(50);<br><br>-- 改数据类型 --<br>ALTER TABLE 表名 MODIFY 列名 新数据类型;<br>-- 将stu表中的address字段的类型改为 char(50) alter table stu modify address char(50);<br><br>-- 删除列 --<br>ALTER TABLE 表名 DROP 列名;<br>-- 将stu表中的addr字段 删除 alter table stu drop addr;<br><br>-- 修改列名和数据类型 --<br>ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;<br>-- 将stu表中的address字段名改为 addr，类型改为varchar(50) alter table stu change address addr varchar(50);<br></code></pre></td></tr></table></figure><h3 id="1-4-MySQL数据增删改"><a href="#1-4-MySQL数据增删改" class="headerlink" title="1.4 MySQL数据增删改"></a>1.4 MySQL数据增删改</h3><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 给指定列添加数据 --<br>INSERT INTO 表名(列名1,列名2,...) VALUES(值1,值2,...);<br><br>-- 给全部列添加数据 --<br>INSERT INTO 表名 VALUES(值1,值2,...);<br><br>-- 批量添加数据 --<br>INSERT INTO 表名(列名1,列名2,...) VALUES(值1,值2,...),(值1,值2,...),(值1,值2,...)...;<br>INSERT INTO 表名 VALUES(值1,值2,...),(值1,值2,...),(值1,值2,...)...;<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from stu;<br>-- 给指定列添加数据<br>INSERT INTO stu (id, NAME) VALUES (1, &#x27;张三&#x27;);<br>-- 给所有列添加数据，列名的列表可以省略的<br>INSERT INTO stu (id,NAME,sex,birthday,score,email,tel,STATUS) VALUES (2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11- 11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1);<br>INSERT INTO stu VALUES (2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1);<br>-- 批量添加数据<br>INSERT INTO stu VALUES<br>(2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1), (2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1), (2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1);<br></code></pre></td></tr></table></figure><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE 表名 SET 列名1=值1,列名2=值2,... [WHERE 条件] ;<br>update stu set birthday = &#x27;1999-12-12&#x27;, score = 99.99 where name = &#x27;张三&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>注意:</p><p>​     1. 修改语句中如果不加条件，则将所有数据都修改!</p><ol><li>像上面的语句中的中括号，表示在写sql语句中可以省略这部分</li></ol></blockquote><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM 表名 [WHERE 条件] ;<br><br>-- 删除张三记录<br>delete from stu where name = &#x27;张三&#x27;;<br>-- 删除stu表中所有的数据 <br>delete from stu;<br></code></pre></td></tr></table></figure><h2 id="2-MySQL数据库查询"><a href="#2-MySQL数据库查询" class="headerlink" title="2. MySQL数据库查询"></a>2. MySQL数据库查询</h2><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询多个字段<br>SELECT 字段列表 FROM 表名;<br>SELECT * FROM 表名; -- 查询所有数据<br><br>-- 把查到的结果的重复记录去掉<br>SELECT DISTINCT 字段列表 FROM 表名;<br><br>-- 起别名<br>AS: AS 也可以省略<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select distinct address from stu;<br>select name,math as 数学成绩,english as 英文成绩 from stu;<br>select name,math 数学成绩,english 英文成绩 from stu;<br></code></pre></td></tr></table></figure><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p><strong>where：</strong>数据库中常用的是where关键字，用于在初始表中筛选查询。它是一个约束声明，用于约束数据，在返回结果集之前起作用。</p><p><strong>group by:</strong>   对select查询出来的结果集按照<strong>某个字段或者表达式</strong>进行分组，获得一组组的集合，然后从每组中取出一个指定字段或者表达式的值。</p><p><strong>having：</strong>用于对where和group by查询出来的分组经行过滤，查出满足条件的分组结果。它是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作。</p><p><strong>where</strong> <strong>和</strong> <strong>having</strong> <strong>区别:</strong></p><p>执行时机不一样：where 是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。<br> 可判断的条件不一样：where 不能对聚合函数进行判断，having 可以。</p><p><strong>执行顺序</strong>：where –&gt; group by–&gt; having–&gt;select–&gt;order by</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表名 WHERE 条件列表;<br></code></pre></td></tr></table></figure><p>where子句除了&lt;,&gt;,&lt;=,&gt;=,=,&lt;&gt;或!=以外还可以使用以下运算符：</p><div class="table-container"><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>Between…and…</td><td>在某个范围之内，包含边界</td></tr><tr><td>In(…)</td><td>多选一</td></tr><tr><td>Like 占位符</td><td>模糊查询，_单个任意字符，%多个任意字符_</td></tr><tr><td>Is null</td><td>空</td></tr><tr><td>Is not null</td><td>非空</td></tr><tr><td>And 或 &amp;&amp;</td><td>并且</td></tr><tr><td>Or 或 \</td><td>\</td><td></td><td>或者</td></tr><tr><td>Not 或 !</td><td>不是</td></tr></tbody></table></div><p>在 where like 的条件查询中，SQL 提供了四种匹配方式。</p><ol><li><strong>%</strong>：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。</li><li><strong>_</strong>：表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句。</li><li><strong>[]</strong>：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。</li><li><strong><sup><a href="#fn_" id="reffn_"></a></sup></strong> ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。</li><li>查询内容包含通配符时，由于通配符的缘故，导致我们查询特殊字符 “%”、“_”、“[” 的语句无法正常实现，而把特殊字符用 “[ ]” 括起便可正常查询。可以使用LIKE子句代替等号 <strong>=</strong>。</li></ol><p><strong>UNION 语句</strong>：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据）</p><p><strong>UNION ALL 语句</strong>：用于将不同表中相同列中查询的数据展示出来；（包括重复数据）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 列名称 FROM 表名称 UNION SELECT 列名称 FROM 表名称 ORDER BY 列名称；<br>SELECT 列名称 FROM 表名称 UNION ALL SELECT 列名称 FROM 表名称 ORDER BY 列名称；<br></code></pre></td></tr></table></figure><p>实例解析：</p><p>从 “Websites” 和 “apps” 表中选取所有<strong>不同的</strong>country（只有不同的值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT country FROM Websites<br>UNION<br>SELECT country FROM apps<br>ORDER BY country;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623155025359.png" alt="image-20220623155025359" style="zoom:50%;"></p><p>使用 UNION ALL 从 “Websites” 和 “apps” 表中选取<strong>所有的</strong>country（也有重复的值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT country FROM Websites<br>UNION ALL<br>SELECT country FROM apps<br>ORDER BY country;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623154845811.png" alt="image-20220623154845811" style="zoom:50%;"></p><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] ...;<br>select * from stu order by math desc , english asc ;<br></code></pre></td></tr></table></figure><p>ASC : 升序排列 <strong>(默认值)</strong> </p><p>DESC : 降序排列</p><blockquote><p>注意:如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序</p></blockquote><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>将一列数据作为一个整体，进行纵向计算。</p><p>例如让我们求表中所有数据的数学成绩的总和。这就是对math字段进行纵向求和。</p><p>常用聚合函数：</p><div class="table-container"><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>count(列名)</td><td>返回统计数量(一般选用不为null的列)</td></tr><tr><td>max(列名)</td><td>返回最大值</td></tr><tr><td>min(列名)</td><td>返回最小值</td></tr><tr><td>sum(列名)</td><td>返回求和</td></tr><tr><td>avg(列名)</td><td>返回平均值</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 聚合函数名(列名) FROM 表;<br></code></pre></td></tr></table></figure><blockquote><p>注意:null 值不参与所有聚合函数运算</p></blockquote><p>实例解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(id) from stu;<br>select count(*) from stu;<br></code></pre></td></tr></table></figure><p>上面语句根据某个字段进行统计，如果该字段某一行的值为null的话，将不会被统计。所以可以用count（*）来实现，<em> 表示所有字段数据，一行中也不可能所有的数据都为null，所以建议使用 count(</em>)。</p><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];<br></code></pre></td></tr></table></figure><blockquote><p>注意:分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义</p></blockquote><p>实例解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select sex, avg(math) from stu group by sex;<br></code></pre></td></tr></table></figure><p>查询结果：男生的数学平均分和女生的数学平均分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select sex, avg(math),count(*) from stu where math &gt; 70 group by sex;<br></code></pre></td></tr></table></figure><p>查询结果：不低于70分的男生的数学平均分和女生的数学平均分以及各自的人数。</p><p><strong>group by：分组依据</strong></p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a><strong>分页查询</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表名 LIMIT 起始索引 , 查询条目数;<br></code></pre></td></tr></table></figure><blockquote><p>注意: 上述语句中的起始索引是从0开始</p></blockquote><p>实例解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from stu limit 0 , 3;<br>select * from stu limit 3 , 3;<br>select * from stu limit 6 , 3;<br></code></pre></td></tr></table></figure><p>每页显示3条数据，分别查看第1，2，3页，可推导出公式：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">起始索引 <span class="hljs-operator">=</span> (当前页码 - <span class="hljs-number">1</span>) * 每页显示的条数<br></code></pre></td></tr></table></figure><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>MySQL中使用 REGEXP 操作符来进行正则表达式匹配。</p><div class="table-container"><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td>.</td><td>匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像 ‘[.\n]’ 的模式。</td></tr><tr><td>[…]</td><td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td><sup><a href="#fn_..." id="reffn_...">...</a></sup></td><td>负值字符集合。匹配未包含的任意字符。例如， ‘<sup><a href="#fn_abc" id="reffn_abc">abc</a></sup>‘ 可以匹配 “plain” 中的’p’。</td></tr><tr><td>p1\</td><td>p2\</td><td>p3</td><td>匹配 p1 或 p2 或 p3。例如，’z\</td><td>food’ 能匹配 “z” 或 “food”。’(z\</td><td>f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td>{n}</td><td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td>{n,m}</td><td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td></tr></tbody></table></div><p>查找name字段中以’st’为开头的所有数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name FROM person_tbl WHERE name REGEXP &#x27;^st&#x27;;<br></code></pre></td></tr></table></figure><p>查找name字段中以’ok’为结尾的所有数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name FROM person_tbl WHERE name REGEXP &#x27;ok$&#x27;;<br></code></pre></td></tr></table></figure><p>查找name字段中包含’mar’字符串的所有数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name FROM person_tbl WHERE name REGEXP &#x27;mar&#x27;;<br></code></pre></td></tr></table></figure><p>查找name字段中以元音字符开头或以’ok’字符串结尾的所有数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name FROM person_tbl WHERE name REGEXP &#x27;^[aeiou]|ok$&#x27;;<br></code></pre></td></tr></table></figure><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="1-约束"><a href="#1-约束" class="headerlink" title="1.约束"></a>1.约束</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1  概念"></a>1.1  概念</h3><ul><li><p>约束是作用于表中列上的规则，用于限制加入表的数据</p><p>例如：我们可以给id列加约束，让其值不能重复，不能为null值。</p></li><li><p>约束的存在保证了数据库中数据的正确性、有效性和完整性</p><p>添加约束可以在添加数据的时候就限制不正确的数据，年龄是3000，数学成绩是-5分这样无效的数据，继而保障数据的完整性。</p></li></ul><h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2  分类"></a>1.2  分类</h3><ul><li><p><strong>非空约束： 关键字是 NOT NULL</strong></p><p>保证列中所有的数据不能有null值。</p><p>例如：id列在添加 <code>马花疼</code> 这条数据时就不能添加成功。</p></li><li><p><strong>唯一约束：关键字是  UNIQUE</strong></p><p>保证列中所有数据各不相同。</p><p>例如：id列中三条数据的值都是1，这样的数据在添加时是绝对不允许的。</p></li><li><p><strong>主键约束： 关键字是  PRIMARY KEY</strong></p><p>主键是一行数据的唯一标识，要求非空且唯一。一般我们都会给没张表添加一个主键列用来唯一标识数据。</p><p>例如：上图表中id就可以作为主键，来标识每条数据。那么这样就要求数据中id的值不能重复，不能为null值。</p></li><li><p><strong>检查约束： 关键字是  CHECK</strong> </p><p>保证列中的值满足某一条件。</p><p>例如：我们可以给age列添加一个范围，最低年龄可以设置为1，最大年龄就可以设置为300，这样的数据才更合理些。</p><blockquote><p>注意：MySQL不支持检查约束。</p><p>这样是不是就没办法保证年龄在指定的范围内了？从数据库层面不能保证，以后可以在java代码中进行限制，一样也可以实现要求。</p></blockquote></li><li><p><strong>默认约束： 关键字是   DEFAULT</strong></p><p>保存数据时，未指定值则采用默认值。</p><p>例如：我们在给english列添加该约束，指定默认值是0，这样在添加数据时没有指定具体值时就会采用默认给定的0。</p></li><li><p><strong>外键约束： 关键字是  FOREIGN KEY</strong></p><p>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。</p><p>外键约束现在可能还不太好理解，后面我们会重点进行讲解。</p></li></ul><h3 id="1-3-非空约束"><a href="#1-3-非空约束" class="headerlink" title="1.3  非空约束"></a>1.3  非空约束</h3><ul><li><p>概念</p><p>非空约束用于保证列中所有数据不能有NULL值</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表时添加非空约束</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>   列名 数据类型 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   …<br>); <br><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 建完表后添加非空约束</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 字段名 数据类型 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 字段名 数据类型;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-4-唯一约束"><a href="#1-4-唯一约束" class="headerlink" title="1.4  唯一约束"></a>1.4  唯一约束</h3><ul><li><p>概念</p><p>唯一约束用于保证列中所有数据各不相同</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表时添加唯一约束</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>   列名 数据类型 <span class="hljs-keyword">UNIQUE</span> [AUTO_INCREMENT],<br>   <span class="hljs-comment">-- AUTO_INCREMENT: 当不指定值时自动增长</span><br>   …<br>); <br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>   列名 数据类型,<br>   …<br>   [<span class="hljs-keyword">CONSTRAINT</span>] [约束名称] <span class="hljs-keyword">UNIQUE</span>(列名)<br>); <br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 建完表后添加唯一约束</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 字段名 数据类型 <span class="hljs-keyword">UNIQUE</span>;<br></code></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> INDEX 字段名;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-5-主键约束"><a href="#1-5-主键约束" class="headerlink" title="1.5  主键约束"></a>1.5  主键约束</h3><ul><li><p>概念</p><p>主键是一行数据的唯一标识，要求非空且唯一</p><p>一张表只能有一个主键</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表时添加主键约束</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>   列名 数据类型 <span class="hljs-keyword">PRIMARY</span> KEY [AUTO_INCREMENT],<br>   …<br>); <br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>   列名 数据类型,<br>   [<span class="hljs-keyword">CONSTRAINT</span>] [约束名称] <span class="hljs-keyword">PRIMARY</span> KEY(列名)<br>); <br><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 建完表后添加主键约束</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY(字段名);<br></code></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-6-默认约束"><a href="#1-6-默认约束" class="headerlink" title="1.6  默认约束"></a>1.6  默认约束</h3><ul><li><p>概念</p><p>保存数据时，未指定值则采用默认值</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表时添加默认约束</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>   列名 数据类型 <span class="hljs-keyword">DEFAULT</span> 默认值,<br>   …<br>); <br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 建完表后添加默认约束</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ALTER</span> 列名 <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> 默认值;<br></code></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ALTER</span> 列名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DEFAULT</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-7-约束练习"><a href="#1-7-约束练习" class="headerlink" title="1.7  约束练习"></a>1.7  约束练习</h3><p><strong>根据需求，为表添加合适的约束</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 员工表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp (<br>id <span class="hljs-type">INT</span>,  <span class="hljs-comment">-- 员工id，主键且自增长</span><br>    ename <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>), <span class="hljs-comment">-- 员工姓名，非空且唯一</span><br>    joindate <span class="hljs-type">DATE</span>,  <span class="hljs-comment">-- 入职日期，非空</span><br>    salary <span class="hljs-keyword">DOUBLE</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>),  <span class="hljs-comment">-- 工资，非空</span><br>    bonus <span class="hljs-keyword">DOUBLE</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>)  <span class="hljs-comment">-- 奖金，如果没有将近默认为0</span><br>);<br></code></pre></td></tr></table></figure><p>上面一定给出了具体的要求，我们可以根据要求创建这张表，并为每一列添加对应的约束。建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> emp;<br><br><span class="hljs-comment">-- 员工表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp (<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY auto_increment, <span class="hljs-comment">-- 员工id，主键且自增长</span><br>  ename <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span>, <span class="hljs-comment">-- 员工姓名，非空并且唯一</span><br>  joindate <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> , <span class="hljs-comment">-- 入职日期，非空</span><br>  salary <span class="hljs-keyword">DOUBLE</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> , <span class="hljs-comment">-- 工资，非空</span><br>  bonus <span class="hljs-keyword">DOUBLE</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> <span class="hljs-comment">-- 奖金，如果没有奖金默认为0</span><br>);<br></code></pre></td></tr></table></figure><p>==注意：默认约束只有在不给值时才会采用默认值。如果给了null，那值就是null值。==</p><h3 id="1-8-外键约束"><a href="#1-8-外键约束" class="headerlink" title="1.8  外键约束"></a>1.8  外键约束</h3><h4 id="1-8-1-概述"><a href="#1-8-1-概述" class="headerlink" title="1.8.1  概述"></a>1.8.1  概述</h4><p>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。</p><h4 id="1-8-2-语法"><a href="#1-8-2-语法" class="headerlink" title="1.8.2  语法"></a>1.8.2  语法</h4><ul><li>添加外键约束</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表时添加外键约束</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>   列名 数据类型,<br>   …<br>   [<span class="hljs-keyword">CONSTRAINT</span>] [外键名称] <span class="hljs-keyword">FOREIGN</span> KEY(外键列名) <span class="hljs-keyword">REFERENCES</span> 主表(主表列名) <br>); <br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 建完表后添加外键约束</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> 外键名称 <span class="hljs-keyword">FOREIGN</span> KEY (外键字段名称) <span class="hljs-keyword">REFERENCES</span> 主表名称(主表列名称);<br></code></pre></td></tr></table></figure><ul><li>删除外键约束</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FOREIGN</span> KEY 外键名称;<br></code></pre></td></tr></table></figure><h4 id="1-8-3-练习"><a href="#1-8-3-练习" class="headerlink" title="1.8.3  练习"></a>1.8.3  练习</h4><p>根据上述语法创建员工表和部门表，并添加上外键约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> emp;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> dept;<br><br><span class="hljs-comment">-- 部门表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dept(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>dep_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>addr <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)<br>);<br><span class="hljs-comment">-- 员工表 </span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>age <span class="hljs-type">int</span>,<br>dep_id <span class="hljs-type">int</span>,<br><br><span class="hljs-comment">-- 添加外键 dep_id,关联 dept 表的id主键</span><br><span class="hljs-keyword">CONSTRAINT</span> fk_emp_dept <span class="hljs-keyword">FOREIGN</span> KEY(dep_id) <span class="hljs-keyword">REFERENCES</span> dept(id)<br>);<br></code></pre></td></tr></table></figure><p>添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 添加 2 个部门</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept(dep_name,addr) <span class="hljs-keyword">values</span><br>(<span class="hljs-string">&#x27;研发部&#x27;</span>,<span class="hljs-string">&#x27;广州&#x27;</span>),(<span class="hljs-string">&#x27;销售部&#x27;</span>, <span class="hljs-string">&#x27;深圳&#x27;</span>);<br><br><span class="hljs-comment">-- 添加员工,dep_id 表示员工所在的部门</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (NAME, age, dep_id) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;赵六&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">2</span>),<br>(<span class="hljs-string">&#x27;孙七&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-number">2</span>),<br>(<span class="hljs-string">&#x27;周八&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>此时删除 <code>研发部</code> 这条数据，会发现无法删除。</p><p>删除外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">drop</span> <span class="hljs-keyword">FOREIGN</span> key fk_emp_dept;<br></code></pre></td></tr></table></figure><p>重新添加外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">add</span> <span class="hljs-keyword">CONSTRAINT</span> fk_emp_dept <span class="hljs-keyword">FOREIGN</span> key(dep_id) <span class="hljs-keyword">REFERENCES</span> dept(id);<br></code></pre></td></tr></table></figure><h2 id="2-数据库设计"><a href="#2-数据库设计" class="headerlink" title="2.数据库设计"></a>2.数据库设计</h2><h3 id="2-1-数据库设计简介"><a href="#2-1-数据库设计简介" class="headerlink" title="2.1  数据库设计简介"></a>2.1  数据库设计简介</h3><ul><li><p>软件的研发步骤</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622170858978.png" alt="image-20220622170858978"></p></li><li><p>数据库设计概念</p><ul><li>数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS，为这个业务系统构造出最优的数据存储模型。</li><li>建立数据库中的==表结构==以及==表与表之间的关联关系==的过程。</li><li>有哪些表？表里有哪些字段？表和表之间有什么关系？</li></ul></li><li><p>数据库设计的步骤</p><ul><li><p>需求分析（数据是什么? 数据具有哪些属性? 数据与属性的特点是什么）</p></li><li><p>逻辑分析（通过ER图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统）</p><p>如下图就是ER(Entity/Relation)图：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622170936569.png" alt="image-20220622170936569"></p></li><li><p>物理设计（根据数据库自身的特点把逻辑设计转换为物理设计）</p></li><li><p>维护设计（1.对新的需求进行建表；2.表优化）</p></li></ul></li><li><p>表关系</p><ul><li><p>一对一</p><ul><li>如：用户 和 用户详情</li><li>一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能</li></ul></li><li><p>一对多</p><ul><li><p>如：部门 和 员工</p></li><li><p>一个部门对应多个员工，一个员工对应一个部门。</p></li></ul></li><li><p>多对多</p><ul><li><p>如：商品 和 订单</p></li><li><p>一个商品对应多个订单，一个订单包含多个商品。</p></li></ul></li></ul></li></ul><h3 id="2-2-表关系-一对多"><a href="#2-2-表关系-一对多" class="headerlink" title="2.2  表关系(一对多)"></a>2.2  表关系(一对多)</h3><ul><li><p>一对多</p><ul><li>如：部门 和 员工</li><li>一个部门对应多个员工，一个员工对应一个部门。</li></ul></li><li><p>实现方式</p><p>==在多的一方建立外键，指向一的一方的主键==</p></li><li><p>案例</p><p>我们还是以 <code>员工表</code> 和 <code>部门表</code> 举例，经过分析发现，员工表属于多的一方，而部门表属于一的一方，此时我们会在员工表中添加一列（dep_id），指向于部门表的主键（id）：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622171235458.png" alt="image-20220622171235458"></p><p>建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> tb_emp;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> tb_dept;<br><br><span class="hljs-comment">-- 部门表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_dept(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>dep_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>addr <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)<br>);<br><span class="hljs-comment">-- 员工表 </span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_emp(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>age <span class="hljs-type">int</span>,<br>dep_id <span class="hljs-type">int</span>,<br><br><span class="hljs-comment">-- 添加外键 dep_id,关联 dept 表的id主键</span><br>  <span class="hljs-comment">-- 外键的命名原则通常是fk_从表_主表</span><br><span class="hljs-keyword">CONSTRAINT</span> fk_emp_dept <span class="hljs-keyword">FOREIGN</span> KEY(dep_id) <span class="hljs-keyword">REFERENCES</span> tb_dept(id)<br>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-3-表关系-多对多"><a href="#2-3-表关系-多对多" class="headerlink" title="2.3  表关系(多对多)"></a>2.3  表关系(多对多)</h3><ul><li><p>多对多</p><ul><li>如：商品 和 订单</li><li>一个商品对应多个订单，一个订单包含多个商品</li></ul></li><li><p>实现方式</p><p>==建立第三张中间表，中间表至少包含两个外键，分别关联两方主键==</p></li><li><p>案例</p><p>我们以 <code>订单表</code> 和 <code>商品表</code> 举例，经过分析发现，订单表和商品表都属于多的一方，此时需要创建一个中间表，在中间表中添加订单表的外键和商品表的外键指向两张表的主键：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622171523285.png" alt="image-20220622171523285"></p><p>建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> tb_order_goods;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> tb_order;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> tb_goods;<br><br><span class="hljs-comment">-- 订单表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_order(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>payment <span class="hljs-keyword">double</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br>payment_type TINYINT,<br>status TINYINT<br>);<br><br><span class="hljs-comment">-- 商品表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_goods(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>title <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>price <span class="hljs-keyword">double</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>)<br>);<br><br><span class="hljs-comment">-- 订单商品中间表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_order_goods(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>order_id <span class="hljs-type">int</span>,<br>goods_id <span class="hljs-type">int</span>,<br>count <span class="hljs-type">int</span><br>);<br><br><span class="hljs-comment">-- 建完表后，添加外键</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tb_order_goods <span class="hljs-keyword">add</span> <span class="hljs-keyword">CONSTRAINT</span> fk_order_id <span class="hljs-keyword">FOREIGN</span> key(order_id) <span class="hljs-keyword">REFERENCES</span> tb_order(id);<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tb_order_goods <span class="hljs-keyword">add</span> <span class="hljs-keyword">CONSTRAINT</span> fk_goods_id <span class="hljs-keyword">FOREIGN</span> key(goods_id) <span class="hljs-keyword">REFERENCES</span> tb_goods(id);<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-4-表关系-一对一"><a href="#2-4-表关系-一对一" class="headerlink" title="2.4  表关系(一对一)"></a>2.4  表关系(一对一)</h3><ul><li><p>一对一</p><ul><li>如：用户 和 用户详情</li><li>一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能</li></ul></li><li><p>实现方式</p><p>==在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)==</p></li><li><p>案例</p><p>我们以 <code>用户表</code> 举例，</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622171708314.png" alt="image-20220622171708314">在真正使用过程中发现 id、photo、nickname、age、gender 字段比较常用，此时就可以将这张表查分成两张表。<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622171737882.png" alt></p></li></ul><p>​    建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_user_desc (<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>city <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>edu <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>income <span class="hljs-type">int</span>,<br>status <span class="hljs-type">char</span>(<span class="hljs-number">2</span>),<br>des <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>)<br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_user (<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>photo <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>nickname <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>),<br>age <span class="hljs-type">int</span>,<br>gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>),<br>desc_id <span class="hljs-type">int</span> <span class="hljs-keyword">unique</span>,<br><span class="hljs-comment">-- 添加外键</span><br><span class="hljs-keyword">CONSTRAINT</span> fk_user_desc <span class="hljs-keyword">FOREIGN</span> KEY(desc_id) <span class="hljs-keyword">REFERENCES</span> tb_user_desc(id)<br>);<br></code></pre></td></tr></table></figure><h2 id="3-多表查询"><a href="#3-多表查询" class="headerlink" title="3.多表查询"></a>3.多表查询</h2><p>多表查询顾名思义就是从多张表中一次性的查询出我们想要的数据。我们通过具体的sql演示，先准备环境</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> emp;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> dept;<br><br><br># 创建部门表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dept(<br>        did <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>        dname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>    );<br><br># 创建员工表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp (<br>        id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>        NAME <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>),<br>        gender <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>), <span class="hljs-comment">-- 性别</span><br>        salary <span class="hljs-keyword">DOUBLE</span>, <span class="hljs-comment">-- 工资</span><br>        join_date <span class="hljs-type">DATE</span>, <span class="hljs-comment">-- 入职日期</span><br>        dep_id <span class="hljs-type">INT</span>,<br>        <span class="hljs-keyword">FOREIGN</span> KEY (dep_id) <span class="hljs-keyword">REFERENCES</span> dept(did) <span class="hljs-comment">-- 外键，关联部门表(部门表的主键)</span><br>    );<br><span class="hljs-comment">-- 添加部门数据</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dept (dNAME) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;研发部&#x27;</span>),(<span class="hljs-string">&#x27;市场部&#x27;</span>),(<span class="hljs-string">&#x27;财务部&#x27;</span>),(<span class="hljs-string">&#x27;销售部&#x27;</span>);<br><span class="hljs-comment">-- 添加员工数据</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp(NAME,gender,salary,join_date,dep_id) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-string">&#x27;孙悟空&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">7200</span>,<span class="hljs-string">&#x27;2013-02-24&#x27;</span>,<span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;猪八戒&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">3600</span>,<span class="hljs-string">&#x27;2010-12-02&#x27;</span>,<span class="hljs-number">2</span>),<br>(<span class="hljs-string">&#x27;唐僧&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">9000</span>,<span class="hljs-string">&#x27;2008-08-08&#x27;</span>,<span class="hljs-number">2</span>),<br>(<span class="hljs-string">&#x27;白骨精&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-number">5000</span>,<span class="hljs-string">&#x27;2015-10-07&#x27;</span>,<span class="hljs-number">3</span>),<br>(<span class="hljs-string">&#x27;蜘蛛精&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-number">4500</span>,<span class="hljs-string">&#x27;2011-03-14&#x27;</span>,<span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;小白龙&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">2500</span>,<span class="hljs-string">&#x27;2011-02-14&#x27;</span>,<span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><p>执行下面的多表查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp , dept;  <span class="hljs-comment">-- 从emp和dept表中查询所有的字段数据</span><br></code></pre></td></tr></table></figure><p>结果如下：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622172039381.png" alt="image-20220622172039381"></p><p>这样直接拼接得到的结果就是两个表进行交叉相乘，得到一堆无用数据。所以我们要通过限制员工表中的 <code>dep_id</code> 字段的值和部门表 <code>did</code> 字段的值相等来消除这些无效的数据，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp , dept <span class="hljs-keyword">where</span> emp.dep_id <span class="hljs-operator">=</span> dept.did;<br></code></pre></td></tr></table></figure><p>执行后结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622172251630.png" alt="image-20220622172251630"></p><p>上面语句就是连接查询，那么多表查询都有哪些呢？</p><ul><li><p>连接查询</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622172311348.png" alt="image-20220622172311348"></p><ul><li>内连接查询 ：相当于查询AB交集数据</li><li>外连接查询<ul><li>左外连接查询 ：相当于查询A表所有数据和交集部门数据</li><li>右外连接查询 ： 相当于查询B表所有数据和交集部分数据</li></ul></li></ul></li><li><p>子查询</p></li></ul><h3 id="3-1-内连接查询"><a href="#3-1-内连接查询" class="headerlink" title="3.1  内连接查询"></a>3.1  内连接查询</h3><ul><li>语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 隐式内连接</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>,表<span class="hljs-number">2</span>… <span class="hljs-keyword">WHERE</span> 条件;<br><br><span class="hljs-comment">-- 显示内连接</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [<span class="hljs-keyword">INNER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件;<br></code></pre></td></tr></table></figure><blockquote><p>内连接相当于查询 A B 交集数据</p></blockquote><ul><li><p>案例</p><ul><li><p>隐式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span><br>emp,<br>dept<br><span class="hljs-keyword">WHERE</span><br>emp.dep_id <span class="hljs-operator">=</span> dept.did;<br></code></pre></td></tr></table></figure></li><li><p>查询 emp的 name， gender，dept表的dname</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>emp. NAME,<br>emp.gender,<br>dept.dname<br><span class="hljs-keyword">FROM</span><br>emp,<br>dept<br><span class="hljs-keyword">WHERE</span><br>emp.dep_id <span class="hljs-operator">=</span> dept.did;<br></code></pre></td></tr></table></figure><p>上面语句中使用表名指定字段所属有点麻烦，sql也支持给表在from里指别名，上述语句可以改进为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>t1. NAME,<br>t1.gender,<br>t2.dname<br><span class="hljs-keyword">FROM</span><br>emp t1,<br>dept t2<br><span class="hljs-keyword">WHERE</span><br>t1.dep_id <span class="hljs-operator">=</span> t2.did;<br></code></pre></td></tr></table></figure></li><li><p>显式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">on</span> emp.dep_id <span class="hljs-operator">=</span> dept.did;<br><span class="hljs-comment">-- 上面语句中的inner可以省略，可以书写为如下语句</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp  <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">on</span> emp.dep_id <span class="hljs-operator">=</span> dept.did;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-2-外连接查询"><a href="#3-2-外连接查询" class="headerlink" title="3.2  外连接查询"></a>3.2  外连接查询</h3><ul><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 左外连接</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件;<br><br><span class="hljs-comment">-- 右外连接</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件;<br></code></pre></td></tr></table></figure><blockquote><p>左外连接：相当于查询A表所有数据和交集部分数据</p><p>右外连接：相当于查询B表所有数据和交集部分数据</p></blockquote></li><li><p>案例</p><ul><li><p>查询emp表所有数据和对应的部门信息（左外连接）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">on</span> emp.dep_id <span class="hljs-operator">=</span> dept.did;<br></code></pre></td></tr></table></figure><p>结果显示查询到了左表（emp）中所有的数据及两张表能关联的数据。</p></li><li><p>查询dept表所有数据和对应的员工信息（右外连接）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">on</span> emp.dep_id <span class="hljs-operator">=</span> dept.did;<br></code></pre></td></tr></table></figure><p>结果显示查询到了右表（dept）中所有的数据及两张表能关联的数据。</p></li></ul></li></ul><h3 id="3-3-子查询"><a href="#3-3-子查询" class="headerlink" title="3.3  子查询"></a>3.3  子查询</h3><ul><li><p>概念</p><p>==查询中嵌套查询，称嵌套查询为子查询。==</p><p>什么是查询中嵌套查询呢？我们通过一个例子来看：</p><p><strong>需求：查询工资高于猪八戒的员工信息。</strong></p><p>来实现这个需求，我们就可以通过二步实现，第一步：先查询出来 猪八戒的工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;猪八戒&#x27;</span><br></code></pre></td></tr></table></figure><p> 第二步：查询工资高于猪八戒的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-number">3600</span>;<br></code></pre></td></tr></table></figure><p>第二步中的3600可以通过第一步的sql查询出来，所以将3600用第一步的sql语句进行替换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;猪八戒&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这就是查询语句中嵌套查询语句。</p></li><li><p>子查询根据查询结果不同，作用不同</p><ul><li>子查询语句结果是单行单列，子查询语句作为条件值，使用 =  !=  &gt;  &lt;  等进行条件判断</li><li>子查询语句结果是<strong><u>多行单列</u></strong>，子查询语句作为条件值，使用 in 等关键字进行条件判断</li><li>子查询语句结果是多行多列，子查询语句作为虚拟表</li><li>即单条结果用=，多条结果用in</li></ul></li><li><p>案例</p><ul><li><p>查询 ‘财务部’ 和 ‘市场部’ 所有的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询 &#x27;财务部&#x27; 或者 &#x27;市场部&#x27; 所有的员工的部门did</span><br><span class="hljs-keyword">select</span> did <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> dname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;财务部&#x27;</span> <span class="hljs-keyword">or</span> dname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;市场部&#x27;</span>;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dep_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> did <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> dname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;财务部&#x27;</span> <span class="hljs-keyword">or</span> dname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;市场部&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>查询入职日期是 ‘2011-11-11’ 之后的员工信息和部门信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询入职日期是 &#x27;2011-11-11&#x27; 之后的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> join_date <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2011-11-11&#x27;</span> ;<br><span class="hljs-comment">-- 将上面语句的结果作为虚拟表和dept表进行内连接查询</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> join_date <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2011-11-11&#x27;</span> ) t1, dept <span class="hljs-keyword">where</span> t1.dep_id <span class="hljs-operator">=</span> dept.did;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-4-案例"><a href="#3-4-案例" class="headerlink" title="3.4  案例"></a>3.4  案例</h3><ul><li>环境准备：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> emp;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> dept;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> job;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> salarygrade;<br><br><span class="hljs-comment">-- 部门表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dept (<br>  did <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY <span class="hljs-keyword">PRIMARY</span> KEY, <span class="hljs-comment">-- 部门id</span><br>  dname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>), <span class="hljs-comment">-- 部门名称</span><br>  loc <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-comment">-- 部门所在地</span><br>);<br><br><span class="hljs-comment">-- 职务表，职务名称，职务描述</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> job (<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>  jname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>  description <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)<br>);<br><br><span class="hljs-comment">-- 员工表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp (<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY, <span class="hljs-comment">-- 员工id</span><br>  ename <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>), <span class="hljs-comment">-- 员工姓名</span><br>  job_id <span class="hljs-type">INT</span>, <span class="hljs-comment">-- 职务id</span><br>  mgr <span class="hljs-type">INT</span> , <span class="hljs-comment">-- 上级领导</span><br>  joindate <span class="hljs-type">DATE</span>, <span class="hljs-comment">-- 入职日期</span><br>  salary <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>), <span class="hljs-comment">-- 工资</span><br>  bonus <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>), <span class="hljs-comment">-- 奖金</span><br>  dept_id <span class="hljs-type">INT</span>, <span class="hljs-comment">-- 所在部门编号</span><br>  <span class="hljs-keyword">CONSTRAINT</span> emp_jobid_ref_job_id_fk <span class="hljs-keyword">FOREIGN</span> KEY (job_id) <span class="hljs-keyword">REFERENCES</span> job (id),<br>  <span class="hljs-keyword">CONSTRAINT</span> emp_deptid_ref_dept_id_fk <span class="hljs-keyword">FOREIGN</span> KEY (dept_id) <span class="hljs-keyword">REFERENCES</span> dept (id)<br>);<br><span class="hljs-comment">-- 工资等级表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> salarygrade (<br>  grade <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,   <span class="hljs-comment">-- 级别</span><br>  losalary <span class="hljs-type">INT</span>,  <span class="hljs-comment">-- 最低工资</span><br>  hisalary <span class="hljs-type">INT</span> <span class="hljs-comment">-- 最高工资</span><br>);<br><br><span class="hljs-comment">-- 添加4个部门</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dept(did,dname,loc) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;教研部&#x27;</span>,<span class="hljs-string">&#x27;北京&#x27;</span>),<br>(<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;学工部&#x27;</span>,<span class="hljs-string">&#x27;上海&#x27;</span>),<br>(<span class="hljs-number">30</span>,<span class="hljs-string">&#x27;销售部&#x27;</span>,<span class="hljs-string">&#x27;广州&#x27;</span>),<br>(<span class="hljs-number">40</span>,<span class="hljs-string">&#x27;财务部&#x27;</span>,<span class="hljs-string">&#x27;深圳&#x27;</span>);<br><br><span class="hljs-comment">-- 添加4个职务</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> job (id, jname, description) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;董事长&#x27;</span>, <span class="hljs-string">&#x27;管理整个公司，接单&#x27;</span>),<br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;经理&#x27;</span>, <span class="hljs-string">&#x27;管理部门员工&#x27;</span>),<br>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;销售员&#x27;</span>, <span class="hljs-string">&#x27;向客人推销产品&#x27;</span>),<br>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;文员&#x27;</span>, <span class="hljs-string">&#x27;使用办公软件&#x27;</span>);<br><br><br><span class="hljs-comment">-- 添加员工</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1001</span>,<span class="hljs-string">&#x27;孙悟空&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1004</span>,<span class="hljs-string">&#x27;2000-12-17&#x27;</span>,<span class="hljs-string">&#x27;8000.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">20</span>),<br>(<span class="hljs-number">1002</span>,<span class="hljs-string">&#x27;卢俊义&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1006</span>,<span class="hljs-string">&#x27;2001-02-20&#x27;</span>,<span class="hljs-string">&#x27;16000.00&#x27;</span>,<span class="hljs-string">&#x27;3000.00&#x27;</span>,<span class="hljs-number">30</span>),<br>(<span class="hljs-number">1003</span>,<span class="hljs-string">&#x27;林冲&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1006</span>,<span class="hljs-string">&#x27;2001-02-22&#x27;</span>,<span class="hljs-string">&#x27;12500.00&#x27;</span>,<span class="hljs-string">&#x27;5000.00&#x27;</span>,<span class="hljs-number">30</span>),<br>(<span class="hljs-number">1004</span>,<span class="hljs-string">&#x27;唐僧&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1009</span>,<span class="hljs-string">&#x27;2001-04-02&#x27;</span>,<span class="hljs-string">&#x27;29750.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">20</span>),<br>(<span class="hljs-number">1005</span>,<span class="hljs-string">&#x27;李逵&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1006</span>,<span class="hljs-string">&#x27;2001-09-28&#x27;</span>,<span class="hljs-string">&#x27;12500.00&#x27;</span>,<span class="hljs-string">&#x27;14000.00&#x27;</span>,<span class="hljs-number">30</span>),<br>(<span class="hljs-number">1006</span>,<span class="hljs-string">&#x27;宋江&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1009</span>,<span class="hljs-string">&#x27;2001-05-01&#x27;</span>,<span class="hljs-string">&#x27;28500.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">30</span>),<br>(<span class="hljs-number">1007</span>,<span class="hljs-string">&#x27;刘备&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1009</span>,<span class="hljs-string">&#x27;2001-09-01&#x27;</span>,<span class="hljs-string">&#x27;24500.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">10</span>),<br>(<span class="hljs-number">1008</span>,<span class="hljs-string">&#x27;猪八戒&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1004</span>,<span class="hljs-string">&#x27;2007-04-19&#x27;</span>,<span class="hljs-string">&#x27;30000.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">20</span>),<br>(<span class="hljs-number">1009</span>,<span class="hljs-string">&#x27;罗贯中&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;2001-11-17&#x27;</span>,<span class="hljs-string">&#x27;50000.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">10</span>),<br>(<span class="hljs-number">1010</span>,<span class="hljs-string">&#x27;吴用&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1006</span>,<span class="hljs-string">&#x27;2001-09-08&#x27;</span>,<span class="hljs-string">&#x27;15000.00&#x27;</span>,<span class="hljs-string">&#x27;0.00&#x27;</span>,<span class="hljs-number">30</span>),<br>(<span class="hljs-number">1011</span>,<span class="hljs-string">&#x27;沙僧&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1004</span>,<span class="hljs-string">&#x27;2007-05-23&#x27;</span>,<span class="hljs-string">&#x27;11000.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">20</span>),<br>(<span class="hljs-number">1012</span>,<span class="hljs-string">&#x27;李逵&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1006</span>,<span class="hljs-string">&#x27;2001-12-03&#x27;</span>,<span class="hljs-string">&#x27;9500.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">30</span>),<br>(<span class="hljs-number">1013</span>,<span class="hljs-string">&#x27;小白龙&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1004</span>,<span class="hljs-string">&#x27;2001-12-03&#x27;</span>,<span class="hljs-string">&#x27;30000.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">20</span>),<br>(<span class="hljs-number">1014</span>,<span class="hljs-string">&#x27;关羽&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1007</span>,<span class="hljs-string">&#x27;2002-01-23&#x27;</span>,<span class="hljs-string">&#x27;13000.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">10</span>);<br><br><br><span class="hljs-comment">-- 添加5个工资等级</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> salarygrade(grade,losalary,hisalary) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>,<span class="hljs-number">7000</span>,<span class="hljs-number">12000</span>),<br>(<span class="hljs-number">2</span>,<span class="hljs-number">12010</span>,<span class="hljs-number">14000</span>),<br>(<span class="hljs-number">3</span>,<span class="hljs-number">14010</span>,<span class="hljs-number">20000</span>),<br>(<span class="hljs-number">4</span>,<span class="hljs-number">20010</span>,<span class="hljs-number">30000</span>),<br>(<span class="hljs-number">5</span>,<span class="hljs-number">30010</span>,<span class="hljs-number">99990</span>);<br></code></pre></td></tr></table></figure><ul><li><p>需求</p><ol><li><p>查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">分析：</span><br><span class="hljs-comment">1. 员工编号，员工姓名，工资 信息在emp 员工表中</span><br><span class="hljs-comment">2. 职务名称，职务描述 信息在 job 职务表中</span><br><span class="hljs-comment">3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">-- 方式一 ：隐式内连接</span><br><span class="hljs-keyword">SELECT</span><br>emp.id,<br>emp.ename,<br>emp.salary,<br>job.jname,<br>job.description<br><span class="hljs-keyword">FROM</span><br>emp,<br>job<br><span class="hljs-keyword">WHERE</span><br>emp.job_id <span class="hljs-operator">=</span> job.id;<br><br><span class="hljs-comment">-- 方式二 ：显式内连接</span><br><span class="hljs-keyword">SELECT</span><br>emp.id,<br>emp.ename,<br>emp.salary,<br>job.jname,<br>job.description<br><span class="hljs-keyword">FROM</span><br>emp<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> job <span class="hljs-keyword">ON</span> emp.job_id <span class="hljs-operator">=</span> job.id;<br></code></pre></td></tr></table></figure></li><li><p>查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">分析：</span><br><span class="hljs-comment">1. 员工编号，员工姓名，工资 信息在emp 员工表中</span><br><span class="hljs-comment">2. 职务名称，职务描述 信息在 job 职务表中</span><br><span class="hljs-comment">3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4. 部门名称，部门位置 来自于 部门表 dept</span><br><span class="hljs-comment">5. dept 和 emp 一对多关系 dept.id = emp.dept_id</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">-- 方式一 ：隐式内连接</span><br><span class="hljs-keyword">SELECT</span><br>emp.id,<br>emp.ename,<br>emp.salary,<br>job.jname,<br>job.description,<br>dept.dname,<br>dept.loc<br><span class="hljs-keyword">FROM</span><br>emp,<br>job,<br>dept<br><span class="hljs-keyword">WHERE</span><br>emp.job_id <span class="hljs-operator">=</span> job.id<br><span class="hljs-keyword">and</span> dept.id <span class="hljs-operator">=</span> emp.dept_id<br>;<br><br><span class="hljs-comment">-- 方式二 ：显式内连接</span><br><span class="hljs-keyword">SELECT</span><br>emp.id,<br>emp.ename,<br>emp.salary,<br>job.jname,<br>job.description,<br>dept.dname,<br>dept.loc<br><span class="hljs-keyword">FROM</span><br>emp<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> job <span class="hljs-keyword">ON</span> emp.job_id <span class="hljs-operator">=</span> job.id<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> dept <span class="hljs-keyword">ON</span> dept.id <span class="hljs-operator">=</span> emp.dept_id<br></code></pre></td></tr></table></figure></li><li><p>查询员工姓名，工资，工资等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">分析：</span><br><span class="hljs-comment">1. 员工姓名，工资 信息在emp 员工表中</span><br><span class="hljs-comment">2. 工资等级 信息在 salarygrade 工资等级表中</span><br><span class="hljs-comment">3. emp.salary &gt;= salarygrade.losalary  and emp.salary &lt;= salarygrade.hisalary</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span><br>emp.ename,<br>emp.salary,<br>t2.<span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span><br>emp,<br>salarygrade t2<br><span class="hljs-keyword">WHERE</span><br>emp.salary <span class="hljs-operator">&gt;=</span> t2.losalary<br><span class="hljs-keyword">AND</span> emp.salary <span class="hljs-operator">&lt;=</span> t2.hisalary<br></code></pre></td></tr></table></figure></li><li><p>查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">分析：</span><br><span class="hljs-comment">1. 员工编号，员工姓名，工资 信息在emp 员工表中</span><br><span class="hljs-comment">2. 职务名称，职务描述 信息在 job 职务表中</span><br><span class="hljs-comment">3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4. 部门名称，部门位置 来自于 部门表 dept</span><br><span class="hljs-comment">5. dept 和 emp 一对多关系 dept.id = emp.dept_id</span><br><span class="hljs-comment">6. 工资等级 信息在 salarygrade 工资等级表中</span><br><span class="hljs-comment">7. emp.salary &gt;= salarygrade.losalary  and emp.salary &lt;= salarygrade.hisalary</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span><br>emp.id,<br>emp.ename,<br>emp.salary,<br>job.jname,<br>job.description,<br>dept.dname,<br>dept.loc,<br>t2.grade<br><span class="hljs-keyword">FROM</span><br>emp<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> job <span class="hljs-keyword">ON</span> emp.job_id <span class="hljs-operator">=</span> job.id<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> dept <span class="hljs-keyword">ON</span> dept.id <span class="hljs-operator">=</span> emp.dept_id<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> salarygrade t2 <span class="hljs-keyword">ON</span> emp.salary <span class="hljs-keyword">BETWEEN</span> t2.losalary <span class="hljs-keyword">and</span> t2.hisalary;<br></code></pre></td></tr></table></figure></li><li><p>查询出部门编号、部门名称、部门位置、部门人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">分析：</span><br><span class="hljs-comment">1. 部门编号、部门名称、部门位置 来自于部门 dept 表</span><br><span class="hljs-comment">2. 部门人数: 在emp表中 按照dept_id 进行分组，然后count(*)统计数量</span><br><span class="hljs-comment">3. 使用子查询，让部门表和分组后的表进行内连接</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">-- 根据部门id分组查询每一个部门id和员工数</span><br><span class="hljs-keyword">select</span> dept_id, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id;<br><br><span class="hljs-keyword">SELECT</span><br>dept.id,<br>dept.dname,<br>dept.loc,<br>t1.count<br><span class="hljs-keyword">FROM</span><br>dept,<br>(<br><span class="hljs-keyword">SELECT</span><br>dept_id,<br><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) count<br><span class="hljs-keyword">FROM</span><br>emp<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>dept_id<br>) t1<br><span class="hljs-keyword">WHERE</span><br>dept.id <span class="hljs-operator">=</span> t1.dept_id<br></code></pre></td></tr></table></figure></li></ol></li></ul><h2 id="4-事务"><a href="#4-事务" class="headerlink" title="4.事务"></a>4.事务</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1  概述"></a>4.1  概述</h3><blockquote><p>数据库的事务（Transaction）是一种机制、一个操作序列，包含了==一组数据库操作命令==。</p><p>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令==要么同时成功，要么同时失败==。</p><p>事务是一个不可分割的工作逻辑单元。</p></blockquote><p>这些概念不好理解，接下来举例说明，如下图有一张表</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622173237289.png" alt="image-20220622173237289"></p><p>张三和李四账户中各有100块钱，现李四需要转换500块钱给张三，具体的转账操作为</p><ul><li>第一步：查询李四账户余额</li><li>第二步：从李四账户金额 -500</li><li>第三步：给张三账户金额 +500</li></ul><p>现在假设在转账过程中第二步完成后出现了异常第三步没有执行，就会造成李四账户金额少了500，而张三金额并没有多500；这样的系统是有问题的。如果解决呢？使用事务可以解决上述问题</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622173306403.png" alt="image-20220622173306403"></p><p>从上图可以看到在转账前开启事务，如果出现了异常回滚事务，三步正常执行就提交事务，这样就可以完美解决问题。</p><h3 id="4-2-语法"><a href="#4-2-语法" class="headerlink" title="4.2  语法"></a>4.2  语法</h3><ul><li><p>开启事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br>或者  <br><span class="hljs-keyword">BEGIN</span>;<br></code></pre></td></tr></table></figure></li><li><p>提交事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure></li><li><p>回滚事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">rollback</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-3-代码验证"><a href="#4-3-代码验证" class="headerlink" title="4.3  代码验证"></a>4.3  代码验证</h3><ul><li><p>环境准备</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> account;<br><br><span class="hljs-comment">-- 创建账户表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> account(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">PRIMARY</span> KEY auto_increment,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>money <span class="hljs-keyword">double</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>)<br>);<br><br><span class="hljs-comment">-- 添加数据</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> account(name,money) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">1000</span>),(<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>不加事务演示问题</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 转账操作</span><br><span class="hljs-comment">-- 1. 查询李四账户金额是否大于500</span><br><br><span class="hljs-comment">-- 2. 李四账户 -500</span><br><span class="hljs-keyword">UPDATE</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">500</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李四&#x27;</span>;<br><br>出现异常了...  <span class="hljs-comment">-- 此处不是注释，在整体执行时会出问题，后面的sql则不执行</span><br><span class="hljs-comment">-- 3. 张三账户 +500</span><br><span class="hljs-keyword">UPDATE</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">500</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br></code></pre></td></tr></table></figure><p>整体执行结果肯定会出问题，我们查询账户表中数据，发现李四账户少了500。</p></li><li><p>添加事务sql如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 开启事务</span><br><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-comment">-- 转账操作</span><br><span class="hljs-comment">-- 1. 查询李四账户金额是否大于500</span><br><br><span class="hljs-comment">-- 2. 李四账户 -500</span><br><span class="hljs-keyword">UPDATE</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">500</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李四&#x27;</span>;<br><br>出现异常了...  <span class="hljs-comment">-- 此处不是注释，在整体执行时会出问题，后面的sql则不执行</span><br><span class="hljs-comment">-- 3. 张三账户 +500</span><br><span class="hljs-keyword">UPDATE</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">500</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><br><span class="hljs-comment">-- 提交事务</span><br><span class="hljs-keyword">COMMIT</span>;<br><br><span class="hljs-comment">-- 回滚事务</span><br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>上面sql中的执行成功进选择执行提交事务，而出现问题则执行回滚事务的语句。以后我们肯定不可能这样操作，而是在java中进行操作，在java中可以抓取异常，没出现异常提交事务，出现异常回滚事务。</p></li></ul><h3 id="4-4-事务的四大特征"><a href="#4-4-事务的四大特征" class="headerlink" title="4.4  事务的四大特征"></a>4.4  事务的四大特征</h3><ul><li><p>原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败</p></li><li><p>一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态</p></li><li><p>隔离性（Isolation） :多个事务之间，操作的可见性</p></li><li><p>持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</p></li></ul><blockquote><p>==说明：==</p><p>mysql中事务是自动提交的。</p><p>也就是说我们不添加事务执行sql语句，语句执行完毕会自动的提交事务。</p><p>可以通过下面语句查询默认提交方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT @<span class="hljs-meta">@autocommit</span>;<br></code></pre></td></tr></table></figure><p>查询到的结果是1 则表示自动提交，结果是0表示手动提交。当然也可以通过下面语句修改提交方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> @<span class="hljs-variable">@autocommit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb&amp;Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac环境配置java工具</title>
    <link href="/2022/06/21/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/06/21/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="一、破解intellij-idea"><a href="#一、破解intellij-idea" class="headerlink" title="一、破解intellij idea"></a>一、破解intellij idea</h1><p>IntelliJ IDEA2022.1安装完成后，下面是激活，建议先不要启动IDEA。</p><p>下载激活工具。</p><p>执行 scripts 下的脚本文件，根据自己的电脑系统选择，执行Windows脚本，双击执行当前用户<strong><em>install-current-user.vbs\</em></strong>脚本。Linux和Mac系统用户终端下切换到scripts目录下，执行“<strong><em>bash install.sh\</em></strong>”脚本，看到提示“Success”，表示激活完成。</p><p>启动IntelliJ IDEA2022.1，可以添加激活码，或者添加代理服务器License server地址，如下图：</p><blockquote><p>1、选择License Server，添加代理服务器地址，更多License server地址：<a href="https://link.zhihu.com/?target=http%3A//blog.idejihuo.com/wp-content/uploads/2022/04/jetbrains-license-servers.txt">jetbrains-license-servers</a></p><p>2、选择Activation Code，添加激活码，激活码在线下载：<a href="https://link.zhihu.com/?target=http%3A//www.idejihuo.com/">http://www.idejihuo.com</a></p><p>3、<a href="https://account.jetbrains.com/licenses/assets">教育网优惠</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-a497c25775193d1dcd95506208e8b1f0_r.jpg" alt="preview"></p><p>点击Test Connection测试没有问题的话，点击Acticate激活</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-52b340986d31cca6beb38ba461c72623_r.jpg" alt="preview"></p><blockquote><p>或者直接添加激活码，试过发现格式不对</p><p>温馨提示：本次激活之后，大家可能比较疑惑，IDE使用时间和授权信息没有更改。其实已经是永久激活状态了！只是显示信息没有更改。</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/498068584">参考链接</a></p><h1 id="二、Mac环境配置maven"><a href="#二、Mac环境配置maven" class="headerlink" title="二、Mac环境配置maven"></a>二、Mac环境配置maven</h1><p>Maven 安装及配置大体可以划分为三个步骤：下载、安装和配置。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>打开 Maven 官方下载页面：<a href="https://maven.apache.org/download.cgi#，点击下载链接即可开始下载：">https://maven.apache.org/download.cgi#，点击下载链接即可开始下载：</a></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621150523428.png" alt="image-20220621150523428"></p><p>以 Maven 3.8.6 为例，解压后可以看到文件夹：apache-maven-3.8.6。 进行下一步之前，需要按照官方说明确认 JDK 已安装完成：</p><p>打开命令行终端，输入命令：java -version。</p><p>解压后，目录结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621153003804.png" alt="image-20220621153003804"></p><ul><li>bin目录 ： 存放的是可执行命令，重点关注mvn 命令。 </li><li>conf目录 ：存放Maven的配置文件。</li><li>lib目录 ：存放Maven依赖的jar包。Maven也是使用java开发的，所以它也依赖其他的jar包。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>将文件夹 apache-maven-3.8.6 拷贝或移动至系统目录 /usr/local（也可以根据个人喜好选择其它目录），Maven 安装完成。</p><p><strong>注</strong>：涉及<strong>系统目录或系统文件</strong>的操作，需要 sudo 权限。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Maven 配置文件：/usr/local/apache-maven-3.8.6/conf/settings.xml。</p><h3 id="本地仓库目录"><a href="#本地仓库目录" class="headerlink" title="本地仓库目录"></a>本地仓库目录</h3><p>Maven 本地仓库用于缓存已下载（远程）的 Jar 及相关文件，默认目录为用户主目录（~/.m2/repository），可以配置为其它目录：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">vim settings.xml<br><br>&lt;localRepository&gt;/Users/yurun/workspace/maven&lt;/localRepository&gt;<br></code></pre></td></tr></table></figure><p><strong>Mac下打开/usr/local目录方法：</strong></p><p>Mac下/usr/local目录默认是对于Finder是隐藏，如果需要到/usr/local下去，打开Finder，然后使用command+shift+G，在弹出的目录中填写/usr/local就可以了。</p><h3 id="阿里云仓库镜像"><a href="#阿里云仓库镜像" class="headerlink" title="阿里云仓库镜像"></a>阿里云仓库镜像</h3><p>添加阿里云仓库镜像，加速文件下载（远程）速度。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">vim settings.xml<br><br>&lt;mirror&gt;<br>  &lt;id&gt;aliyunmaven&lt;/id&gt;<br>  &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;<br>  &lt;name&gt;aliyun&lt;/name&gt;<br>  &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;<br>&lt;/mirror&gt;<br></code></pre></td></tr></table></figure><h3 id="系统环境变量"><a href="#系统环境变量" class="headerlink" title="系统环境变量"></a>系统环境变量</h3><p>将 mvn 添加到系统环境变量里：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">vim ~/.bash_profile <br><br>export M2_HOME=/usr/local/apache-maven-3.8.4 <br>export PATH=$PATH:$M2_HOME/bin<br></code></pre></td></tr></table></figure><p><strong>注</strong>：Mac 系统环境变量配置文件支持多个，这里仅以 ~/.bash_profile 为例。 添加完成之后，可以手动执行命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">source ~/.bash_profile<br></code></pre></td></tr></table></figure><p>强制系统环境变量生效；或者也可以关闭/重新打开命令行终端，系统环境变量会自动生效。再次输入命令：mvn -version</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621160120189.png" alt="image-20220621160120189"></p><p><strong>Zsh 添加环境变量</strong></p><p>给 Linux/Unix 系统增加环境变量，是使用 <code>export</code> 命令。</p><p>为了永久性生效，则需要考虑加入到登录的 <code>profile</code>中。</p><p>这个时候要考虑你当前使用的 <code>shell</code>,比如默认的 <code>bash shell</code>，则可编辑用户根目录下的隐藏文件 <code>./bash_profile</code></p><p>对于<code>zsh</code> 而言，需要编辑 <code>.zshrc</code> 这个文件 <code>vi ~/.zshrc</code></p><p>在最后面加上一句</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">export PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/python-2.7.6/</span>bin:<span class="hljs-variable">$PATH</span> <br></code></pre></td></tr></table></figure><p>解释：环境变量中，各个值是以冒号分隔开的。上面的语句表示给 <code>PATH</code> 这个变量重新赋值，让它等于</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">usr</span>/local/python-<span class="hljs-number">2</span>.<span class="hljs-number">7</span>.<span class="hljs-number">6</span>/bin  <br></code></pre></td></tr></table></figure><p>同时后面加上原来的 <code>$PATH</code>。</p><h2 id="IDEA使用Maven"><a href="#IDEA使用Maven" class="headerlink" title="IDEA使用Maven"></a>IDEA使用Maven</h2><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621165347529.png" alt="image-20220621165347529"></p><p><strong>Maven 坐标主要组成</strong></p><ul><li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima） </li><li>artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service） </li><li>version：定义当前项目版本号</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621165541511.png" alt="image-20220621165541511"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621165558114.png" alt="image-20220621165558114"></p><p><strong>使用坐标引入jar包的步骤：</strong></p><ul><li>在项目的 pom.xml 中编写标签</li><li>在标签中使用引入坐标</li><li>定义坐标的 groupId，artifactId，version</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621165752347.png" alt="image-20220621165752347"></p><ul><li><p>点击刷新按钮，使坐标生效，或者在设置Maven里选择任何改动生效</p><blockquote><p>注意：</p><p>具体的坐标我们可以到如下网站进行搜索 <a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p></blockquote></li></ul><p><strong>快捷方式导入jar包的坐标：</strong></p><p>每次需要引入jar包，都去对应的网站进行搜索是比较麻烦的，接下来给大家介绍一种快捷引入坐标的方式 </p><ul><li>在 pom.xml 中 按 alt + insert(Mac:command+N)，选择 Dependency</li><li>在弹出的面板中搜索对应坐标，然后双击选中对应坐标</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621170825271.png" alt="image-20220621170825271"></p><h1 id="三、Mac环境配置Mybatis"><a href="#三、Mac环境配置Mybatis" class="headerlink" title="三、Mac环境配置Mybatis"></a>三、Mac环境配置Mybatis</h1><p>MyBatis 是一款优秀的持久层框架，用于简化 JDBC 开发。</p><ul><li><p>硬编码 </p><ul><li><p>注册驱动、获取连接 </p></li><li><p>SQL语句 </p></li></ul></li></ul><p>这部分代码操作繁琐，而且没什么技术含量，于是采用Mybatis对其进行封装</p><p>优化内容：</p><ul><li>硬编码可以配置到配置文件 </li><li>操作繁琐的地方mybatis都自动完成</li></ul><p><a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=692132">Mac破解安装navicat</a></p><p>navicat：command+R 运行全部</p><p><a href="https://blog.csdn.net/qq_30101647/article/details/121339098?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165581554816780357280161%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165581554816780357280161&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-121339098-null-null.142^v20^control,157^v15^new_3&amp;utm_term=mac%E5%AE%89%E8%A3%85mysql&amp;spm=1018.2226.3001.4187">Mac安装Mysql服务</a></p><p>Intellij：option+Enter 解决异常，control+R运行</p><p>IDEA中配置MySQL数据库连接：</p><ul><li>点击右边框的数据库，在数据源里选择MySQL</li><li>在弹出的界面进行基本信息的填写</li><li>点击完成后进入数据库页面，就能和navicat工具一样进行数据库的操作，编写SQL语句。</li></ul><p>使用 Mapper 代理方式替代selectList()方法传参解决硬编码问题。</p><p>官网上有，照着官网说明安装就行。</p><h1 id="四、安装Python"><a href="#四、安装Python" class="headerlink" title="四、安装Python"></a>四、安装Python</h1><ul><li><p>macOS自带python，只需要将所有的python指令全部换成python3即可。</p></li><li><p>去官网安装一个Sublime Text。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习第一周</title>
    <link href="/2022/06/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0week01/"/>
    <url>/2022/06/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0week01/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h3 id="1-1-什么是机器学习"><a href="#1-1-什么是机器学习" class="headerlink" title="1.1 什么是机器学习"></a>1.1 什么是机器学习</h3><p>类似人类通过对经验的利用对新情况做出有效的决策，计算机通过计算的手段，利用经验来改善系统自身的性能。</p><p>在计算机系统中，”经验”通常以”数据”形式存在，因此机器学习所研究的主要内容，是关于在计算机上从数据中产生”<strong>模型”(model)</strong>的算法，即”学习算法”(learningalgorithm).有了学习算法，我们把经验数据提供给它，它就能基于这些数据产生模型；在面对新的情况时(例如看到一个没剖开的西瓜)，模型会给我们提供相应的判断(例如好瓜).</p><p>如果说计算机科学是研究关于”算法”的学问，那么类似的，可以说机器学习是研究关于”学习算法”的学问.</p><h3 id="1-2-基本术语"><a href="#1-2-基本术语" class="headerlink" title="1.2 基本术语"></a>1.2 基本术语</h3><p>假定我们收集了一批关于西瓜的数据，例如(色泽=青绿；根蒂=蜷缩；敲声=浊响)，(色泽=乌黑；根蒂:稍蜷；敲声=沉闷)，(色泽=浅自；根蒂硬挺；敲声=清脆)…</p><p>每对括号内是一条<strong>记录</strong>，=的意思是”取值为”。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220617192915496.png" alt="image-20220617192915496"></p><p>从数据中学得模型的过程称为<u><strong>“学习”(learning)或”训练”(training)</strong></u>,这个过程通过执行某个学习算法来完成学得模型对应了关于数据的某种潜在的规律，因此亦称<strong><u>“假设”</u></strong>(hypothesis)；这种潜在规律自身，则称为<u><strong>“真相”或”真实”(ground-truth)</strong></u>，学习过程就是为了找出或逼近真相.本书有时将模型称为<u><strong>“学习器”(learner)</strong></u>，可看作学习算法在给定数据和参数空间上的实例化.</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220617200149951-5467313-5467314-5467315.png" alt="image-20220617200149951"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220617200824722-5467707.png" alt="image-20220617200824722"></p><p>学得模型后，使用其进预测的过程称为<u><strong>“测试”(testing)</strong></u>，被预测的样本称为<u><strong>“测试样本”(testingsample)</strong></u>.例如在学得$f$后，对测试例，可得到其预测标记$ν=f(x)$.</p><p><u><strong>“聚类”(clustering)</strong></u>，即将训练集中的西瓜分成若干组，每组称为一个”<u><strong>簇</strong></u>“(cluster)；这些自动形成的簇可能对应一些潜在的概念划分，例如”浅色瓜””深色瓜”，这些概念事先是不知道的，而且学习过程中使用的训练样本通常不拥有标记信息.</p><p>根据<u>训练数据是否拥有标记信息</u>，学习任务可大致划分为两大类”监督学习”(supervisedlearning)和”<strong>无监督学习</strong>“(unsupervisedlearning)，分类和回归是前者的代表，而聚类则是后者的代表.</p><p><u>学得模型适用于新样本的能力</u>，称为”<strong><u>泛化</u></strong>“(generalization)能力.具有强泛化能力的模型能很好地适用于整个样本空间.通常假设样本空间的样本均服从独立同分布，一般而言，训练样本越多，我们得到的关于分布的信息越多，这样就越有可能通过学习获得具有强泛化能力的模型.</p><h3 id="1-3-假设空间"><a href="#1-3-假设空间" class="headerlink" title="1.3 假设空间"></a>1.3 假设空间</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618134035759.png" alt="image-20220618134035759" style="zoom: 50%;"></p><p>归纳学习有<strong>狭义</strong>与<strong>广义</strong>之分：</p><p>广义的归纳学习大体相当于<u>从样例中学习</u>。</p><p>狭义的归纳学习则要求<u>从训练数据中学得概念(concept)</u>，因此亦称为<u><strong>“概念学习”或”概念形成”</strong></u>。</p><p>举一个西瓜数据集的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">色泽</th><th style="text-align:center">根蒂</th><th style="text-align:center">敲声</th><th style="text-align:center">好瓜</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">青绿</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">乌黑</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">青绿</td><td style="text-align:center">硬挺</td><td style="text-align:center">清脆</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">乌黑</td><td style="text-align:center">稍缩</td><td style="text-align:center">沉闷</td><td style="text-align:center">否</td></tr></tbody></table></div><p>这里要学习的目标是”好瓜”，表1.1第一行虽然是好瓜，但这是一个已经见过的瓜，不属于“泛化”的范畴，因此引入一个概念——<u><strong>假设空间</strong></u>，里面包含所有假设。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618104530154.png" alt="image-20220618104530154"></p><p>搜索过程中可以不断删除<u><strong>与正例不一致</strong></u>的假设、和(或)<u><strong>与反例一致</strong></u>的假设，最终获得与训练集一致(即<u>对所有训练样本能够进行正确判断</u>)的假设，这就是我们学得的结果.</p><p>与训练集一致的”假设集合”称之为”版本空间”(versionspace).例如，在西瓜问题中，与表1.1训练集所对应的版本空间如图1.2所示.<a href="https://blog.csdn.net/qq_18433441/article/details/55682732">详细过程</a></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618110202690.png" alt="image-20220618110202690"></p><h3 id="1-4-归纳偏好"><a href="#1-4-归纳偏好" class="headerlink" title="1.4 归纳偏好"></a>1.4 归纳偏好</h3><p>通过学习得到的模型对应了假设空间中的一个假设，但很可能存在有多个与训练集一致的假设，但与它们对应的模型在面临新样本的时候，却会产生不同的输出.</p><p>机器学习算法在学习过程中对某种类型假设的偏好，称为”<strong><u>归纳偏好</u></strong>“(inductivebias),或简称为”偏好”。<u>任何一个有效的机器学习算法必有其归纳偏好</u>。</p><p>“奥卡姆剃刀”(Occam’srazor)原则：”若有多个假设与观察一致，则选最简单的那个。</p><p>在具体的现实问题中，这个假设是否成立，即算法的归纳偏好是否与问题本身匹配，大多数时候直接决定了算法能否取得好的性能.脱离具体问题，空泛地谈论”什么学习算法更好”毫无意义，因为若考虑所有潜在的问题，则所有学习算法都一样好.</p><h3 id="1-5-习题"><a href="#1-5-习题" class="headerlink" title="1.5 习题"></a>1.5 习题</h3><h4 id="1-5-1"><a href="#1-5-1" class="headerlink" title="1.5.1"></a>1.5.1</h4><p><em>表1. 1 中若只包含编号为 1 和 4 的两个样例，试给出相应的版本空间.</em></p><div class="table-container"><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">色泽</th><th style="text-align:center">根蒂</th><th style="text-align:center">敲声</th><th style="text-align:center">好瓜</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">青绿</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">乌黑</td><td style="text-align:center">稍缩</td><td style="text-align:center">沉闷</td><td style="text-align:center">否</td></tr></tbody></table></div><p>表1.1的训练数据集对应的假设空间应该如下：</p><p>搜索过程中可以不断删除与正例不一致的假设、和（或）与反例一致的假设。最终将会获得与训练集一致（即对所有训练样本能够进行正确判断）的假设，这就是我们学得的结果。</p><p>按照上述过程进行学习：</p><p>编号1可以删除：3，5，6，8，9，11-15，17-21，23-30，32-49</p><p>编号4可以删除：3，6，15，21，30，48，即剩余假设空间中无可删除的假设</p><p>学习过后剩余的假设为：</p><p>1，2，4，7，10。</p><p>这就是最后的“假设集合”，也就是<strong>“版本空间”</strong>。</p><p>1 色泽＝＊，根蒂＝＊，敲声＝＊<br>2 色泽＝青绿，根蒂＝＊，敲声＝＊<br>3 色泽＝乌黑，根蒂＝＊，敲声＝＊<br>4 色泽＝＊，根蒂＝蜷缩，敲声＝＊<br>5 色泽＝＊，根蒂＝硬挺，敲声＝＊<br>6 色泽＝＊，根蒂＝稍蜷，敲声＝＊<br>7 色泽＝＊，根蒂＝＊，敲声＝浊响<br>8 色泽＝＊，根蒂＝＊，敲声＝清脆<br>9 色泽＝＊，根蒂＝＊，敲声＝沉闷<br>10 色泽＝青绿，根蒂＝蜷缩，敲声＝＊<br>11 色泽＝青绿，根蒂＝硬挺，敲声＝＊<br>12 色泽＝青绿，根蒂＝稍蜷，敲声＝＊<br>13 色泽＝乌黑，根蒂＝蜷缩，敲声＝＊<br>14 色泽＝乌黑，根蒂＝硬挺，敲声＝＊<br>15 色泽＝乌黑，根蒂＝稍蜷，敲声＝＊<br>16 色泽＝青绿，根蒂＝＊，敲声＝浊响<br>17 色泽＝青绿，根蒂＝＊，敲声＝清脆<br>18 色泽＝青绿，根蒂＝＊，敲声＝沉闷<br>19 色泽＝乌黑，根蒂＝＊，敲声＝浊响<br>20 色泽＝乌黑，根蒂＝＊，敲声＝清脆<br>21 色泽＝乌黑，根蒂＝＊，敲声＝沉闷<br>22 色泽＝＊，根蒂＝蜷缩，敲声＝浊响<br>23 色泽＝＊，根蒂＝蜷缩，敲声＝清脆<br>24 色泽＝＊，根蒂＝蜷缩，敲声＝沉闷<br>25 色泽＝＊，根蒂＝硬挺，敲声＝浊响<br>26 色泽＝＊，根蒂＝硬挺，敲声＝清脆<br>27 色泽＝＊，根蒂＝硬挺，敲声＝沉闷<br>28 色泽＝＊，根蒂＝稍蜷，敲声＝浊响<br>29 色泽＝＊，根蒂＝稍蜷，敲声＝清脆<br>30 色泽＝＊，根蒂＝稍蜷，敲声＝沉闷<br>31 色泽＝青绿，根蒂＝蜷缩，敲声＝浊响<br>32 色泽＝青绿，根蒂＝蜷缩，敲声＝清脆<br>33 色泽＝青绿，根蒂＝蜷缩，敲声＝沉闷<br>34 色泽＝青绿，根蒂＝硬挺，敲声＝浊响<br>35 色泽＝青绿，根蒂＝硬挺，敲声＝清脆<br>36 色泽＝青绿，根蒂＝硬挺，敲声＝沉闷<br>37 色泽＝青绿，根蒂＝稍蜷，敲声＝浊响<br>38 色泽＝青绿，根蒂＝稍蜷，敲声＝清脆<br>39 色泽＝青绿，根蒂＝稍蜷，敲声＝沉闷<br>40 色泽＝乌黑，根蒂＝蜷缩，敲声＝浊响<br>41 色泽＝乌黑，根蒂＝蜷缩，敲声＝清脆<br>42 色泽＝乌黑，根蒂＝蜷缩，敲声＝沉闷<br>43 色泽＝乌黑，根蒂＝硬挺，敲声＝浊响<br>44 色泽＝乌黑，根蒂＝硬挺，敲声＝清脆<br>45 色泽＝乌黑，根蒂＝硬挺，敲声＝沉闷<br>46 色泽＝乌黑，根蒂＝稍蜷，敲声＝浊响<br>47 色泽＝乌黑，根蒂＝稍蜷，敲声＝清脆<br>48 色泽＝乌黑，根蒂＝稍蜷，敲声＝沉闷<br>49 Ø</p><h4 id="1-5-2"><a href="#1-5-2" class="headerlink" title="1.5.2"></a>1.5.2</h4><p><a href="https://blog.csdn.net/qq_26371477/article/details/102292685?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-102292685-blog-103812745.pc_relevant_antiscanv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-102292685-blog-103812745.pc_relevant_antiscanv3&amp;utm_relevant_index=10">代码实现</a></p><p><em>与使用单个合取式来进行假设表示相比，使用”析合范式”将使得假设空间具有更强的表示能力.例如</em></p><p><em>好瓜$\leftrightarrow$((色泽=all)$\cap$(根蒂=蜷缩) $\cap$(敲声=all )) $\cup$ ((色泽=乌黑) $\cap$ (根蒂= all)$\cap$(敲声=沉闷)),</em></p><p>会把”(色泽=青绿)$\cap$(根蒂=蜷缩) $\cap$(敲声=清脆 <em>)”以及”(色泽=乌黑)$\cap$(根蒂=硬挺) $\cap$(敲声=沉闷 </em>)”都分类为”好瓜”。若使用最 多包含 $k$个合取式的析合范式来表达表1. 1 西瓜分类问题的假设空 间 ,试估算共有多少种可能的假设.*</p><blockquote><p>知识储备</p><p>合取式：是用合取真值联结词“∧”将两个或两个以上的命题联结起来而形成的命题形式。</p><p>析取式：用析取真值连接词“∨”将两个或两个以上的命题联结而成的一种命题形式</p><p>合取：相当于交集但不是交集</p><p>析取：相当于并集但不是并集</p><p>合取范式（合析范式）：有限个简单析取式构成的合取式</p><p>析取范式（析合范式）：由有限个简单合取式构成的析取式称为析取范式。</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">色泽</th><th style="text-align:center">根蒂</th><th style="text-align:center">敲声</th><th style="text-align:center">好瓜</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">青绿</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">乌黑</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">青绿</td><td style="text-align:center">硬挺</td><td style="text-align:center">清脆</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">乌黑</td><td style="text-align:center">稍缩</td><td style="text-align:center">沉闷</td><td style="text-align:center">否</td></tr></tbody></table></div><p>表中4个样例，3种属性，属性个数分别为2，3，3，假若考虑没有泛化属性和空集的情况下，剔除含通配符和相同的项，得到无冗余的假设空间共有2$\times$3$\times$3=18种假设，这18种假设的自由组合成的析合范式能够唯一的表示所有的假设。</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">色泽=青绿</td><td style="text-align:center">色泽=乌黑</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">根蒂=蜷缩</td><td style="text-align:center">根蒂=稍蜷</td><td style="text-align:center">根蒂=硬挺</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">敲声=浊响</td><td style="text-align:center">敲声=清脆</td><td style="text-align:center">敲声=沉闷</td></tr></tbody></table></div><p>可列集合为（$a_1<script type="math/tex">b_1</script>c_1$, $a_1b_1c_2$ ,……, $a_2b_3c_3$)，将其简化为（$1,2,3,……,18$),</p><p>$k=1$时，所有的析合范式为：$(1,2,3,……18)$。</p><p>$k=2$时，所有的析合范式为：$((1,2),(1,3),(1,4),(1,5),……(16,17),(16,18),(17,18))$。</p><p>有可能的析合范式的个数为：$17+16+……+3+2+1$=153。</p><p>$k=3$时，析合范式的个数为816,代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">result=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">17</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((i+<span class="hljs-number">1</span>),<span class="hljs-number">19</span>):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((j+<span class="hljs-number">1</span>),<span class="hljs-number">19</span>):<br>            <span class="hljs-built_in">print</span>((i,j,k))<br>            result=result+<span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>$k=4$时，析合范式的个数为3060,代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">result=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> a1 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">16</span>):<span class="hljs-comment">#这里16和循环次数相加就等于20</span><br>    <span class="hljs-keyword">for</span> a2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((a1+<span class="hljs-number">1</span>),<span class="hljs-number">19</span>):<br>        <span class="hljs-keyword">for</span> a3 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((a2+<span class="hljs-number">1</span>),<span class="hljs-number">19</span>):<br>            <span class="hljs-keyword">for</span> a4  <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((a3  + <span class="hljs-number">1</span>), <span class="hljs-number">19</span>):<br>                <span class="hljs-built_in">print</span>((a1 ,a2 ,a3 ,a4 ))<br>                result=result+<span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><h4 id="1-5-3"><a href="#1-5-3" class="headerlink" title="*1.5.3"></a>*1.5.3</h4><p>若数据包含噪声，则假设空间中有可能不存在与所有训练样本都一致 的假设，在此情形下，试设计一种归纳偏好用于假设选择.</p><p><u>不会</u></p><p>数据包含噪声，其含义就是，存在训练集本身的部分数据，其<u>属性取值对应的标记值是错误的</u>。对于噪声，最理想的情况是去除所有噪声，即将这部分“错误”的数据剔除出训练集。但事实上，单从数据集本身来剔除噪声并无通用的办法，甚至无法直接判断哪些数据属于噪声。</p><p>通俗来讲，我们可以先认为所有不矛盾的数据是正确的，只有哪些属性值相同但标记值不同的数据，“相互矛盾”的情况下，才剔除一部分数据使矛盾消除，此时剔除的方法可以归纳为一种偏好。 </p><p>例如，属性值相同的两个数据，其标记值分别为正例和反例，可以设计归纳偏好为：<u>始终保留正例的数据，或始终保留反例的数据。</u><br><a href="https://blog.csdn.net/MaxQuYY/article/details/120287245">原文链接</a></p><h4 id="1-5-4"><a href="#1-5-4" class="headerlink" title="*1.5.4"></a>*1.5.4</h4><p>换用其它性能度量，试证明没有免费的午餐定理成立。</p><p><a href="https://zhuanlan.zhihu.com/p/48493722">公式推导</a></p><h4 id="1-5-5"><a href="#1-5-5" class="headerlink" title="1.5.5"></a>1.5.5</h4><p>试述机器学习能在互联网搜索的哪些环节起什么作用.</p><ol><li>在向搜索引擎提交信息阶段，能够从提交文本中进行信息提取，进行语义分析。</li><li>在搜索引擎进行信息匹配阶段，能够提高问题与各个信息的匹配程度。</li><li>在向用户展示搜索结果的阶段，能够根据用户对结果感兴趣的程度进行排序。 </li></ol><h1 id="第二章-模型评估与选择"><a href="#第二章-模型评估与选择" class="headerlink" title="第二章 模型评估与选择"></a>第二章 模型评估与选择</h1><h3 id="章节主要内容"><a href="#章节主要内容" class="headerlink" title="章节主要内容"></a>章节主要内容</h3><p>在第一章绪论中，我们知道要根据具体的问题选择具体的算法和归纳偏好。那么要怎么判定我们的选择是正确的呢？这就需要拥有一套规范的模型评估与选择方法论了。</p><p>具体的章节思路可参考如下图解。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5328356-6afc770c7199ac3d.jpeg" alt="img"></p><p><a href="https://www.jianshu.com/p/8e369f73a0cc">参考链接</a></p><h3 id="2-1-经验误差与过拟合"><a href="#2-1-经验误差与过拟合" class="headerlink" title="2.1 经验误差与过拟合"></a><strong>2.1 </strong>经验误差与过拟合</h3><p>——机器学习为什么需要一套模型评估与选择方法论？</p><p>在前一章的学习中，我们知道<u>机器学习是对数据集的泛化过程，即从输入的数据中归纳出一套能适用于所有潜在样本的“普遍规律”</u>。可因为训练数据不够充分，机器学习出来的模型并没办法涵盖所有的情况，这就会导致学习器的实际预测输出与样本的真实输出之间存在“误差”。</p><p>学习器在训练集上的误差称为“经验误差”，在新样本上的误差称为“泛化误差”。很明显，要使得分类器尽可能的有用，我们应该要让泛化误差仅可能的小。可惜在现实环境中，我们很难知道新样本是什么样的，所以我们实际能做的只有努力使经验误差最小化。</p><p>但如果将算法设计的尽可能百分百的满足所有训练样本，就忘了学习器真正要达到的是泛化误差尽可能小，而不是目前的折中方案降低经验误差。而在降低经验误差的道路上，有着机器学习领域最大的难题之一：<u><strong>“过拟合”</strong></u>。</p><p>“过拟合”是指学习器对训练样本学的太好了，导致泛化程度不够（机器学习本身就是一个泛化过程），没法适应新的数据样本。与之相反的还有一个“欠拟合”的概念，就是对训练样本中的一般规律都没学习好。举个例子，你通过姚明这个训练样本来学习一个人类判断器，如果你将身高两米二十以上作为判断是否是人的依据，那就是过拟合了；而如果你没有“直立行走”这样的特征都没有找出来作为判断是否是人的标准，那就是欠拟合了。</p><p>所以，为什么需要一套模型评估与选择的方法论呢？<u><strong>因为我们的训练数据没法真正代表真实的样本空间，而泛化误差无法直接获得，经验误差又因为过拟合的存在而不适合作为标准，所以我们才需要一套模型评估与选择的方法论。</strong></u></p><h4 id="2-1-1-相关概念"><a href="#2-1-1-相关概念" class="headerlink" title="2.1.1 相关概念"></a>2.1.1 相关概念</h4><p>误差分为训练误差、经验误差和泛化误差，前两种为在学习集上的误差，最后一种是在新样本上的误差。</p><p>错误率$E$=分类错误的样本数$a$/总样本数$m$</p><p>精度=$1 - $ 错误率=$1-\frac{a}{m}$</p><p>误差=学习器的实际预测输出-真实输出</p><p><strong>欠拟合与过拟合的例子</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618142530466.png" alt="image-20220618142530466"></p><h3 id="2-2-评估方法"><a href="#2-2-评估方法" class="headerlink" title="2.2  评估方法"></a><strong>2.2 </strong> 评估方法</h3><p>——在已经知道为什么要对模型进行评估后，在不知道泛化误差的情况下，我们该如何进行评估呢？</p><p>一个合理的思路是：<u>既然我们没法拿到新样本来进行泛化误差计算，那么我们可以从训练样本中取出一部分来，假装它是一组新样本，并用这些样本计算出来的误差作为泛化误差的近似。</u>这组选出来的样本被称为“测试集”，测试集上的误差被称为测试误差。我们学习本书的一个主要目的是学会机器学习领域的脉络和背后逻辑，这种评估思路是科学研究领域的一个常用思路。领悟这种思路有助于我们解决其它领域上的问题）</p><p>不过我们需要注意一点，那就是测试集应该尽量不与训练集重合，否则测试集计算出的误差将没法准确代表该学习器的泛化能力。</p><p>基于这个考虑，书中列出了以下几种把包含$m$个样例的数据集$D$划分为训练集$S$和测试集$T$的办法。</p><h4 id="［1］留出法（hold-out）"><a href="#［1］留出法（hold-out）" class="headerlink" title="［1］留出法（hold-out）"></a><strong>［1］留出法（hold-out）</strong></h4><p>直接将$D$划分为互斥的两部分$S和T$，在$S$上训练出模型后，用$T$来评估测试误差，即 $D=S\cup T$，$S\cap T=\empty$。</p><p>需要注意的是训练/测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外的偏差而对最终结果产生影响。</p><blockquote><p>“分层采样” (stratified sampling)：一种保留类别比例的采样方式. 例如通过对 D 进行分层采样而获得含 70% 样本的训练集 S 和含 30% 样本的测试集 T， 若 D 包含 500 个正例、 500 个反例，则分层采样得到的 S 应包含 350 个正例、 350 个反例?而 T 则包含 150 个正例和 150 个反例；若 S、 T 中样本类别比例差别很大，则误差估计将由于训练/测试数据分布的差异 而产生偏差.</p></blockquote><p>在样本数量上的划分上，为了平衡模型的准确性与测试结果的保真性，常见做法是将大约 2/3～ 4/5 的样本用于训练，剩余样本用于测试（一般而言，测试集至少应含 30 个样例）。</p><h4 id="［2］交叉验证法（cross-validation）"><a href="#［2］交叉验证法（cross-validation）" class="headerlink" title="［2］交叉验证法（cross validation）"></a><strong>［2］交叉验证法（cross validation）</strong></h4><p>将数据集 $D $划 分为 $k $个互斥子集，即$D=D_1\cup D_2\cup ……\cup D_k$，$D_i\cap D_j=\empty $，每次用$k-1 $个子集的并集作为训练集，余下的那个子集作为测试集；对获得的 $k$组训练/测试集进行 $k$ 次训练和测试，得到这 $k$ 个测试结果的均值。</p><p>显然，交叉验证法评估结果的稳定性和保真性在很大程度上取决于 $k $的取值，为强调这一点，通常把交叉验证法称为 “$ k $折交叉验证” (k-fold cross validation). $k $最常用的取值是 10，此时称为 10 折交叉验 证；其他常用的$k$值有 5、 20 等.</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618155420458.png" alt="image-20220618155420458"></p><p>交叉验证法的一 个特例:留一法(Leave-One-Out，简称 LOO) . 假定数据集 $D$ 中包含 $m$ 个样本，令 $k=m$ ，即子集数量设定为样本数量。</p><blockquote><p>10次10 折交叉验证法与100 次留出法都是进行了 100 次训练/测试</p></blockquote><h4 id="［3］自助法（bootstrapping）"><a href="#［3］自助法（bootstrapping）" class="headerlink" title="［3］自助法（bootstrapping）"></a><strong>［3］自助法（bootstrapping）</strong></h4><p>每次从$D$中随机复制一个样本到$D1$中，重复$m$次，会得到一个拥有$m$个数据样本的$D1$数据集。显然，$D$中的一部分数据会多次出现在$D1$中，而另一部分样本不出现。根据平均分布概率计算，大约有36.8%的数据不会被复制到$D1$中。</p><p>可以做一个简单的估计，样本在 $m$ 次采样中始终不被采到的概率是 $(1-\frac{1}{m})^m$， 取极限得到$\lim_{m\to \infin}(1-\frac{1}{m})^m \to \frac{1}{e} \approx. 0.368$</p><p>于是我们可将$ D’ $用作训练集， $D/D’ $用作测试集；这样实际评估的模型与期望评估的模型都使用 $m $个训练样本，而我们仍有数据总量约 $1/3$ 的，没在训练集中出现的样本用于测试。这样的测试结果，亦称”包外估计” (out-of-bag estimate).</p><h4 id="［4］注意点"><a href="#［4］注意点" class="headerlink" title="［4］注意点"></a><strong>［4］注意点</strong></h4><p>训练/测试集的划分要尽可能保持数据分布一致性。</p><p>单次划分往往不够稳定可靠，一般要采用若干次随机划分、重复进行实验评估后取平均值作为评估结果。</p><p>训练/测试集的划分比例没有完美答案，训练样本多会使得模型更接近$D$，测试样本多会使得评估结果更可靠，这其中的取舍因人/场景而异。常见的训练/测试划分比例是2:1～4:1。</p><h4 id="［5］调参"><a href="#［5］调参" class="headerlink" title="［5］调参"></a><strong>［5］调参</strong></h4><p>不同的参数其实就代表着不同的模型了。一般参数分两种：一类是算法的参数，亦称“超参数”，如聚类要分的簇数量$k$；一类是模型的参数，如神经网络中每个节点的权重。前者多为人工选择一组候选，后者是让机器自己学习。</p><p>常用的做法是对每个参数选定一个范围和变化步长，<u>例如在 [0， 0.2] 范围内以 0.05 为步长，则实际要评估的候选参数值有 5 个，最终是从这 5 个候选值中产生选定值。简单估算一下：假定算法有 3 个参数，每个参数仅考虑 5 个候选 值，这样对每一组训练/测试集就有 53 = 125 个模型需考察；</u>很多强大的学习算 法有大量参数需设定，这将导致极大的调参工程量，例如大型”深度学习模型甚至有上百亿个参数。</p><p>调参是机器学习的重点，也是决定模型性能的关键。一般调参过程中，会将训练数据再次划分为训练集和验证集（validation set）。具体包含关系如下：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220619171542448.png" alt="image-20220619171542448"></p><h4 id="［6］适用性"><a href="#［6］适用性" class="headerlink" title="［6］适用性"></a><strong>［6］适用性</strong></h4><p>自助法在数据集较小、难以有效划分训练/测试集时很有用</p><p>自助法产生的数据集改变了初始数据集的分布，这会引入估计偏差。因此，在初始数据量足够时，留出法和交叉验证法更常用一些。</p><p>留出法和交叉验证法由于都把数据集中的一部分用来测试，没有参与训练，因此必然会引入一些因训练样本规模不同而导致的估计偏差，留一法受影响较小，但计算复杂度又太高了。</p><h3 id="2-3-性能度量"><a href="#2-3-性能度量" class="headerlink" title="2.3  性能度量"></a><strong>2.3 </strong> 性能度量</h3><p>——在了解了有效可行实验评估方法后，接下来我们需要了解一下具体的衡量模型泛化能力的评价标准，即性能度量（performance measure）</p><p>性能度量反映了任务需求，使用不同的性能度量会导致对模型的评判结果不同。这意味着模型的“好坏”是相对的，什么样的模型是好的，不仅取决于算法和数据，还决定于任务需求。</p><p>在预测任务中，给定样例集 $D = {(x1 , y1) , (x2 ， y2)， . . . , (xm, ym)} $， 其中 $yi$ 是示例 $xi$ 的真实标记。要评估学习器 $f$ 的性能，就要把学习器预测结果 $f(x)$  与真实标记  $y$ 进行比较。</p><p>回归任务<strong>最常用的性能度量</strong>是”<strong>均方误差</strong>“ (mean squared error)：</p><script type="math/tex; mode=display">E(f;D)=\frac{1}{m}\sum_{i=1}^{m}(f(xi)-yi)^2</script><p>更一般的，对于数据分布 $Ð$ 和概率密度函数 $p(.) $， 均方误差可描述为</p><script type="math/tex; mode=display">E(f;Ð)=\int_{x～Ð}(f(x)-y)^2p(x)dx</script><h4 id="2-3-1-错误率与精度"><a href="#2-3-1-错误率与精度" class="headerlink" title="2.3.1 错误率与精度"></a>2.3.1 错误率与精度</h4><p>对样例集 $D$，分类错误率定义为：</p><script type="math/tex; mode=display">E(f;D)=\frac{1}{m}\sum_{i=1}^{m}I(f(xi)\ne yi)</script><p>精度则定义为：</p><script type="math/tex; mode=display">acc(f;D)=\frac{1}{m}\sum_{i=1}^{m}I(f(xi)= yi)=1-E(f;D)</script><p>更一般的，对于数据分布 $Ð$ 和概率密度函数 $p(.)$ ，错误率与精度可分别描述为</p><script type="math/tex; mode=display">E(f;Ð)=\int_{x～Ð}(f(x)\ne y)p(x)dx</script><script type="math/tex; mode=display">acc(f;Ð)=\int_{x～Ð}(f(x)= y)p(x)dx=1-E(f;Ð)</script><h4 id="2-3-2-查准率、查全率与-F1"><a href="#2-3-2-查准率、查全率与-F1" class="headerlink" title="2.3.2 查准率、查全率与$F1$"></a>2.3.2 查准率、查全率与$F1$</h4><p>查准率和查全率可以理解为”挑出的西瓜中有多少比例是好瓜”，或者”所有好瓜中有多少比例被挑了出来”，或者”检索出的信息中有多少比例是用户感兴趣的” 和”用户感兴趣的信息中有多少被检索出来了”。</p><p>对于二分类问题，可将样例根据其真实类别与学习器预测类别的组合划分为真正例 (true positive) 、假正例 (false positive) 、真反例 (true negative) 、 假反例 (false negative) 四种情形，令 $TP、 FP、 TN、 FN$ 分别表示其对应的样例数，则显然有 $TP+FP+TN+FN=样例总数$。分类结果的误差矩阵或者精度矩阵称为”混淆矩阵” (confusion matrix)。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618175331853.png" alt="image-20220618175331853"></p><p>查准率 $P $ 与查全率 $R$ 分别定义为：</p><p>$P=\frac{TP}{TP+FP}$  =  真正例 / 预测出的正例</p><p>$R=\frac{TP}{TP+FN}$ =。真正例 / 实际上的正例</p><p>二者通常呈反比。</p><p>举个例子：假设有10个西瓜，6个好瓜，4个坏瓜。我们将这十个瓜按照预测结果排序，最可能是好瓜的排在前头，最不可能的排在最后，然后控制学习器的分类阀值来依次逐个把样本作为好瓜来进行预测，则可以计算出不同的阀值时的$P$和$R$如下表所示：</p><div class="table-container"><table><thead><tr><th>指标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>TP</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td></tr><tr><td>FN</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>FP</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>TN</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>P</td><td>X</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>6/7</td><td>6/8</td><td>6/9</td><td>6/10</td></tr><tr><td>R</td><td>0</td><td>1/6</td><td>2/6</td><td>3/6</td><td>4/6</td><td>5/6</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>由上边例子可以看到，P和R的值也基本满足了一方升高，另一方下降的状况，通常只有在一些简单的任务（比如我举的这个）中，才可能使查全率和查准率都很高。以查准率为纵轴、查全率为横轴作图，就得到了查准率－查全率曲线，简称“P-R曲线”。</p><p>再举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//20160721114615857-20220619182907525.png" alt="img"></p><p>Inst#是样本序号，图中有20个样本。Class是ground truth 标签，p是positive样本（正例），n当然就是negative（负例） score是分类器对于该样本属于正例的可能性的打分。因为一般模型输出的不是0,1的标注，而是小数，相当于置信度。</p><p>然后设置一个从高到低的阈值y，大于等于阈值y的被正式标注为正例，小于阈值y的被我正式标注为负例。</p><p>显然，设置n个阈值，就能得到n种标注结果，评判模型好不好使。</p><p>比如阈值0.9，只有第一个样本被判断为正例，那么我的查准率precision就是100%，但是查全率recall就是10%。阈值0.1，所有样本都被我判断为正例，查全率是100%，查准率就是50%</p><p>最后我能得到若干对precision，recall值(P,R) :  (1, 0.1),… ,(0.5,1),将这若干对画在图上，再连接起来就是这个pr曲线了。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//20160721111312507.png" alt="img"></p><p>在进行比较时，若一个学习器的P-R曲线被另一个学习器的曲线完全“包住”，则可断言后者的性能优于前者。当曲线有相交时，很难断言两者的优劣。真要判别时，“平衡点”（Break-Even Point）是一个不错的度量方法。下图是一个具体的示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618181148275.png" alt="image-20220618181148275"></p><p>平衡点(Break-Event Point，简称 BEP)，它是” 查准率=查全率”时的取值，例如上图中基于 BEP的比较，可认为学习器 A 优于 B。</p><p>但 BEP 还是过于简化了些，更常用的是 F1 度量：</p><script type="math/tex; mode=display">F1=\frac{2\times P\times R}{P+R}=\frac{2\times TP}{样例总数+TP-TN}</script><p>$F1$ 是基于查准率与查 全率的调和平均 (harinonic mean)定义的:</p><script type="math/tex; mode=display">\frac{1}{F1}=\frac{1}{2}.(\frac{1}{P}+\frac{1}{R})</script><p>在不同的条件下，对查准率和查全率的重视程度有所不同。比如在大数据推送时，为了少打扰用户，更希望能推荐用户感兴趣的广告，此时查准率要比查全率更重要；在追捕逃犯时，为了不漏掉逃犯，此时查全率比查准率更重要。为了表达出对查准率/查全率的不同偏好，定义了$F1 $度量的一般形式</p><script type="math/tex; mode=display">F_\beta=\frac{(1+\beta^2)\times P \times R}{(\beta^2 \times P)+R}</script><p>$ß&gt; 1$ 时查全率有更大影响 ; $ß &lt; 1$ 时查准率有更大影响。</p><p>很多时候我们有多个二分类混淆矩阵，例如进行多次训练/测试，每次得到一个混淆矩阵；或是在多个数据集上进行训练/测试，希望估计算法的”全局” 性能；甚或是执行多分类任务，每两两类别的组合都对应一个混淆矩阵，总之，我们希望在 $n$ 个二分类混淆矩阵上综合考察查准率和查全率。</p><p>一种直接的做法是先在各混淆矩阵上分别计算出查准率和查全率，记为 $(P_1， R_1 ) ， (P_2 ， R_2) ，…… ， (Pn ， Rn)$ ，再计算平均值，这样就得到”宏查准率” ($macro-P$) 、”宏查全率” ($macro-R$) ，以及相应的”宏 $F1$” ($macro-F1$):</p><script type="math/tex; mode=display">macro-P=\frac{1}{n}\sum^n_{i=1}P_i</script><script type="math/tex; mode=display">macro-R=\frac{1}{n}\sum^n_{i=1}R_i</script><script type="math/tex; mode=display">macro-F1=\frac{2\times macro-P \times macro-R}{macro-P+macro-R}</script><p>还可先将各混 淆矩阵的对应元素进行平均，得到 $TP 、FP 、 TN 、FN$ 的平均值，分别记为 $\overline{TP}、 \overline{FP}、 \overline{TN}、 \overline{FN}$，再基于这些平均值计算出”微查准率 “(micro-P) 、 “微查全率” (micro-R)和”微F1” (micro-F1):</p><script type="math/tex; mode=display">micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FP}}</script><script type="math/tex; mode=display">micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FN}}</script><script type="math/tex; mode=display">micro-F1=\frac{2\times micro-P\times micro-R}{micro-P+micro-R}</script><h4 id="2-3-3-ROC-与-AUC"><a href="#2-3-3-ROC-与-AUC" class="headerlink" title="2.3.3 ROC 与 AUC"></a>2.3.3 ROC 与 AUC</h4><p>ROC：“受试者工作特征”（receiver operating characteristic）曲线，与P-R 曲线类似，只不过取用“真正利率”（TPR ）作为纵轴，“假正例率”（FPR）作为横轴 ，两者分别定义为</p><script type="math/tex; mode=display">TPR=\frac{TP}{TP+FN},FPR=\frac{FP}{TN+FP}</script><p>显示 ROC 曲线的图称为 “ROC 图”，显然，对角线对应于 “随机猜测” 模型，而点 ($0，1)$ 则对应于将所有正例排在所有反例之前的”理想模型”。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220619155415423.png" alt="image-20220619155415423"></p><p>现实任务中测试样例有限 ，无法产生图 a 中的光滑 ROC 曲线，只能绘制出如图 b 所示的近似 ROC 曲线。绘图过程很简单：给定 $m^+ $个正例和$m^-$ 个反例，根据学习器预测结果对样例进行排序，然后把分类阈值设为最大，即把所有样例均预测为反例，此时真正例率和假正例率均为 0， 在坐标$ (0， 0)$ 处标记一个点。然后，将分类阈值依次设为每个样例的预测值，即依次将每个样例划分为正例。设前一个标记点坐标为 $(x， y) $， 当前若为真正例，则对应标记点的坐标为 $(x， y + \frac{1}{m^+})$ ;当前若为假正例，则对应标记点的坐标为 ($( x + \frac{1}{m^-},y)$ ，然后用线段连接相邻点即得。</p><p>​        进行学习器的比较时，与 P-R 图相似， 若一个学习器的 ROC 曲线被另 一个学习器的曲线完全”包住”， 则可断言后者的性能优于前者；若两个学习 器 的 ROC 曲线发生交叉，则难以一般性地断言两者孰优孰劣。此时如果一定要进行比较，则较为合理的判据是比较 ROC 曲线下的面积，即 AUC (Area Under ROC Curve) 。</p><p>​        从定义可知， AUC 可通过对 ROC 曲 线下各部分的面积求和而得,估算为</p><script type="math/tex; mode=display">AUC=\frac{1}{2}\sum^{m-1}_{i=1}(x_{i+1}-x_i).(y_i+y_{i+1})</script><h4 id="2-3-4-代价敏感错误率与代价曲线"><a href="#2-3-4-代价敏感错误率与代价曲线" class="headerlink" title="2.3.4 代价敏感错误率与代价曲线"></a>2.3.4 代价敏感错误率与代价曲线</h4><p>代价敏感错误率代表数据的平均总体代价。</p><p>不同类型的错误所造成的后果不同，为权衡不同类型错误所造成的不同损失，可为错误赋予”非均等代价” (unequa1 cost)。以二分类任务为例，我们可根据任务的领域知识设定一个”代价矩阵” (cost matrix) ，其中 $cost_{ij} $表示将第$ i $类样本预测为第 $j $类样本的代价。一般来说， $cost_{ii} = 0$；若将第 0 类判别为第 1 类所造成的损失更大，则 $cost_{01} &gt; cost_{10}$; 损失程度相差越大， $cost_{01} 与 cost_{10}$ 值的差别越大。</p><div class="table-container"><table><thead><tr><th style="text-align:center">真实</th><th style="text-align:center">预测</th><th style="text-align:center">类别</th><th></th></tr></thead><tbody><tr><td style="text-align:center">类别</td><td style="text-align:center">第0类</td><td style="text-align:center">第1类</td><td></td></tr><tr><td style="text-align:center">第0类</td><td style="text-align:center">0</td><td style="text-align:center">$cost_{01{}}$</td><td></td></tr><tr><td style="text-align:center">第1类</td><td style="text-align:center">$cost_{10}$</td><td style="text-align:center">0</td></tr></tbody></table></div><p>上面的例子中都隐式地假设了均等代价，所定义的错误率是直接计算错误次数。而在非均等代价下，我们所希望的不再是简单地最小化错误次数，而是希望最小化”总体代价” (total cost). 若将表中的第 0 类作为正类、第 1 类作为反类，令 $D^+$ 与 $D^-$分别代表样例集 D 的正例子集和反例子集，则”代价敏感” (cost-sensitive)错误率为</p><script type="math/tex; mode=display">E(f;D;cost)=\frac{1}{m}(\sum_{x_i\in D^+}I(f(x_i)\ne y_i)\times cost_{01}+\sum_{x_i\in D^-}I(f(x_i)\ne y_i)\times cost_{10})</script><p>在非均等代价下， ROC 曲线不能直接反映出学习器的期望总体代价，而”代价曲线” (cost curve) 则可达到该目的.代价曲线图的横轴是取值为 [0,1]的正例概率代价</p><script type="math/tex; mode=display">P(+)cost=\frac{p\times cost_{01}}{p\times cost_{01}+(1-p)\times cost_{10}}</script><p>其中 $p$ 是样例为正例的概率；纵轴是取值为 [0,1] 的归一化代价。</p><script type="math/tex; mode=display">P(+)cost=\frac{FNP\times p\times cost_{01}+FNP\times (1-p)\times cost_{10}}{p\times cost_{01}+(1-p)\times cost_{10}}</script><p>其中 $FPR$ 是假正例率， $FNR = 1 - TPR$ 是假反例率。</p><p>代价曲线的绘制很简单：ROC 曲线上每一点对应了代价平面上的一条线段 ， 设 ROC 曲线上点的坐标为 $(TPR， FPR)$ ，则可相应计算出 $FNR$，然后在代价平面上绘制 一条从 $(0， FPR)$ 到 $(1 ，FNR)$ 的线段，线段下的面积即表示了该条件下的期望总体代价；如此将 ROC 曲线上的每个点转化为代价平面上的一条线段，然后取所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220619191716330.png" alt="image-20220619191716330"></p><h3 id="2-4-比较检验"><a href="#2-4-比较检验" class="headerlink" title="2.4  比较检验"></a><strong>2.4 </strong> 比较检验</h3><p>——有了实验评估方法和性能度量，就要研究如何应用方法和度量指标去对学习器的性能进行评估比较了</p><p>研究怎么来做“比较”是很有必要的，因为第一，我们要的是<strong>泛化性能</strong>，但是能用的只是测试性能；第二，测试性能和测试集的选择对测试结果有很大影响；第三，有的机器学习算法本身也有随机性，对同一测试集的多次测试结果也可能会不同。</p><p>为了解决这些问题，统计假设检验（hypothesis test）为我们提供了重要的依据。</p><h4 id="2-4-1-假设检验"><a href="#2-4-1-假设检验" class="headerlink" title="2.4.1 假设检验"></a>2.4.1 假设检验</h4><blockquote><p>西瓜书介绍的是假设检验方法，个人认为更好的方式应该是求泛化性能的置信区间，而不是进行假设检验。置信区间不仅可以得到泛化性能的一个区间，同时它也可以进行假设检验。所以，置信区间完全可以替换掉假设检验。</p><p>泛化性能的估计值 u=k/n，它是泛化性能p的一个无偏估计，E(u)=p，u的方差为 u<em>(1-u)/n，基于中心极限定理知道 u 渐进符合正态分布 N[p,u</em>(1-u)/n]。知道了u的抽样分布，u的置信区间就可以计算出来。</p><p><a href="https://zhuanlan.zhihu.com/p/259232881">如何计算置信区间</a></p></blockquote><p>假设检验中的“假设”是对学习器泛化错误率分布的某种猜想或判断，现实任务中学习器的泛化错误率不可知，只能获知其测试错误率，尽管二者未必相同，但肯定相似，因此， 可根据测试错误率估推出泛化错误率的分布。</p><p>然后通过假设的验证结果来对不同的学习器或模型的性能进行判断。比如假设“学习器A和B性能相同”，当该假设被拒绝时，说明学习器A和B具有显著差异，这时候错误率较低的学习器性能较优。</p><p>假设检验的具体逻辑和使用方法是这样的：</p><p>［1］设定一个假设，比如“一个机器学习真正的泛化错误率不大于0.3”</p><p>［2］设定一个置信概率“显著度a”，a的一般取值为0.05、0.1；a代表的意思是当我们的假设成立的概率在（1-a，1］的范围内时，我们认为是成立的。</p><p>［3］计算使假设在置信范围内成立的最大值是多少，比如根据上边［1］中的假设，要使泛化错误率不大于0.3成立，即泛化错误率小于0.3的概率大于（1-a）。要计算这个，我们要算出要使错误率大于0.3的概率之和小于a时的最大泛化错误率是多少。</p><p>［4］比较计算出的满足假设的最大值和我们实际计算出的值，如果我们实际计算出来的错误率已经大于最大可能的错误率了，说明假设不成立。</p><p>［5］在这里的假设中，假设不成立说明我们的学习器错误率要大于0.3啊，这是个很烂的学习器，我们还需要继续调优。</p><p>在实际实验时，我们会多次使用留出法或交叉验证法进行多次训练/测试，那么我们实际上会得到多个测试错误率（这里假设为$k$个）。我们可以通过求这些错误率的平均和方差来将假设检验转换为自由度为$k-1$的$ t $分布。通过查询 $t$ 检验常用临界表可以很方便的计算出假设是否成立。</p><p>书中提到的交叉验证 $t $检验、Friedman检验与Nemenyi后续检验都是基于一样的假设检验流程的稍微变化。其中交叉验证 $t$ 检验是针对两种学习器之间性能的比较，Friedman检验与Nemenyi后续检验是针对多个学习器之间性能的比较。在这里就不一一介绍了。</p><h3 id="2-5-偏差与方差"><a href="#2-5-偏差与方差" class="headerlink" title="2.5 偏差与方差"></a><strong>2.5 </strong>偏差与方差</h3><p>——对学习算法除了通过实验估计其泛化性能，我们还需要理解“为什么”具有这样的性能，“偏差与方差分解”（bias-variance decomposition）是解释学习算法泛化性能的一种重要工具。</p><p>省略具体的算法和公式推导过程，偏差与方差分解是对学习算法的期望泛化错误率的分解，分解结果是下边这个重要的公式</p><p>$E(f;D)=bias^2(x)+var(x)+\varepsilon^2$</p><p>也就是说，泛化误差可分解为偏差、方差与噪声之和。</p><p>其中，偏差度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法的拟合能力；方差度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所带来的影响；噪声则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。</p><p>偏差-方差分解说明，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。</p><p>一般来说，偏差与方差是有冲突的。要使偏差小则需要算法对数据充分拟合，这就有可能会导致过拟合，这样对新样本的适应性差，就会导致方差变高。反之亦然，拟合过低，偏差较大，但是方差会相对较低。</p><blockquote><p>很多学习算法都可控制训练程度，例如决策树可控制层数，神经网络可控制训练轮数，集成学习方法可控制基学习器个数。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220619224405067.png" alt="image-20220619224405067"></p><h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h3><p>泛化误差无法获得，经验误差因为过拟合的存在而不适合作为标准，导致我们需要专门的模型评估方法来测量学习器的效果。</p><p>专门的模型评估方法是通过从数据集中选取一部分数据作为测试集来对训练出的模型进行验证，以测试误差来近似泛化误差实现的。</p><p>测试误差体现在具体的性能度量指标上，我们要根据具体情况选择对应的指标。</p><p>假设检验是我们对学习器性能进行比较的有效方法。</p><p>泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。</p><p>通常来讲，更多的数据胜过更好的算法：对一批数据使用高明的算法，比不上用普通算法但是引入一部分外部数据源的效果要好。</p><p><a href="http://anand.typepad.com/datawocky/2008/03/more-data-usual.html">额外阅读</a></p><h3 id="2-7-习题"><a href="#2-7-习题" class="headerlink" title="2.7 习题"></a>2.7 习题</h3><h4 id="2-7-1"><a href="#2-7-1" class="headerlink" title="2.7.1"></a>2.7.1</h4><p><em>数据集包含 1000 个样本，其中 500 个正例、 500 个反例，将其划分为包含 70% 样本的训练集和 30% 样本的测试集用于留出法评估，试估算共有多少种划分方式。</em></p><p>500个正例和500个反例，根据分层抽样的原则，30%的测试样本共300个，其中必须包含150个正例和150个反例。若不考虑样本其他的分布情况，则选取方式为：从500个正例中随机抽取150个，再从500个反例中随机抽取150个，两个过程相互独立，则共有$(C_{500}^{150})^2$种方式。</p><h4 id="2-7-2"><a href="#2-7-2" class="headerlink" title="2.7.2"></a>2.7.2</h4><p><em>数据集包含 100 个样本，其中正、反例各一半，假定学习算法所产生的模型是将新样本预测为训练样本数较多的类别(训练样本数相同时进行随机猜测)，试给出用 10 折交叉验证法和留一法分别对错误率进行评估所得的结果。</em></p><p>10 折交叉验证法：将样本集划分为10个同分布不相交的子集，将其中9个作为训练集，1个作为测试集，每个划分可得到10次不同的训练和验证。对于题目所述的模型，总是将新样本预测为训练样本较多的类别，但每一次验证时，训练集的正例和反例一样多，将会进行随机猜测。每次都进行随即猜测，其错误率的期望是50%。</p><p>留一法：$k$折交叉验证中$k$等于样本个数的特例。在题目所述的情况下，即将100个样本每次取出1个样本用于测试，99个用于训练。当1个测试样本为正例时，99个训练样本为50个反例和49个正例，新样本将被预测为出现较多的反例，而测试样本的ground truth是正例，必然会预测错误。当测试样本为反例时同理必然会预测错误，此时错误率的期望为100%。</p><h4 id="2-7-3"><a href="#2-7-3" class="headerlink" title="2.7.3"></a>2.7.3</h4><p><em>若学习器 A 的 F1 值比学习器 B 高，试析 A 的 BEP 值是否也比 B 高。</em></p><p>F1：查准率P和查全率R的调和平均；</p><p>BEP：Beak-Even Point，P-R曲线上P = R时二者的取值。</p><p>F1和BEP有概念上的巨大差异，二者没有必然联系。P-R曲线的定义是：学习器将所有样本按“可能是正例”的概率从前向后排序，然后依次将前若干个样本按正例进行预测，所得出的预测结论。注意此时<u>BEP曲线只是衡量了学习器进行“排序”的性能，并不包含最终预测的结果。</u>也就是说，给定了P-R曲线的情况下，根据不同的预测策略，会产生不同的P和R。<u>而F1是一个确定的概念，是在P和R都确定的情况下计算出的二者的调和平均。</u>因此在同一P-R曲线上，F1在不同的位置有不同的取值。</p><p>因此对于题目所述的假设，我们很容易给出反例：对于R-P曲线完全相同的两个学习器，二者的P-R曲线上存在两个不同位置，使得对应的F1值不同。不妨设F1值较大的位置所对应的预测策略为学习器A，另一个为B，此时学习器A的F1值比学习器B高，但二者P-R曲线完全相同，也有相同的BEP值。</p><h4 id="2-7-4"><a href="#2-7-4" class="headerlink" title="2.7.4"></a>2.7.4</h4><p><em>试述真正例率(TPR) 、假正例率 (FPR)与查准率(P) 、查全率(R)之间的联系。</em></p><p>查全率: 真实正例被预测为正例的比例。<br>真正例率: 真实正例被预测为正例的比例。<br>显然查全率与真正例率是相等的。</p><p>查准率:预测为正例的实例中真实正例的比例。<br>假正例率: 真实反例被预测为正例的比例。<br>两者并没有直接的数值关系。</p><h4 id="2-7-5"><a href="#2-7-5" class="headerlink" title="*2.7.5"></a>*2.7.5</h4><p><em>试证明式(2.22).</em></p><p><a href="https://datawhalechina.github.io/pumpkin-book/#/chapter2/chapter2?id=_221">南瓜书中有证明，但同时，根据南瓜书的建议</a></p><blockquote><p>对于初学机器学习的小白，西瓜书第1章和第2章的公式<strong>强烈不建议深究</strong>，简单过一下即可，等你学得有点飘的时候再回来啃都来得及。</p></blockquote><h4 id="2-7-6"><a href="#2-7-6" class="headerlink" title="2.7.6"></a>2.7.6</h4><p><em>试述错误率与 ROC 曲线的联系。</em></p><p>ROC曲线本质上只反映学习器的“排序能力”，而具体的预测策略则取决于在ROC曲线上的哪一点作截断。当确定了一种预测策略时，才会对应一个确定的错误率。因此可以说，ROC曲线上的每一点，对应了学习器一种情况下的错误率。</p><h4 id="2-7-7"><a href="#2-7-7" class="headerlink" title="2.7.7"></a>2.7.7</h4><p><em>试证明任意一条 ROC 曲线都有一条代价曲线与之对应，反之亦然.</em></p><p>代价曲线、ROC曲线、P-R曲线都是为了描述某一学习器的“排序能力”而引入的概念。ROC曲线下方的面积仅能在“错误代价均等”的条件下反应学习器的排序质量，而在错误代价并不均等的情况下，引入代价矩阵后，应当使用代价曲线来反应考虑代价的排序质量。但不论使用哪一种曲线，衡量哪一种面积，一旦学习器给定，其排序质量是一定的，则三种曲线都是确定的。从这一角度来看，任意一条ROC曲线都对应了一个确定的学习器，而该学习器有唯一确定的代价曲线，反之亦然。</p><p>若要严格证明该结论，西瓜书给出了ROC曲线和代价曲线的转换方法：ROC曲线上每一点对应了代价平面上的一条线段，设ROC曲线上点的坐标为(FPR, TPR)，则可计算相应的FNR，然后再代价平面上绘制一条从(0, FPR)到(1, FNR)的线段，如此求出ROC曲线上所有点对应的线段，其下界围成的曲线即代价曲线。同理，在代价曲线上寻找一个连续的分段，将其线段计算出相应的FPR与FNR，再计算出TPR，即得到ROC曲线上的一个点，连接所有如此的到的点即得ROC曲线。</p><h4 id="2-7-8"><a href="#2-7-8" class="headerlink" title="2.7.8"></a>2.7.8</h4><p><em>Min-Max规范化与z-score规范化如下所示。试析二者的优缺点</em></p><p>Min−max规范化方法简单，而且保证规范化后所有元素都是正的，每当有新的元素进来，只有在该元素大于最大值或者小于最小值时才要重新计算全部元素。但是若存在一个极大(小)的元素，会导致其他元素变的非常小(大)。</p><p>z−score标准化对个别极端元素不敏感，且把所有元素分布在0的周围，一般情况下元素越多，0周围区间会分布大部分的元素，每当有新的元素进来，都要重新计算方差与均值。</p><h4 id="2-7-9"><a href="#2-7-9" class="headerlink" title="2.7.9"></a>2.7.9</h4><p><em>试述 χ2 检验过程.</em></p><p><a href="http://guoze.me/2015/09/07/chi-square/">参考链接</a></p><h4 id="2-7-10"><a href="#2-7-10" class="headerlink" title="2.7.10*"></a>2.7.10*</h4><p><em>试述在Friedman 检验中使用式 (2.34) 与 (2.35) 的区别.</em></p><p><a href="https://www.cnblogs.com/daigz1224/p/7163342.html">参考链接</a></p><h1 id="第三章-线性模型"><a href="#第三章-线性模型" class="headerlink" title="第三章 线性模型"></a>第三章 线性模型</h1><h3 id="章节主要内容-1"><a href="#章节主要内容-1" class="headerlink" title="章节主要内容"></a>章节主要内容</h3><p>线性模型形式简单、易于建模，许多功能更为强大的非线性模型可在线性模型的基础上通过引入层级结构或高维映射而得（神经网络就是一个例子，后边学习神经网络时会发现其实神经网络的每个神经元就是一个广义的线性模型）</p><p><a href="https://www.jianshu.com/p/04786709258b">思维导图</a></p><p>基本知识：</p><p><a href="https://www.jianshu.com/p/af0a4f71c05a">最小二乘法</a></p><p><a href="https://www.jianshu.com/p/bcfc11c216a3">极大似然法</a></p><h3 id="3-1-基本形式"><a href="#3-1-基本形式" class="headerlink" title="3.1 基本形式"></a>3.1 基本形式</h3><p>——线性模型的背后逻辑以及变型思路</p><p>线性模型的本质是通过训练数据学习出一个通过样本数据的属性的线性组合来进行预测的函数。</p><p>线性模型具体是什么，简单来说和我们学过的线性函数是一样的，我们学过的线性函数形式一般为：$y = ax + b$，在这里$a，b$代表系数，也就是我们模型要学习的东西，代表的是属性，也就是我们的特征。</p><p>给定由 $d$ 个属性描述的示例$x=(x_1;x_2;……;x_d)$ ， 其中$x_i$是 $x$ 在第 $i$ 个属性上的取值，线性模型(linear model)试图学得一个通过属性的线性组合来进行预测的函数，即$f(x)=w_1x_1+w_2x_2+……+w_dx_d+b$ ，一般用向量形式写成$f(x)=w^Tx+b$ ，其中$w=(w_1;w_2;…;w_d)$ ，$w$ 和 $b$ 学得之后，模型就得以确定。</p><p>举一个例子，在西瓜样例中，</p><script type="math/tex; mode=display">f_{好瓜}(x)=0.2\times x_{色泽}+0.5\times x_{根蒂}+0.3\times x_{敲声}+1</script><p>其中0.2,0.5,0.3还有1 都是属于线性模型通过训练数据学到的系数，而其中的色泽，根蒂，敲声属于一个样本的各个特征，我们在本章中先从回归讲起，然后讨论二分类再讨论多分类问题。 </p><p>二分类：新闻可以分为体育、非体育等两个类别，这就是一个典型的二分类任务，1可以代表正类，0代表负类。</p><p>多分类：新闻可以分为体育、财经、其它等三个类别，这就是一个典型的多分类任务。</p><p><a href="https://zhuanlan.zhihu.com/p/270458779">二分类、多分类、多标签分类的基础、原理、算法和工具</a></p><h3 id="3-2-线性回归"><a href="#3-2-线性回归" class="headerlink" title="3.2 线性回归"></a>3.2 线性回归</h3><p>——<strong>线性模型最基础的算法</strong></p><p>首先我们考虑最简单的问题，也就是只有一个输入属性的情况。</p><p>对离散属性，若属性值间存在”序” (order)关系，可通过连续化将其转化为连续值，例如二值属性”身高”的取值——“高” “矮”可转化为 {1.0,0.0}，三值属性”高度” 的取值”高” “中” “低”可转化为 {1.0, 0.5, 0.0}；若属性值间不存在序关 系，假定有 $k$ 个属性值，则通常转化为 $k$ 维向量，例如属性”瓜类”的取值”西瓜”、”南瓜”、”黄瓜”可转化为(0,0,1),(0,1,0),(1,0,0)。</p><p>线性回归试图学得$f(x_i)=wx_i+b$ ，使得$f(x_i)\approx y_i$ ，</p><p><u><em>如何确定 $ω$ 和 $b$ 呢？显然，关键在于如何衡量$ f(x) $与 $y$ 之间的差别。</em></u></p><p>这时候需要用到均方误差了，也就是我们常说的”欧式距离“，我们可以通过让均方误差最小化来求解需要的$w,b$。即</p><script type="math/tex; mode=display">(w^*,b^*)=arg\min_{(w,b)}\sum^m_{i=1}(f(x_i)-y_i)^2=arg\min_{(w,b)}\sum^m_{i=1}(y_i-wx_i-b)^2</script><p>求解$w$和$b$使所有样本到一条直线上的欧氏距离之和最小，称为线性回归模型的最小二乘”参数估计” (parameter estimation).。我们可将上式对 $ω $和 $b$ 分别求导，得到</p><script type="math/tex; mode=display">\frac{\partial{E_{w,b}}}{\partial w}=2(w\sum^m_{i=1}x_i^2-\sum^m_{i=1}x_i(y_i-b))</script><script type="math/tex; mode=display">\frac{\partial{E_{w,b}}}{\partial b}=2(mb-\sum^m_{i=1}(y_i-wx_i))</script><p>令导数等于0可得到$w$和$b$最优解的闭式解：</p><script type="math/tex; mode=display">w=\frac{\sum^m_{i=1}y_i(x_i-\overline{x})}{\sum^m_{i=1}x_i^2-\frac{1}{m}(\sum^m_{i=1}x_i)^2}</script><script type="math/tex; mode=display">b=\frac{1}{m}\sum^m_{i=1}(y_i-wx_i)</script><p>其中$\overline{x}=\frac{1}{m}\sum^m_{i=1}x_i$为 $x$ 的均值。</p><p><strong>整理一下思路：线性回归要得到式子①，那么①里面的未知数怎么求，利用②式子最小二乘法求，通过对②求偏导等于0，来得到解，即式子③和式子④</strong></p><p>当我们的问题中存在的不止一个特征，我们称之为多元线性回归，形式与上述过程类似。<br>把$w,b$吸入向量模式，表示形式为$\hat{w}=(w;b)$，然后把数据集$D$表示为一个$m*(d+1)$的大小矩阵，前$d$行对应$d$个属性，最后一行元素置为$1$，即</p><script type="math/tex; mode=display">X=\left|    \begin{matrix}    x_{11} & x_{12} & \cdots & x_{1d} & 1\\    x_{21} & x_{22} & \cdots & x_{2d} & 1\\    \vdots & \vdots & \ddots & \vdots & \vdots\\    x_{m1} & x_{m2} & \cdots & x_{md} & 1 \\    \end{matrix}    \right|=\left|    \begin{matrix}    x_1^T &1\\    x_2^T &1\\    \vdots & \vdots\\    x_m^T &1\\    \end{matrix}    \right|</script><p>再把标记也写成向量形式$y=(y_1;y_2;…;y_m)$，则类似于单变量线性回归模型，有</p><script type="math/tex; mode=display">\hat{w}^*=argmin_{\hat{w}}(y-X\hat{w})^T{}(y-X\hat{w})</script><p>令$E_\hat{w}=(y-X\hat{w})^T{}(y-X\hat{w})$，对$\hat{w}$求导得到：</p><script type="math/tex; mode=display">\frac{\partial E_{\hat{w}}}{ \partial\hat w}=2X^T(X\hat w-y)</script><p>令上式为零可得 $\hat w$ 最优解的闭式解。假设当为满秩矩阵或正定矩阵时<script type="math/tex">\hat{w^*}=(X^TX)^{-1}X^Ty</script>，回归模型为<script type="math/tex">f(\hat{x_i})=\hat{x_i}(X^TX)^{-1}X^Ty</script>。<br> <strong>【注】现实任务往往<script type="math/tex">X^TX</script>不满秩，所以会有多个$\hat{w}$，此时结果由算法的学习偏好决定。</strong></p><p>下面说一下线性模型的变种，有时候我们的$y$和$x$之间不是线性变化，比如说y是跟随$x$呈现指数变化，这就导致了一个问题，$y=w<em>x+b$不能再表示他们之间的关系，那么这时候应该通过一个“<em>*联系函数</em></em>”，如上面我们举出来的例子，如果$y$和$wx+b$之间不再是线性而是指数变换，这是我们可以对$y$进行取对数操作</p><script type="math/tex; mode=display">ln y=w^Tx+b</script><p>这个取对的操作就相当于在原先的等式之间又加上了一个函数，这个函数我们就叫作联系函数，而我们把上面的式子叫做对数线性回归。<br> 我们再回味一下为什么这么做呢？因为$y$和$x$之间不再具有某种线性关系，取而代之的是一种指数关系，那我们怎么将这种指数关系表示出来呢？将$y$进行取对操作，这样$lny$又一次和$wx+b$呈现一种线性关系，这实际上是一种空间映射。这就是”对数线性回归” (log-linear regression) ，它实际上是在试图让 $e^{w^Tx+ b} $ 逼近 $y$。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220620162127816.png" alt="image-20220620162127816"></p><p>如上图所示，这里的对数函数起到了<u>将线性回归模型的预测值与真实标记联系起来的作用</u>。</p><p>更一般地，考虑单调可微函数$ g(.) $， 令</p><script type="math/tex; mode=display">y=g^{-1}(w^Tx+b)</script><p>$g(.) $连续且充分光滑，这样得到的模型称为”广义线性模型” (generalized linear model) ，其中函数$g(.)$ 称为”联系函数” (link function).。显然?，对数线性回归是广义线性模型在$g(.) = ln(.) $时的特例.</p><h3 id="3-3-对数几率回归"><a href="#3-3-对数几率回归" class="headerlink" title="3.3 对数几率回归"></a>3.3 对数几率回归</h3><p>——<strong>线性回归函数的变型</strong></p><p>这里的对数几率回归是我们经常见到的一种算法：logistic回归，虽然它叫做回归算法，但实际上它是一种分类算法。</p><p>上一节说的是如何使用线性模型进行回归学习，但是如何利用线性模型进行分类算法呢？这时候就需要我们的联系函数，只要能找到一个函数可以将预测值与真实标签联系起来就可以。</p><p>考虑二分类任务，其输出标记$y$是[0，1]之中的一个，但是线性模型$w*x+b$预测出来是一个实际的值，我们应该把值转换成$0/1$，</p><script type="math/tex; mode=display">y=\left\{\begin{array}{c}    0,z<0\\    0.5,z=0\\    1,z>0\end{array}\right.</script><p>即若预测值 $ z$ 大于零就判为正例，小于零则判为反例，预测值为临界值零则可任意判别，如图所示为单位阶跃函数与对数几率函数。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220620163011834.png" alt="image-20220620163011834"></p><p>从图中可看出单位阶跃函数并不连续，因此不能直接用作广义线性模型中的联系函数$g^-(.)$，于是我们用对数几率函数这种近似单位阶跃函数且单调可微的函数来作为其替代函数。</p><script type="math/tex; mode=display">y=\frac{1}{1+e^{-z}}</script><p>对数几率函数与对数函数是不同的，它是一种”Sigmod”函数，几率是什么意思呢？假设为正例的概率是$y$那么$y/1-y$就表示几率。</p><p>我们要时刻记住这个函数为什么出现在这里，他是为了<strong>将我们的输出转换成别的函数，这个对数几率函数将作为我们的联系函数</strong>。</p><p>我们将上一节讲的线性函数代入到对数几率函数中得到如下所示</p><script type="math/tex; mode=display">y=\frac{1}{1+e^{-(w^Tx+b)}}</script><p>进行变换之后我们将含$w$以及$b$的放在等式的一边，其余的放在另一边，如下所示</p><script type="math/tex; mode=display">ln\frac{y}{1-y}=w^Tx+b</script><p>由此可以看出，我们是在用线性回归模型的预测结果去逼近真实标记的对数几率(即几率的对数)，其中对数几率表示的是$x$做为正例的可能性。</p><p>那么如何求得<script type="math/tex">w,b</script>，这里用了<strong>极大似然法</strong>(推导就不列出来)。最后得到一个关于β的高阶可导连续凸函数</p><script type="math/tex; mode=display">l(β)=\sum_{i=1}^m(-y_iβ^T\hat{x_i}+\ln(1+e^{β^T\hat{x_i}}))</script><p>通过梯度下降法、牛顿法等都可求得这个函数的最优解<script type="math/tex">β^*=argmin_βl(β)</script>。</p><h3 id="3-4线性判别分析"><a href="#3-4线性判别分析" class="headerlink" title="3.4线性判别分析"></a>3.4线性判别分析</h3><p>——<strong>线性模型在多分类场景下的应用</strong></p><p><strong>线性判别分析（LDA）：设法将样例投到一条线上，同类样例尽可能接近，不同样例间尽可能远离，将新样例投到线上通过其位置来分类。</strong>简单点就是正例尽量投在一起，反例投一起，正反例尽可能远离，拿到新样例投上去看更接近哪。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220620171630343.png" alt="image-20220620171630343"></p><p>LDA 的二维示意图”+”、 “ “分别代表正例和反例，椭圆表示数据簇的外轮廓，虚线表示投影， 红色实心园和实心三角形分别表示两类样本投影后的中心点。</p><p>LDA常常用于二分类问题以及多分类的降维处理，我们先讲解关于二分类的问题。由于两类数据过于繁多，导致无法直接对数据属于哪一类进行判断，LDA的基本思想是对于两类数据，想办法将两类数据映射到一条合适的直线上，此时只需要找到直线上一个可以将两类数据分开到两边的点，就可以直观且简便地判断某个样本数据属于哪一类了。</p><p>但并不是所有直线都可以找到这个分界点，如下图所示，紫色与红色分别代表两类数据，左侧将两类数据的一部分映射到一起了显然增加了判断难度，右侧可以找到一个蓝色的点将两类数据区分开来,相对于左侧图像而言，右侧映射到直线的数据，具有类内尽可能聚集，不同类数据尽可能分散的特点，如何利用数学公式去描述这种特点，就是Linear Discriminant Analysis(LDA)的任务了。<br><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc2MjEz,size_16,color_FFFFFF,t_70.png" alt="img"></p><h4 id="二分类线性判别分析"><a href="#二分类线性判别分析" class="headerlink" title="二分类线性判别分析"></a><strong>二分类线性判别分析</strong></h4><p>首先需要理解映射的概念，具体内容在<a href="https://blog.csdn.net/qq_41876213/article/details/107695663">PCA降维的投影</a>部分中讲解过，简单来说，若单位向量$θ $是直线$l $上的单位向量，那么样本数据$x_i $在直线$l$上的投影距离为$\theta^Tx_i$。类别$k$的样本平均向量为</p><script type="math/tex; mode=display">u^k=\frac{1}{m^k}\sum^{m^k}_{i=1}x_i,k\in c</script><p><a href="https://blog.csdn.net/qq_41876213/article/details/108140335">详细推导过程及代码实现见链接</a></p><p>数据集<script type="math/tex">D=\{(x_i,y_i)\}_{i=1}^m,y_i\in\{0,1\}</script>，令<script type="math/tex">X_i、u_i、\sum{i}</script>分别表示<script type="math/tex">i\in\{0,1\}</script>类示例的集合、均值向量、协方差矩阵，$w$表示直线。<br> 线性判别分析有两个目标:①同类样例投影点尽可能接近，即同类投影点协方差<script type="math/tex">（w^T\sum{0w}+w^T\sum{1w}</script>  尽可能小，②异类尽可能远离，即类中心点之间的距离<script type="math/tex">||w^Tu_0-w^Tu_1||^2_2</script>尽可能大。所以同时还要考虑二者，则可以得到最大化目标</p><script type="math/tex; mode=display">J={\frac{||w^Tu_0-w^Tu_1||^2_2}{w^T\sum_0{w}+w^T\sum_{1}{w}}}={\frac{w^T{(u_0-u_1)}(u_0-u_1)^Tw}{w^T(\sum_0+\sum_1)w}})①</script><p> 定义“类内散度矩阵”</p><script type="math/tex; mode=display">S_w=\sum_0+\sum_1=\sum_{x∈X_0}(x-u_0)(x-u_0)^T+\sum_{x∈X_1}(x-u_1)(x-u_1)^T</script><p>定义“类间散度矩阵”</p><script type="math/tex; mode=display">S_b=(u_0-u_1)(u_0-u_1)^T</script><p> 将式子①重写为</p><script type="math/tex; mode=display">J=\frac{w^TS_bw}{w^TS_ww}</script><p>这就是LDA要求的最大化目标，即<script type="math/tex">S_b与S_w</script>的“广义瑞利商”。那么$w$怎么求呢？因为上式分子分母都有$w$二次项所以解$w$长度无关只和方向有关。由拉格朗日乘子式得</p><script type="math/tex; mode=display">S_bw={\lambda}S_ww</script><p>λ是拉格朗日乘子。</p><p>又因为$S_bw$方向衡为$u_0-u_1$，所以令<script type="math/tex">S_bw={\lambda}(u_0-u_1)</script>代入上式最终得$w=S_w^{-1}(u_0-u_1)$。</p><h4 id="多分类线性判别分析"><a href="#多分类线性判别分析" class="headerlink" title="多分类线性判别分析"></a>多分类线性判别分析</h4><p>假设存在$N$个类，且第$i$类示例数为$m_i$；</p><p>定义“全局散度矩阵”</p><script type="math/tex; mode=display">S_t=S_b+S_w=\sum_{i=1}^m(x_i-u)(x_i-u)^T①</script><p><strong>【注】$u$是所有示例的均值向量</strong><br>定义“每个类别的散度矩阵之和”</p><script type="math/tex; mode=display">S_w=\sum_{i=1}^NS_{w_i}②</script><p>**【注】<script type="math/tex">S_{w_i}=\sum_{x∈X_i}(x-u_i)(x-u_i)^T</script><br>由上式①和②得</p><script type="math/tex; mode=display">S_b=S_t-S_w=\sum_{i=1}^Nm_i(u_i-u)(u_i-u)^T</script><p>所以多分类LDA有多种实现方法，使用<script type="math/tex">S_b,S_t,S_w</script>任何两个就可以了。</p><h3 id="3-5-多分类学习"><a href="#3-5-多分类学习" class="headerlink" title="3.5 多分类学习"></a>3.5 多分类学习</h3><p>——<strong>线性模型在多分类场景下的应用</strong></p><p>多分类学习有两个思路。一种是将二分类学习方法推广到多分类，比如上一节讲到的LDA。另一种则是利用二分类的学习器来解决多分类问题。下面讨论第二种。</p><p>多分类学习的基本思路是“拆解法”，即将多分类任务拆为若干个二分类任务求解。</p><p><strong>拆解法步骤：</strong></p><p>1.通过拆分策略对问题进行【<strong>拆分】</strong>；</p><p>2.为拆分出的每个二分类任务【<strong>训练】</strong>一个分类器；</p><p>3.对各个分类器的结果进行【<strong>集成】</strong>，以获得多分类结果。</p><p>最经典的拆分策略有以下三种：</p><p>多分类学习有N个类别$C_1,C_2,…,C_N$，给定数据集$D={(x_1,y_1),…,(x_m,y_m)},y_i\in {C_1,…,C_n}$。</p><p><strong>［1］“一对一”（One vs One，简称OvO）</strong></p><p>将 N 个分类分别两两配对，从而【<strong>拆分】</strong>成 $N(N-1)/2$ 个二分类任务；【<strong>训练</strong>】时为了区分 $C_i$和 $C_j$ 这两个分类，这 $N(N-1)/2$ 个分类器中的一个将 $C_i$ 作为正例， $C_j $作为反例；测试时候将新样本同时提交给所有分类器，将得到 $N(N-1)/2$ 个分类结果，【<strong>集成】</strong>的方法是通过投票在这些结果中选出最终结果。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-437db32129fdc1d411ac560bfa0f8842_1440w.jpg" alt="img"></p><p><strong>［2］“一对其余”（One vs Rest，简称OvR）</strong></p><p>将N个分类中的一个类拿出来作为一个分类器的正例，其余均设置为反例，从而【拆分】成N个分类任务；【训练】得到N个分类结果；【集成】的方法是考虑各被判为正例的分类器的置信度，选择置信度大的类别标记作为分类的结果。（如果只有一个，直接选择）</p><p>我们看到OvO和OvR相比，前者要训练的分类器要多得多，因此存储和测试开销要相对多些。但是在训练时，因为前者每个分类器只使用部分数据，而后者要用全量数据，所以类别多时，OvO的训练开销要更小一些。</p><p>至于预测性能，则取决于数据分布，在多数情况下两者差不多。</p><p><strong>［3］“多对多”（Many vs Many，简称MvM）</strong></p><p>每次将若干个类别作为正类，若干个其它类作为反类。显然，OvO和OvR是MvM的特例。但其正反类的划分必须有特殊的设计，不能随意选取。一种最常用的MvM技术是：“纠错输出码”（Error Correcting Output Codes，简称ECOC）</p><p>ECOC过程主要分两步：</p><ul><li><p>编码：对N个类进行M次划分，产生M个分类器。</p></li><li><p>解码：M个分类器对测试样本进行预测，得到M个预测标记，将其组成编码；这个编码与N个类别各自的编码进行比较，返回其中距离最小的类别作为最终预测的结果。</p></li></ul><p>编码形式又分为二元码和三元码，前者指定“正类”、“反类”，后者又多一个“停用类”。</p><p>以二元ECOC码为例：如下图，首先，将<script type="math/tex">N(N=4)</script>个类通过设计构造成<script type="math/tex">M(M=5)</script>个分类器$(f_1,f_2,f_3,f_4,f_5)$，每个分类器为每个类分配了一个标记结果(-1/+1)，这样一来，每个类$C_i,i\in{1,N}$都获得了一个$M$位的编码，这个编码就是【各类所对应的编码】。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-2c27bcec29d2a98b0a4725775cb8b2c4_1440w.jpg" alt="img"></p><p>当有一个测试例$A$时，先将 A 依照次序放入 $M$ 个分类器中，得到了$ M$ 个分类标记结果$(-1，-1，+1，-1，+1)$；再将这 $M$ 个标记结果编成一个纠错输出码$（-1-1+1-1+1）$；最后去和【各类所对应的编码】进行比较海明距离或欧式距离，距离最短的对应编码对应的分类就是结果。（图中结果为 $C_3$）</p><p>海明距离：每个分类器对样本的分类结果如果和$C_1$类不一致，则计数加1，否则不加，结果为：0+1+1+1+0 = 3</p><p>欧式距离：每个分类器对样本的分类结果减去$C_1$类的分类划分，差值的平方和的开方，结果为：$\sqrt{( 0+4+4+4+0)}$ = $\sqrt12$ ＝<script type="math/tex">2\sqrt3</script></p><p>纠错输出码还有一个功能是为分类器的错误进行修正。比如正确的分类结果是$（-1，-1，+1，-1，+1）$，但如果分类器 $f_2$ 出了错误，得到的结果就是$（-1，+1，+1，-1，+1)$。但通过这一套编码，可以让最终的结果仍为$C_3$ 。</p><p>分类器越多，ECOC编码越长，纠错能力越强，但开销越大；而且，如果分类有限，那么可组合的数目也有限，码长超过一定程度，也没有意义了。</p><p>同等长度的编码，【各类所对应的编码】之间计算出的距离越远，编码的纠错能力越强，但当码长到达一定程度时，无法得出最优解。</p><p><a href="https://blog.csdn.net/lafengxiaoyu/article/details/107886065">ECOC编码详解</a></p><h3 id="3-6-类别不平衡问题"><a href="#3-6-类别不平衡问题" class="headerlink" title="3.6 类别不平衡问题"></a>3.6 类别不平衡问题</h3><p>——<strong>类别不平衡时的调优方案</strong></p><p>类别不平衡（class-imbalance），就是指分类任务中不同类别的训练样例数目差别很大的情况。例如有 998 个反例，但正例只有 2 个，那么学 习方法只需返回一个永远将新样本预测为反例的学习器，就能达到 99.8% 的精度；然而这样的学习器往往没有价值，因为它不能预测出任何正例。</p><p>目前类别不平衡性学习的一个基本策略是“再缩放”（rescaling），现有技术大体上有以下三种做法：</p><p><strong>［1］欠采样（undersampling）</strong></p><p>去除样例过多的类别中的一部分样例，使得正、反例数目接近。代表性算法EasyEnsemble，将反例划分为若干个集合供不同学习器使用，这样对每个学习器来看都进行了欠采样，但在全局来看却不会丢失重要信息。</p><p><strong>［2］过采样（oversampling）</strong></p><p>对样例少的类别增加数据，使得正、反例数目接近。过采样法不能简单地对初始正例样本进行重复采样，否则会招致严重的过拟合。代表性算法SMOTE是通过对训练集里的正例进行插值来产生额外的正例。</p><p><strong>［3］阈值移动（threshold-moving）</strong></p><p>一般我们对二分类法的正负值的判定阈值是基于中间值0.5来判断的，这是基于分类器认为真实正、反例可能性相同的认知下的判断，即分类器决策规则为：</p><p>若$ y / ( 1 - y ) &gt; 1$，则预测为正例②</p><p>然而，当训练集中正、反例不同时，令$m^+$表示正例数，$m^-$表示反例数，则观察几率为：$m^+/m^-$，这时我们应该改变分类器决策规则为：</p><p>若$ y / ( 1 - y ) &gt; m^+/m-$，则预测为正例③</p><p>将③代入②中，我们可以得到新的决策规则：</p><p>若</p><script type="math/tex; mode=display">\frac{ y'} { (1 - y') }= \frac{y} {(1 - y)} \times \frac{m^-}{m^+} > 1</script><p>则预测为正例</p><p>这种在用训练好的分类器进行预测时，将决策规则根据数据分布来进行移动的方法就是阈值移动。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>［1］线性模型是一个形式简单、易于建模的机器学习模型，因为$w$直观表达了各属性在预测中的重要性，因此线性模型有很好的可解释性</p><p>［2］线性回归背后的逻辑是用模型的预测值去逼近真实标记$y$，并通过计算训练样本在向量空间上距离模型线的欧式距离之和的最小值来确定参数$w和b$</p><p>［3］线性回归可写成广义线性模型形式：$g(y) = wx + b$，通过选择不同的联系函数$g(.)$会构成不同的线性回归模型</p><p>［4］在遇到多分类学习任务时，基本的解决思路是“拆解法”，即将多分类任务拆为若干个二分类任务求解</p><p>［5］当不同类别的样例数不同时，会造成类别不平衡问题，解决该问题的基本策略是对数据进行“再缩放”</p><h3 id="3-7-习题"><a href="#3-7-习题" class="headerlink" title="3.7 习题"></a>3.7 习题</h3><p><a href="https://www.jianshu.com/p/49ef509ef874">习题答案</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarDown使用教程</title>
    <link href="/2022/06/16/MarkDown%E6%95%99%E7%A8%8B/"/>
    <url>/2022/06/16/MarkDown%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="MarkDown基础"><a href="#MarkDown基础" class="headerlink" title="MarkDown基础"></a>MarkDown基础</h1><p><a href="https://www.bilibili.com/video/av87982836#reply2366896129">基础篇视频讲解链接</a><br><a href="https://www.bilibili.com/video/av88551739/">画图篇视频讲解链接</a></p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 标题名字（井号的个数代表标题的级数）</span><br></code></pre></td></tr></table></figure><p>快捷键（<strong>⌘ + 数字</strong>）</p><h1 id="一级标题使用1个"><a href="#一级标题使用1个" class="headerlink" title="一级标题使用1个"></a>一级标题使用1个</h1><h2 id="二级标题使用2个"><a href="#二级标题使用2个" class="headerlink" title="二级标题使用2个"></a>二级标题使用2个</h2><h3 id="三级标题使用3个"><a href="#三级标题使用3个" class="headerlink" title="三级标题使用3个"></a>三级标题使用3个</h3><h4 id="四级标题使4用个"><a href="#四级标题使4用个" class="headerlink" title="四级标题使4用个"></a>四级标题使4用个</h4><h5 id="五级标题使用5个"><a href="#五级标题使用5个" class="headerlink" title="五级标题使用5个"></a>五级标题使用5个</h5><h6 id="六级标题使用6个"><a href="#六级标题使用6个" class="headerlink" title="六级标题使用6个"></a>六级标题使用6个</h6><h6 id="最多支持六级标题"><a href="#最多支持六级标题" class="headerlink" title="# 最多支持六级标题"></a># 最多支持六级标题</h6><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><h3 id="删除线（-⇧-）"><a href="#删除线（-⇧-）" class="headerlink" title="删除线（^ + ⇧ + `）"></a>删除线<strong>（^ + ⇧ + `）</strong></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这就是 ~~删除线~~ (使用波浪号)<br></code></pre></td></tr></table></figure><p>这就是 <del>删除线</del> (使用波浪号)</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 <span class="hljs-emphasis">*斜体*</span> 的 <span class="hljs-emphasis">_文本_</span><br></code></pre></td></tr></table></figure><p>这是用来 <em>斜体</em> 的 _文本_</p><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 <span class="hljs-strong">**加粗**</span> 的 <span class="hljs-strong">__文本__</span><br></code></pre></td></tr></table></figure><p>这是用来 <strong>加粗</strong> 的 <strong>文本</strong></p><h3 id="斜体-加粗（加粗⌘-b-斜体⌘-i）"><a href="#斜体-加粗（加粗⌘-b-斜体⌘-i）" class="headerlink" title="斜体+加粗（加粗⌘+b, 斜体⌘+i）"></a>斜体+加粗<strong>（加粗⌘+b, 斜体⌘+i）</strong></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 <span class="hljs-strong">**<span class="hljs-emphasis">*斜体+加粗*</span>**</span> 的 <span class="hljs-strong">__<span class="hljs-emphasis">_文本_</span>__</span><br></code></pre></td></tr></table></figure><p>这是用来 <strong><em>斜体+加粗</em></strong> 的 <strong>_文本_</strong></p><h3 id="下划线（⌘-u）"><a href="#下划线（⌘-u）" class="headerlink" title="下划线（⌘ + u）"></a>下划线<strong>（⌘ + u）</strong></h3><p>下划线是HTML语法</p><p><code>下划线</code> <u>下划线(快捷键<code>command</code>+<code>u</code>，视频中所有的快捷键都是针对Mac系统，其他系统可自行查找)</u></p><h3 id="高亮（需勾选扩展语法）"><a href="#高亮（需勾选扩展语法）" class="headerlink" title="高亮（需勾选扩展语法）"></a>高亮（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 ==斜体+加粗== 的文本<br></code></pre></td></tr></table></figure><p>这是用来 ==斜体+加粗== 的文本</p><h3 id="下标（需勾选扩展语法）"><a href="#下标（需勾选扩展语法）" class="headerlink" title="下标（需勾选扩展语法）"></a>下标（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">水 H~2~O <br>双氧水 H~2~O~2~ <br></code></pre></td></tr></table></figure><p>水 H~2~O </p><p>双氧水 H~2~O~2~</p><h3 id="上标（需勾选扩展语法）"><a href="#上标（需勾选扩展语法）" class="headerlink" title="上标（需勾选扩展语法）"></a>上标（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">面积 m^2^ <br>体积 m^3^<br></code></pre></td></tr></table></figure><p>面积 m^2^<br>体积 m^3^</p><h3 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h3><p> Emoji 支持表情符号，你可以用系统默认的 Emoji 符号（ Windows 用户不一定支持，自己试下~）。 也可以用图片的表情，输入 <code>:</code> 将会出现智能提示。  </p><h4 id="一些表情例子"><a href="#一些表情例子" class="headerlink" title="一些表情例子"></a>一些表情例子</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">:smile: :laughing: :dizzy<span class="hljs-emphasis">_face: :sob: :cold_</span>sweat: :sweat<span class="hljs-emphasis">_smile:  :cry: :triumph: :heart_</span>eyes: :relaxed: :sunglasses: :weary:<br><br>:+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat<span class="hljs-emphasis">_drops: :hankey: :exclamation: :anger:</span><br><span class="hljs-emphasis"></span><br></code></pre></td></tr></table></figure><p>:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile:  :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary: :+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger:</p><p>(  Mac: <code>control</code>+<code>command</code>+<code>space</code>点选)</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><h2 id="快速生成表格（⌘-⌥-T）"><a href="#快速生成表格（⌘-⌥-T）" class="headerlink" title="快速生成表格（⌘ + ⌥ + T）"></a><strong>快速生成表格（⌘ + ⌥ + T）</strong></h2><h2 id="按行选中（⌘-l）"><a href="#按行选中（⌘-l）" class="headerlink" title="按行选中（⌘ + l）"></a><strong>按行选中（⌘ + l）</strong></h2><p>使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">name | price<br>--- | ---<br>fried chicken | 19<br>cola|5<br></code></pre></td></tr></table></figure><blockquote><p>为了使 Markdown 更清晰，<code>|</code> 和 <code>-</code> 两侧需要至少有一个空格（最左侧和最右侧的 <code>|</code> 外就不需要了）。</p></blockquote><div class="table-container"><table><thead><tr><th>name</th><th>price</th></tr></thead><tbody><tr><td>fried chicken</td><td>19</td></tr><tr><td>cola</td><td>5</td></tr></tbody></table></div><p>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 <code>|</code> 来标记单元格边界，在表头下方的分隔线标记中加入 <code>:</code>，即可标记下方单元格内容的对齐方式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">|    name       | price |<br>| :------------ | :---: |<br>| fried chicken | 19    |<br>| cola          |  32   |<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">name</th><th style="text-align:center">price</th></tr></thead><tbody><tr><td style="text-align:left">fried chicken</td><td style="text-align:center">19</td></tr><tr><td style="text-align:left">cola</td><td style="text-align:center">32</td></tr></tbody></table></div><p>使用快捷键<code>command</code>+<code>opt</code>+<code>T</code>更方便(段落→表格→插入表格，即可查看快捷键)</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;“后悔创业”<br></code></pre></td></tr></table></figure><blockquote><p>“后悔创业”</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;也可以在引用中<br>&gt;&gt;使用嵌套的引用<br></code></pre></td></tr></table></figure><blockquote><p>也可以在引用中</p><blockquote><p>使用嵌套的引用</p></blockquote></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表—符号-空格（⌥-⌘-u）"><a href="#无序列表—符号-空格（⌥-⌘-u）" class="headerlink" title="无序列表—符号 空格（⌥ + ⌘ + u）"></a>无序列表—符号 空格<strong>（⌥ + ⌘ + u）</strong></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 可以使用 <span class="hljs-code">`*`</span> 作为标记<br><span class="hljs-bullet">+</span> 也可以使用 <span class="hljs-code">`+`</span><br><span class="hljs-bullet">-</span> 或者 <span class="hljs-code">`-`</span><br></code></pre></td></tr></table></figure><ul><li>可以使用 <code>*</code> 作为标记</li></ul><ul><li>也可以使用 <code>+</code></li></ul><ul><li>或者 <code>-</code></li></ul><h3 id="有序列表—数字-空格（⌥-⌘-o）"><a href="#有序列表—数字-空格（⌥-⌘-o）" class="headerlink" title="有序列表—数字 . 空格（⌥ + ⌘ + o）"></a>有序列表—数字 <code>.</code> 空格<strong>（⌥ + ⌘ + o）</strong></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 有序列表以数字和 <span class="hljs-code">`.`</span> 开始；<br><span class="hljs-bullet">3.</span> 数字的序列并不会影响生成的列表序列；<br><span class="hljs-bullet">4.</span> 但仍然推荐按照自然顺序（1.2.3...）编写。<br></code></pre></td></tr></table></figure><ol><li><p>有序列表以数字和 <code>.</code> 开始；</p></li><li><p>数字的序列并不会影响生成的列表序列；</p></li><li><p>但仍然推荐按照自然顺序（1.2.3…）编写。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">可以使用：数字\. 来取消显示为列表（用反斜杠进行转义）<br></code></pre></td></tr></table></figure></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码块（⌘-⌥-c）"><a href="#代码块（⌘-⌥-c）" class="headerlink" title="代码块（⌘ + ⌥ + c）"></a>代码块<strong>（⌘ + ⌥ + c）</strong></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">```语言名称</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">也可以通过 <span class="hljs-code">``，插入行内代码（`</span> 是 <span class="hljs-code">`Tab`</span> 键上边、数字 <span class="hljs-code">`1`</span> 键左侧的那个按键）：<br><br>例如 <span class="hljs-code">`Markdown`</span><br></code></pre></td></tr></table></figure><p><code>Markdown</code></p><h3 id="公式块（⌘-⌥-b）"><a href="#公式块（⌘-⌥-b）" class="headerlink" title="公式块（⌘ + ⌥ + b）"></a>公式块（⌘ + ⌥ + b）</h3><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><p>代码块中的文本（包括 Markdown 语法）都会显示为原始内容</p><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>可以在一行中使用三个或更多的 <code>*</code>、<code>-</code> 或 <code>_</code> 来添加分隔线（``）：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-section">------</span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-section">___</span></span></span><br></code></pre></td></tr></table></figure><hr><hr><hr><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>跳转至文章开头<strong><em>（⌘ + 向上箭头）\</em></strong><br>跳转至文章结尾<strong><em>（⌘ + 向下箭头）\</em></strong></p><h3 id="外部跳转—超链接"><a href="#外部跳转—超链接" class="headerlink" title="外部跳转—超链接"></a>外部跳转—超链接</h3><p>格式为 <code>[link text](link)</code>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">帮助文档</span>](<span class="hljs-link">https://support.typora.io/Links/#faq</span>)<br></code></pre></td></tr></table></figure><p><a href="https://support.typora.io/Links/#faq">帮助文档</a></p><h3 id="内部跳转—本文件内跳（Typora支持）"><a href="#内部跳转—本文件内跳（Typora支持）" class="headerlink" title="内部跳转—本文件内跳（Typora支持）"></a>内部跳转—本文件内跳（Typora支持）</h3><p>格式为 <code>[link text](#要去的目的地--标题）</code>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">我想跳转</span>](<span class="hljs-link">#饼图（Pie）</span>)<br></code></pre></td></tr></table></figure><blockquote><p>Open Links in Typora</p><p>You can use <code>command+click</code> (macOS), or <code>ctrl+click</code> (Linux/Windows) on links in Typora to jump to target headings, or open them in Typora, or open in related apps.</p></blockquote><p><a href="#饼图（Pie）">我想跳转</a></p><h3 id="自动链接（⌘-k）"><a href="#自动链接（⌘-k）" class="headerlink" title="自动链接（⌘ + k）"></a>自动链接<strong>（⌘ + k）</strong></h3><p>使用 <code>&lt;&gt;</code> 包括的 URL 或邮箱地址会被自动转换为超链接：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml">&lt;https://www.baidu.com&gt;</span><br><br>&lt;123@email.com&gt;<br></code></pre></td></tr></table></figure><p><a href="https://www.baidu.com">https://www.baidu.com</a></p><p><a href="mailto:123@email.com">123@email.com</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">自己起的图片名字</span>](<span class="hljs-link">图片地址或者图片本地存储的路径</span>)<br></code></pre></td></tr></table></figure><h3 id="网上的图片"><a href="#网上的图片" class="headerlink" title="网上的图片"></a>网上的图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">friedChicken</span>](<span class="hljs-link">https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg</span>)<br></code></pre></td></tr></table></figure><p><img src="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg" alt="炸鸡"></p><h3 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">friedChicken</span>](<span class="hljs-link">friedChicken.jpg</span>)<br>在同一个文件夹里（用相对路径）<br>或者直接拷贝<br></code></pre></td></tr></table></figure><h2 id="利用Markdown画图（需勾选扩展语法）"><a href="#利用Markdown画图（需勾选扩展语法）" class="headerlink" title="利用Markdown画图（需勾选扩展语法）"></a>利用Markdown画图（需勾选扩展语法）</h2><p>markdown画图也是轻量级的，功能并不全。</p><p>Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。Mermaid 作为一个使用 JS 渲染的库，生成的不是一个“图片”，而是一段 HTML 代码。</p><p>（不同的编辑器渲染的可能不一样）</p><h3 id="流程图-graph"><a href="#流程图-graph" class="headerlink" title="流程图(graph)"></a>流程图(graph)</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph 方向描述<br><span class="hljs-code">    图表中的其他语句...</span><br></code></pre></td></tr></table></figure><p>关键字graph表示一个流程图的开始，同时需要指定该图的方向。</p><p>其中“方向描述”为：</p><div class="table-container"><table><thead><tr><th style="text-align:left">用词</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">TB</td><td style="text-align:left">从上到下</td></tr><tr><td style="text-align:left">BT</td><td style="text-align:left">从下到上</td></tr><tr><td style="text-align:left">RL</td><td style="text-align:left">从右到左</td></tr><tr><td style="text-align:left">LR</td><td style="text-align:left">从左到右</td></tr></tbody></table></div><blockquote><p>T = TOP，B = BOTTOM，L = LEFT，R = RIGHT，D = DOWN</p></blockquote><p>最常用的布局方向是TB、LR。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB;<br>  A--&gt;B<br>  B--&gt;C<br>  C--&gt;A<br> <br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB;  A--&gt;B  B--&gt;C  C--&gt;A</code></pre><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph LR;<br>  A--&gt;B<br>  B--&gt;C<br>  C--&gt;A<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph LR;  A--&gt;B  B--&gt;C  C--&gt;A</code></pre><h4 id="流程图常用符号及含义"><a href="#流程图常用符号及含义" class="headerlink" title="流程图常用符号及含义"></a>流程图常用符号及含义</h4><h5 id="节点形状"><a href="#节点形状" class="headerlink" title="节点形状"></a>节点形状</h5><div class="table-container"><table><thead><tr><th style="text-align:left">表述</th><th style="text-align:left">说明</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:left">id[文字]</td><td style="text-align:left">矩形节点</td><td>表示过程，也就是整个流程中的一个环节</td></tr><tr><td style="text-align:left">id(文字)</td><td style="text-align:left">圆角矩形节点</td><td>表示开始和结束</td></tr><tr><td style="text-align:left">id((文字))</td><td style="text-align:left">圆形节点</td><td>表示连接。为避免流程过长或有交叉，可将流程切开。成对</td></tr><tr><td style="text-align:left">id{文字}</td><td style="text-align:left">菱形节点</td><td>表示判断、决策</td></tr><tr><td style="text-align:left">id&gt;文字]</td><td style="text-align:left">右向旗帜状节点</td></tr></tbody></table></div><p><strong>单向箭头线段</strong>：表示流程进行方向</p><blockquote><p>id即为节点的唯一标识，A~F 是当前节点名字，类似于变量名，画图时便于引用</p><p>括号内是节点中要显示的文字，默认节点的名字和显示的文字都为A</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br>  A<br>  B(圆角矩形节点)<br>  C[矩形节点]<br>  D((圆形节点))<br>  E&#123;菱形节点&#125;<br>  F&gt;右向旗帜状节点] <br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB  A  B(圆角矩形节点)  C[矩形节点]  D((圆形节点))  E&#123;菱形节点&#125;  F&gt;右向旗帜状节点]</code></pre><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br><span class="hljs-code">    begin(出门)--&gt; buy[买炸鸡]</span><br><span class="hljs-code">    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;</span><br><span class="hljs-code">    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家)</span><br><span class="hljs-code">    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack</span><br><span class="hljs-code">    </span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB    begin(出门)--&gt; buy[买炸鸡]    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家)    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack    </code></pre><h5 id="连线"><a href="#连线" class="headerlink" title="连线"></a>连线</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br>  A1--&gt;B1<br>  A2---B2<br>  A3--text---B3<br>  A4--text--&gt;B4<br>  A5-.-B5<br>  A6-.-&gt;B6<br>  A7-.text.-B7<br>  A8-.text.-&gt;B8<br>  A9===B9<br>  A10==&gt;B10<br>  A11==text===B11<br>  A12==text==&gt;B12<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB  A1--&gt;B1  A2---B2  A3--text---B3  A4--text--&gt;B4  A5-.-B5  A6-.-&gt;B6  A7-.text.-B7  A8-.text.-&gt;B8  A9===B9  A10==&gt;B10  A11==text===B11  A12==text==&gt;B12</code></pre><pre><code class=" mermaid">graph TB A ---B</code></pre><h5 id="子图表"><a href="#子图表" class="headerlink" title="子图表"></a>子图表</h5><p>使用以下语法添加子图表</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">subgraph 子图表名称<br><span class="hljs-code">    子图表中的描述语句...</span><br><span class="hljs-code">end</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br><span class="hljs-code">  subgraph 买炸鸡前</span><br><span class="hljs-code">    begin(出门)--&gt; buy[出门买炸鸡]</span><br><span class="hljs-code">    end</span><br><span class="hljs-code">    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;</span><br><span class="hljs-code">    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack(回家)</span><br><span class="hljs-code">    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB  subgraph 买炸鸡前    begin(出门)--&gt; buy[出门买炸鸡]    end    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack(回家)    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack</code></pre><h3 id="序列图-sequence-diagram"><a href="#序列图-sequence-diagram" class="headerlink" title="序列图(sequence diagram)"></a>序列图(sequence diagram)</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram <br><span class="hljs-code">[参与者1][消息线][参与者2]:消息体</span><br><span class="hljs-code">    ...</span><br></code></pre></td></tr></table></figure><blockquote><p><code>sequenceDiagram</code> 为每幅时序图的固定开头</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">Title: 买炸鸡</span><br><span class="hljs-code">    救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？</span><br><span class="hljs-code">    炸鸡店小哥--&gt;&gt;救救: 没有，要现炸</span><br><span class="hljs-code"></span><br><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagramTitle: 买炸鸡    救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？    炸鸡店小哥--&gt;&gt;救救: 没有，要现炸</code></pre><h4 id="参与者（participant）"><a href="#参与者（participant）" class="headerlink" title="参与者（participant）"></a>参与者（participant）</h4><p>传统时序图概念中参与者有角色和类对象之分，但这里我们不做此区分，用参与者表示一切参与交互的事物，可以是人、类对象、系统等形式。中间竖直的线段从上至下表示时间的流逝。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 参与者 1</span><br><span class="hljs-code">    participant 参与者 2</span><br><span class="hljs-code">    ...</span><br><span class="hljs-code">    participant 简称 as 参与者 3 #该语法可以在接下来的描述中使用简称来代替参与者 3</span><br></code></pre></td></tr></table></figure><blockquote><p><code>participant &lt;参与者名称&gt;</code> 声明参与者，语句次序即为参与者横向排列次序。</p></blockquote><h4 id="消息线"><a href="#消息线" class="headerlink" title="消息线"></a>消息线</h4><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-&gt;</td><td style="text-align:left">无箭头的实线</td></tr><tr><td style="text-align:left">—&gt;</td><td style="text-align:left">无箭头的虚线</td></tr><tr><td style="text-align:left">-&gt;&gt;</td><td style="text-align:left">有箭头的实线（主动发出消息）</td></tr><tr><td style="text-align:left">–-&gt;&gt;</td><td style="text-align:left">有箭头的虚线（响应）</td></tr><tr><td style="text-align:left">-x</td><td style="text-align:left">末端为叉的实线（表示异步）</td></tr><tr><td style="text-align:left">—x</td><td style="text-align:left">末端为叉的虚线（表示异步）</td></tr></tbody></table></div><h4 id="处理中-激活框"><a href="#处理中-激活框" class="headerlink" title="处理中-激活框"></a>处理中-激活框</h4><p>从消息接收方的时间线上标记一小段时间，表示对消息进行处理的时间间隔。</p><p>在消息线末尾增加 <code>+</code> ，则消息接收者进入当前消息的“处理中”状态；<br>在消息线末尾增加 <code>-</code> ，则消息接收者离开当前消息的“处理中”状态。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="hljs-code">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="hljs-code">    99 -x +seller:给我炸！</span><br><span class="hljs-code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -x +seller:给我炸！    seller --&gt;&gt; -99: 您的炸鸡好了！    </code></pre><h4 id="注解（note）"><a href="#注解（note）" class="headerlink" title="注解（note）"></a>注解（note）</h4><p>语法如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Note 位置表述 参与者: 标注文字<br></code></pre></td></tr></table></figure><p>其中位置表述可以为</p><div class="table-container"><table><thead><tr><th style="text-align:left">表述</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">right of</td><td style="text-align:left">右侧</td></tr><tr><td style="text-align:left">left of</td><td style="text-align:left">左侧</td></tr><tr><td style="text-align:left">over</td><td style="text-align:left">在当中，可以横跨多个参与者</td></tr></tbody></table></div><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    Note over 99,seller : 热爱炸鸡</span><br><span class="hljs-code">    Note left of 99 : 女</span><br><span class="hljs-code">    Note right of seller : 男</span><br><span class="hljs-code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="hljs-code">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="hljs-code">    99 -x +seller : 给我炸！</span><br><span class="hljs-code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br><span class="hljs-code"></span><br><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    Note over 99,seller : 热爱炸鸡    Note left of 99 : 女    Note right of seller : 男    99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -x +seller : 给我炸！    seller --&gt;&gt; -99: 您的炸鸡好了！</code></pre><h4 id="循环（loop）"><a href="#循环（loop）" class="headerlink" title="循环（loop）"></a>循环（loop）</h4><p>在条件满足时，重复发出消息序列。（相当于编程语言中的 while 语句。）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">   </span><br><span class="hljs-code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="hljs-code">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="hljs-code">    99 -&gt;&gt; +seller:给我炸！</span><br><span class="hljs-code">    loop 三分钟一次</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 我的炸鸡好了吗？</span><br><span class="hljs-code">        seller --&gt;&gt; 99 : 正在炸</span><br><span class="hljs-code">    end</span><br><span class="hljs-code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥       99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -&gt;&gt; +seller:给我炸！    loop 三分钟一次        99 -&gt;&gt; seller : 我的炸鸡好了吗？        seller --&gt;&gt; 99 : 正在炸    end    seller --&gt;&gt; -99: 您的炸鸡好了！</code></pre><h4 id="选择（alt）"><a href="#选择（alt）" class="headerlink" title="选择（alt）"></a>选择（alt）</h4><p>在多个条件中作出判断，每个条件将对应不同的消息序列。（相当于 if 及 else if 语句。）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram    <br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？</span><br><span class="hljs-code">    seller --&gt;&gt; 99 : 可卖的炸鸡数</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    alt 可卖的炸鸡数 &gt; 3</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 买三只！</span><br><span class="hljs-code">    else 1 &lt; 可卖的炸鸡数 &lt; 3</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 有多少买多少</span><br><span class="hljs-code">    else 可卖的炸鸡数 &lt; 1</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 那我明天再来</span><br><span class="hljs-code">    end</span><br><span class="hljs-code"></span><br><span class="hljs-code">    seller --&gt;&gt; 99 : 欢迎下次光临</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram        participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？    seller --&gt;&gt; 99 : 可卖的炸鸡数        alt 可卖的炸鸡数 &gt; 3        99 -&gt;&gt; seller : 买三只！    else 1 &lt; 可卖的炸鸡数 &lt; 3        99 -&gt;&gt; seller : 有多少买多少    else 可卖的炸鸡数 &lt; 1        99 -&gt;&gt; seller : 那我明天再来    end    seller --&gt;&gt; 99 : 欢迎下次光临</code></pre><h4 id="可选（opt）"><a href="#可选（opt）" class="headerlink" title="可选（opt）"></a>可选（opt）</h4><p>在某条件满足时执行消息序列，否则不执行。相当于单个分支的 if 语句。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    99 -&gt;&gt; seller : 买炸鸡</span><br><span class="hljs-code">    opt 全都卖完了</span><br><span class="hljs-code">        seller --&gt;&gt; 99 : 下次再来</span><br><span class="hljs-code">    end</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller : 买炸鸡    opt 全都卖完了        seller --&gt;&gt; 99 : 下次再来    end</code></pre><h4 id="并行（Par）"><a href="#并行（Par）" class="headerlink" title="并行（Par）"></a>并行（Par）</h4><p>将消息序列分成多个片段，这些片段并行执行。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br>   participant 99 as 救救<br>   participant seller as 炸鸡店小哥<br>   <br><span class="hljs-code">    99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！</span><br><span class="hljs-code"></span><br><span class="hljs-code">    par 并行执行</span><br><span class="hljs-code">        seller -&gt;&gt; seller : 装可乐</span><br><span class="hljs-code">    and</span><br><span class="hljs-code">        seller -&gt;&gt; seller : 炸炸鸡</span><br><span class="hljs-code">    end</span><br><span class="hljs-code"></span><br><span class="hljs-code">    seller --&gt;&gt; 99 : 您的炸鸡好了！</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram   participant 99 as 救救   participant seller as 炸鸡店小哥       99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！    par 并行执行        seller -&gt;&gt; seller : 装可乐    and        seller -&gt;&gt; seller : 炸炸鸡    end    seller --&gt;&gt; 99 : 您的炸鸡好了！</code></pre><h3 id="饼图（Pie）"><a href="#饼图（Pie）" class="headerlink" title="饼图（Pie）"></a>饼图（Pie）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">pie<br><span class="hljs-code">    title Pie Chart</span><br><span class="hljs-code">    &quot;Dogs&quot; : 386</span><br><span class="hljs-code">    &quot;Cats&quot; : 85</span><br><span class="hljs-code">    &quot;Rats&quot; : 150 </span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">pie    title Pie Chart    &quot;Dogs&quot; : 386    &quot;Cats&quot; : 85    &quot;Rats&quot; : 150     &quot;panda&quot; : 200</code></pre><blockquote><p><a href="http://support.typora.io/Draw-Diagrams-With-Markdown/">Typora支持mermaid的官方链接</a></p></blockquote><h3 id="甘特图（gantt）"><a href="#甘特图（gantt）" class="headerlink" title="甘特图（gantt）"></a>甘特图（gantt）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"> title 标题<br>dateFormat 日期格式<br>section 部分名<br>任务名:参数一, 参数二, 参数三, 参数四，参数五<br><br> //参数一：crit（是否重要，红框框） 或者 不填<br> //参数二：done（已完成）、active（正在进行） 或者 不填(表示为待完成状态)<br> //参数三：取小名 或者 不填<br> //参数四：任务开始时间<br> //参数五：任务结束时间<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://mermaid-js.github.io/mermaid/#/gantt">官方教程</a></p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gantt</span><br>       <span class="hljs-attribute">dateFormat</span>  YYYY-MM-DD<br>       <span class="hljs-attribute">title</span> Adding GANTT diagram functionality to mermaid<br><br>       <span class="hljs-attribute">section</span> A section<br>       <span class="hljs-attribute">Completed</span> task            :done,    des1, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span>,<span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">08</span><br>       <span class="hljs-attribute">Active</span> task               :active,  des2, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">09</span>, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Future</span> task               :         des3, after des2, <span class="hljs-number">5</span>d<br>       <span class="hljs-attribute">Future</span> task2              :         des4, after des3, <span class="hljs-number">5</span>d<br><br>       <span class="hljs-attribute">section</span> Critical tasks<br>       <span class="hljs-attribute">Completed</span> task in the critical line :crit, done, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span>,<span class="hljs-number">24</span>h<br>       <span class="hljs-attribute">Implement</span> parser and jison          :crit, done, after des1, <span class="hljs-number">2</span>d<br>       <span class="hljs-attribute">Create</span> tests for parser             :crit, active, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Future</span> task in critical line        :crit, <span class="hljs-number">5</span>d<br>       <span class="hljs-attribute">Create</span> tests for renderer           :<span class="hljs-number">2</span>d<br>       <span class="hljs-attribute">Add</span> to mermaid                      :<span class="hljs-number">1</span>d<br><br>       <span class="hljs-attribute">section</span> Documentation<br>       <span class="hljs-attribute">Describe</span> gantt syntax               :active, a1, after des1, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Add</span> gantt diagram to demo page      :after a1  , <span class="hljs-number">20</span>h<br>       <span class="hljs-attribute">Add</span> another diagram to demo page    :doc1, after a1  , <span class="hljs-number">48</span>h<br><br>       <span class="hljs-attribute">section</span> Last section<br>       <span class="hljs-attribute">Describe</span> gantt syntax               :after doc1, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Add</span> gantt diagram to demo page      :<span class="hljs-number">20</span>h<br>       <span class="hljs-attribute">Add</span> another diagram to demo page    :<span class="hljs-number">48</span>h<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">gantt       dateFormat  YYYY-MM-DD       title Adding GANTT diagram functionality to mermaid       section A section       Completed task            :done,    des1, 2014-01-06,2014-01-08       Active task               :active,  des2, 2014-01-09, 3d       Future task               :         des3, after des2, 5d       Future task2              :         des4, after des3, 5d       section Critical tasks       Completed task in the critical line :crit, done, 2014-01-06,24h       Implement parser and jison          :crit, done, after des1, 2d       Create tests for parser             :crit, active, 3d       Future task in critical line        :crit, 5d       Create tests for renderer           :2d       Add to mermaid                      :1d       section Documentation       Describe gantt syntax               :active, a1, after des1, 3d       Add gantt diagram to demo page      :after a1  , 20h       Add another diagram to demo page    :doc1, after a1  , 48h       section Last section       Describe gantt syntax               :after doc1, 3d       Add gantt diagram to demo page      :20h       Add another diagram to demo page    :48h</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Labview</title>
    <link href="/2022/06/16/Labiew/"/>
    <url>/2022/06/16/Labiew/</url>
    
    <content type="html"><![CDATA[<h2 id="如何动态选择曲线可见性"><a href="#如何动态选择曲线可见性" class="headerlink" title="如何动态选择曲线可见性"></a>如何动态选择曲线可见性</h2><p>利用属性节点。首先找到属性节点，活动曲线。</p><p>首先给大家说明一下，LV里面，不管是列表框，还是表格，都会有一个活动单元格，活动曲线之类的。</p><p>你要操作某一个单元格或者曲线，首先你得让这个 单元格或者曲线变为活动单元格，然后才可以操纵活动单元格的属性。</p><p>所以，<u>活动XX的，一定要在前面板中设置，不然你的属性，都是默认是对曲线0或者单元格0做的设置。</u></p><p>下面是用来设置曲线显示的方法，用了一个循环，集体设置属性。这个<u>最好放到一个事件结构里，避免反复轮询控件而降低程序使用效率</u>。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709163115081-20220709163143790-20220709163149596.png" alt="image-20220709163115081"></p><h2 id="错误簇的使用"><a href="#错误簇的使用" class="headerlink" title="错误簇的使用"></a>错误簇的使用</h2><p>错误簇其实就是一个簇，里面放了三个控件，一个布尔，一个代码，一个源。</p><p>按名称解绑簇 ，提取了错误簇里的 status元素。这个元素如果是真，表示有错误发生，可以用来停止while循环。</p><p>当然也有人利用错误簇强制vi执行顺序的，毕竟LabVIEW是数据流的编程。</p><p><strong>LabVIEW自带有一些函数是有错误，仍旧执行，可以通过查看帮助文档看相关介绍</strong></p><h2 id="串口读取问题"><a href="#串口读取问题" class="headerlink" title="串口读取问题"></a>串口读取问题</h2><h4 id="用属性节点得到缓冲字节数"><a href="#用属性节点得到缓冲字节数" class="headerlink" title="用属性节点得到缓冲字节数"></a>用属性节点得到缓冲字节数</h4><p>读取缓冲区字节数这个“<strong>黄金组合</strong>”时，前面要加延时等待，等待仪器响应，等待缓冲区收到数据。如下图画圈地方所示。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709163245461.png" alt="image-20220709163245461"></p><h4 id="保证串口接收数据的完整性"><a href="#保证串口接收数据的完整性" class="headerlink" title="保证串口接收数据的完整性"></a>保证串口接收数据的完整性</h4><p>串口这块逻辑都是一样的，收到数据很容易，重点在于如何保证<strong>接收帧的完整性</strong>。</p><p>1，如何保证接收数据是正常接收的，这个可以在帧尾用校验码，累加求和，或者CRC校验。发送时候把校验码加在数据帧最后，解析时候在计算一下校验，对比下，不对则抛弃。</p><p>2，校验前，还是要获取一个正常排列的数据。比如接收10个字节，那么第一个字节帧头，确实是帧头，而不是错位的。有的就需要拼接了。</p><p>3，有些数据帧比较复杂，比如数据帧长度不一样，那要做的条件判断就很多了，需要一个一个解析。</p><p>建议采用两步读取的方法，第一次读取长度为1的数据。如果超时则忽略；如果不超时，延时一段时间再将所有数据读上来，然后再拼接上第一个字符。此方法最能保证传输完整性，相当于用第一个字符做硬触发。</p><h4 id="用串口助手可以正常发送接收，用LabVIEW编程却不能"><a href="#用串口助手可以正常发送接收，用LabVIEW编程却不能" class="headerlink" title="用串口助手可以正常发送接收，用LabVIEW编程却不能"></a>用串口助手可以<strong>正常发送接收</strong>，用LabVIEW编程却不能</h4><p>串口助手勾选了发送新行，LabVIEW没有对这个<strong>发送新行</strong>处理。</p><p>解决方法有好几种：</p><ol><li><p>最粗暴的，就是自己输入字符串控件里敲个回车。</p></li><li><p>正常点，在程序框图里，输入字符串控件后面，用连接字符串，默默地加上16进制的0D0A。也就是串口助手里的“发送新行”的功能。<strong>勾选“</strong>发送新行”时候，串口助手为我们默认都加了这两个字符。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709163337127.png" alt="image-20220709163337127"></p></li><li><p>不想敲16进制的0D0A字符串也可以，字符串选板默认有一个常量，叫“行结束符常量”，用这个可以和0D0A一样的效果。</p></li></ol><h4 id="高亮调试能收到数据，但是正常运行，就收不到数据"><a href="#高亮调试能收到数据，但是正常运行，就收不到数据" class="headerlink" title="高亮调试能收到数据，但是正常运行，就收不到数据"></a>高亮调试能收到数据，但是正常运行，就收不到数据</h4><p>这个问题最常见的解决方式，就是加<strong>等待延时</strong>，因为高亮执行时，写入缓冲区后，执行到读取缓冲区速度慢，这个时候缓冲区可以读取到数据。而正常执行，延时太短，缓冲区没有数据。可以把上述的100ms改大即可。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709163430732.png" alt="image-20220709163430732"></p><p>当然，还有一个常见原因，就是程序读到数据了，但是一闪而过（以上这个程序只是举例，和真实案例有差距），因为这个程序字符串不能显示历史字符串。而串口助手都可以显示历史数据的。</p><h2 id="局部变量问题"><a href="#局部变量问题" class="headerlink" title="局部变量问题"></a>局部变量问题</h2><h4 id="情境一"><a href="#情境一" class="headerlink" title="情境一"></a>情境一</h4><p>TEST A的vi输出了一个结果Result A，然后给TEST B作为输入，但是TEST B的输入，却总是不对，导致TEST B计算有问题。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709163503057.png" alt="image-20220709163503057"></p><p>以上程序中，看似Result A被TEST A赋值了。其实TEST B这个vi的输入值在整个程序一运行就执行了，数据流已经进入了TEST B的输入那儿。前面的A的vi输出并不会刷新后面B的输入。</p><p>估计有些初学者会说，上图用错误簇数据流限制了B 必须在A后面执行呀。是的，限制了。但是变量却无所谓的数据流限制，程序一运行就给B输入了。所以，一般建议大家规范编程，能用连线的尽量连线，局部变量除了上述问题外，还会存在其他问题。</p><h4 id="情境二"><a href="#情境二" class="headerlink" title="情境二"></a>情境二</h4><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709163625734.png" alt="image-20220709163625734"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709163657324.png" alt="image-20220709163657324"></p><p>问题出在使用FOR解析读取的数据这儿。FOR有一个特性，输入是数组时候，可以不连接左上角的<strong>N</strong> 这个端子，FOR会自动按数组的大小执行对应次数。但是，这个VISA读取有时候串口读不到数据，是空的，那么这个FOR执行次数是0。</p><p>如果FOR执行次数是0，那么穿过FOR的连线，<strong>输出就会是默认值（一般是空）</strong>，也就是说，连线的数据，穿过了FOR后，数据无法传递给FOR后面的函数。所以，吃亏还是吃亏在了基础知识，但是很多人估计书本学习不会遇到，毕竟这个靠实际调试才会发现。</p><p>所以，如果要改程序，请用移位寄存器，稍微改一下就可以解决这个问题啦。如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//640-20220617120800417.png" alt="图片"></p><h2 id="Labview状态机的介绍与程序示例"><a href="#Labview状态机的介绍与程序示例" class="headerlink" title="Labview状态机的介绍与程序示例"></a>Labview状态机的介绍与程序示例</h2><h5 id="一、状态机简介"><a href="#一、状态机简介" class="headerlink" title="一、状态机简介"></a>一、状态机简介</h5><p>  状态机是在工程应用中使用最多的设计模型。使用状态机，我们可以很容易的实现程序流程图中的判断、分支。<br>  Labview状态机是由一个While循环、一个条件结构和一个移位寄存器组成的。其中while循环用来保证程序可以连续的运行；条件结构的各种分支中的代码用来描述状态机的各种状态，以及下一状态的选择；移位寄存器用来将之前状态所作出的选择传递到下一次循环的选择端子。</p><h5 id="二、状态机的基本框架"><a href="#二、状态机的基本框架" class="headerlink" title="二、状态机的基本框架"></a>二、状态机的基本框架</h5><p>状态机主要由3部分组成，包括一个while循环，一个条件结构，以及while循环的移位寄存器，其中while循环用于保证程序的持续运行，条件结构用于处理不同状态的执行，移位寄存器用于实现从一个状态跳转到另外一个状态。</p><p>此外一个重要的变量构建是：<strong>枚举常量</strong>表示了两组成对的数据，一组是字符串，一组是数值，两者一一对应，在前面板上，能直观地看到字符串，在程序面板上则简单地表示为数值型数据，整个枚举型数据的值可以是预定义的多个数据中的任何一个值。</p><p>考虑到以后<strong>对状态机修改及维护的方便</strong>， 通常，我们将该枚举常量保存为一个<strong>自定义控件</strong>，将该自定义控件作为枚举常量引入状态机中，当我们需要对状态变量迚行修改的时候，只需要对这个自定义控件迚行一次修改，更新，就能对该状态机中任何位置的状态变量迚行统一的管理了。</p><p>状态机的状态转换：有5种方法</p><p>1、默认状态：无论这个状态执行如何，都无条件转入下一个状态</p><p>2、选择转换 ：利用真假选择函数来实现，在逻辑子VI输出为真时，跳入真分支的状态，迚行State1，为假时，跳入假分支的状态，迚行State2，这个方式在两个可能状态的情况下非常简单和好用，但如果下一个状态的有可能是三个或三个以上的状态呢？ </p><p>后两种方式就是处理这个情况的 </p><p>3、条件结构转换 ：条件结构的多个分支分别对应了不同的下一状态值，根据逻辑判断子VI输出的结果，跳入不同的分支以选择不同的状态，当子VI输出1时，跳入State1, </p><p>4、转换数组转换：条件结构虽然解决了多个状态选择的问题，但从结构上来看不太直观，管理不够方便，我们可以把所有待选择的状态放入数组中，通过逻辑判断子VI输出不同的索引值直接从数组中索引出下一个状态输出到移位寄存器 </p><p><a href="https://blog.csdn.net/ba_wang_mao/article/details/119799081">状态机傻瓜入门教程</a></p><h2 id="元素同址操作结构"><a href="#元素同址操作结构" class="headerlink" title="元素同址操作结构"></a>元素同址操作结构</h2><p>使用元素同址操作结构用于控制LabVIEW编译器更高效地执行常见操作，以及提高内存使用效率。</p><p>许多LabVIEW操作要求LabVIEW对数据复制并保存在内存中，因此降低了执行速度且增加到了内存占用。<br>元素同址操作结构使用边框节点或与结构的边框相连接的节点来进行数据操作。移动或删除边框节点时，LabVIEW自动将结构另一侧的对应节点移动或删除。<br>与传统的LabVIEW编程方法相比，元素同址操作结构在执行常见的LabVIEW操作时效率更高。<br>下列程序框图显示了如何通过使用元素同址操作结构提高VI执行及内存使用的效率：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709165559615.png" alt="image-20220709165559615"></p><p>在上面的程序框图中，LabVIEW对一个32位无符号整数数组进行索引，将数组的第三个元素递增，再将新元素替换数组中同一位置上的元素。</p><p>如需替换同一数组中的新值，替换数组子集函数要求对数组和数组索引值连线至函数的数组和索引输入端。</p><p>运行VI时，LabVIEW将为数组生成一个副本并将该副本保存在内存中。</p><p>使用元素同址操作结构可避免额外为数组及其索引值生成副本，如下列程序框图所示。<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709165917459.png" alt="image-20220709165917459"></p><p>在上面的程序框图中，元素同址操作结构的数组索引/替换元素边框节点对一个32位无符号整数数组进行索引，将数组的第三个元素递增，再将新元素替换数组中原位置上的元素。整个过程与第一个程序框图类似。然而在本例中，LabVIEW无需创建数组值的副本并将其保存于内存。</p><p>元素同址操作结构将数组中每个已索引的元素以结构右侧的节点取代。由于结构要求取代原有的数组元素，而LabVIEW编译器也可识别出需要替换的元素，故LabVIEW无需创建或保存数组或数组元素的副本并保存在内存中。</p><h2 id="降低CPU利用率及卡顿"><a href="#降低CPU利用率及卡顿" class="headerlink" title="降低CPU利用率及卡顿"></a>降低CPU利用率及卡顿</h2><p>从增加程序运行速度和效率的角度：</p><p>1、执行处禁止VI调试可以大大提高VI运行速度，降低内存利用。</p><p>2、根据实际需要选择短数据类型，节约空间，提高效率。注意溢出即可。</p><p>3、循环中加入几十至几百毫秒的延时，避免作无谓的运算。</p><p>4、文件的读写放在循环外。</p><p>5、涉及界面刷新的相关属性节点放在循环外。</p><p>6、局部变量、全局变量的读写放在循环外。</p><p>7、利用等待用户反馈的时间做下一步工作。</p><p>进一步从内存的角度：</p><p>1、把复杂VI分解为数个子VI。</p><p>2、没必要时不要设置子VI的可重入性，避免生成副本增加开销。</p><p>3、避免在子VI中使用子VI前面板控件的属性节点。</p><p>4、打开句柄后要关闭，避免内存泄露。</p><p>5、缓存重用技术：如果可能，用变量代替常量；使用移位寄存器/元素同址操作操作等；子VI连接板实现变量效果实现缓存重用</p><p>6、输入输出参数排布，最左边和最右边，尽量循环外。</p><p>7、优化数据流结构，分支看能不能进行直连实现重用。</p><p>降低CPU占有率:</p><p>CPU的身高是循环处理的太快，通过降低循环速度可以有效的降低CPU占有率。</p><h2 id="多循环引入队列"><a href="#多循环引入队列" class="headerlink" title="多循环引入队列"></a>多循环引入队列</h2><p>我们可以使用“多循环”来解决程序并行运行的问题，那么程序中的两个循环如何进行数据交互和共享呢？最普通的方式是采用全局变量或局域变量，但是当两个循环执行的速率不相等时，必然会造成数据的丢失或重复。如前所述，LabVIEW提供了队列操作函数，允许数据的发送者和接受者之间建立一条缓冲通道，这样就避免了循环不同步带来的影响。这里就用到了我们常说的队列函数，由于队列中的元素是“先进先出”的，因此确保了接收到的数据是有序的。</p><p> 在LabVIEW的队列操作中（入列和出列函数），提供了timeout选项以处理数据缓冲区的溢出或不足。当数据溢出时，入列函数（数据进入队列）将停止发送数据（处于等待状态），直到缓冲区存在数据空间或者达到了timeout设置的时间；而当数据不足时，出列函数（数据流出队列）将停止接收数据（处于等到状态），直到缓冲区进入了新的数据或者达到了timeout设置的时间。</p><p>实例介绍生产者消费者循环的基本特性以及队列操作的特点：</p><p>例程提供了操作方式控件控制生产者和消费者的数据传递速率，包含五种状态：不生产只消费、生成快于消费、生成速率等于消费速率、生成慢于消费、只生产不消费。</p><p>代码包括三个循环，分别是生产者循环，消费者循环，状态循环</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//931855-20180121144518756-33953560.png" alt="img"></p><p>将生产者的【枚举+条件结构】改成【枚举+事件结构】，即变成了消费者生产者（事件模式）；<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//931855-20180121153604193-604180882.png" alt="img"></p><p>实际中应该避免由于<strong>timeout（超时）</strong>设置为-1而导致的无限等待和死循环。</p><h2 id="VI可重入性"><a href="#VI可重入性" class="headerlink" title="VI可重入性"></a>VI可重入性</h2><p>正常的labview是多线程设计语言，而我们在执行VI时的规则是通过VI的命名来分别调用实现的。</p><p>打开VI的Highlight调试工具，可以看出两个Wait.vi实例的调用并不是同时执行的，而是依次按顺序执行的，至于哪一个实例先执行是不确定的。这是由于LabVIEW本身是并行设计的，从理论上而言，两个VI的实例是同步执行的，但是如果两个Wait.vi实例同时执行必定会产生参数赋值紊乱，因为LabVIEW只允许内存中存在一个名称的VI。</p><p>如果在一个顺序结构里要同时进行两个vi的调用，采用的方法是单击ctrl+I,在新点出来的对话框中选择执行框里边的可重入选择Reentrant execution，这样的话再次运行上述实例用时长为并行执行的时间。事实上，LabVIEW的可重入技术相当于在原有VI的基础上产生了一个相同的副本，打开Wait.vi从标题栏可以看出VI的名称为Wait.vi:1(clone)。同理这是由于LabVIEW中不允许内存中的VI存在同名，VI的可重入技术相当于产生了与原VI具有同样功能的新VI并且修改了该VI的命名。 </p><p>在实际应用中，需要根据情况决定是否设置VI的可重入属性，灵活使用。并不是需要将所有的VI都设置为可重入，那将占据大量的内存资源。</p><h2 id="布尔控件机械动作"><a href="#布尔控件机械动作" class="headerlink" title="布尔控件机械动作"></a>布尔控件机械动作</h2><p>总共6种机械动作，m（mouse）表示操作控件时鼠标的动作，v(value)表示控件输出值，RD（Read）表示VI读取控件的时刻。<br>下面分别介绍这六种动作：</p><ul><li><p>1、单击时转换</p><pre><code class="hljs"> 这种机械动作相当于机械开关，单击鼠标后，立即改变状态，并保持改变的状态，改变的时刻是鼠标单击的时刻。再次单击后，恢复原来的状态，与VI是否读取控件无关。</code></pre></li><li><p>2、释放时转换</p><pre><code class="hljs"> 当鼠标释放后，立即改变状态。改变的时刻是鼠标按键释放的时刻。再次单击鼠标并释放鼠标时，恢复原来的状态，与VI是否读取控件无关。</code></pre></li><li><p>3、单击时转换保持到鼠标释放</p><pre><code class="hljs"> 这种机械动作相当于机械按钮。鼠标单击时控件状态立即改变，鼠标按键释放后立即恢复，保持时间取决于单击和释放之间的时间间隔。</code></pre></li><li><p>4、单击时触发</p><pre><code class="hljs"> 单击控件时改变控件值，保留该控件值直到VI读取该控件。此时，即使长按鼠标按钮控件也将返回至其默认值。该动作与断路器相似，适用于停止While循环或令VI在每次用户设置控件时只执行一次。单按钮控件不可选择该动作。</code></pre></li><li><p>5、释放时触发</p><pre><code class="hljs"> 仅当在控件的图片边界内单击一次鼠标后放开鼠标按钮时，控件值改变。VI读取该动作一次，则控件返回至其默认值。该动作与对话框按钮和系统按钮的动作相似。单按钮控件不可选择该动作。</code></pre></li><li>6、保持触发直到鼠标释放<pre><code class="hljs"> 单击控件时改变控件值，保留该控件值直到VI读取该值一次或用户释放鼠标按钮，取决于二者发生的先后。单按钮控件不可选择该动作。</code></pre></li></ul><p>其实最简单的方法就是看懂机械动作的图标。图标非常形象，只要理解了这六种机械动作的含义，很容易选对机械动作的</p>]]></content>
    
    
    
    <tags>
      
      <tag>labview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建Hexo博客</title>
    <link href="/2022/06/16/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/06/16/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo-GitHub-文章发布原理"><a href="#Hexo-GitHub-文章发布原理" class="headerlink" title="Hexo + GitHub 文章发布原理"></a>Hexo + GitHub 文章发布原理</h2><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a56bynskj20k909naaw.jpg" alt="image-20220616123316035"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a530lrdgj20qk0m5gol.jpg" alt="image-20220616112321010"></p><h2 id="step1-配置环境"><a href="#step1-配置环境" class="headerlink" title="step1.配置环境"></a>step1.配置环境</h2><p>Git</p><p>Node.js</p><p>step1.github上建立仓库</p><p><em>仓库名称和注册名一致</em></p><h2 id="step2-生成SSH-Keys"><a href="#step2-生成SSH-Keys" class="headerlink" title="step2.生成SSH Keys"></a><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a53aguqmj212f0j40vl.jpg" alt="image-20220616113621975">step2.生成SSH Keys</h2><p>在任意文件夹下进入Git Bash，输入ssh检测是否已经安装ssh</p><p>输入<code>ssh-keygen -t rsa -C &quot;注册GitHub用的邮箱&quot;</code></p><p>敲四次回车</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a53j6kxhj20tf0axq42.jpg" alt="image-20220616113950805">在以下文件夹中获得刚生成的密钥，pub里是公钥，复制公钥</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a53qm5b8j20so05o74j.jpg" alt="image-20220616114046868">在GitHub中粘贴</p><p>测试ssh是否绑定成功，<code>ssh -T git@github.com</code></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a54si3wlj20l201lt8q.jpg" alt="image-20220616121224727"></p><p>绑定成功</p><h2 id="step3-本地生成博客内容"><a href="#step3-本地生成博客内容" class="headerlink" title="step3.本地生成博客内容"></a>step3.本地生成博客内容</h2><p>新建文件夹Blog</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">npm install -g hexo-cli #安装hexo，Mac用户需要加sudo<br><br>hexo init #已安装过需要初始化<br><br>hexo g #生成<br><br>hexo s #启动服务，打开本地服务器<br></code></pre></td></tr></table></figure><h2 id="step4-发布博客到互联网"><a href="#step4-发布博客到互联网" class="headerlink" title="step4.发布博客到互联网"></a>step4.发布博客到互联网</h2><p>Hexo 博客文件夹目录结构如下：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a555r2doj21130793z4.jpg" alt="image-20220616122404265"></p><p>打开博客配置文件，做出如下修改</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a55jpj2ij20y305oq35.jpg" alt="image-20220616122503416"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">deploy:<br>  type: git<br>  repository: https://github.com/moyudexiaosong/moyudexiaosong.github.io<br>  branch: main<br></code></pre></td></tr></table></figure><p><code>npm install hexo-deployer-git --save #安装上传工具</code></p><p><code>hexo d</code> #上传互联网</p><p>第一次要输入注册名和密码，密码（令牌）</p><p>上传成功，找到网址</p><p>查看当前git用户名和邮箱</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">git config user.name<br>git config user.email<br></code></pre></td></tr></table></figure><p>修改</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">git config --global user.name &quot;zhangsan(新的用户名)&quot;<br>git config --global user.email &quot;123456@qq.com(新的邮箱)&quot;<br>git config --global user.password &quot;123456(新的密码)&quot;<br><span class="hljs-params">#</span> 这里的zhangsan和邮箱都是你修改之后的用户名和邮箱<br></code></pre></td></tr></table></figure><p>step4.安装主题</p><p><code>npm install --save hexo-theme-fluid</code></p><p>然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。</p><p>将_config.yml下的theme的值landscape修改为fluid，这样才能使用到主题fluids</p><h2 id="step5-hexo基本配置"><a href="#step5-hexo基本配置" class="headerlink" title="step5.hexo基本配置"></a>step5.hexo基本配置</h2><p>在文件根目录下的<code>_config.yml</code>，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考<a href="https://hexo.io/zh-cn/docs/configuration">官方的配置</a>描述。</p><h5 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h5><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>title</code></td><td style="text-align:center">网站标题</td></tr><tr><td style="text-align:center"><code>subtitle</code></td><td style="text-align:center">网站副标题</td></tr><tr><td style="text-align:center"><code>description</code></td><td style="text-align:center">网站描述</td></tr><tr><td style="text-align:center"><code>author</code></td><td style="text-align:center">您的名字</td></tr><tr><td style="text-align:center"><code>language</code></td><td style="text-align:center">网站使用的语言</td></tr><tr><td style="text-align:center"><code>timezone</code></td><td style="text-align:center">网站时区。Hexo 默认使用您电脑的时区。<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</td></tr></tbody></table></div><p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p><h6 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><h5 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h5><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">title: Hello World<br>date: 2013/7/13 20:46:25<br>---<br></code></pre></td></tr></table></figure><p>下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>layout</code></td><td style="text-align:center">布局</td></tr><tr><td style="text-align:center"><code>title</code></td><td style="text-align:center">标题</td></tr><tr><td style="text-align:center"><code>date</code></td><td style="text-align:center">建立日期</td></tr><tr><td style="text-align:center"><code>updated</code></td><td style="text-align:center">更新日期</td></tr><tr><td style="text-align:center"><code>comments</code></td><td style="text-align:center">开启文章的评论功能</td></tr><tr><td style="text-align:center"><code>tags</code></td><td style="text-align:center">标签（不适用于分页）</td></tr><tr><td style="text-align:center"><code>categories</code></td><td style="text-align:center">分类（不适用于分页）</td></tr><tr><td style="text-align:center"><code>permalink</code></td><td style="text-align:center">覆盖文章网址</td></tr></tbody></table></div><h6 id="layout（布局）"><a href="#layout（布局）" class="headerlink" title="layout（布局）"></a>layout（布局）</h6><p>当你每一次使用代码</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo new paper<br></code></pre></td></tr></table></figure><p>它其实默认使用的是<code>post</code>这个布局，也就是在<code>source</code>文件夹下的<code>_post</code>里面。</p><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>，它们分别对应不同的路径，而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><div class="table-container"><table><thead><tr><th style="text-align:center">布局</th><th style="text-align:center">路径</th></tr></thead><tbody><tr><td style="text-align:center"><code>post</code></td><td style="text-align:center"><code>source/_posts</code></td></tr><tr><td style="text-align:center"><code>page</code></td><td style="text-align:center"><code>source</code></td></tr><tr><td style="text-align:center"><code>draft</code></td><td style="text-align:center"><code>source/_drafts</code></td></tr></tbody></table></div><p>而new这个命令其实是：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo new [layout] &lt;title&gt; <span class="hljs-params">#</span>这个layout默认是post<br></code></pre></td></tr></table></figure><h6 id="page"><a href="#page" class="headerlink" title="page"></a>page</h6><p>如果你想另起一页，那么可以使用</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo new page board<br></code></pre></td></tr></table></figure><p>系统会自动给你在source文件夹下创建一个board文件夹，以及board文件夹中的index.md.</p><h6 id="draft"><a href="#draft" class="headerlink" title="draft"></a>draft</h6><p>draft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo new draft newpage<br></code></pre></td></tr></table></figure><p>如果你的草稿文件写的过程中，想要预览一下，那么可以使用</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo server --draft<br></code></pre></td></tr></table></figure><p>在本地端口中开启服务预览。</p><p>如果你的草稿文件写完了，想要发表到post中，</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo publish draft newpage<br></code></pre></td></tr></table></figure><p>就会自动把newpage.md发送到post中。</p><h2 id="Step6-Live2D看板娘"><a href="#Step6-Live2D看板娘" class="headerlink" title="Step6.Live2D看板娘"></a>Step6.Live2D看板娘</h2><p>安装插件</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-helper-live2d</span><br></code></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 是否启动</span><br>  <span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">local</span> <span class="hljs-comment"># 默认</span><br>  <span class="hljs-attr">pluginRootPath:</span> <span class="hljs-string">live2dw/</span>  <span class="hljs-comment"># 插件在站点上的根目录(相对路径)</span><br>  <span class="hljs-attr">pluginJsPath:</span> <span class="hljs-string">lib/</span>  <span class="hljs-comment"># 脚本文件相对与插件根目录路径</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span>  <span class="hljs-comment"># 模型文件相对与插件根目录路径</span><br>  <span class="hljs-attr">tagMode:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br>  <span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 调试, 是否在控制台输出日志</span><br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget</span>  <span class="hljs-comment"># 模型文件</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span> <span class="hljs-comment"># 定位方向 left right top bottom</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">150</span>  <span class="hljs-comment"># 小人宽度</span><br>    <span class="hljs-attr">height:</span> <span class="hljs-number">300</span> <span class="hljs-comment"># 小人高度</span><br>    <span class="hljs-attr">hOffset:</span> <span class="hljs-number">-15</span>  <span class="hljs-comment"># 水平偏移</span><br>    <span class="hljs-attr">vOffset:</span> <span class="hljs-number">-15</span>  <span class="hljs-comment"># 垂直偏移</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 手机端是否显示</span><br>  <span class="hljs-attr">react:</span><br>    <span class="hljs-attr">opacity:</span> <span class="hljs-number">0.7</span>  <span class="hljs-comment"># 模型透明度</span><br></code></pre></td></tr></table></figure><p>选择人物</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs gams">live2d-widget-<span class="hljs-keyword">model</span>-chitose<br>live2d-widget-<span class="hljs-keyword">model</span>-epsilon2_1<br>live2d-widget-<span class="hljs-keyword">model</span>-gf<br>live2d-widget-<span class="hljs-keyword">model</span>-haru/<span class="hljs-number">01</span> (use npm install --save live2d-widget-<span class="hljs-keyword">model</span>-haru)<br>live2d-widget-<span class="hljs-keyword">model</span>-haru/<span class="hljs-number">02</span> (use npm install --save live2d-widget-<span class="hljs-keyword">model</span>-haru)<br>live2d-widget-<span class="hljs-keyword">model</span>-haruto<br>live2d-widget-<span class="hljs-keyword">model</span>-hibiki<br>live2d-widget-<span class="hljs-keyword">model</span>-hijiki<br>live2d-widget-<span class="hljs-keyword">model</span>-izumi<br>live2d-widget-<span class="hljs-keyword">model</span>-koharu<br>live2d-widget-<span class="hljs-keyword">model</span>-miku<br>live2d-widget-<span class="hljs-keyword">model</span>-ni-j<br>live2d-widget-<span class="hljs-keyword">model</span>-nico<br>live2d-widget-<span class="hljs-keyword">model</span>-nietzsche<br>live2d-widget-<span class="hljs-keyword">model</span>-nipsilon<br>live2d-widget-<span class="hljs-keyword">model</span>-nito<br>live2d-widget-<span class="hljs-keyword">model</span>-shizuku<br>live2d-widget-<span class="hljs-keyword">model</span>-tororo<br>live2d-widget-<span class="hljs-keyword">model</span>-tsumiki<br>live2d-widget-<span class="hljs-keyword">model</span>-unitychan<br>live2d-widget-<span class="hljs-keyword">model</span>-wanko<br>live2d-widget-<span class="hljs-keyword">model</span>-z16<br></code></pre></td></tr></table></figure><p>进行安装</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save 上面对应的代码</span><br></code></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">model:</span><br><span class="hljs-symbol">    use:</span> live2d-widget  <span class="hljs-meta">## 选择的模型文件</span><br></code></pre></td></tr></table></figure><h2 id="Step7-设置图床"><a href="#Step7-设置图床" class="headerlink" title="Step7.设置图床"></a>Step7.设置图床</h2><h6 id="创建-GitHub-仓库"><a href="#创建-GitHub-仓库" class="headerlink" title="创建 GitHub 仓库"></a>创建 GitHub 仓库</h6><h6 id="使用-jsDelivr-进行-CDN-加速"><a href="#使用-jsDelivr-进行-CDN-加速" class="headerlink" title="使用 jsDelivr 进行 CDN 加速"></a>使用 jsDelivr 进行 CDN 加速</h6><h6 id="使用PicGo上传图片"><a href="#使用PicGo上传图片" class="headerlink" title="使用PicGo上传图片"></a>使用PicGo上传图片</h6><h6 id="Typora-配置-PicGo-上传"><a href="#Typora-配置-PicGo-上传" class="headerlink" title="Typora 配置 PicGo 上传"></a>Typora 配置 PicGo 上传</h6><ul><li><p>打开 PicGo 软件，找到<code>图床设置</code>中的<code>GitHub图床</code>，填写相关信息。</p></li><li><ul><li><strong>设定仓库名【必填】</strong>：填写<code>你的用户名/你的仓库名</code>，比如我的 yifeng-talking/pictures</li><li><strong>设定分支名【必填】</strong>：填写<code>main</code></li><li><strong>设定Token【必填】</strong>：在Github主页点击自己头像后，依次选择【Settings】-&gt;【Developer settings】-&gt;【Personal access tokens】-&gt;【Generate new token】，填写Note描述（随便），设置过期时间Expiration为永不过期No expiration，设定勾选【repo】，然后点击下方的【Generate token】生成一个Token，这个Token只会显示一次，自行保存，然后复制到 PicGo 中。</li><li>指定存储路径【选填】：填写图片要存储的路径，比如填【images/】，这样就会在仓库下创建一个名为 images 的文件夹，图片将会储存在此文件夹中，这里不填。</li><li><strong>设定自定义域名【选填】</strong>：图片上传后，PicGo 会按照【自定义域名+上传的图片名】的方式生成访问链接，放到剪贴板上，因为我们要使用 jsDeliver 进行加速，因而这里设置为<code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名</code>，比如我设置为<strong><a href="https://cdn.jsdelivr.net/gh/yifeng-talking/pictures">https://cdn.jsdelivr.net/gh/yifeng-talking/pictures</a></strong></li></ul></li><li><ul><li>打开 Typera，点击【文件】 -&gt; 【偏好设置】-&gt; 【图像】，然后进行如下配置，其中 PicGo 路径是你的 PicGo 的安装路径。</li></ul></li></ul><h2 id="Step8-设置内联公式"><a href="#Step8-设置内联公式" class="headerlink" title="Step8.设置内联公式"></a>Step8.设置内联公式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-kramed --save<br></code></pre></td></tr></table></figure><p>更换Hexo的markdown渲染引擎，<a href="https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fsun11%2Fhexo-renderer-kramed">hexo-renderer-kramed</a>引擎是在默认的渲染引擎<a href="https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fhexojs%2Fhexo-renderer-marked">hexo-renderer-marked</a>的基础上修改了一些bug，两者比较接近，也比较轻量级。</p><p>执行上面的命令，先卸载原来的渲染引擎，再安装新的。</p><p>然后，跟换引擎后行间公式可以正确渲染了，但是这样还没有完全解决问题，行内公式的渲染还是有问题，因为<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fsun11%2Fhexo-renderer-kramed">hexo-renderer-kramed</a>引擎也有语义冲突的问题。接下来到博客根目录下，找到node_modules\kramed\lib\rules\inline.js，把第11行的escape变量的值做相应的修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br>  <span class="hljs-attr">escape</span>: <span class="hljs-regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span><br></code></pre></td></tr></table></figure><p>这一步是在原基础上取消了对\,{,}的转义(escape)。<br>同时把第20行的em变量也要做相应的修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*[\s\S])+?)\*(?!\*)/,</span><br>  <span class="hljs-attr">em</span>: <span class="hljs-regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span><br></code></pre></td></tr></table></figure><p>如果已经开启主题，需要先修改配置文件，再在文章的Front-matter里打开math开关，如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">math</span>: <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029?utm_source=app&amp;app_version=5.5.0">hexo史上最全搭建教程</a></p><p><a href="https://zhuanlan.zhihu.com/p/60578464#:~:text=%E4%BD%BF%E7%94%A8%20Hexo%2BGitHub%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89%201%20%E5%87%86%E5%A4%87%202%20%E8%BF%9E%E6%8E%A5%20Github....,Hexo%20%E5%88%B0%20GitHub%20Pages%206%20%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89....%207%20%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8">使用 Hexo+GitHub 搭建个人免费博客教程</a></p><p><a href="https://baijiahao.baidu.com/s?id=1710047962336524256&amp;wfr=spider&amp;for=pc">高速稳定图床</a></p><p><a href="https://www.jianshu.com/p/7ab21c7f0674">在Hexo中渲染MathJax数学公式</a></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
