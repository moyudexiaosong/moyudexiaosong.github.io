<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript基础知识</title>
    <link href="/2022/08/14/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/08/14/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="JavaScript基础知识"><a href="#JavaScript基础知识" class="headerlink" title="JavaScript基础知识"></a>JavaScript基础知识</h1><h2 id="一、现代模式，”use-strict”"><a href="#一、现代模式，”use-strict”" class="headerlink" title="一、现代模式，”use strict”"></a>一、现代模式，”use strict”</h2><p>长久以来，JavaScript 不断向前发展且并未带来任何兼容性问题。新的特性被加入，旧的功能也没有改变。</p><p>这么做有利于兼容旧代码，但缺点是 JavaScript 创造者的任何错误或不完善的决定也将永远被保留在 JavaScript 语言中。</p><p>这种情况一直持续到 2009 年 ECMAScript 5 (ES5) 的出现。ES5 规范增加了新的语言特性并且修改了一些已经存在的特性。为了保证旧的功能能够使用，大部分的修改是默认不生效的。你需要一个特殊的指令 —— <code>&quot;use strict&quot;</code> 来明确地激活这些特性。</p><h3 id="“use-strict”"><a href="#“use-strict”" class="headerlink" title="“use strict”"></a><a href="https://zh.javascript.info/strict-mode#usestrict">“use strict”</a></h3><p><code>&quot;use strict&quot;</code> 可以被放在函数体的开头。这样则可以只在该函数中启用严格模式。但通常人们会在整个脚本中启用严格模式。</p><p><strong>确保 “use strict” 出现在最顶部</strong></p><p>请确保 <code>&quot;use strict&quot;</code> 出现在脚本的最顶部，否则严格模式可能无法启用。</p><p>这里的严格模式就没有被启用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;some code&quot;</span>);<br><span class="hljs-comment">// 下面的 &quot;use strict&quot; 会被忽略，必须在最顶部。</span><br><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br><span class="hljs-comment">// 严格模式没有被激活</span><br></code></pre></td></tr></table></figure><p>只有注释可以出现在 <code>&quot;use strict&quot;</code> 的上面。</p><p><strong>没有办法取消 <code>use strict</code></strong></p><p>没有类似于 <code>&quot;no use strict&quot;</code> 这样的指令可以使程序返回默认模式。</p><p>一旦进入了严格模式，就没有回头路了。</p><h3 id="我们应该使用-“use-strict”-吗？"><a href="#我们应该使用-“use-strict”-吗？" class="headerlink" title="我们应该使用 “use strict” 吗？"></a><a href="https://zh.javascript.info/strict-mode#wo-men-ying-gai-shi-yong-usestrict-ma">我们应该使用 “use strict” 吗？</a></h3><p>有人可能会建议在脚本的最顶部放置 <code>&quot;use strict&quot;</code> 这行代码…… 但你知道更酷的方式吗？</p><p>现代 JavaScript 支持 “class” 和 “module” —— 高级语言结构（本教程后续章节会讲到），它们会自动启用 <code>use strict</code>。因此，如果我们使用它们，则无需添加 <code>&quot;use strict&quot;</code> 指令。</p><p><strong>因此，目前我们欢迎将 <code>&quot;use strict&quot;;</code> 写在脚本的顶部。稍后，当你的代码全都写在了 class 和 module 中时，你则可以将 <code>&quot;use strict&quot;;</code> 这行代码省略掉。</strong></p><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><p>JavaScript 中有八种基本的数据类型。</p><ul><li>七种原始数据类型：<ul><li><code>number</code> 用于任何类型的数字：整数或浮点数，在 <code>±(253-1)</code> 范围内的整数。</li><li><code>bigint</code> 用于任意长度的整数。</li><li><code>string</code> 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。</li><li><code>boolean</code> 用于 <code>true</code> 和 <code>false</code>。</li><li><code>null</code> 用于未知的值 —— 只有一个 <code>null</code> 值的独立类型。</li><li><code>undefined</code> 用于未定义的值 —— 只有一个 <code>undefined</code> 值的独立类型。</li><li><code>symbol</code> 用于唯一的标识符。</li></ul></li><li>以及一种非原始数据类型：<ul><li><code>object</code> 用于更复杂的数据结构。</li></ul></li></ul><p>我们可以通过 <code>typeof</code> 运算符查看存储在变量中的数据类型。</p><ul><li>通常用作 <code>typeof x</code>，但 <code>typeof(x)</code> 也可行。</li><li>以字符串的形式返回类型名称，例如 <code>&quot;string&quot;</code>。</li><li><code>typeof null</code> 会返回 <code>&quot;object&quot;</code> —— 这是 JavaScript 编程语言的一个错误，实际上它并不是一个 <code>object</code>。</li></ul><h2 id="三、空值合并运算符-‘-’"><a href="#三、空值合并运算符-‘-’" class="headerlink" title="三、空值合并运算符 ‘??’"></a>三、空值合并运算符 ‘??’</h2><p><strong>最近新增的特性</strong></p><p>空值合并运算符（nullish coalescing operator）的写法为两个问号 <code>??</code>。</p><p><code>a ?? b</code> 的结果是：</p><ul><li>如果 <code>a</code> 是已定义的，则结果为 <code>a</code>，</li><li>如果 <code>a</code> 不是已定义的，则结果为 <code>b</code>。</li></ul><p>如果第一个参数不是 <code>null/undefined</code>，则 <code>??</code> 返回第一个参数。否则，返回第二个参数。</p><p>我们可以使用我们已知的运算符重写 <code>result = a ?? b</code>，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">result = (a !== <span class="hljs-literal">null</span> &amp;&amp; a !== <span class="hljs-literal">undefined</span>) ? a : b;<br></code></pre></td></tr></table></figure><p><code>??</code> 的常见使用场景是提供默认值。</p><p>例如，在这里，如果 <code>user</code> 的值不为 <code>null/undefined</code> 则显示 <code>user</code>，否则显示 <code>匿名</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user;<br><br><span class="hljs-title function_">alert</span>(user ?? <span class="hljs-string">&quot;匿名&quot;</span>); <span class="hljs-comment">// 匿名（user 未定义）</span><br></code></pre></td></tr></table></figure><p>在下面这个例子中，我们将一个名字赋值给了 <code>user</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-string">&quot;John&quot;</span>;<br><br><span class="hljs-title function_">alert</span>(user ?? <span class="hljs-string">&quot;匿名&quot;</span>); <span class="hljs-comment">// John（user 已定义）</span><br></code></pre></td></tr></table></figure><p>我们还可以使用 <code>??</code> 序列从一系列的值中选择出第一个非 <code>null/undefined</code> 的值。</p><p>假设我们在变量 <code>firstName</code>、<code>lastName</code> 或 <code>nickName</code> 中存储着一个用户的数据。如果用户决定不填写相应的值，则所有这些变量的值都可能是未定义的。</p><p>我们想使用这些变量之一显示用户名，如果这些变量的值都是 <code>null/undefined</code>，则显示 “匿名”。</p><p>让我们使用 <code>??</code> 运算符来实现这一需求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> firstName = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> lastName = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> nickName = <span class="hljs-string">&quot;Supercoder&quot;</span>;<br><br><span class="hljs-comment">// 显示第一个已定义的值：</span><br><span class="hljs-title function_">alert</span>(firstName ?? lastName ?? nickName ?? <span class="hljs-string">&quot;匿名&quot;</span>); <span class="hljs-comment">// Supercoder</span><br></code></pre></td></tr></table></figure><h2 id="四、箭头函数，基础知识"><a href="#四、箭头函数，基础知识" class="headerlink" title="四、箭头函数，基础知识"></a>四、箭头函数，基础知识</h2><p>创建函数还有另外一种非常简单的语法，并且这种方法通常比函数表达式更好。</p><p>函数表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sayHi = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Hello&quot;</span> );<br>&#125;;<br></code></pre></td></tr></table></figure><p>箭头函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params">arg1, arg2, ..., argN</span>) =&gt; expression;<br></code></pre></td></tr></table></figure><p>这里创建了一个函数 <code>func</code>，它接受参数 <code>arg1..argN</code>，然后使用参数对右侧的 <code>expression</code> 求值并返回其结果。</p><p>换句话说，它是下面这段代码的更短的版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> func = <span class="hljs-keyword">function</span>(<span class="hljs-params">arg1, arg2, ..., argN</span>) &#123;<br>  <span class="hljs-keyword">return</span> expression;<br>&#125;;<br></code></pre></td></tr></table></figure><p>让我们来看一个具体的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><br><span class="hljs-comment">/* 这个箭头函数是下面这个函数的更短的版本：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">let sum = function(a, b) &#123;</span><br><span class="hljs-comment">  return a + b;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>可以看到 <code>(a, b) =&gt; a + b</code> 表示一个函数接受两个名为 <code>a</code> 和 <code>b</code> 的参数。在执行时，它将对表达式 <code>a + b</code> 求值，并返回计算结果。</p><ul><li><p>如果我们只有一个参数，还可以省略掉参数外的圆括号，使代码更短。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">double</span> = n =&gt; n * <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 差不多等同于：let double = function(n) &#123; return n * 2 &#125;</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-title function_">double</span>(<span class="hljs-number">3</span>) ); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure></li><li><p>如果没有参数，括号则是空的（但括号必须保留）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">sayHi</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br><br><span class="hljs-title function_">sayHi</span>();<br></code></pre></td></tr></table></figure></li></ul><p>箭头函数可以像函数表达式一样使用。</p><p>例如，动态创建一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;What is your age?&quot;</span>, <span class="hljs-number">18</span>);<br><br><span class="hljs-keyword">let</span> welcome = (age &lt; <span class="hljs-number">18</span>) ?<br>  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>) :<br>  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Greetings!&quot;</span>);<br><br><span class="hljs-title function_">welcome</span>();<br></code></pre></td></tr></table></figure><p>一开始，箭头函数可能看起来并不熟悉，也不容易读懂，但一旦我们看习惯了之后，这种情况很快就会改变。</p><p>箭头函数对于简单的单行行为（action）来说非常方便，尤其是当我们懒得打太多字的时候。</p><h3 id="多行的箭头函数"><a href="#多行的箭头函数" class="headerlink" title="多行的箭头函数"></a><a href="https://zh.javascript.info/arrow-functions-basics#duo-hang-de-jian-tou-han-shu">多行的箭头函数</a></h3><p>到目前为止，我们看到的箭头函数非常简单。它们从 <code>=&gt;</code> 的左侧获取参数，计算并返回右侧表达式的计算结果。</p><p>有时我们需要更复杂一点的函数，比如带有多行的表达式或语句。</p><p>在这种情况下，我们可以使用花括号将它们括起来。主要区别在于，用花括号括起来之后，需要包含 <code>return</code> 才能返回值（就像常规函数一样）。</p><p>就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;  <span class="hljs-comment">// 花括号表示开始一个多行函数</span><br>  <span class="hljs-keyword">let</span> result = a + b;<br>  <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 如果我们使用了花括号，那么我们需要一个显式的 “return”</span><br>&#125;;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) ); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h2 id="五、回调函数"><a href="#五、回调函数" class="headerlink" title="五、回调函数"></a>五、回调函数</h2><p>让我们多举几个例子，看看如何将函数作为值来传递以及如何使用函数表达式。</p><p>我们写一个包含三个参数的函数 <code>ask(question, yes, no)</code>：</p><ul><li><p><code>question</code></p><p>关于问题的文本</p></li><li><p><code>yes</code></p><p>当回答为 “Yes” 时，要运行的脚本</p></li><li><p><code>no</code></p><p>当回答为 “No” 时，要运行的脚本</p></li></ul><p>函数需要提出 <code>question</code>（问题），并根据用户的回答，调用 <code>yes()</code> 或 <code>no()</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ask</span>(<span class="hljs-params">question, yes, no</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">confirm</span>(question)) <span class="hljs-title function_">yes</span>()<br>  <span class="hljs-keyword">else</span> <span class="hljs-title function_">no</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showOk</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;You agreed.&quot;</span> );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showCancel</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;You canceled the execution.&quot;</span> );<br>&#125;<br><br><span class="hljs-comment">// 用法：函数 showOk 和 showCancel 被作为参数传入到 ask</span><br><span class="hljs-title function_">ask</span>(<span class="hljs-string">&quot;Do you agree?&quot;</span>, showOk, showCancel);<br></code></pre></td></tr></table></figure><p>在实际开发中，这样的函数是非常有用的。实际开发与上述示例最大的区别是，实际开发中的函数会通过更加复杂的方式与用户进行交互，而不是通过简单的 <code>confirm</code>。在浏览器中，这样的函数通常会绘制一个漂亮的提问窗口。但这是另外一件事了。</p><p><code>ask</code> 的两个参数值 <code>showOk</code> 和 <code>showCancel</code> 可以被称为 <strong>回调函数</strong> 或简称 <strong>回调</strong>。</p><p>主要思想是我们传递一个函数，并期望在稍后必要时将其“回调”。在我们的例子中，<code>showOk</code> 是回答 “yes” 的回调，<code>showCancel</code> 是回答 “no” 的回调。</p><p>我们可以使用函数表达式来编写一个等价的、更简洁的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ask</span>(<span class="hljs-params">question, yes, no</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">confirm</span>(question)) <span class="hljs-title function_">yes</span>()<br>  <span class="hljs-keyword">else</span> <span class="hljs-title function_">no</span>();<br>&#125;<br><br><span class="hljs-title function_">ask</span>(<br>  <span class="hljs-string">&quot;Do you agree?&quot;</span>,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;You agreed.&quot;</span>); &#125;,<br>  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;You canceled the execution.&quot;</span>); &#125;<br>);<br></code></pre></td></tr></table></figure><p>这里直接在 <code>ask(...)</code> 调用内进行函数声明。这两个函数没有名字，所以叫 <strong>匿名函数</strong>。这样的函数在 <code>ask</code> 外无法访问（因为没有对它们分配变量），不过这正是我们想要的。</p><p>这样的代码在我们的脚本中非常常见，这正符合 JavaScript 语言的思想。</p><p><strong>一个函数是表示一个“行为”的值</strong></p><p>字符串或数字等常规值代表 <strong>数据</strong>。</p><p>函数可以被视为一个 <strong>行为（action）</strong>。</p><p>我们可以在变量之间传递它们，并在需要时运行。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3.x 基础语法篇</title>
    <link href="/2022/08/13/vue3-x-01/"/>
    <url>/2022/08/13/vue3-x-01/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="Vue3-x从零开始学"><a href="#Vue3-x从零开始学" class="headerlink" title="Vue3.x从零开始学"></a>Vue3.x从零开始学</h1><h2 id="基础语法篇"><a href="#基础语法篇" class="headerlink" title="基础语法篇"></a>基础语法篇</h2><h3 id="1-初识vue3-x"><a href="#1-初识vue3-x" class="headerlink" title="1.初识vue3.x"></a>1.初识vue3.x</h3><p><strong>编写第一个HelloWorld</strong></p><p>在VSCode中新建立一个<code>index.html</code>的文件。</p><p>打开<code>index.html</code>后，直接输入<code>html</code>，然后会出现选项，直接选择<code>html:5</code>，就可以快速生成html的基本结构。</p><p>当然，你也可以直接输入<code>!</code>号，然后<code>回车</code>，也会给我们输出同样的结果。根据自己的喜好，自行选择就好。</p><p><strong>直接引入Vue3.x源码</strong></p><p>Vue官方提供直接引入的CDN服务地址，只要用<code>&lt;script&gt;</code>标签，就可以直接在<code>&lt;head&gt;</code>里引入<code>Vue3</code>，并且使用它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;https://unpkg.com/vue@next&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>引入Vue3的框架之后，我们就可以写Vue的代码了。先在<code>&lt;body&gt;</code>标签中，加入一个<code>&lt;div&gt;</code>层,并给他一个<code>id=&quot;root&quot;</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Hello World&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    Vue.createApp(&#123;<br>        template: &#x27;&lt;div&gt;Hello World&lt;/div&gt;&#x27;<br>    &#125;).mount(&quot;#app&quot;)<br>&lt;/script&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>其中，Vue的语法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;   <span class="hljs-comment">//创建一个Vue实例，简单理解就说，我要使用Vue了</span><br>    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;Hello World&lt;/div&gt;&#x27;</span>   <span class="hljs-comment">// template是模板的意思，就是在JS里写html代码</span><br>&#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)   <span class="hljs-comment">//这个模板需要放一个位置，也就是说挂载，挂载到`id=app`的DOM上</span><br></code></pre></td></tr></table></figure><ol><li>用<code>Vue.</code>创建一个实例对象，符合命名规范即可</li><li>用<code>template</code>创建一个模版，里面是<code>html</code>代码</li><li><code>.mount</code>是模版要挂载的位置</li></ol><h3 id="2-Vue3编写的计数器"><a href="#2-Vue3编写的计数器" class="headerlink" title="2. Vue3编写的计数器"></a>2. Vue3编写的计数器</h3><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;   <br>    &lt;script&gt;<br>        Vue.createApp(&#123;<br>            data()&#123;<br>                return&#123;<br>                    counter:1<br>                &#125;<br>            &#125;,<br>            mounted()&#123;<br>                setInterval(()=&gt;&#123;<br>                    this.counter+=1<br>                &#125;,1000)<br>            &#125;,//只要页面一加载，就会执行这个步骤<br>            template:&#x27;&lt;div&gt;&#123;&#123;counter&#125;&#125;&lt;/div&gt;&#x27;<br>        &#125;).mount(&quot;#app&quot;)<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>计数器能变化，肯定是需要一个变量的，这个变量起名为<code>counter</code>。在Vue的<code>template</code>(模板)中使用变量，需要用到字面量标识双大括号，我喜欢把这个双大括号叫做字面量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123;counter&#125;&#125;&lt;/div&gt;&#x27;</span><br>    &#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br></code></pre></td></tr></table></figure><p>到目前为止，只是在模板中使用了<code>counter</code>变量，但是还没有声明，声明这个变量需要在<code>data()</code>函数中，具体代码如下，可以在浏览器中看到 一个1显示出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">counter</span>: <span class="hljs-number">1</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p><strong>mounted( )中实现自增</strong></p><p><code>mounted</code>是一个声明周期钩子函数，可以把他想成是页加载渲染完成，<strong>自动执行</strong>，不用调用的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面加载完成后-自动执行&#x27;</span>)<br>    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">counter</span> += <span class="hljs-number">1</span>   <span class="hljs-comment">//这个this.counter指向的就是data中的counter</span><br>        <span class="hljs-comment">//this.$data.counter +=1   //效果相同</span><br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;,<br></code></pre></td></tr></table></figure><p>这节就是你要转变的一个观点，从面向DOM编程，改为面向数据编程。</p><h3 id="3-来宾欢迎语展示"><a href="#3-来宾欢迎语展示" class="headerlink" title="3.来宾欢迎语展示"></a>3.来宾欢迎语展示</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>    &lt;script&gt;<br>        Vue.createApp(&#123;<br>            data()&#123;<br>                return&#123;<br>                    content:&quot;&quot;,<br>                    setMeal:&#x27;芝士蛋糕 黄金脆皮鸡 螺蛳粉 火锅&#x27;,<br>                    isShowMeal:false,<br>                &#125;<br>            &#125;,<br>            methods:&#123;<br>                welcomBtnClick()&#123;<br>                    this.content=&quot;你来啦亲&quot;<br>                &#125;,<br>                byeBtnClick()&#123;<br>                    this.content=&quot;怎么又走了&quot;<br>                &#125;,<br>                showOrHide()&#123;<br>                    this.isShowMeal=!this.isShowMeal<br>                &#125;,<br>            &#125;,<br>            template:`<br>            &lt;div&gt;<br>                &lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;<br>                &lt;button v-on:click=&quot;welcomBtnClick&quot;&gt;有人来了&lt;/button&gt;&amp;nbsp;<br>                &lt;button v-on:click=&quot;byeBtnClick&quot;&gt;有人走了&lt;/button&gt;<br>                &lt;div v-if=&quot;isShowMeal&quot;&gt;&#123;&#123;setMeal&#125;&#125;&lt;/div&gt;<br>                &lt;button v-on:click=&quot;showOrHide&quot;&gt;显示/隐藏菜单&lt;/button&gt;<br>            &lt;/div&gt;<br>            `<br>        &#125;).mount(&quot;#app&quot;)<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>Vue3的绑定事件和事件方法</strong></p><p>先在<code>methods</code>属性里加入两个方法<code>welcomeBtnClick</code>和<code>byeBtnClick</code>，再给两个按钮绑定事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">welcomeBtnClick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">content</span> = <span class="hljs-string">&quot;欢迎你的光临，贵宾一位！&quot;</span><br>    &#125;,<br>    <span class="hljs-title function_">byeBtnClick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">content</span> = <span class="hljs-string">&quot;欢迎下次光临，真空套餐下次8折优惠&quot;</span><br>    &#125;,<br>&#125;,<br><span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;</span><br><span class="hljs-string">               &lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;</span><br><span class="hljs-string">               &lt;button v-on:click=&quot;welcomeBtnClick&quot;&gt;有顾客来&lt;/button&gt;&amp;nbsp;</span><br><span class="hljs-string">               &lt;button v-on:click=&quot;byeBtnClick&quot;&gt;顾客离开&lt;/button&gt;</span><br><span class="hljs-string">          &lt;/div&gt;`</span><br>    &#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>显示和隐藏服务</strong></p><p>我们需要新生成一个套餐的变量<code>setMeal</code>，然后还要有一个是否展示的变量<code>isShowMeal</code>。有了这个变量之后，我们还需要有一个能改变<code>isShowMeal</code>的响应方法<code>showOrHideBtnClick</code>.用来控制套餐的显示很隐藏。</p><p><code>v-if</code>,它的作用是如果值为真，就显示这个DOM元素，如果为假，就不显示这个元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">showOrHideBtnClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isShowMeal</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">isShowMeal</span><br>&#125;<br><span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;</span><br><span class="hljs-string">            &lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;</span><br><span class="hljs-string">            &lt;button v-on:click=&quot;welcomeBtnClick&quot;&gt;有顾客来&lt;/button&gt;&amp;nbsp;</span><br><span class="hljs-string">            &lt;button v-on:click=&quot;byeBtnClick&quot;&gt;顾客离开&lt;/button&gt;</span><br><span class="hljs-string">            &lt;div&gt;</span><br><span class="hljs-string">                &lt;div v-if=&quot;isShowMeal&quot; &gt;&#123;&#123;setMeal&#125;&#125;&lt;/div&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">                &lt;button v-on:click=&quot;showOrHideBtnClick&quot;&gt;显示/隐藏套餐&lt;/button&gt;</span><br><span class="hljs-string">            &lt;/div&gt;</span><br><span class="hljs-string">        &lt;/div&gt;`</span><br></code></pre></td></tr></table></figure><h3 id="4-Vue3列表和循环-制作菜单"><a href="#4-Vue3列表和循环-制作菜单" class="headerlink" title="4.Vue3列表和循环-制作菜单"></a>4.Vue3列表和循环-制作菜单</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>    &lt;script&gt;<br>        Vue.createApp(&#123;<br>            data()&#123;<br>                return&#123;<br>                    list:[&#x27;1-芝士蛋糕&#x27;,&#x27;2-章鱼小丸子&#x27;,&#x27;3-车仔面&#x27;],<br>                    inputValue:&#x27;&#x27;<br>                &#125;<br>            &#125;,<br>            methods:&#123;<br>                handleAddItem()&#123;<br>                    this.list.push(this.inputValue)<br>                    this.inputValue=&#x27;&#x27;<br>                &#125;<br>            &#125;<br>            ,<br>            template:`<br>            &lt;div&gt;<br>                &lt;input v-model=&quot;inputValue&quot; /&gt; <br>                &lt;button v-on:click=&quot;handleAddItem&quot;&gt;增加&lt;/button&gt;<br>                &lt;ul&gt;<br>                    &lt;li v-for=&quot;item of list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;<br>                &lt;/ul&gt;<br>                &lt;ul&gt;<br>                    &lt;li v-for=&quot;(item,index) of list&quot;&gt;(&#123;&#123;index&#125;&#125;)&#123;&#123;item&#125;&#125;&lt;/li&gt;<br>                &lt;/ul&gt;<br>            &lt;/div&gt;<br>            `<br>        &#125;).mount(&quot;#app&quot;)<br>    &lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208151950442.png" alt="image-20220815195021376" style="zoom:67%;" /></p><p><strong>声明数组并循环</strong></p><p>需要一个数据<code>菜单列表</code>。在<code>createrApp()</code>方法里增加一个<code>data()</code>方法，声明<code>list[]</code>数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">list</span>: [<span class="hljs-string">&#x27;1-大脚&#x27;</span>,<span class="hljs-string">&#x27;2-刘英&#x27;</span>,<span class="hljs-string">&#x27;3-晓红&#x27;</span>]<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>有了数组，需要在模板中循环出来。这个需要用到<code>v-for</code>指令.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;ul&gt;</span><br><span class="hljs-string">        &lt;li v-for=&quot;item of list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="hljs-string">    &lt;/ul&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这句代码的意思是，我要进行循环，循环的数据是<code>list</code>,<code>list</code>中的每一项我会放到item中，然后使用字面量在模板中进行展示就可以了。</p><p><code>v-for</code>指令还有一个索引值，可以如下写法，打印出索引值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;li v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item,index) of list&quot;</span>&gt;[&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;&lt;/li&gt;<br></code></pre></td></tr></table></figure><p>会了循环之后，我们就可以根据前面的知识，做一个动态的可交互的菜单列表了。</p><p><strong>动态增加菜单</strong></p><p>先来做一个简单的效果，就是点击按钮后，就增加一个菜到列表中。先去掉数组中的值，然后来写一个按钮，按钮绑定<code>handleAddItem</code>事件。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">list</span>: []<br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">methods</span>: &#123;<br>            <span class="hljs-title function_">handleAddItem</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;&quot;</span>)<br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">            &lt;div&gt;</span><br><span class="hljs-string">                &lt;button v-on:click=&quot;handleAddItem&quot;&gt;增加&lt;/button&gt;</span><br><span class="hljs-string">                &lt;ul&gt;</span><br><span class="hljs-string">                    &lt;li v-for=&quot;(item,index) of list&quot;&gt;[&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="hljs-string">                &lt;/ul&gt;</span><br><span class="hljs-string">            &lt;/div&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">        `</span><br>    &#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>现在增加的<code>菜</code>都是一样的，而我们最终的目的是能够自定义的增加菜单。这个时候我们就需要一个<code>input</code>输入框了，而且需要用<code>v-model</code>指令，进行绑定。代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-comment">//---此处修改</span><br>                <span class="hljs-attr">inputValue</span>: <span class="hljs-string">&#x27;&#x27;</span>,  <br>                <span class="hljs-attr">list</span>: []   <br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">methods</span>: &#123;<br>            <span class="hljs-title function_">handleAddItem</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-comment">//----此处修改</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>)<br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">            &lt;div&gt;</span><br><span class="hljs-string">                &lt;!--此处修改--&gt;</span><br><span class="hljs-string">                &lt;input v-model=&quot;inputValue&quot; /&gt;</span><br><span class="hljs-string">                &lt;button v-on:click=&quot;handleAddItem&quot;&gt;增加&lt;/button&gt;</span><br><span class="hljs-string">                &lt;ul&gt;</span><br><span class="hljs-string">                    &lt;li v-for=&quot;(item,index) of list&quot;&gt;[&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="hljs-string">                &lt;/ul&gt;</span><br><span class="hljs-string">            &lt;/div&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">        `</span><br>    &#125;).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>这时候我们就可以根据我们的喜欢增加菜了，比如增加一个<code>烤乳猪</code>、<code>螺蛳粉</code>。</p><p>现在这个效果还是不太完美，在实际工作中，如果我们增加完成后，希望<code>&lt;input/&gt;</code>的值为空。这个时候你要再明白Vue中的一个特性，就是双向数据绑定。也就是这时候我们改变<code>inputValue</code>的值，页面文本框的内容也会被清空。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">handleAddItem</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span> = <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>写完后，可以在浏览器中打开，看一下最终的效果。</p><p>好了，让我们总结一下，这篇文章我们都学到了那些内容，学到<code>v-for</code>循环指令，<code>v-model</code>数据双向绑定。后面我们还会继续详解这些内容。</p><h3 id="5-Vue3组件化开发-每个菜单都是组件"><a href="#5-Vue3组件化开发-每个菜单都是组件" class="headerlink" title="5.Vue3组件化开发-每个菜单都是组件"></a>5.Vue3组件化开发-每个菜单都是组件</h3><p><strong>如何编写一个组件</strong></p><p>Vue中一个最主要的特性，就是让你使用组件化进行开发。页面上你看到的任何的东西，都可以写成组件。先来看看如何编写一个静态的Vue组件，编写一个标题组件。</p><p>为了方便书写，把<code>&lt;script&gt;</code>标签的第一行前，声明一个变量，比如就叫做<code>app</code>,声明完变量之后，就可以把<code>mount</code>部分独立出来了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>      <span class="hljs-comment">//.....somting........</span><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br></code></pre></td></tr></table></figure><p>有了<code>app</code>变量，可以非常方便的自定义组件并使用了。比如现在写一个关于标题的组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;my-title&#x27;</span>, &#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;h1 style=&quot;text-align:center&quot;&gt;象牙山洗脚城&lt;/h1&gt;&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>有了这个组件，就可以在<code>app</code>的模板部分使用了，比如我们放在<code>template</code>的最上面，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">        &lt;my-title /&gt;</span><br><span class="hljs-string">        &lt;!--...somting......--&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/68#toc320">动态组件的编写</a></p><blockquote><p>什么是动态组件？也许我说的并不标准，我这里指的动态组件是显示内容不固定，通过父组件或者程序控制而输出的内容。</p></blockquote><p>现在会了静态组件的基本使用方法，把上节课的<code>菜单</code>组件单独出来，写一个组件，这个组件会绑定一些<code>props</code>，用于接受父组件传递过来的参数,然后动态显示出内容。 动态组件有一个关键的指令是<code>v-bind</code>,用这种方法，组件可以通过<code>props</code>取得对应的值。代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;my-jiali&#x27;</span>, &#123;<br>    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;item&#x27;</span>, <span class="hljs-string">&#x27;index&#x27;</span>],<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">` &lt;li &gt;[&#123;&#123;index&#125;&#125;]-&#123;&#123;item&#125;&#125;&lt;/li&gt;`</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><code>props</code>是一个数组，可以接受多个值。有了<code>my-jiali</code>组件后，就可以在<code>app</code>的<code>template</code>中使用了，方法如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;my-jiali <br>    v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item,index) of list&quot;</span>  <br>    v-<span class="hljs-attr">bind</span>:item=<span class="hljs-string">&quot;item&quot;</span> <br>    v-<span class="hljs-attr">bind</span>:index=<span class="hljs-string">&quot;index&quot;</span>  <br>/&gt;<br></code></pre></td></tr></table></figure><p>这时候肯定会有小伙伴认为，这也没有减少代码的工作量哦，第一是因为我们的代码还比较简单，第二是组件的意义是降低程序的耦合性，让大规模开发编程可能。比如一个页面，分成几个人开发，每个人写不同的模块，写好后拼凑在一起。有了组件这就变的非常容易。</p><p>这里给出全部代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;列表&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app = Vue.createApp(&#123;<br>        data() &#123;<br>            return &#123;<br>                inputValue: &#x27;&#x27;,<br>                list: []<br>            &#125;<br>        &#125;,<br>        methods: &#123;<br>            handleAddItem() &#123;<br>                this.list.push(this.inputValue)<br>                this.inputValue = &#x27;&#x27;<br>            &#125;<br>        &#125;,<br>        template: `<br>            &lt;div&gt;<br>                &lt;my-title /&gt;<br>                &lt;input v-model=&quot;inputValue&quot; /&gt;<br>                &lt;button v-on:click=&quot;handleAddItem&quot;&gt;增加&lt;/button&gt;<br>                &lt;ul&gt;<br>                    &lt;my-jiali <br>                        v-for=&quot;(item,index) of list&quot;  <br>                        v-bind:item=&quot;item&quot; <br>                        v-bind:index=&quot;index&quot;  <br>                    /&gt;<br>                &lt;/ul&gt;<br>            &lt;/div&gt;<br><br>        `<br>    &#125;)<br><br>    app.component(&#x27;my-title&#x27;, &#123;<br>        template: &#x27;&lt;h1 style=&quot;text-align:center&quot;&gt;象牙山洗脚城&lt;/h1&gt;&#x27;<br>    &#125;)<br><br>    app.component(&#x27;my-jiali&#x27;, &#123;<br>        props: [&#x27;item&#x27;, &#x27;index&#x27;],<br>        template: ` &lt;li &gt;[&#123;&#123;index&#125;&#125;]-&#123;&#123;item&#125;&#125;&lt;/li&gt;`<br>    &#125;)<br>    app.mount(&quot;#app&quot;)<br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h3 id="6-Vue的createApp-和mount-方法讲解"><a href="#6-Vue的createApp-和mount-方法讲解" class="headerlink" title="6.Vue的createApp()和mount()方法讲解"></a>6.Vue的createApp()和mount()方法讲解</h3><p><a href="https://jspang.com/article/68#toc322">最常见的Vue初级代码</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo6&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app = Vue.createApp(&#123;&#125;)<br>    app.mount(&quot;#app&quot;)<br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/68#toc323">createApp()和mount()方法讲解</a></p><p>现在你先看下面两句JavaScript代码,代码中有两个重要的方法<code>createApp()</code>和<code>mount()</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;&#125;)<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li><code>createApp()</code>方法：</li></ul><p>在第一篇文章编写<code>HelloWorld</code>的时候，就写过这句话<code>Vue.createApp()</code>从英文单词上理解，这个就是创建一个应用<code>create-创建</code>，<code>App-Application-应用</code>，前面的Vue就是Vue这个框架，所以<code>Vue.createApp()</code>的意思就是创建一个Vue的应用。</p><ul><li><code>mount()</code>方法</li></ul><p><code>mount()</code>方法就是挂载到某个Html的<code>DOM</code>节点上，它接受一个字符串型参数,参数可以使用CSS选择器，一般都是ID选择器的形式，指定挂载的<code>DOM</code>元素。</p><p><a href="https://jspang.com/article/68#toc324">createApp()方法的基本参数讲解</a></p><p>当你明白了<code>createApp()</code>方法的作用，接下来可以更深层次的去了解它的参数。首先它接受一个对象形式的参数<code>&#123;&#125;</code>。这个对象就是告诉Vue应该如何展现我们最外层的组件。 根据我们在初始章节学习的内容，我们很容易写出下面的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;jspang.com&#x27;</span><br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&quot;</span><br>    &#125;)<br>    app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>写完后，可以到浏览器中预览一下结果。</p><p><a href="https://jspang.com/article/68#toc325">如何获取Vue的根组件vm</a></p><p>当你使用<code>creatApp()</code>方法创建了一个Vue应用时，如何能获取根组件那?其实你使用<code>mount()</code>方法时，就会返回根组件。下面的代码，声明一个变量来获取根组件，并打印出来。通过打印你可以看出根组件是一个<code>Proxy</code>形式的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm)<br></code></pre></td></tr></table></figure><p>这里为什么我把根组件起名为<code>vm</code>那？我先按下不表，我们先来了解一下<code>Vue</code>的设计模式。</p><p><a href="https://jspang.com/article/68#toc326">mvvm设计模式讲解</a></p><p>Vue的编程设计模式应该叫做<code>mvvm</code>的设计模式。什么叫做<code>mvvm</code>？它首先是面向数据的编程，程序中定义了数据，然后定义了模板，<code>Vue</code>就可以把数据和模板自动进行关联。最后挂载到真实的<code>DOM</code>上，展示给用户。</p><blockquote><p>mvvm解释: 第一个<code>m</code>代表<code>model</code>数据，第一个<code>v</code>代表<code>view</code>视图，最后两个字幕<code>vm</code>代表<code>viewModel</code>视图数据连接层。</p></blockquote><p>如果你看完这个解释还不太明白，我们可以看一下<code>Demo6.html</code>进行理解。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;jspang.com&#x27;</span>   <span class="hljs-comment">//1.在这里定义了数据，也就是`model`数据</span><br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&quot;</span> <span class="hljs-comment">//2.在这里定义了模板，也就是`view`，</span><br>        <span class="hljs-comment">//定义后的自动关联，就叫做`vm`，viewModel数据视图连接层。</span><br>    &#125;)<br>    app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><code>model</code>数据，是我们自己定义的，<code>view</code>模板也是我们自己定义的，但是<code>vm</code>是Vue自动给我们关联的。</p><p>当我们明白了什么是<code>mvvm</code>后，你就知道为什么我们给根组件起名<code>vm</code>了。</p><p>当我们获取了<code>vm</code>根节点后，其实就可以操作里边的数据了。比如在控制台中输入下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.<span class="hljs-property">$data</span>.<span class="hljs-property">message</span> =<span class="hljs-string">&#x27;技术胖&#x27;</span><br></code></pre></td></tr></table></figure><p>这个时候你会发现网页界面也跟着发生了变化，变成了<code>技术胖</code>.</p><p>好了，我们总结一下这篇文章我们都学到了什么，首先我们学习了Vue中的两个最基本方法<code>createApp()</code>和<code>mount()</code>,然后学习了如何获取和使用<code>根组件</code>，在学习根组件的时候又讲解了Vue框架的基本模式是<code>mvvm</code>，并对<code>mvvm</code>模式进行了具体讲解。</p><h3 id="7-Vue的生命周期函数-1"><a href="#7-Vue的生命周期函数-1" class="headerlink" title="7.Vue的生命周期函数-1"></a>7.Vue的生命周期函数-1</h3><p>这篇文章我们讲解Vue3中的生命周期函数，生命周期函数你可以这样理解，就是<strong>在某一时刻会自动执行</strong>的函数，这句话你可以注意两个关键词<code>某一时刻</code>和<code>自动执行</code>。学完这节以后，你会对这两个词有深刻的理解。</p><p><a href="https://jspang.com/article/68#toc328">准备一个空白的页面</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Demo7<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue@next&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;jspang.com&#x27;</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&quot;</span></span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> vm = app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/68#toc329">自动执行函数的理解</a></p><p>如果要理解什么是自动执行函数，我认为可以对比来看，先清楚什么是被动执行函数。比如我们写了一个<code>handleItemClick( )</code>方法，然后让模板里的<code>&lt;h2&gt;</code>点击后执行此事件，代码如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">handleItemClick</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;jspang.com&#x27;</span>)<br>     &#125;<br> &#125;,<br> <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;&lt;h2 v-on:click=&#x27;handleItemClick&#x27;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&quot;</span><br></code></pre></td></tr></table></figure><p>这时候可以打开浏览器，看一下这个效果。你需要点击对应的dom元素，他才会执行方法，这个就是被动执行函数。当你了解被动执行函数，再来了解什么是自动执行函数。写一个<code>mounted</code>方法，它就会自动执行。这种就是自动执行函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;mounted&#x27;</span>)<br>&#125;,<br></code></pre></td></tr></table></figure><p>这时候你再刷新一下网页，就可以看出<code>mounted</code>被直接弹出了。这种没有任何操作，自动执行的方法，就叫做自动执行函数。</p><p>当你明白了什么是自动执行函数后，我们再来学习Vue3.x的生命周期函数。</p><p><a href="https://jspang.com/article/68#toc330">Vue3.x生命周期函数</a></p><p>学习生命周期函数，这里我们用一张Vue官方给出的声明周期函数图片来进行理解。看图理解会更透彻些。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208151958288.png" alt="https://newimg.jspang.com/Vuelifecycle.png"></p><ul><li>beforeCreate( ) ：在实例生成之前会自动执行的函数</li><li>created( ) : 在实例生成之后会自动执行的函数</li><li>beforeMount( ) : 在模板渲染完成之前执行的函数</li><li>mounted( ) : 在模板渲染完成之后执行的函数</li></ul><p>我们也写了对应的方法，通过这些代码和查看效果，可以很好的理解生命周期函数执行的先后顺序。代码如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeCreate&#x27;</span>)<br>&#125;,<br><span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;created&#x27;</span>)<br>&#125;,<br><span class="hljs-title function_">beforeMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeMount&#x27;</span>)<br>&#125;,<br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;mounted&#x27;</span>)<br>&#125;,<br></code></pre></td></tr></table></figure><p>写完这些代码后，你可以到浏览器中查看一下效果。由于Vue的生命周期函数内容很多，所以我们分两节来讲。下节继续讲解Vue的生命周期函数。</p><h3 id="8-Vue的生命周期函数-2"><a href="#8-Vue的生命周期函数-2" class="headerlink" title="8.Vue的生命周期函数-2"></a>8.Vue的生命周期函数-2</h3><p>接着上篇文章继续学习，上篇文章只讲了Vue3中的前四个生命周期。</p><p><a href="https://jspang.com/article/68#toc332">beforeUpdate和updated生命周期函数</a></p><p>这两个生命周期函数在Vue中的data数据发生变化时，才会被执行，一个是在变化之前，一个是在变化之后。先来看<code>beforeUpdate</code>函数，也就是在数据变化之前。</p><p>为了能展示这个效果，我们写一个数据变化的功能，每次点击文字都进行改变。在上节课编写的<code>handleItemClick</code>方法中，改变<code>message</code>的值。这里使用了三元运算符，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">handleItemClick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> == <span class="hljs-string">&#x27;jspang.com&#x27;</span> ? <span class="hljs-string">&quot;技术胖&quot;</span> : <span class="hljs-string">&quot;jspang.com&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有了这个方法之后，再来编写<code>beforeUpdate</code>方法。代码如下：</p><ul><li>beforeUpdate ：当data中的数据变化时， 会立即自动执行的函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeUpdate&#x27;</span>)<br>&#125;,<br></code></pre></td></tr></table></figure><ul><li>updated：当data中的数据发生变化，页面重新渲染完后，会自动执行的函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">updated</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;updated&#x27;</span>)<br>&#125;,<br></code></pre></td></tr></table></figure><p>在浏览器中你是可以看出先后顺序的。这个不太直观，如何用代码的方式看出<code>beforeUpdate</code>和<code>updated</code>区别？我们可以通过下面这种方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeUpdate&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>).<span class="hljs-property">innerHTML</span>)<br>&#125;,<br><span class="hljs-title function_">updated</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;updated&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>).<span class="hljs-property">innerHTML</span>)<br>&#125;,<br></code></pre></td></tr></table></figure><p>通过这种形式，就可以清楚的看出，在<code>beforeUpdate</code>时，DOM的内容并没有渲染更新，而到了<code>updated</code>中DOM的内容已经进行了更新。这就是两个生命周期函数的区别。</p><p><a href="https://jspang.com/article/68#toc333">beforUnmount( )和unmounted( )生命周期函数</a></p><p>这两个生命周期函数是在Vue销毁时自动执行的函数，一个是销毁前执行，一个是销毁后执行。</p><ul><li>beforeUnmount( ) :当Vue应用失效时，会自动执行的函数</li><li>unmounted() : 当Vue应用失效时，且DOM完全销毁之后，会自动执行</li></ul><p>我们可以先把这两个生命周期函数写在页面上，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">beforeUnmount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeUnmount&#x27;</span>)<br>&#125;,<br><span class="hljs-title function_">unmounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;unmounted&#x27;</span>)<br>&#125;,<br></code></pre></td></tr></table></figure><p>那如何能看到这个效果那？这个需要在浏览器的控制台中输入销毁代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">unmount</span>()<br></code></pre></td></tr></table></figure><p>这时候就会打印出这两个对应的生命周期函数了。当然你这时候如果编写程序看出页面变化，也可以通过打印<code>innerHTML</code>方式。来看出效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">beforeUnmount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeUnmount&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>).<span class="hljs-property">innerHTML</span>)<br>&#125;,<br><span class="hljs-title function_">unmounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;unmounted&#x27;</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>).<span class="hljs-property">innerHTML</span>)<br>&#125;,<br></code></pre></td></tr></table></figure><p>这时候在浏览器执行<code>app.unmount()</code>,会看到，在<code>beforeUnmount</code>方法中还是有DOM内容的，然后到了<code>unmounted</code>方法中，就已经没有任何的DOM内容了。</p><p>现在来总结一下：Vue3中有八个生命周期函数，</p><ul><li>beforeCreate( ) ：在实例生成之前会自动执行的函数</li><li>created( ) : 在实例生成之后会自动执行的函数</li><li>beforeMount( ) : 在模板渲染完成之前执行的函数</li><li>mounted( ) : 在模板渲染完成之后执行的函数</li><li>beforeUpdate ：当data中的数据变化时， 会立即自动执行的函数</li><li>updated：当data中的数据发生变化，页面重新渲染完后，会自动执行的函数</li><li>beforeUnmount( ) :当Vue应用失效时，会自动执行的函数</li><li>unmounted() : 当Vue应用失效时，且DOM完全销毁之后，会自动执行</li></ul><p>这些生命周期虽然多，你可以成对的去记忆，这样就有四个关键节点了：创建、渲染、更新、销毁。最主要的理解是他们是自动执行的函数。这节课就到这里，我们下节继续学习。</p><h3 id="9-插值表达式和v-bind数据绑定"><a href="#9-插值表达式和v-bind数据绑定" class="headerlink" title="9.插值表达式和v-bind数据绑定"></a>9.插值表达式和v-bind数据绑定</h3><p>这节课我们主要学习两个模板语法：插值表达式和v-bind的使用。</p><p><a href="https://jspang.com/article/68#toc335">插值表达式是什么？</a></p><p>以前经常说的<code>字面量</code>，其实正确叫法应该叫做<code>插值表达式</code>，当然我们公司大部分还是叫<code>字面量</code>的,也就是我们经常看到的<code>&#123;&#123;xxxx&#125;&#125;</code>这样的东西。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo7&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app = Vue.createApp(&#123;<br>        data() &#123;<br>            return &#123;<br>                message: &#x27;jspang.com&#x27;<br>            &#125;<br>        &#125;,<br>        methods: &#123;<br>            handleItemClick() &#123;<br>                this.message = this.message == &#x27;jspang.com&#x27; ? &quot;技术胖&quot; : &quot;jspang.com&quot;<br>            &#125;<br>        &#125;,<br>        template: &quot;&lt;h2 v-on:click=&#x27;handleItemClick&#x27;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;&quot;<br>    &#125;)<br>    const vm = app.mount(&quot;#app&quot;)<br><br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>这时候我们看到在<code>template</code>属性中的<code>&#123;&#123;message&#125;&#125;</code>就是插值表达式。也就是说利用这种形式，可以使用data中的变量，展示在模板中。</p><p><a href="https://jspang.com/article/68#toc336">插值表达式输出html标签-v-html指令</a></p><p>如果我想在变量里，编写一些html的标签，然后输出展现在页面中，这时候会出现点小问题。我们先修改代码，看看问题所在。例如在message中加入<code>&lt;i&gt;</code>标签。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;&lt;i&gt;jspang.com&lt;/i&gt;&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这时候如果什么都不做，直接输出，你在浏览器中看到的结果就是下面的样子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;i&gt;jspang.<span class="hljs-property">com</span>&lt;/i&gt;<br></code></pre></td></tr></table></figure><p>这并不是你想要的结果，这时候需要使用<code>v-html</code>的标签解决这个问题。把template属性的部分改成下面的样子。需要注意的是这压力要改成”`”符号，否则不能使用双引号这种形式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;h2 v-html=&quot;message&quot;&gt; &lt;/h2&gt;`</span><br></code></pre></td></tr></table></figure><p>这时候再预览，就可以看到浏览器中的字变成了斜体。</p><p><a href="https://jspang.com/article/68#toc337">插值表达式只作一次渲染-v-once</a></p><p>现在这种插值表达式，是跟着data中的数据一起变化的，也就是我们常说的数据双向绑定。但是如果我希望一个插值表达式，只有在第一次渲染去data中的值，而以后不再跟随data变化，这时候就要用到<code>v-once</code>指令。</p><p>先来看一下目前这种代码，我们为<code>h2</code>标签，加入相应事件<code>handleItemClick</code>,代码如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;h2 v-on:click=&quot;handleItemClick&quot; v-html=&quot;message&quot;&gt; &lt;/h2&gt;`</span><br></code></pre></td></tr></table></figure><p>这时候在浏览器中可以看到，我们每点击一次h2标签，<code>message</code>的值都是变化的。再改写一下代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;h2 </span><br><span class="hljs-string">                v-on:click=&quot;handleItemClick&quot; </span><br><span class="hljs-string">                v-html=&quot;message&quot;</span><br><span class="hljs-string">                v-once</span><br><span class="hljs-string">            &gt; &lt;/h2&gt;`</span><br></code></pre></td></tr></table></figure><p>加入了<code>v-once</code>后，无论data中的数据如何变化，模板也不会再次重新渲染了，这就是<code>v-once</code>的变化。</p><p><a href="https://jspang.com/article/68#toc338">插值表达式中是可以使用JS表达式的</a></p><p>其实在插值表达式中是可以使用JS表达式的，最常用的表达式是三元运算符。比如下面这样的代码也是可以的。比如在data中新声明一个变量<code>count</code>，用三元运算符判断是否是大于2，如果大于2显示大，小于2显示小，编写代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;<br>        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;&lt;i&gt;jspang.com&lt;/i&gt;&#x27;</span>,<br>                <span class="hljs-attr">count</span>: <span class="hljs-number">5</span><br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">methods</span>: &#123;<br>            <span class="hljs-title function_">handleItemClick</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> == <span class="hljs-string">&#x27;jspang.com&#x27;</span> ? <span class="hljs-string">&quot;技术胖&quot;</span> : <span class="hljs-string">&quot;jspang.com&quot;</span><br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;h2 </span><br><span class="hljs-string">                        v-on:click=&quot;handleItemClick&quot; </span><br><span class="hljs-string">                        v-html=&quot;message&quot;</span><br><span class="hljs-string">                        v-once</span><br><span class="hljs-string">                    &gt; &lt;/h2&gt;</span><br><span class="hljs-string">                    &lt;div&gt;&#123;&#123;count&gt;2?&#x27;大&#x27;:&#x27;小&#x27;&#125;&#125;&lt;/div&gt;</span><br><span class="hljs-string">                    `</span><br>    &#125;)<br>    <span class="hljs-keyword">const</span> vm = app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>当然你也可以使用一些简单的表达式，比如下面这些样子的JS表达式.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;&#123;&#123;<span class="hljs-string">&#x27;jspang&#x27;</span>+<span class="hljs-string">&#x27;.com&#x27;</span>&#125;&#125;&lt;/div&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;1+2&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这些形式的表达式都是可以的，但是如果你想用if语句，就是不可以的，因为只能用JS表达式而不能用语句。</p><p><a href="https://jspang.com/article/68#toc339">v-bind指令的使用</a></p><p>现在我们给h2标签加入一个title属性(鼠标放上去会出现的小便签)，属性的值也想使用<code>message</code>。代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;h2 <br>  v-<span class="hljs-attr">on</span>:click=<span class="hljs-string">&quot;handleItemClick&quot;</span> <br>  v-html=<span class="hljs-string">&quot;message&quot;</span><br>  v-once<br>  title=<span class="hljs-string">&quot;message&quot;</span><br>&gt; &lt;/h2&gt;<span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这时候浏览器中鼠标放上时显示的是双引号里的<code>message</code>这个单词，而并没有出现我们想要的结果。这时候就可以使用<code>v-bind</code>标签了。写成下面的样式就可以把<code>message</code>和变量名进行绑定，输出<code>message</code>变量的内容了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">v-<span class="hljs-attr">bind</span>:title=<span class="hljs-string">&quot;message&quot;</span><br></code></pre></td></tr></table></figure><p>总结一下，先学习了插值表达式和一些特殊情况的用法，从而引出了<code>v-html</code>指令,<code>v-once</code>指令和在插值表达式中使用JS表达式。然后又学习了<code>v-bind</code>指令。</p><h3 id="10-模板动态参数和阻止默认事件"><a href="#10-模板动态参数和阻止默认事件" class="headerlink" title="10.模板动态参数和阻止默认事件"></a>10.模板动态参数和阻止默认事件</h3><p><a href="https://jspang.com/article/68#toc341">v-on的基本用法和简写</a></p><p><code>v-on</code>是用来绑定响应事件的，在以前的课程中多次用到了。这里就先写一个最简单的事件，弹出对话框。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">hanldClick</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;欢迎光临红浪漫&#x27;</span>)<br>    &#125;<br>&#125;,<br><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">&lt;h2 v-on:click=&quot;hanldClick&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>在浏览器中可以看出，点击<code>&lt;h2&gt;</code>标签，就可以弹出alert效果。这个你一定很熟悉了，所以没必要作过多的讲解。</p><p><code>v-on</code>还有一个简写方法，就是可以把<code>v-on:</code>用<code>@</code>代替，比如把代码改成下面的样子，也是完全可以使用的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">&lt;h2 @click=&quot;hanldClick&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>不仅<code>v-on</code>有简写方法，上节我们学习的<code>v-bind</code>也有简写方法<code>:</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;h2 v-<span class="hljs-attr">bind</span>:title=<span class="hljs-string">&quot;message&quot;</span>&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>Vue在开发中还是鼓励大家使用简写，这样可以让代码更加清晰。</p><p><a href="https://jspang.com/article/68#toc342">模板动态参数</a></p><p>现在绑定的事件<code>click</code>和<code>title</code>都是固定死的，显得不太灵活，Vue也提供了动态参数，要叫做动态属性的功能。比如这里<code>v-bind:title</code>中的<code>title</code>是来自<code>data</code>中的，就可以这样写。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123; <br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span>&#123;<br>            <span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;jspang.com&#x27;</span> ,<br>            <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;title&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-comment">//.........</span><br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;h2 </span><br><span class="hljs-string">            @click=&quot;hanldClick&quot;</span><br><span class="hljs-string">            :[name]=&quot;message&quot;</span><br><span class="hljs-string">        &gt;</span><br><span class="hljs-string">        &#123;&#123;message&#125;&#125;</span><br><span class="hljs-string">        &lt;/h2&gt;</span><br><span class="hljs-string">    `</span><br><br>&#125;)<br></code></pre></td></tr></table></figure><p>可以看到我们在<code>data</code>中，定义了一个name的变量，值是一个字符串，然后在绑定属性时我们使用了<code>[]</code>方括号加上data中变量名的形式。这时候绑定的属性就变的灵活了，这种形式就是模板动态参数，也称为动态属性。</p><p>可以在浏览器中使用<code>检查</code>的方式，查看此时绑定属性的名称，如果进行修改，比如改成<code>title1</code>,浏览器中也会跟随改变，形成动态效果，这就是动态属性了。</p><p><strong>事件动态绑定</strong></p><p>这种形式，也可以用到<code>v-on</code>事件绑定当中，比如在<code>data</code>中声明一个<code>event</code>的变量，然后给他一个<code>click</code>,然后用同样的方法实现事件动态绑定。</p><p>data中的写法如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">return</span>&#123;<br>    <span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;jspang.com&#x27;</span> ,<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;title&#x27;</span>,<br>    <span class="hljs-attr">event</span>:<span class="hljs-string">&#x27;click&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>模板中的写法如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h2 </span><br><span class="hljs-string">        @[event]=&quot;hanldClick&quot;</span><br><span class="hljs-string">        :[name]=&quot;message&quot;</span><br><span class="hljs-string">    &gt;</span><br><span class="hljs-string">    &#123;&#123;message&#125;&#125;</span><br><span class="hljs-string">    &lt;/h2&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这时候就实现了动态绑定方法，可以打开浏览器，看一下效果。当点击<code>&lt;h2&gt;</code>标签时，也会弹出对应的alert效果。当然你还可以帮<code>click</code>改成其他相应事件，比如改成<code>event:&#39;mouseenter&#39;</code>，这样，当鼠标滑入时就可以相应弹出效果了。</p><p><a href="https://jspang.com/article/68#toc343">阻止默认事件</a></p><p>最常见的默认事件就是表单的默认提交事件，比如我们这里写一个表单，然后写一个属性为<code>submit</code>的按钮，当点击按钮时，表单就会默认提交到对应的网址。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;form action=<span class="hljs-string">&quot;https://jspang.com&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>默认提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/form&gt;<br></code></pre></td></tr></table></figure><p>这时候在浏览器中预览，点击“默认提交”按钮，就会立即跳转到我的博客上去，这就是默认响应事件。但是在开发中我们经常需要阻止这种默认响应事件。比如写出下面的代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">hanldeClick</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;欢迎光临红浪漫&#x27;</span>)<br>    &#125;,<br>    <span class="hljs-title function_">hanldeButton</span>(<span class="hljs-params">e</span>)&#123;<br>        e.<span class="hljs-title function_">preventDefault</span>()<br>    &#125;<br>&#125;,<br><span class="hljs-comment">//...</span><br><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">      //....</span><br><span class="hljs-string">&lt;form action=&quot;https://jspang.com&quot; @click=&quot;hanldeButton&quot;&gt;</span><br><span class="hljs-string">    &lt;button type=&quot;submit&quot;&gt;默认提交&lt;/button&gt;</span><br><span class="hljs-string">&lt;/form&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这样写就可以阻止默认事件方法了，但是这是一个经常要做的操作，每次写太麻烦了，所以Vue也给我们提供了一个模板修饰符，直接可以阻止默认行为。写法如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;form <br>    action=<span class="hljs-string">&quot;https://jspang.com&quot;</span> <br>    @click.<span class="hljs-property">prevent</span>=<span class="hljs-string">&quot;hanldeButton&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>默认提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/form&gt;<br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>methods中的写法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">hanldeButton</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;jspang.com&#x27;</span>) <br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以阻止默认事件，直接响应对应事件的内容了。<code>prevent</code>就是阻止默认事件的修饰符。修饰符可以简化一些代码的编写，也是比较常用的一个操作。</p><p>好了这节课就到这里了，下节课我们再介绍一个模板中最常用的语法，<code>v-if</code>。</p><h3 id="11-模板中使用条件判断"><a href="#11-模板中使用条件判断" class="headerlink" title="11.模板中使用条件判断"></a>11.模板中使用条件判断</h3><p>模板中使用条件判断，控制页面的样式，是最常见的应用。Vue中提供了两种基本的方法，一种是我们已经讲过的三元运算符，另一种就是<code>v-if</code>。</p><p><a href="https://jspang.com/article/68#toc345">三元运算符控制模板样式</a></p><p>我们先来看利用三元运算符来控制模板的样式，根据Data中值的不同，显示不同的样式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>    &lt;head&gt;<br>        &lt;meta charset=&quot;UTF-8&quot;&gt;<br>        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>        &lt;title&gt;Demo11&lt;/title&gt;<br>        &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;<br>    &lt;/head&gt;<br><br>    &lt;body&gt;<br>        &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>    &lt;/body&gt;<br>    &lt;script&gt;<br>        const app = Vue.createApp(&#123;<br>            data() &#123;<br>                return &#123;<br>                    message: &#x27;jspang.com&#x27;,<br>                &#125;<br>            &#125;,<br>            methods: &#123;<br>                handleItemClick() &#123;<br>                    this.message = this.message == &#x27;jspang.com&#x27; ? &quot;技术胖&quot; : &quot;jspang.com&quot;<br>                &#125;<br>            &#125;,<br>            template: `&lt;h2 &gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;`<br><br>        &#125;)<br>        const vm = app.mount(&quot;#app&quot;)<br>    &lt;/script&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>这就是一个最简单的Vue代码了，然后我们在<code>&lt;script&gt;</code>标签下面，写一段<code>style</code>样式代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;style&gt;<br>    .<span class="hljs-property">one</span> &#123;<span class="hljs-attr">color</span>: red;&#125;<br>    .<span class="hljs-property">two</span> &#123;<span class="hljs-attr">color</span>: green;&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>这里有两个基本的CSS样式，分别是让文字是红色和绿色。现在的需求是，要根据<code>message</code>的值显示不同的颜色，是<code>jspang.com</code>显示红色，是<code>技术胖</code>时显示绿色。类似这样的需求，就可以使用三元运算符，然后绑定class的形式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;h2 </span><br><span class="hljs-string">                :class=&quot;message==&#x27;jspang.com&#x27;?&#x27;one&#x27;:&#x27;two&#x27;&quot; </span><br><span class="hljs-string">                @click=&quot;handleItemClick&quot; &gt;</span><br><span class="hljs-string">                &#123;&#123;message&#125;&#125;</span><br><span class="hljs-string">        &lt;/h2&gt;`</span><br></code></pre></td></tr></table></figure><p>这时候文字变化，对应的css样式也会变化。可以打开浏览器，看一下效果。</p><p><a href="https://jspang.com/article/68#toc346">v-if判断</a></p><p>三元运算符的限制还是比较明显的，就是只能判断两个值，如果这时候我们再加入一个值，就是既不是<code>jspang.com</code>,也不是<code>技术胖</code>的时候，我们显示橙色。这时候三元运算符就满足不了需求了。vue给我们准备了v-if判断。</p><p>我们先加入一个CSS样式<code>three</code>:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;style&gt;<br>    .<span class="hljs-property">one</span> &#123;<span class="hljs-attr">color</span>: red;&#125;<br>    .<span class="hljs-property">two</span> &#123;<span class="hljs-attr">color</span>: green;&#125;<br>    .<span class="hljs-property">three</span>&#123;<span class="hljs-attr">color</span>:orange;&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>然后可以使用<code>v-if</code>来进行编写模板。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">&lt;h2 @click=&quot;handleItemClick&quot; v-if=&quot;message==&#x27;jspang.com&#x27;&quot; class=&quot;one&quot; &gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt;</span><br><span class="hljs-string">&lt;h2 @click=&quot;handleItemClick&quot; v-if=&quot;message==&#x27;技术胖&#x27;&quot; class=&quot;two&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt;</span><br><span class="hljs-string">&lt;h2 @click=&quot;handleItemClick&quot; v-if=&quot;message==&#x27;bilibili&#x27;&quot;  class=&quot;three&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt;</span><br><span class="hljs-string">    `</span><br></code></pre></td></tr></table></figure><p>当然，你也可以使用<code>v-else</code>，比如下面把代码改为这个样子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">&lt;h2 @click=&quot;handleItemClick&quot; v-if=&quot;message==&#x27;jspang.com&#x27;&quot; class=&quot;one&quot; &gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt;</span><br><span class="hljs-string">&lt;h2 @click=&quot;handleItemClick&quot; v-else  class=&quot;three&quot;&gt; &#123;&#123;message&#125;&#125; &lt;/h2&gt;</span><br><span class="hljs-string">    `</span><br></code></pre></td></tr></table></figure><p><code>v-if</code> 在实际的工作中使用的也是非常多的，所以建议你多写两边，加深一下印象。这篇文章完成后，我们关于Vue模板方面的语法就基本结束了。</p><h3 id="12-计算属性-computed"><a href="#12-计算属性-computed" class="headerlink" title="12.计算属性-computed"></a>12.计算属性-computed</h3><p>这篇文章来学习一下Vue3中的计算属性。计算属性的特性是：当计算属性依赖的内容发生变更时，才会重新执行计算。我相信这时候你还不能很好的理解这句话的意思，所以需要通过实际的代码来进行演示。</p><p><a href="https://jspang.com/article/68#toc348">编写基本页面和准备变量</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo12-Vue中的计算属性&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot; &gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br><br>    const app=Vue.createApp(&#123; <br>        data()&#123;<br>            return&#123;<br>                message:&#x27;jspang.com&#x27; , <br>            &#125;<br>        &#125;,<br>        methods:&#123;<br>            handleItemClick()&#123;<br>               this.message = this.message==&#x27;jspang.com&#x27;?&#x27;技术胖&#x27;:&#x27;jspang.com&#x27;<br>            &#125;<br>        &#125;,<br>        template:`<br>            &lt;h2&gt; &#123;&#123;message&#125;&#125;&lt;/h2&gt;<br>        `<br>    &#125;) <br>    const vm=app.mount(&quot;#app&quot;)<br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>有了基本的Vue基本结构后，我们先在Data中生命两个变量，单价(price)和数量（count）。单价设置为10，数量设置为2个。data中的代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;jspang.com&#x27;</span> , <br>        <span class="hljs-attr">price</span>:<span class="hljs-number">10</span>,<br>        <span class="hljs-attr">count</span>:<span class="hljs-number">2</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后我们在模板<code>template</code>中打印出两个变量的综合<code>price * count</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">` &lt;h2&gt; &#123;&#123;price * count&#125;&#125;&lt;/h2&gt;`</span><br></code></pre></td></tr></table></figure><p>如果 一切正常的话，这时候打开浏览器预览，你应该可以看到页面上显示的是<code>20</code>。</p><p>这种方法当然可以，但是显得不够优雅，也没有语义化。如果你想进行语义化，你可能想到的第一个办法就是写一个<code>getTotal</code>的方法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>        <span class="hljs-title function_">getTotal</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * (<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++);<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">` &lt;h2&gt; &#123;&#123;getTotal()&#125;&#125;&lt;/h2&gt;`</span><br></code></pre></td></tr></table></figure><p>这时候你再次查看浏览器，依然可以得到同样的结果。也许你还看不出来什么问题，但此时他确实存在一些问题，问题就是只要页面中有一个值重新渲染了，他都会重新执行。</p><p><a href="https://jspang.com/article/68#toc349">methods方法无法满足的需求</a></p><p>如何看出这个问题？我们可以稍微修改一下代码，让每次得到的值都不同。这时候可以使用获得时间戳的方法，来获得当前的时间戳。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">getTotal</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>我们同时在模板中，打印出<code>message</code>的值，代码如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">` </span><br><span class="hljs-string">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;h2&gt; &#123;&#123;getTotal()&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这时候打开浏览器的控制台<code>console</code>，然后在里边通过手都的方式修改<code>message</code>的值<code>vm.message=&#39;1111&#39;</code>，比如修改为<code>技术胖</code>。这时候问题产生了，你会发现<code>getTotal( )</code>方法被重新执行了。这就是这个问题的所在，这个问题其实可以用今天的主角<code>coumputed</code>计算属性来解决。</p><p><a href="https://jspang.com/article/68#toc350">编写计算属性</a></p><p>还是获取当前的时间戳，但是写在了计算属性中。计算属性的关键字是<code>computed</code>,然后里边可以写计算用的方法，这里我起名叫做<code>total</code>，当然你可以起任何的名字。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">computed</span>:&#123;<br>    <span class="hljs-title function_">total</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后我们把上面模板中的方法<code>getTotal( )</code>换成计算属性<code>total</code>。模板的代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">` </span><br><span class="hljs-string">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;h2&gt; &#123;&#123;total&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这时候到浏览器中，用手动的方法，修改<code>message</code>的值，<code>total</code>的值就不会进行改变了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">vm.<span class="hljs-property">message</span>=<span class="hljs-string">&#x27;1111&#x27;</span><br></code></pre></td></tr></table></figure><p>通过这个例子，你会对普通方法和计算属性的区别有所了解。这时候我们作一下总结：</p><ol><li>方法methods：只要有任何参数发生改变进行页面重新渲染，就会重新执行方法</li><li>计算属性computed: 当计算属性依赖的内容发生变更时，才会重新执行计算</li></ol><p>那我们再来看计算属性改变的例子。</p><p><a href="https://jspang.com/article/68#toc351">计算属性-computed实例</a></p><p>我们还是用<code>单价X数量=总和</code>这个小例子，来说明具体计算属性的使用方法。修改当前代码，把计算属性中<code>total( )</code>方法内容修改。不同的是我们这次加入一个按钮，每点击一下按钮，就会让数量<code>count</code>加1。</p><p>我们先来修改计算属性中的内容。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">computed</span>:&#123;<br>    <span class="hljs-title function_">total</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后在模板中写一个按钮，每次点击按钮<code>count</code>数量进行增加。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">addCount</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++<br>    &#125;<br>&#125;,<br><span class="hljs-attr">template</span>:<span class="hljs-string">` </span><br><span class="hljs-string">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;h2&gt; &#123;&#123;total&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;button @click=&quot;addCount&quot;&gt;再买一个&lt;/button&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这时候我们再到浏览器中查看效果，当点击按钮的时候，计算属性会帮助我们完成模板的自动更新。</p><p>好了，我们总结一下，这节我们主要学习了Vue中的计算属性，重点在于理解计算属性和普通methods方法的区别，当你明白了两者的区别后，在工作中就可以清楚的知道什么时候该用计算属性，什么时候该用vue的方法了。</p><h3 id="13-Vue中的侦听器-监听器-watch"><a href="#13-Vue中的侦听器-监听器-watch" class="headerlink" title="13.Vue中的侦听器/监听器-watch"></a>13.Vue中的侦听器/监听器-watch</h3><p>这篇文章学习Vue中的侦听器（也有叫监听器），它可以侦听data中值的变化，做出相应的操作。这看起来和上节讲的计算属性（computed）很像，但如果你足够细心，也可以发现一些区别，下面我们就开始学习吧。</p><p><a href="https://jspang.com/article/68#toc353">侦听器的基本写法</a></p><p>watch侦听器的作用就是侦听一个data中的值的变化，变化后可以写一个方法，让其进行一些操作（业务逻辑的编写）。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">watch</span>:&#123;<br>    <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;count changed&#x27;</span>)<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>上面代码的意思是，写一个侦听器来侦听<code>count</code>的数据变化，当<code>count</code>变化之后立即在控制台打印出<code>count changed</code>。</p><p>侦听器中的方法还可以接收两个参数，一个是现在的值（current），一个是变化之前的值（prev），是系统内置的，顺序固定，变量名可任意取。我们分别接收这两个值，并打印在控制台，看一下效果。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">watch</span>:&#123;<br>    <span class="hljs-title function_">count</span>(<span class="hljs-params">current,prev</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;watch changed&#x27;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;现在的值：&#x27;</span>,current)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;变化前的值：&#x27;</span>,prev)<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>在浏览器中可以看到打印的效果。先打印出了3，然后又打印出了2。需要注意的是两个参数的先后顺序，如果不小心，是很容易记反的。</p><p><a href="https://jspang.com/article/68#toc354">侦听器和计算属性的区别</a></p><p>这时候问题来了，计算属性也是可以根据变化执行一些操作的，那侦听器watch和计算属性computed的区别是什么？</p><p>先给出结论，计算属性computed必须要返回一个值，而且在页面渲染的同时就会执行里边的业务逻辑，也就是会先执行一遍你写的业务逻辑，而<code>watch</code>只有发生变化时才会执行，也就是说值没有变化，它是不执行里边业务逻辑的。为了验证结果，先注释掉侦听器watch相关的内容，在计算属性<code>total</code>中写这样的代码。</p><p>代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">computed</span>:&#123;<br>    <span class="hljs-title function_">total</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;....count changed&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/68#toc355">计算属性（computed）更加简洁</a></p><p>再来思考一个问题，用watch侦听器，可以写出类似计算属性的代码吗？答案是肯定的。现在我们就就写一个类似计算属性效果。</p><p>先在data中声明一个新的变量，叫做<code>newTotal</code>，给出一个<code>20</code>的值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-comment">//....</span><br>        <span class="hljs-attr">newTotal</span>:<span class="hljs-number">20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后修改watch中代码，写一个乘法表达式算出<code>总和</code>，赋值给<code>this.newTotal</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">watch</span>:&#123;<br>    <span class="hljs-title function_">count</span>(<span class="hljs-params">current,prev</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">newTotal</span>=<span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> * current<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>最后把模板中的渲染值，改为<code>newTotal</code>就可以了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    //......</span><br><span class="hljs-string">    &lt;h2&gt;总和：&#123;&#123;newTotal&#125;&#125;&lt;/h2&gt;</span><br><span class="hljs-string">    //......</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>写完这些，你在浏览器中看到的效果和计算是属性是一样的。但是从代码简洁性上，显然侦听器的写法是麻烦并冗余，所以建议优先使用计算属性来完成同样的操作。</p><p><a href="https://jspang.com/article/68#toc356">method、watch和computed三者使用优先级</a></p><p>现在总结一下method、watch和computed三者如果都能实现相同的功能，它们之间的取舍和使用优先级。</p><ul><li><code>computed</code> 和 <code>method</code>都能实现的功能，建议使用computed,因为有缓存，不用渲染页面就刷新。</li><li><code>computed</code> 和 <code>watch</code> 都能实现的功能，建议使用 computed，因为更加简洁。</li></ul><h3 id="14-模板样式绑定详细讲解"><a href="#14-模板样式绑定详细讲解" class="headerlink" title="14.模板样式绑定详细讲解"></a>14.模板样式绑定详细讲解</h3><p>这篇文章我们主要学习Vue中的一些关于样式(style)的内容。样式绑定的内容还是不少的，所以分两篇文章：初识和进阶来讲述。首先我们要编写一个基本的最简单的页面。</p><p><a href="https://jspang.com/article/68#toc358">准备干净的页面</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo14&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot; &gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app=Vue.createApp(&#123; <br><br>        template:`<br>            &lt;h2&gt;JSPang.com&lt;/h2&gt;  <br>        ` <br>    &#125;) <br>    const vm=app.mount(&quot;#app&quot;)<br><br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/68#toc359">写两个最基本的样式 并引入到模板</a></p><p>在文件的下方，我们写三个最进本的样式<code>red</code>、<code>green</code>和<code>background</code>，代码分别如下:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;style&gt;<br>    .<span class="hljs-property">red</span>&#123;<span class="hljs-attr">color</span>:red;&#125;<br>    .<span class="hljs-property">green</span>&#123;<span class="hljs-attr">color</span>:green;&#125;<br>    .<span class="hljs-property">background</span>&#123; background-<span class="hljs-attr">color</span>: orange;&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>引用样式,在Vue的模板中引用和普通的html的方法一样。直接写class加上类名就可以了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h2 class=&quot;red&quot;&gt;JSPang.com&lt;/h2&gt;  </span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这时候你可以考虑一个问题，如果你希望程序足够灵活，样式也是可以控制的，这样引入样式的方法就不行了。你需要先在Data中声明变量，然后在模板<code>template</code>中进行绑定。</p><p>声明data变量:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">classString</span>:<span class="hljs-string">&#x27;red&#x27;</span>,<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>有了这个变量（或者叫做数据项）以后，就可以用bind的形式进行绑定。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;h2 v-<span class="hljs-attr">bind</span>:<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;<span class="hljs-title class_">JSPang</span>.<span class="hljs-property">com</span>&lt;/h2&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>JSPang.com<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>绑定同样使用<code>v-bind</code>，你也可以使用简写<code>:</code>。上面的两种形式都可以进行绑定。这时候你可以到浏览器中查看一下效果，如果一切正常，此时应该还是红色的。</p><p>此时你可以利用浏览器的控制台，输入对应的代码，直接控制样式了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">vm.<span class="hljs-property">$data</span>.<span class="hljs-property">classString</span>=<span class="hljs-string">&#x27;green&#x27;</span><br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/68#toc360">Vue中用对象和数组的形式控制样式</a></p><p><strong>对象的绑定方式</strong></p><p>比如现在用对象的形式进行绑定样式，好处是一次可以绑定多个样式。比如这样的代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">classString</span>:<span class="hljs-string">&#x27;red&#x27;</span>,<br>        <span class="hljs-attr">classObject</span>:&#123;<span class="hljs-attr">red</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">background</span>:<span class="hljs-literal">true</span>&#125;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>值为<code>true</code>代表绑定，值为<code>false</code>代表不绑定这个样式。</p><p>然后进行绑定</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h2 :class=&quot;classObject&quot;&gt;JSPang.com&lt;/h2&gt;  </span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这时候再到浏览器中查看效果，就会有两个样式被绑定了<code>red</code>和<code>background</code>。如果你这时候把red改为false，那效果就是只有背景颜色，没有字体颜色了。</p><p><strong>数组的绑定方式</strong></p><p>再来看一下数组的绑定方式，数组也是可以绑定多个样式的。</p><p>代码如下:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">classString</span>:<span class="hljs-string">&#x27;red&#x27;</span>,<br>        <span class="hljs-attr">classObject</span>:&#123;<span class="hljs-attr">red</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">background</span>:<span class="hljs-literal">true</span>&#125;,<br>        <span class="hljs-attr">classArray</span>:[<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;background&#x27;</span>],<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>这时候再修改一下绑定值,页面样式就变成了绿字，橙色的底啦。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h2 :class=&quot;classArray&quot;&gt;JSPang.com&lt;/h2&gt;  </span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>你也可以在这种数组的数据项中，再嵌套对象的形式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">classArray</span>:[<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;background&#x27;</span>,&#123;<span class="hljs-attr">red</span>:<span class="hljs-literal">true</span>&#125;],<br></code></pre></td></tr></table></figure><p>如果看不到效果，可以在CSS样式中增加<code>!important</code>，把优先级提高，当然你也可以在浏览器的控制台查看。</p><h3 id="15-模板样式绑定-2进阶"><a href="#15-模板样式绑定-2进阶" class="headerlink" title="15.模板样式绑定-2进阶"></a>15.模板样式绑定-2进阶</h3><p>这篇文章继续学习Vue的模板样式绑定。上篇文章你已经对Vue中的样式绑定有一个基本了解。我们预习一下，上节课我们学了三种绑定样式的方法：</p><ul><li>通过普通字符串进行绑定；</li><li>通过对象的方式进行绑定；</li><li>通过数组的方式进行绑定。</li></ul><p>这篇主要学习一下Vue中子组件样式的绑定和行内样式如何编写。</p><p><a href="https://jspang.com/article/68#toc362">子组件的样式绑定</a></p><p>先来看一下子组件如何绑定样式。编写一个子组件<code>SonCom</code>，组件中就是展示一个简单的内容。</p><p>代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;sonCom&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;SonCom&lt;/div&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>有了子组件后，就可以在父组件的模板中进行使用了，使用就是直接写一个类似html的标签进去就可以。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h2 :class=&quot;classArray&quot;&gt;JSPang.com&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;sonCom /&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p><strong>如何区分父子组件</strong></p><p>在<code>vue.createApp( )</code>方法中用对象形式<code>&#123; &#125;</code>配置的一般叫做父组件，而下面使用的其他组件，叫做子组件。<strong>你也可以这样理解，主动调用的是父组件，被调用的是子组件</strong>。</p><p>最简单的为子组件添加样式的方法，就是自己给子组件加上<code>class</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;sonCom&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div class=&quot;green&quot;&gt;SonCom&lt;/div&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这时候子组件的字体颜色就变成了绿色。你还可以把class写在调用子组件的地方（也就是写在父组件里），例如下面的代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h2 :class=&quot;classArray&quot;&gt;JSPang.com&lt;/h2&gt;</span><br><span class="hljs-string">    &lt;sonCom class=&#x27;green&#x27; /&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>先去掉子组件里的class，在调用地方增加class样式。这时候效果也是一样的。</p><p><a href="https://jspang.com/article/68#toc363">子组件使用样式的小坑</a></p><p>这时候我们修改一下子组件，再写一个<code>&lt;div&gt;</code>进去，里边写上<code>技术胖</code>的字样。这时候再来看结果。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;sonCom&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;SonCom&lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;技术胖&lt;/div&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>你会发现两个<code>&lt;div&gt;</code>的样式都不起作用了。那我们如何让它变成绿色那，其实只有再两个并列的<code>&lt;div&gt;</code>外层，加上一个包括性的标签就可以了。也就是说让子组件的最外层只有一个根元素。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;sonCom&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">            &lt;div&gt;SonCom&lt;/div&gt;</span><br><span class="hljs-string">            &lt;div&gt;技术胖&lt;/div&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这样就又变成了绿色字体。还有一种用到动态绑定的方法，直接绑定属性中的class。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;sonCom&#x27;</span>,&#123;<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div :class=&quot;$attrs.class&quot;&gt;SonCom&lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;技术胖&lt;/div&gt; </span><br><span class="hljs-string">    `</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/68#toc364">行内样式的编写</a></p><p>什么是行内样式?就是自己在模板的DOM元素上写CSS样式，比如下面的这样。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;h2 style=<span class="hljs-string">&quot;color:orange;&quot;</span>&gt;<span class="hljs-title class_">JSPang</span>.<span class="hljs-property">com</span>&lt;/h2&gt;<br></code></pre></td></tr></table></figure><p>除了这种写法以外，Vue中也为我们扩展了一些内容，让行内样式的写法更直观和令狐。你可以直接在data中编写样式，比如在Data中这样写。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">styleString</span>:<span class="hljs-string">&#x27;color:orange;&#x27;</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后用绑定行内样式的形式，在模板中进行绑定。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h2 :style=&quot;styleString&quot;&gt;JSPang.com&lt;/h2&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p><strong>你也可以用对象的形式在data中编写CSS样式。</strong>比如写成下面的代码，然后再进行绑定。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>       <span class="hljs-comment">//.....</span><br>        <span class="hljs-attr">styleString</span>:<span class="hljs-string">&#x27;color:orange;&#x27;</span>,<br>        <span class="hljs-attr">styleObject</span>:&#123;<br>            <span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;red&#x27;</span>,<br>            <span class="hljs-attr">background</span>:<span class="hljs-string">&#x27;yellow&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>在写行内样式的使用，个人觉的对象的写法更加直观和简洁，所以建议小伙伴可以采用这种对象的形式来进行编写。</p><h3 id="16-v-show和v-if的差别"><a href="#16-v-show和v-if的差别" class="headerlink" title="16.v-show和v-if的差别"></a>16.v-show和v-if的差别</h3><p>这篇学一个和<code>v-if</code>很类似的语法<code>v-show</code>，以及它和<code>v-if</code>有什么区别，算是一个补充课程。</p><p><a href="https://jspang.com/article/68#toc366">v-show的基本语法</a></p><p>代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo16&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot; &gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app=Vue.createApp(&#123; <br>    data()&#123;<br>        return&#123;<br><br>        &#125;<br>    &#125;,<br>    template:`<br>        &lt;h2&gt;JSPang.com&lt;/h2&gt;  <br>        ` <br>    &#125;) <br>    const vm=app.mount(&quot;#app&quot;)<br><br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>准备好最基本的结构后，在数据项中声明一个<code>show</code>的变量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">show</span>:<span class="hljs-literal">true</span>,<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>有了变量后，可以在模板中使用<code>v-show</code>来控制CSS样式，从而控制DOM元素的展示与否。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;h2 v-show=&quot;show&quot;&gt;JSPang.com&lt;/h2&gt;  </span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这时候打开浏览器进行预览，是可以看到<code>JSPang.com</code>这个h2的DOM元素的。如果把数据项<code>show</code>改成<code>false</code>就看不到了。</p><p><a href="https://jspang.com/article/68#toc367">v-if和v-show的区别</a></p><p>v-show看起来和v-if语法的功能基本一样，但其实他们无论是灵活性还是功能都是有区别的。</p><p><code>v-if</code><strong>更加灵活</strong>，可以增加多个判断，比如<code>v-else-iif</code>和<code>else</code>，而<code>v-show</code><strong>不具备这样的灵活性</strong>。</p><p>v-show控制DOM元素显示，其实控制的是css样式，也就是<code>display:none</code>。现在你可以把<code>data</code>的值修改为false，然后刷新浏览器，打开浏览器调试器的<code>Elements</code>选项卡，就可以清楚的看到，这时候<code>&lt;h2&gt;</code>标签上的style样式就是<code>display:none</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;h2 style=<span class="hljs-string">&quot;display: none;&quot;</span>&gt;<span class="hljs-title class_">JSPang</span>.<span class="hljs-property">com</span>&lt;/h2&gt;<br></code></pre></td></tr></table></figure><p>现在回到vscode中的代码，在模板中再复制一行，这时候用<code>v-if</code>进行判断。再次在浏览器中预览，你会发现整个DOM元素都不见了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;h2 v-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;<span class="hljs-title class_">JSPang</span>.<span class="hljs-property">com</span>&lt;/h2&gt;<br></code></pre></td></tr></table></figure><p>现在你应该明白了<code>v-if</code> 和<code>v-show</code>的区别,那如何使用他们。这个就要看具体的需求了，如果显示和隐藏的状态切换比较频繁，并且没有什么多余复杂的业务逻辑，建议使用<code>v-show</code>,因为他不会一直渲染你的页面DOM元素，这或多或少对性能和稳定性有点提升。反之可以使用<code>v-if</code>。</p><h3 id="17-v-for循环详细讲解-1"><a href="#17-v-for循环详细讲解-1" class="headerlink" title="17.v-for循环详细讲解-1"></a>17.v-for循环详细讲解-1</h3><p><a href="https://jspang.com/article/68#toc369">v-for循环数组的方法</a></p><p>v-for最常用的功能就是循环数组，先来看一个数组循环的例子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot; &gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app=Vue.createApp(&#123; <br>        data()&#123;<br>            return&#123;   <br>            &#125;<br>        &#125;,<br>        methods:&#123;<br>        &#125;,<br>        template:``<br><br>    &#125;) <br>    const vm=app.mount(&quot;#app&quot;)<br>&lt;/script&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>也就是最基本的一个Vue文件结构。然后在<code>data</code>中声明一个数组，数组叫做<code>listArray</code>,代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;  <br>        <span class="hljs-attr">listArray</span>:[<span class="hljs-string">&#x27;谢大脚&#x27;</span>,<span class="hljs-string">&#x27;刘英&#x27;</span>,<span class="hljs-string">&#x27;晓红&#x27;</span>]<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>data中数组写完后，现在要做的是在<code>template</code>中循环出这些数组,这里当然使用<code>v-for</code>，代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;ul&gt;</span><br><span class="hljs-string">        &lt;li v-for=&quot;item in listArray&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="hljs-string">    &lt;/ul&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>上面代码写完后在浏览器中预览效果，可以看到，已经如我们所愿，在页面渲染出了列表。在<code>v-for</code>渲染数组时中还可以加入索引<code>index</code>,也就是 数组的下标。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;ul&gt;</span><br><span class="hljs-string">        &lt;li v-for=&quot;(item,index)  in listArray&quot;&gt;[&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="hljs-string">    &lt;/ul&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这些就是最基本v-for循环数组的知识。</p><p><a href="https://jspang.com/article/68#toc370">关于循环时的key值</a></p><p>为了提高循环时性能，在数组其中一项变化后，整个数组不进行全部重新渲染，Vue提供了绑定key值的使用方法，目的就是增加渲染性能，避免重复渲染。</p><p>为了理解这个概念，先编写出一个按钮，然后每次点击按钮后向数组中增加<code>push</code>一个新值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">handleChangeBtnClick</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">listArray</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;JSPang.com&#x27;</span>)<br>    &#125;,<br>&#125;,<br><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    //......</span><br><span class="hljs-string">    &lt;button @click=&quot;handleChangeBtnClick&quot;&gt;点我改变&lt;/button&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>写完后，你到页面中预览，当你点击按钮时，表面上你看到增加了一个新的内容，实际整个列表都被重新渲染了。在实际工作中，这样的代码是不被允许的，它会降低页面的性能，在数据量变多的时候，用户用起来会变的卡顿。</p><p>这时，你可以加唯一性<code>key</code>值，增加后vue就会辨认出哪些内容被渲染后并没有变化，而只渲染新变化的内容。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index)  in listArray&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index+item&quot;</span>&gt;</span></span><br><span class="language-xml">        [&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>官方不建议使用索引<code>index</code>为key值，因为若存在多个数组，会出现重复，但此时又为了保持唯一性，所以这里使用了<code>index+item</code>进行绑定key值</p><p><a href="https://jspang.com/article/68#toc371">v-for循环对象的方法</a></p><p>v-for不仅可以循环数组，还可以循环对象，使用方法基本和数组一样（但其中参数值是不一样的）。这里先在data中建立一个对象。代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;  <br>        <span class="hljs-comment">//......</span><br>        <span class="hljs-attr">listObject</span>:&#123;<br>            <span class="hljs-title class_">GirlOne</span>:<span class="hljs-string">&#x27;谢大脚&#x27;</span>,<br>            <span class="hljs-title class_">GirlTwo</span>:<span class="hljs-string">&#x27;刘英&#x27;</span>,<br>            <span class="hljs-title class_">GirlThree</span>:<span class="hljs-string">&#x27;晓红&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>在模板中进行循环的时候，为了更好的语义化，我们把参数改为了<code>value</code>,<code>key</code>和<code>index</code>。然后进行循环。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value,key,index)  in listObject&quot;</span> </span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;key&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      &gt;</span></span><br><span class="language-xml">        [&#123;&#123;index&#125;&#125;]&#123;&#123;value&#125;&#125;-&#123;&#123;key&#125;&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>写完后可以到浏览器中预览，也是可以得到你想要的结果的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">[<span class="hljs-number">0</span>]谢大脚-<span class="hljs-title class_">GirlOne</span><br>[<span class="hljs-number">1</span>]刘英-<span class="hljs-title class_">GirlTwo</span><br>[<span class="hljs-number">2</span>]晓红-<span class="hljs-title class_">GirlThree</span><br></code></pre></td></tr></table></figure><h3 id="18-v-for循环详细讲解-2"><a href="#18-v-for循环详细讲解-2" class="headerlink" title="18.v-for循环详细讲解-2"></a>18.v-for循环详细讲解-2</h3><p>上篇文章已经对<code>v-for</code>的使用有了基本的了解，这篇文章主要讲v-for中的三个注意点。</p><p><a href="https://jspang.com/article/68#toc373">v-for循环数字</a></p><p><code>v-for</code>是可以用来循环数字的，比如你要循环1-99的数字，可以直接写成下面的样子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;span v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;count in 99&quot;</span>&gt;&#123;&#123;count&#125;&#125;,&lt;/span&gt;<br></code></pre></td></tr></table></figure><p>这样就可以快速的循环出1-99的值在页面上。可以在浏览器中看一下这个效果。</p><p><a href="https://jspang.com/article/68#toc374">v-for中如何使用判断</a></p><p>你看一下，上篇文章写的关于数组循环的小例子，现在的新需求有些变化，由于<code>谢大脚</code>的年龄比较大了，我们想刨除出去，只显示<code>刘英</code>和<code>晓红</code>。这时候你很可能把代码写成这个样子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> </span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in listArray&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index+item&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;item != &#x27;谢大脚&#x27;&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span></span><br><span class="language-xml">        [&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>在浏览器中进行预览，你会发现<code>谢大脚</code>的循环项，并没有消失。这是为什么那？<strong>因为在同一个标签里，v-for循环的优先级要高于<code>v-if</code>判断的优先级，所以判断失效。</strong></p><p>正确的写法应该是在<code>&lt;li&gt;</code>外层独立出一个标签，在<code>&lt;li&gt;</code>上做循环。比如写成下面的代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in listArray&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index+item&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;item != &#x27;谢大脚&#x27;&quot;</span>&gt;</span></span><br><span class="language-xml">        [&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>这时候到浏览器中预览，<code>谢大脚</code>如愿以偿的消失了。</p><p><a href="https://jspang.com/article/68#toc375">template标签的使用</a></p><p>上面的结果完美吗？当你打开浏览器的控制台，看Elements选项卡时，你会发现DOM结构是有问题的，明明循环出两项，却有3个<code>&lt;div&gt;</code>，而且这种外层套用<code>&lt;div&gt;</code>里边使用<code>&lt;li&gt;</code>的形式，不符合HTML语法的基本结构。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>为了解决这个问题，Vue给我们提供了<code>&lt;template&gt;</code>模版标签，也就是一个空的占位符，目的就是解决模板中为完成业务逻辑，而使用的无用html标签的现象。</p><p>现在可以把上面的代码写成这样。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in listArray&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index+item&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;item != &#x27;谢大脚&#x27;&quot;</span>&gt;</span></span><br><span class="language-xml">        [&#123;&#123;index&#125;&#125;]&#123;&#123;item&#125;&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>这时候再到浏览器看一下结果，这样就符合我们的期待了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;ul&gt;<br>    &lt;!--v-<span class="hljs-keyword">if</span>--&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br></code></pre></td></tr></table></figure><h3 id="19-绑定事件详讲-方法和参数"><a href="#19-绑定事件详讲-方法和参数" class="headerlink" title="19.绑定事件详讲-方法和参数"></a>19.绑定事件详讲-方法和参数</h3><p>可能你会觉的Vue中的绑定事件非常简单，和原生JavaScript对比，确实是简化了很多，但里边还是有很多你需要注意的点的，特别是事件修饰符这部分的内容还是相当多的。我们将用两节文章的篇幅，讲解Vue3.x中的绑定事件和它相关的种种。第一节先来介绍一下绑定事件的基本用法。</p><p><a href="https://jspang.com/article/68#toc377">按钮的基本绑定事件</a></p><p>现在的需求是这样的，只要顾客点击按钮，我们就会增加菜单数量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo19&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot; &gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app=Vue.createApp(&#123; <br>    data()&#123;<br>        return&#123;<br>            count:0<br>        &#125;<br>    &#125;,<br>    methods:&#123;&#125;,<br>    template:`<br>      &lt;div&gt;目前已点菜的数量&#123;&#123;count&#125;&#125;.&lt;/div&gt;<br>      &lt;button&gt;增加一道菜&lt;/button&gt;<br>        ` <br>    &#125;) <br>    const vm=app.mount(&quot;#app&quot;)<br><br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>可以先简单的看一下这段代码，在模板(template)里边有一个<code>&lt;div&gt;</code>显示了目前的数量，数量是在<code>data</code>中定义的变量<code>count</code>。然后有一个按钮<code>&lt;button&gt;</code>。现在要做的就是每点击一下按钮，让数量加1。到这里小伙伴可以不先向下看，自己先写一下。</p><p>先在<code>methods</code>里写一个方法，我这里给方法起名字叫<code>addCountClick( )</code>,代码如下:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">addCountClick</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;<br>    &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后在button上绑定这个响应事件.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;目前已点数量&#123;&#123;count&#125;&#125;.&lt;/div&gt;</span><br><span class="hljs-string">    &lt;button @click=&quot;addCountClick&quot;&gt;增加&lt;/button&gt;</span><br><span class="hljs-string">    `</span> <br>&#125;)<br></code></pre></td></tr></table></figure><p>这时候你可以打开浏览器预览一下效果，当你点击按钮时，””的数量就会不断增加。</p><p><a href="https://jspang.com/article/68#toc378">直接用表达式实现</a></p><p>你还可以使用更简单的方法，不在<code>methods</code>中写任何的响应方法，而是使用<code>表达式</code>来编写。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button @click=<span class="hljs-string">&quot;count++&quot;</span>&gt;增加一位&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>这看起来更见的简单了，保持代码的精简，是一个程序员应有的追求，但这样灵活性也会比较差。</p><p><a href="https://jspang.com/article/68#toc379">事件中的event对象</a></p><p>在编写响应事件事，是可以接受一个event参数的，这个参数就是关于响应事件的一些内容。我们直接打印出event，你会发现内容比较多，其实这些参数还是值得一看的，在工作中有时真的会用到。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">addCountClick</span>(<span class="hljs-params">event</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event)<br>    &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><p>这时候你可以打开浏览器，然后打开<code>控制台</code>查看一下效果。可以看到event的内容非常多，想直观看到是那个DOM元素触发事件，可以使用<code>target</code>属性。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>)<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/68#toc380">单参数/多参数的传递</a></p><p>先来看传入单独的参数，比如现在每次点击的增量不再是1，而是2。就可以这样来编写。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">addCountClick</span>(<span class="hljs-params">num</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>+=num<br>    &#125;,<br>&#125;,<br><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        //.....</span><br><span class="hljs-string">    &lt;button @click=&quot;addCountClick(2)&quot;&gt;增加一&lt;/button&gt;</span><br><span class="hljs-string">    `</span> <br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>有参数的情况下使用event</strong></p><p>这时候你还想使用<code>event</code>参数，那需要如何编写那，方法是参数增加<code>$event</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">addCountClick</span>(<span class="hljs-params">num,event</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>+=num;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>)<br>    &#125;,<br>&#125;,<br><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;目前已点数量&#123;&#123;count&#125;&#125;.&lt;/div&gt;</span><br><span class="hljs-string">    &lt;button @click=&quot;addCountClick(2,$event)&quot;&gt;增加一位&lt;/button&gt;</span><br><span class="hljs-string">    `</span> <br>&#125;)<br></code></pre></td></tr></table></figure><p>总结一下，在有多个参数的情况下，要继续使用event，需要在调用的地方使用<code>$event</code>，进行传递参数，然后在方法上正常接收就可以了。</p><p><a href="https://jspang.com/article/68#toc381">一个按钮调用两个方法</a></p><p>在有些复杂的需求中，是需要点击一个按钮，同时执行两个方法的。</p><p>先写两个方法<code>handleBtnClick1</code>和<code>handleBtnClick2</code>,每个方法里的业务逻辑，就是弹出一个<code>alert</code>。代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-title function_">handleBtnClick1</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>)<br>    &#125;,<br>    <span class="hljs-title function_">handleBtnClick2</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">2</span>)<br>    &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><p>在模板的按钮中可以这样使用这两个方法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button @click=<span class="hljs-string">&quot;handleBtnClick1(),handleBtnClick2()&quot;</span>&gt;增加&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>这里需要注意的是:调用方法的时候，要加上<code>( )</code>如果不加，调用是无效的。</p><p>总结一下：如果想在模板中一次触发两个事件方法，需要 用<code>,</code>逗号，把事件隔开，然后每个事件后边必须加上<code>( )</code>才能起作用。</p><p>这节就先到这里了，下节继续讲解绑定事件的修饰符。</p><h3 id="20-绑定事件详讲-事件修饰符"><a href="#20-绑定事件详讲-事件修饰符" class="headerlink" title="20.绑定事件详讲-事件修饰符"></a>20.绑定事件详讲-事件修饰符</h3><p>绑定事件中的修饰符有很多种，这些修饰符各有各的用处。本节课将讲解Vue中的事件修饰符，分别是：<code>stop</code>,<code>prevent</code>,<code>capture</code>,<code>self</code>,<code>once</code>和<code>passive</code>。</p><p><a href="https://jspang.com/article/68#toc383">通过修饰符解决冒泡事件</a></p><p>在JavaScript中冒泡事件是最长处理的事件，先写一段代码，手动创造一个冒泡事件。</p><ul><li>修改模板<code>template</code>部分，在最外层增加一个<code>&lt;div&gt;</code>并添加click事件。</li><li>修改方法<code>methods</code>部分，删除无用方法，保留两个方法，增加alter提示。</li><li>形成冒泡效果，就是有嵌套的DOM元素时，两个都有绑定事件，JS会自动向上传递事件。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo19&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot; &gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app=Vue.createApp(&#123; <br>    data()&#123;<br>        return&#123;<br>            count:0<br>        &#125;<br>    &#125;,<br>    methods:&#123;<br>        addCountClick()&#123;<br>            this.count++<br>        &#125;,<br>        handleBtnClick1()&#123;<br>            alert(1)<br>        &#125;,<br>    &#125;,<br>    template:`<br>        &lt;div @click=&quot;handleBtnClick1&quot;&gt;<br>            &lt;div&gt;目前已点数量&#123;&#123;count&#125;&#125;.&lt;/div&gt;<br>            &lt;button @click=&quot; addCountClick()&quot;&gt;增加&lt;/button&gt;<br>       &lt;/div&gt;<br>        ` <br>    &#125;) <br>    const vm=app.mount(&quot;#app&quot;)<br><br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><strong>stop修饰符</strong></p><p>在Vue中要停止冒泡是非常简单的，只要加一个事件修饰符<code>stop</code>就可以了，相当于点这个按钮的时候不会触发外层效果，只有点除按钮外的区域时才出发。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;button @click.<span class="hljs-property">stop</span>=<span class="hljs-string">&quot; addCountClick()&quot;</span>&gt;增加&lt;/button&gt;<br></code></pre></td></tr></table></figure><p><strong>self修饰符</strong></p><p>除了使用<code>.stop</code>修饰符，还有一种修饰符<code>self</code>，意思是只有点击自己的时候才会被执行。 只不过加的位置要在外层DOM元素的事件上。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div @click.self=&quot;handleBtnClick1&quot;&gt;</span><br><span class="hljs-string">            &lt;div&gt;目前已点数量&#123;&#123;count&#125;&#125;.&lt;/div&gt;</span><br><span class="hljs-string">            &lt;button @click=&quot; addCountClick()&quot;&gt;增加一位&lt;/button&gt;</span><br><span class="hljs-string">       &lt;/div&gt;</span><br><span class="hljs-string">        `</span><br></code></pre></td></tr></table></figure><p>这时候你会发现无论点击哪里，都没办法触发<code>hanldeBtnClick1</code>方法了，这是因为目前最外层div下都是独立的DOM元素，就是都有成对标签出现，都不属于最外自己，都是他们的子元素。</p><p>可以编写一段专属最外层DIV的文字。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div @click.self=&quot;handleBtnClick1&quot;&gt;</span><br><span class="hljs-string">            我是最外层的DIV文字</span><br><span class="hljs-string">            &lt;div&gt;目前已点数量&#123;&#123;count&#125;&#125;.&lt;/div&gt;</span><br><span class="hljs-string">            &lt;button @click=&quot; addCountClick()&quot;&gt;增加一位&lt;/button&gt;</span><br><span class="hljs-string">       &lt;/div&gt;</span><br><span class="hljs-string">        `</span><br></code></pre></td></tr></table></figure><p>这样当点击<code>我是最外层的DIV文字</code>时，就会触犯<code>handleBtnClick1</code>方法了。</p><p><a href="https://jspang.com/article/68#toc384">其它常用修饰符</a></p><p><strong>prevent修饰符：</strong>阻止默认行为的修饰符，这个以前讲过，例如阻止<code>form</code>表单的默认提交行为。（不在重复介绍，如果你还没有掌握，可以复习以前课程）</p><p><strong>capture修饰符：</strong>改成捕获模式，默认的模式都是冒泡模式，也就是从下到上，从内到外，但是你用capture后，是从上到下，从外到内的。</p><p>修改一下模板部分的代码，不再使用修饰符，而是让事件存在冒泡。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">addCountClick</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">0</span>)  <span class="hljs-comment">//修改了此处</span><br>    &#125;,<br>    <span class="hljs-title function_">handleBtnClick1</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>)<br>    &#125;,<br>&#125;,<br><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div @click.capture=&quot;handleBtnClick1&quot;&gt;  //修改了此处</span><br><span class="hljs-string">        我是最外层的DIV文字</span><br><span class="hljs-string">        &lt;div&gt;目前已点数量&#123;&#123;count&#125;&#125;.&lt;/div&gt;</span><br><span class="hljs-string">        &lt;button @click=&quot; addCountClick()&quot;&gt;增加一位&lt;/button&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br></code></pre></td></tr></table></figure><p><strong>once修饰符：</strong>事件只执行一次（视频中作演示）。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div @click.self=&quot;handleBtnClick1&quot;&gt;</span><br><span class="hljs-string">        我是最外层的DIV文字</span><br><span class="hljs-string">        &lt;div&gt;目前已点数量&#123;&#123;count&#125;&#125;.&lt;/div&gt;</span><br><span class="hljs-string">        &lt;button @click.once=&quot; addCountClick()&quot;&gt;增加一位&lt;/button&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br></code></pre></td></tr></table></figure><p>此时再点击按钮，事件只执行一次。这时候我们修改了两个地方，最外层的事件加了<code>self</code>修饰符，button上加了<code>once</code>修饰符。</p><p><strong>passive修饰符</strong>：解决滚动时性能的修饰符，不太好演示，等以后用到我们会再详细讲解。</p><p>这节就先到这里了，我们学习了6种修饰符：<code>stop</code>,<code>prevent</code>,<code>capture</code>,<code>self</code>,<code>once</code>,<code>passive</code>。下节课我们讲解按键修饰符。</p><h3 id="21-绑定事件详讲-按键、鼠标饰修符"><a href="#21-绑定事件详讲-按键、鼠标饰修符" class="headerlink" title="21.绑定事件详讲-按键、鼠标饰修符"></a>21.绑定事件详讲-按键、鼠标饰修符</h3><p>这节课的内容会讲一下事件绑定中的<code>按键修饰符</code>和<code>鼠标修饰符</code>。他们对应的是在使用特点的某个按键时才会用到。这节课的内容在工作中也是比较常用的，比如按下回车键时触发表达提交，按下鼠标右键时弹出选项菜单。都是工作中用得到的。</p><p><a href="https://jspang.com/article/68#toc386">构建基础页面</a></p><p>可以看到，这就是一个最简单的页面，只不过是在模板<code>template</code>中加入了一个<code>&lt;input /&gt;</code>标签。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo21&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot; &gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app=Vue.createApp(&#123; <br>    data()&#123;<br>        return&#123;&#125;<br>    &#125;,<br>    methods:&#123;<br>    &#125;,<br>    template:`<br>        &lt;div&quot;&gt;<br>            &lt;input /&gt;<br>        &lt;/div&gt;<br>        ` <br>    &#125;) <br>    const vm=app.mount(&quot;#app&quot;)<br><br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>然后在<code>methods</code>部分加入一个方法<code>handleKeyDwon( )</code>，具体内容只是在控制台打印出来<code>keydown</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">handleKeyDown</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;keydow....&#x27;</span>)<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后在模板中的<code>&lt;input /&gt;</code>中绑定键盘按下时响应<code>keydown</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&quot;&gt;</span><br><span class="hljs-string">        &lt;input @keydown=&quot;handleKeyDown&quot;/&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/68#toc387">单个按键修饰符</a></p><p>单个按键修饰符：顾名思义，就是指定键盘上某个特殊的按键时才会响应事件方法。</p><p>如果现在的需求是，上面的代码只有在按下回车时，才在控制台进行打印，这时候就需要按键修饰符了。我们学的第一个按键修饰符<code>enter</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&quot;&gt;</span><br><span class="hljs-string">        &lt;input @keydown.enter=&quot;handleKeyDown&quot;/&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    `</span> <br>    &#125;)<br></code></pre></td></tr></table></figure><p>类似这样只响应单个按键的修饰符有很多</p><ul><li>enter回车 、tab、delete、esc、up 、down、left、right</li></ul><p>这些你可以通过上面的列子，自行测试，我这里不在赘述。</p><p><a href="https://jspang.com/article/68#toc388">鼠标修饰符</a></p><p>除了按键修饰符，还有鼠标修饰符，就是按下鼠标上的某个键时，才会响应。</p><p>最常用的就是: left、right、middle</p><p>现在的需求是在页面上作一行文字<code>JSPang.com</code>，然后只有用鼠标右键点击时，才会弹出<code>alert( )</code>。</p><p>先在<code>methods</code>里编写一个<code>handleClick</code>方法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">methods</span>:&#123;<br>   <span class="hljs-comment">//...</span><br>    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;click&#x27;</span>)<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后在模板中使用鼠标修饰符，确定只有点击鼠标右键时才会响应。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div @click.<span class="hljs-property">right</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;<span class="hljs-title class_">JSPang</span>.<span class="hljs-property">com</span>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>好了这节的内容就到这里了，事件绑定我们一共讲了三节，希望小伙伴们能动手把这部分的内容联系一下，这是最常用的一些功能。</p><h3 id="22-表单数据的双绑定-1"><a href="#22-表单数据的双绑定-1" class="headerlink" title="22.表单数据的双绑定-1"></a>22.表单数据的双绑定-1</h3><p>我在课程刚开始的初识阶段，经常强调Vue是数据驱动的开发。其中最重要的一点应用是数据的双向绑定，从这节课开始，我们就详细讲解一下Vue3中表单和数据绑定的一些方法。学完后你可以对数据双向绑定有很好的了解。</p><p><a href="https://jspang.com/article/68#toc390">写干净的Vue3文件</a></p><p>这个你可以直接拷贝下面的代码，这样就可以快速写出Vue3的基本结构。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo22&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot; &gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app=Vue.createApp(&#123; <br>    data()&#123;<br>        return&#123;&#125;<br>    &#125;,<br>    methods:&#123;<br><br>    &#125;,<br>    template:`<br>        &lt;div&gt;&lt;/div&gt;<br>        ` <br>    &#125;) <br>    const vm=app.mount(&quot;#app&quot;)<br><br>&lt;/script&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><a href="https://jspang.com/article/68#toc391">input的数据双向绑定</a></p><p>这个可能是最简单和最常用的双向绑定方式，我们先在模板中给写一个<code>&lt;input/&gt;</code>，然后在<code>data</code>中声明一个<code>name</code>的变量。有了变量后和<code>input</code>进行双向数据绑定。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;script&gt;<br>    <span class="hljs-keyword">const</span> app=<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123; <br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span>&#123;<br>            <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;</span><br><span class="hljs-string">            &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="hljs-string">            &lt;input v-model=&quot;name&quot; /&gt;</span><br><span class="hljs-string">        &lt;/div&gt;</span><br><span class="hljs-string">        `</span> <br>    &#125;) <br>    <span class="hljs-keyword">const</span> vm=app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>写完这个，打开浏览器预览一下效果。可以看到，当<code>input</code>改变时，对应的变量也会变化，页面中的值也会变化。</p><p>那什么是双向绑定呢？</p><ul><li><p><strong>data中的变量改变时，绑定的数据会跟随变化，此为一项修改；</strong></p></li><li><p><strong>当通过页面修改数据，data中的变量也随之改变，这就是另一项修改。两个彼此依存改变，就为双向数据绑定。</strong></p></li></ul><p>目前这种就完成了<code>&lt;input /&gt;</code>的双向数据绑定。</p><p><a href="https://jspang.com/article/68#toc392">textarea的数据双向绑定</a></p><p>以前我们写<code>HTML</code>的时候，写<code>textarea</code>标签都是成对出现的，比如这样<code>&lt;textarea&gt;&lt;/textarea&gt;</code>，如果想在Vue中实现textarea的双向数据绑定，这时候只要写单标签就可以了，剩下的事情Vue底层就帮你完成了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">        &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;&lt;input v-model=&quot;name&quot; /&gt;&lt;/div&gt;</span><br><span class="hljs-string">        &lt;div&gt;&lt;textarea v-model=&quot;name&quot; /&gt;&lt;/div&gt;  </span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">    `</span><br></code></pre></td></tr></table></figure><p>这样也是可以实现数据的双向绑定的。</p><p><a href="https://jspang.com/article/68#toc393">checkbox数据双向绑定</a></p><p><code>checkbox</code>是一个勾选框（复选框），如果只有一个选项时，我们可以给<code>&lt;checkbox /&gt;</code>一个布尔值，也就是true或者false。</p><p>现在data中新声明一个变量<code>checked</code>.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">checked</span>:<span class="hljs-literal">false</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后在模板中进行双向数据绑定。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;&#123;&#123;checked&#125;&#125;&lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> v-model=<span class="hljs-string">&quot;checked&quot;</span> /&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>写完后进行预览，双向绑定是完全可以实现的。<code>checkbox</code>还有一个功能就是复选，可以选择多个。</p><p>比如还是象牙山三女的例子，现在勾选谁，谁就可以显示在页面上。</p><p>这时候要先定义一个变量，这个变量是一个空数组。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">checked</span>:<span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">girls</span>:[]<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后增加模板中的内容如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>    &#123;&#123;girls&#125;&#125;<br>    大脚&lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> v-model=<span class="hljs-string">&quot;girls&quot;</span> value=<span class="hljs-string">&quot;大脚&quot;</span> /&gt;<br>    刘英&lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> v-model=<span class="hljs-string">&quot;girls&quot;</span> value=<span class="hljs-string">&quot;刘英&quot;</span> /&gt;<br>    晓红&lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> v-model=<span class="hljs-string">&quot;girls&quot;</span> value=<span class="hljs-string">&quot;晓红&quot;</span> /&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>这时候就可以实现多选的双向数据绑定了。</p><p><a href="https://jspang.com/article/68#toc394">Radio的双向数据绑定</a></p><p>学会了<code>checkbox</code>的双向数据绑定，<code>radio</code>单选按钮就简单了。但是需要注意的是，既然是单选，这时候data中的变量就不能是一个数字了，一般是一个字符串。比如我们这里新定义了一个<code>girl</code>的变量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">checked</span>:<span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">girls</span>:[],<br>        <span class="hljs-attr">girl</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>复制上面的template代码，然后进行修改，把<code>checkbox</code>换成<code>radio</code>,代码如下:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>    &#123;&#123;girl&#125;&#125;<br>    大脚&lt;input type=<span class="hljs-string">&quot;radio&quot;</span> v-model=<span class="hljs-string">&quot;girl&quot;</span> value=<span class="hljs-string">&quot;大脚&quot;</span> /&gt;<br>    刘英&lt;input type=<span class="hljs-string">&quot;radio&quot;</span> v-model=<span class="hljs-string">&quot;girl&quot;</span> value=<span class="hljs-string">&quot;刘英&quot;</span> /&gt;<br>    晓红&lt;input type=<span class="hljs-string">&quot;radio&quot;</span> v-model=<span class="hljs-string">&quot;girl&quot;</span> value=<span class="hljs-string">&quot;晓红&quot;</span> /&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>这样就完成了单项选择的数据双向数据绑定了。</p><h3 id="23-表单数据的双绑定-2修饰符"><a href="#23-表单数据的双绑定-2修饰符" class="headerlink" title="23.表单数据的双绑定-2修饰符"></a>23.表单数据的双绑定-2修饰符</h3><p>这节我们主要来看一下<code>v-model</code>（数据双向绑定）中的修饰符。但是在学习修饰符前，我们补充一下上节遗漏的知识点。</p><p><strong>checkbox里的true-value和false-value</strong></p><p>在上节课我们作了复选框选择<code>true</code>和<code>false</code>的情况。新建一个文件，我们重现一下代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Demo23&lt;/title&gt;<br>    &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;script&gt;<br>    const app = Vue.createApp(&#123;<br>        data() &#123;<br>            return &#123;<br>                checked: true,<br>            &#125;<br>        &#125;,<br><br>        template: `<br>        &lt;div&gt;&#123;&#123;checked&#125;&#125;&lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot; /&gt;&lt;/div&gt;<br>        `<br><br>    &#125;)<br>    const vm = app.mount(&quot;#app&quot;)<br><br>&lt;/script&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>在浏览器中预览时，当选择复选框时，会显示true，没选中显示false。</p><p>现在的需求是，我选中的时候显示<code>JSPang.com</code>，没选中的时候显示<code>技术胖</code>。这时候要如何处理那？</p><p>Vue给我们提供了这样两个属性<code>true-value</code>和<code>false-value</code>。我们在Data中新声明一个变量name,值为空字符串。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">checked</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>这时候在模板中编写下面的代码。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">&lt;div&gt;&#123;&#123;name&#125;&#125;</span><br><span class="hljs-string">    &lt;input </span><br><span class="hljs-string">        type=&quot;checkbox&quot; </span><br><span class="hljs-string">        v-model=&quot;name&quot;  </span><br><span class="hljs-string">        true-value=&quot;JSPang.com&quot;</span><br><span class="hljs-string">        false-value=&quot;技术胖&quot;</span><br><span class="hljs-string">        /&gt;&lt;/div&gt;</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><p>这时候到浏览器中预览，就可以看到，在选择时插值表达式会变成<code>JSPang.com</code>，在没选中时会变成<code>技术胖</code>。</p><p>补充的部分就到这里了，下满我们来看一下，<code>v-model</code>数据双向绑定的修饰符。</p><p><a href="https://jspang.com/article/68#toc396">v-model数据双向绑定修饰符</a></p><p><strong>lazy修饰符</strong></p><p><code>v-model</code>也有很多实用的修饰符，现在就学习一下。第一个修饰符<code>lazy</code>，这个也叫做懒更新修饰符。</p><p>我们作一个<code>input</code>的绑定效果，现在data中声明一个<code>message</code>变量，值为空。然后在模板中写一个<code>&lt;input /&gt;</code>并和<code>message</code>进行双向数据绑定。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">checked</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>模板中进行双向数据绑定：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>    &#123;&#123;message&#125;&#125;&lt;input v-model=<span class="hljs-string">&quot;message&quot;</span> /&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>这时候当你在文本框中输入任何内容的时候，插值表达式会跟着改变。如果你不想马上显示，就可以用<code>lazy</code>修饰符，这样就可以实现当输入完成后，失去焦点再进行改变。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>    &#123;&#123;message&#125;&#125;&lt;input v-model.<span class="hljs-property">lazy</span>=<span class="hljs-string">&quot;message&quot;</span> /&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>写完lazy修饰符后，可以看一下效果，这时候的效果就和我们想象的一样了。</p><p><strong>number修饰符</strong></p><p><code>&lt;input /&gt;</code>输入的内容无论是数字还是字母，最终都会变为<code>字符串</code>。如果想最终输入的变成数字，你就可以使用<code>number</code>修饰符了。</p><p>比如我们现在去掉<code>lazy</code>修饰符，直接输入数字，这时候你修改插值表达式的结果，输出当前类型。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>    &#123;&#123;<span class="hljs-keyword">typeof</span> message&#125;&#125;&lt;input v-model=<span class="hljs-string">&quot;message&quot;</span> /&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>这时候你预览，就会发现最终input绑定的值会变成字符串类型。这是html的底层逻辑造成的，这时候我们可以使用<code>number</code>修饰付，解决这个问题。加上<code>number</code>修饰符后，<strong>你输入的值只要是数字</strong>，就变成了number类型。（也就是说，如果你输入的是字母，它还会是字符串类型）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>    &#123;&#123;<span class="hljs-keyword">typeof</span> message&#125;&#125;&lt;input v-model.<span class="hljs-property">number</span>=<span class="hljs-string">&quot;message&quot;</span> /&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p><strong>trim修饰</strong></p><p><code>trim</code>修饰符大家一定不陌生，它是用来消除<code>input</code>框输入内容前后的空格的。现在我们再字符串上输入空格，其实它会在DOM元素上进行增加空格的，这个可以在控制台清楚的看出(详细请看视频操作)。 加入<code>trim</code>修饰符后，Vue就会自动给我们去除前后的空格。</p><p>现在data中新声明一个变量，比如叫做<code>message1</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-comment">//......</span><br>        <span class="hljs-attr">message1</span>: <span class="hljs-string">&#x27;JSPang.com&#x27;</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>用法如下:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div&gt;<br>    &#123;&#123;message1&#125;&#125;&lt;input v-model.<span class="hljs-property">trim</span>=<span class="hljs-string">&quot;message1&quot;</span> /&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>这时候Vue就会自动为我们去除前后空格，但不会去除字符串中间的空格。</p><p>好了，这节课就先到这里了。第一季也算结束了，第一季我们主要讲了Vue的基础语法。但是我们会马上开始第二季，这部分我们会全面讲解Vue中的组件概念。我们下一季见了，再见。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 05</title>
    <link href="/2022/08/13/JavaScript-05/"/>
    <url>/2022/08/13/JavaScript-05/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="JavaScript-基础-第五天"><a href="#JavaScript-基础-第五天" class="headerlink" title="JavaScript 基础 - 第五天"></a>JavaScript 基础 - 第五天</h1><h2 id="一、构造器和操作符-“new”"><a href="#一、构造器和操作符-“new”" class="headerlink" title="一、构造器和操作符 “new”"></a>一、构造器和操作符 “new”</h2><p>常规的 <code>&#123;...&#125;</code> 语法允许创建一个对象。但是我们经常需要创建很多类似的对象，例如多个用户或菜单项等。</p><p>这可以使用构造函数和 <code>&quot;new&quot;</code> 操作符来实现。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><a href="https://zh.javascript.info/constructor-new#gou-zao-han-shu">构造函数</a></h3><p>构造函数在技术上是常规函数。不过有两个约定：</p><ol><li>它们的命名以大写字母开头。</li><li>它们只能由 <code>&quot;new&quot;</code> 操作符来执行。</li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Jack&quot;</span>);<br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// Jack</span><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">isAdmin</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>当一个函数被使用 <code>new</code> 操作符执行时，它按照以下步骤：</p><ol><li>一个新的空对象被创建并分配给 <code>this</code>。</li><li>函数体执行。通常它会修改 <code>this</code>，为其添加新的属性。</li><li>返回 <code>this</code> 的值，即整个新对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-comment">// this = &#123;&#125;;（隐式创建）</span><br><br>  <span class="hljs-comment">// 添加属性到 this</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// return this;（隐式返回）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以 <code>new User(&quot;Jack&quot;)</code> 的结果是相同的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Jack&quot;</span>,<br>  <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">false</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>现在，如果我们想创建其他用户，我们可以调用 <code>new User(&quot;Ann&quot;)</code>，<code>new User(&quot;Alice&quot;)</code> 等。比每次都使用字面量创建要短得多，而且更易于阅读。</p><p>这是构造器的主要目的 —— 实现可重用的对象创建代码。</p><p>让我们再强调一遍 —— 从技术上讲，任何函数（除了箭头函数，它没有自己的 <code>this</code>）都可以用作构造器。即可以通过 <code>new</code> 来运行，它会执行上面的算法。</p><p><u>“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 <code>new</code> 来运行。</u></p><p><strong>new function() { … }</strong></p><p>如果我们有许多行用于创建单个复杂对象的代码，我们可以将它们封装在一个立即调用的构造函数中，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个函数并立即使用 new 调用它</span><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// ……用于用户创建的其他代码</span><br>  <span class="hljs-comment">// 也许是复杂的逻辑和语句</span><br>  <span class="hljs-comment">// 局部变量等</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><u>这个构造函数不能被再次调用</u>，因为它不保存在任何地方，只是被创建和调用。因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。</p><h3 id="构造器的-return"><a href="#构造器的-return" class="headerlink" title="构造器的 return"></a><a href="https://zh.javascript.info/constructor-new#gou-zao-qi-de-return">构造器的 return</a></h3><p>通常，构造器没有 <code>return</code> 语句。它们的任务是将所有必要的东西写入 <code>this</code>，并自动转换为结果。</p><p>但是，如果这有一个 <code>return</code> 语句，那么规则就简单了：</p><ul><li>如果 <code>return</code> 返回的是一个对象，则返回这个对象，而不是 <code>this</code>。</li><li>如果 <code>return</code> 返回的是一个原始类型，则忽略。</li></ul><p>换句话说，带有对象的 <code>return</code> 返回该对象，在所有其他情况下返回 <code>this</code>。</p><p>例如，这里 <code>return</code> 通过返回一个对象覆盖 <code>this</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">BigUser</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;<br><br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Godzilla&quot;</span> &#125;;  <span class="hljs-comment">// &lt;-- 返回这个对象</span><br>&#125;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUser</span>().<span class="hljs-property">name</span> );  <span class="hljs-comment">// Godzilla，得到了那个对象</span><br></code></pre></td></tr></table></figure><p>这里有一个 <code>return</code> 为空的例子（或者我们可以在它之后放置一个原始类型，没有什么影响）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SmallUser</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;<br><br>  <span class="hljs-keyword">return</span>; <span class="hljs-comment">// &lt;-- 返回 this</span><br>&#125;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmallUser</span>().<span class="hljs-property">name</span> );  <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure><p>通常构造器没有 <code>return</code> 语句。这里我们主要为了完整性而提及返回对象的特殊行为。</p><p><strong>省略括号</strong></p><p>顺便说一下，如果没有参数，我们可以省略 <code>new</code> 后的括号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>; <span class="hljs-comment">// &lt;-- 没有参数</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br></code></pre></td></tr></table></figure><p>这里省略括号不被认为是一种“好风格”，但是规范允许使用该语法。</p><h3 id="构造器中的方法"><a href="#构造器中的方法" class="headerlink" title="构造器中的方法"></a><a href="https://zh.javascript.info/constructor-new#gou-zao-qi-zhong-de-fang-fa">构造器中的方法</a></h3><p>我们不仅可以将属性添加到构造器中，还可以添加方法。</p><p>例如，下面的 <code>new User(name)</code> 用给定的 <code>name</code> 和方法 <code>sayHi</code> 创建了一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;My name is: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;John&quot;</span>);<br><br>john.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// My name is: John</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">john = &#123;</span><br><span class="hljs-comment">   name: &quot;John&quot;,</span><br><span class="hljs-comment">   sayHi: function() &#123; ... &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><a href="https://zh.javascript.info/classes">类</a> 是用于创建复杂对象的一个更高级的语法，我们稍后会讲到。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/constructor-new#zong-jie">总结</a></h3><ul><li>构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其命名首字母要大写。</li><li>构造函数只能使用 <code>new</code> 来调用。这样的调用意味着在开始时创建了空的 <code>this</code>，并在最后返回填充了值的 <code>this</code>。</li></ul><p>我们可以使用构造函数来创建多个类似的对象。</p><p>JavaScript 为许多内建的对象提供了构造函数：比如日期 <code>Date</code>、集合 <code>Set</code> 以及其他我们计划学习的内容。</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a><a href="https://zh.javascript.info/constructor-new#tasks">任务</a></h3><h4 id="两个函数-——-一个对象"><a href="#两个函数-——-一个对象" class="headerlink" title="两个函数 —— 一个对象"></a><a href="https://zh.javascript.info/constructor-new#liang-ge-han-shu-yi-ge-dui-xiang">两个函数 —— 一个对象</a></h4><p>是否可以创建像 <code>new A() == new B()</code> 这样的函数 <code>A</code> 和 <code>B</code>？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123; ... &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) &#123; ... &#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> A;<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B;<br><br><span class="hljs-title function_">alert</span>( a == b ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>是的，这是可以的。</p><p>如果一个函数返回一个对象，那么 <code>new</code> 返回那个对象而不是 <code>this</code>。</p><p>所以它们可以，例如，返回相同的外部定义的对象 <code>obj</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj=&#123;&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> obj<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-keyword">return</span> obj<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> A;<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B;<br><br><span class="hljs-title function_">alert</span>( a == b ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="创建-new-Calculator"><a href="#创建-new-Calculator" class="headerlink" title="创建 new Calculator"></a><a href="https://zh.javascript.info/constructor-new#chuang-jian-newcalculator">创建 new Calculator</a></h4><p>重要程度: 5</p><p>创建一个构造函数 <code>Calculator</code>，它创建的对象中有三个方法：</p><ul><li><code>read()</code> 使用 <code>prompt</code> 请求两个值并把它们记录在对象的属性中。</li><li><code>sum()</code> 返回这些属性的总和。</li><li><code>mul()</code> 返回这些属性的乘积。</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> calculator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br>calculator.<span class="hljs-title function_">read</span>();<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Sum=&quot;</span> + calculator.<span class="hljs-title function_">sum</span>() );<br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Mul=&quot;</span> + calculator.<span class="hljs-title function_">mul</span>() );<br></code></pre></td></tr></table></figure><p>解决方案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Calculator</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>=<span class="hljs-literal">null</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>=<span class="hljs-literal">null</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">read</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>=<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入第一个值&quot;</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>=<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入第二个值&quot;</span>)<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sum</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> -(-<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>-<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>)<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mul</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>*<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> calculator=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>()<br>calculator.<span class="hljs-title function_">read</span>()<br><span class="hljs-title function_">alert</span>(calculator.<span class="hljs-title function_">sum</span>())<br><span class="hljs-title function_">alert</span>(calculator.<span class="hljs-title function_">mul</span>())<br></code></pre></td></tr></table></figure><p>构造函数不同于直接创建对象，而是一个函数，所以每一个语句都要用<code>;</code>或换行分割，并且也没有本身属性，所以必须用this来调用属性和方法。</p><h4 id="创建-new-Accumulator"><a href="#创建-new-Accumulator" class="headerlink" title="创建 new Accumulator"></a><a href="https://zh.javascript.info/constructor-new#chuang-jian-newaccumulator">创建 new Accumulator</a></h4><p>重要程度: 5</p><p>创建一个构造函数 <code>Accumulator(startingValue)</code>。</p><p>它创建的对象应该：</p><ul><li>将“当前 value”存储在属性 <code>value</code> 中。起始值被设置到构造器 <code>startingValue</code> 的参数。</li><li><code>read()</code> 方法应该使用 <code>prompt</code> 来读取一个新的数字，并将其添加到 <code>value</code> 中。</li></ul><p>换句话说，<code>value</code> 属性是所有用户输入值与初始值 <code>startingValue</code> 的总和。</p><p>下面是示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> accumulator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Accumulator</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 初始值 1</span><br><br>accumulator.<span class="hljs-title function_">read</span>(); <span class="hljs-comment">// 添加用户输入的 value</span><br>accumulator.<span class="hljs-title function_">read</span>(); <span class="hljs-comment">// 添加用户输入的 value</span><br><br><span class="hljs-title function_">alert</span>(accumulator.<span class="hljs-property">value</span>); <span class="hljs-comment">// 显示这些值的总和</span><br></code></pre></td></tr></table></figure><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Accumulator</span>(<span class="hljs-params">startingValue</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>=startingValue<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">read</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>+=<span class="hljs-built_in">parseInt</span>(<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入一个值&quot;</span>))<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> acc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Accumulator</span>(<span class="hljs-number">5</span>)<br>acc.<span class="hljs-title function_">read</span>()<br>acc.<span class="hljs-title function_">read</span>()<br><span class="hljs-title function_">alert</span>(acc.<span class="hljs-property">value</span>)<br></code></pre></td></tr></table></figure><p>在构造函数里定义方法时，等号左边是为函数命名，而不是声明函数，记得别加括号。</p><h2 id="二、可选链-“-”"><a href="#二、可选链-“-”" class="headerlink" title="二、可选链 “?.”"></a>二、可选链 “?.”</h2><p><strong>最近新增的特性</strong></p><p>这是一个最近添加到 JavaScript 的特性。 旧式浏览器可能需要 polyfills.</p><p>可选链 <code>?.</code> 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误。</p><h3 id="“不存在的属性”的问题"><a href="#“不存在的属性”的问题" class="headerlink" title="“不存在的属性”的问题"></a><a href="https://zh.javascript.info/optional-chaining#bu-cun-zai-de-shu-xing-de-wen-ti">“不存在的属性”的问题</a></h3><p>举个例子，假设我们有很多个 <code>user</code> 对象，其中存储了我们的用户数据。</p><p>我们大多数用户的地址都存储在 <code>user.address</code> 中，街道地址存储在 <code>user.address.street</code> 中，但有些用户没有提供这些信息。</p><p>在这种情况下，当我们尝试获取 <code>user.address.street</code>，而该用户恰好没提供地址信息，我们则会收到一个错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// 一个没有 &quot;address&quot; 属性的 user 对象</span><br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span>); <span class="hljs-comment">// Error!</span><br></code></pre></td></tr></table></figure><p>这是预期的结果。JavaScript 的工作原理就是这样的。因为 <code>user.address</code> 为 <code>undefined</code>，尝试读取 <code>user.address.street</code> 会失败，并收到一个错误。</p><p>但是在很多实际场景中，我们更希望得到的是 <code>undefined</code>（表示没有 <code>street</code> 属性）而不是一个错误。</p><p>还有另一个例子。在 Web 开发中，我们可以使用特殊的方法调用（例如 <code>document.querySelector(&#39;.elem&#39;)</code>）以对象的形式获取一个网页元素，如果没有这种对象，则返回 <code>null</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 如果 document.querySelector(&#x27;.elem&#x27;) 的结果为 null，则这里不存在这个元素</span><br><span class="hljs-keyword">let</span> html = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.elem&#x27;</span>).<span class="hljs-property">innerHTML</span>; <span class="hljs-comment">// 如果 document.querySelector(&#x27;.elem&#x27;) 的结果为 null，则会出现错误</span><br></code></pre></td></tr></table></figure><p>同样，如果该元素不存在，则访问 <code>null</code> 的 <code>.innerHTML</code> 属性时会报错。在某些情况下，当元素的缺失是没问题的时候，我们希望避免出现这种错误，而是接受 <code>html = null</code> 作为结果。</p><p>我们如何实现这一点呢？</p><p>可能最先想到的方案是在访问该值的属性之前，使用 <code>if</code> 或条件运算符 <code>?</code> 对该值进行检查，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;;<br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">address</span> ? user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span> : <span class="hljs-literal">undefined</span>);<br></code></pre></td></tr></table></figure><p>这样可以，这里就不会出现错误了……但是不够优雅。就像你所看到的，<code>&quot;user.address&quot;</code> 在代码中出现了两次。</p><p>对于嵌套层次更深的属性，代码会变得更丑，因为需要更多的重复。</p><p>例如，让我们以相同的方式尝试获取 <code>user.address.street.name</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// user 没有 address 属性</span><br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">address</span> ? user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span> ? user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span>.<span class="hljs-property">name</span> : <span class="hljs-literal">null</span> : <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>这样就太扯淡了，并且这可能导致写出来的代码很难让别人理解。</p><p>这里有一种更好的实现方式，就是使用 <code>&amp;&amp;</code> 运算符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// user 没有 address 属性</span><br><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">address</span> &amp;&amp; user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span> &amp;&amp; user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span>.<span class="hljs-property">name</span> ); <span class="hljs-comment">// undefined（不报错）</span><br></code></pre></td></tr></table></figure><p>依次对整条路径上的属性使用与运算进行判断，以确保所有节点是存在的（如果不存在，则停止计算），但仍然不够优雅。</p><p>就像你所看到的，在代码中我们仍然重复写了好几遍对象属性名。例如在上面的代码中，<code>user.address</code> 被重复写了三遍。</p><p>这就是为什么可选链 <code>?.</code> 被加入到了 JavaScript 这门编程语言中。那就是彻底地解决以上所有问题！</p><h3 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a><a href="https://zh.javascript.info/optional-chaining#ke-xuan-lian">可选链</a></h3><p>如果可选链 <code>?.</code> 前面的值为 <code>undefined</code> 或者 <code>null</code>，它会停止运算并返回 <code>undefined</code>。</p><p><strong>为了简明起见，在本文接下来的内容中，我们会说如果一个属性既不是 <code>null</code> 也不是 <code>undefined</code>，那么它就“存在”。</strong></p><p>换句话说，例如 <code>value?.prop</code>：</p><ul><li>如果 <code>value</code> 存在，则结果与 <code>value.prop</code> 相同，</li><li>否则（当 <code>value</code> 为 <code>undefined/null</code> 时）则返回 <code>undefined</code>。</li></ul><p>下面这是一种使用 <code>?.</code> 安全地访问 <code>user.address.street</code> 的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// user 没有 address 属性</span><br><br><span class="hljs-title function_">alert</span>( user?.<span class="hljs-property">address</span>?.<span class="hljs-property">street</span> ); <span class="hljs-comment">// undefined（不报错）</span><br></code></pre></td></tr></table></figure><p>代码简洁明了，也不用重复写好几遍属性名。?在哪边，哪边就是不确认但需要返回的量。</p><p>这里是一个结合 <code>document.querySelector</code> 使用的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> html = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.elem&#x27;</span>)?.<span class="hljs-property">innerHTML</span>; <span class="hljs-comment">// 如果没有符合的元素，则为 undefined</span><br></code></pre></td></tr></table></figure><p>即使 对象 <code>user</code> 不存在，使用 <code>user?.address</code> 来读取地址也没问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-literal">null</span>;<br><br><span class="hljs-title function_">alert</span>( user?.<span class="hljs-property">address</span> ); <span class="hljs-comment">// undefined</span><br><span class="hljs-title function_">alert</span>( user?.<span class="hljs-property">address</span>.<span class="hljs-property">street</span> ); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>请注意：<code>?.</code> 语法使其前面的值成为可选值，但不会对其后面的起作用。</p><p><strong>不要过度使用可选链</strong></p><p>我们应该只将 <code>?.</code> 使用在一些东西可以不存在的地方。</p><p>例如，如果根据我们的代码逻辑，<code>user</code> 对象必须存在，但 <code>address</code> 是可选的，那么我们应该这样写 <code>user.address?.street</code>，而不是这样 <code>user?.address?.street</code>。</p><p>那么，如果 <code>user</code> 恰巧为 undefined，我们会看到一个编程错误并修复它。否则，如果我们滥用 <code>?.</code>，会导致代码中的错误在不应该被消除的地方消除了，这会导致调试更加困难。</p><p><strong><code>?.</code> 前的变量必须已声明</strong></p><p>如果未声明变量 <code>user</code>，那么 <code>user?.anything</code> 会触发一个错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ReferenceError: user is not defined</span><br>user?.<span class="hljs-property">address</span>;<br></code></pre></td></tr></table></figure><p><strong>短路效应</strong></p><p>正如前面所说的，如果 <code>?.</code> 左边部分不存在，就会立即停止运算（“短路效应”）。</p><p>因此，如果在 <code>?.</code> 的右侧有任何进一步的函数调用或操作，它们均不会执行。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>;<br><br>user?.<span class="hljs-title function_">sayHi</span>(x++); <span class="hljs-comment">// 没有 &quot;user&quot;，因此代码执行没有到达 sayHi 调用和 x++</span><br><br><span class="hljs-title function_">alert</span>(x); <span class="hljs-comment">// 0，值没有增加</span><br></code></pre></td></tr></table></figure><p><strong>其它变体：?.( )，?.[ ]</strong></p><ul><li><p><code>?.()</code>用于访问不确定是否存在的方法</p><p>在下面这段代码中，有些用户具有 <code>admin</code> 方法，而有些没有：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> userAdmin = &#123;<br>  <span class="hljs-title function_">admin</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;I am admin&quot;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> userGuest = &#123;&#125;;<br><br>userAdmin.<span class="hljs-property">admin</span>?.(); <span class="hljs-comment">// I am admin</span><br><br>userGuest.<span class="hljs-property">admin</span>?.(); <span class="hljs-comment">// 啥都没发生（没有这样的方法）</span><br></code></pre></td></tr></table></figure><p>如果 <code>admin</code> 函数存在，那么就调用运行它（对于 <code>userAdmin</code>）。否则（对于 <code>userGuest</code>）运算停止，没有报错。</p></li><li><p><code>?.[]</code>用于访问不确定是否存在对象的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;firstName&quot;</span>;<br><br><span class="hljs-keyword">let</span> user1 = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> user2 = <span class="hljs-literal">null</span>;<br><br><span class="hljs-title function_">alert</span>( user1?.[key] ); <span class="hljs-comment">// John</span><br><span class="hljs-title function_">alert</span>( user2?.[key] ); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure></li><li><p>还可以将 <code>?.</code> 跟 <code>delete</code> 一起使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> user?.<span class="hljs-property">name</span>; <span class="hljs-comment">// 如果 user 存在，则删除 user.name</span><br></code></pre></td></tr></table></figure><p><strong>我们可以使用 <code>?.</code> 来安全地读取或删除，但不能写入</strong></p><p>可选链 <code>?.</code> 不能用在赋值语句的左侧。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> user = <span class="hljs-literal">null</span>;<br><br>user?.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>; <span class="hljs-comment">// Error，不起作用</span><br><span class="hljs-comment">// 因为它在计算的是：undefined = &quot;John&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/optional-chaining#zong-jie">总结</a></h3><p>可选链 <code>?.</code> 语法有三种形式：</p><ol><li><code>obj?.prop</code> —— 如果 <code>obj</code> 存在则返回 <code>obj.prop</code>，否则返回 <code>undefined</code>。</li><li><code>obj?.[prop]</code> —— 如果 <code>obj</code> 存在则返回 <code>obj[prop]</code>，否则返回 <code>undefined</code>。</li><li><code>obj.method?.()</code> —— 如果 <code>obj.method</code> 存在则调用 <code>obj.method()</code>，否则返回 <code>undefined</code>。</li></ol><p>正如我们所看到的，这些语法形式用起来都很简单直接。<code>?.</code> 检查左边部分是否为 <code>null/undefined</code>，如果不是则继续运算。</p><p><code>?.</code> 链使我们能够安全地访问嵌套属性。</p><p>但是，我们应该谨慎地使用 <code>?.</code>，根据我们的代码逻辑，仅在当左侧部分不存在也可接受的情况下使用为宜。以保证在代码中有编程上的错误出现时，也不会对我们隐藏。</p><h2 id="三、symbol-类型"><a href="#三、symbol-类型" class="headerlink" title="三、symbol 类型"></a>三、symbol 类型</h2><p>根据规范，只有两种原始类型可以用作对象属性键：</p><ul><li>字符串类型</li><li>symbol 类型</li></ul><p>否则，如果使用另一种类型，例如数字，它会被自动转换为字符串。所以 <code>obj[1]</code> 与 <code>obj[&quot;1&quot;]</code> 相同，而 <code>obj[true]</code> 与 <code>obj[&quot;true&quot;]</code> 相同。</p><p>到目前为止，我们一直只使用字符串。</p><p>现在我们来看看 symbol 能给我们带来什么。</p><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a><a href="https://zh.javascript.info/symbol#symbol">symbol</a></h3><p>“symbol” 值表示唯一的标识符。</p><p>可以使用 <code>Symbol()</code> 来创建这种类型的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>();<br></code></pre></td></tr></table></figure><p>创建时，我们可以给 symbol 一个描述（也称为 symbol 名），这在代码调试时非常有用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// id 是描述为 &quot;id&quot; 的 symbol</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br></code></pre></td></tr></table></figure><p>symbol 保证是唯一的。即使我们创建了许多具有相同描述的 symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。</p><p>例如，这里有两个描述相同的 symbol —— 它们不相等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-keyword">let</span> id2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-title function_">alert</span>(id1 == id2); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>如果你熟悉 Ruby 或者其他有 “symbol” 的语言 —— 别被误导。JavaScript 的 symbol 是不同的。</p><p>所以，总而言之，symbol 是带有可选描述的“原始唯一值”。让我们看看我们可以在哪里使用它们。</p><p><strong>symbol 不会被自动转换为字符串</strong></p><p>JavaScript 中的大多数值都支持字符串的隐式转换。例如，我们可以 <code>alert</code> 任何值，都可以生效。symbol 比较特殊，它不会被自动转换。</p><p>例如，这个 <code>alert</code> 将会提示出错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-title function_">alert</span>(id); <span class="hljs-comment">// 类型错误：无法将 symbol 值转换为字符串。</span><br></code></pre></td></tr></table></figure><p>这是一种防止混乱的“语言保护”，因为字符串和 symbol 有本质上的不同，不应该意外地将它们转换成另一个。</p><p>如果我们真的想显示一个 symbol，我们需要在它上面调用 <code>.toString()</code>，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-title function_">alert</span>(id.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// Symbol(id)，现在它有效了</span><br></code></pre></td></tr></table></figure><p>或者获取 <code>symbol.description</code> 属性，只显示描述（description）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-title function_">alert</span>(id.<span class="hljs-property">description</span>); <span class="hljs-comment">// id</span><br></code></pre></td></tr></table></figure><h3 id="“隐藏”属性"><a href="#“隐藏”属性" class="headerlink" title="“隐藏”属性"></a><a href="https://zh.javascript.info/symbol#yin-cang-shu-xing">“隐藏”属性</a></h3><p>symbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。</p><p>例如，如果我们使用的是属于第三方代码的 <code>user</code> 对象，我们想要给它们添加一些标识符。</p><p>我们可以给它们使用 symbol 键：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-comment">// 属于另一个代码</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br>user[id] = <span class="hljs-number">1</span>;<span class="hljs-comment">//给user对象添加id属性，并且赋值为1</span><br><br><span class="hljs-title function_">alert</span>( user[id] ); <span class="hljs-comment">// 我们可以使用 symbol 作为键来访问数据</span><br></code></pre></td></tr></table></figure><p>使用 <code>Symbol(&quot;id&quot;)</code> 作为键，比起用字符串 <code>&quot;id&quot;</code> 来有什么好处呢？</p><p>由于 <code>user</code> 对象属于另一个代码库，所以向它们添加字段是不安全的，因为我们可能会影响代码库中的其他预定义行为。但 symbol 属性不会被意外访问到。第三方代码不会知道新定义的 symbol，因此将 symbol 添加到 <code>user</code> 对象是安全的。</p><p>另外，假设另一个脚本希望在 <code>user</code> 中有自己的标识符，以实现自己的目的。</p><p>那么，该脚本可以创建自己的 <code>Symbol(&quot;id&quot;)</code>，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br>user[id] = <span class="hljs-string">&quot;Their id value&quot;</span>;<br></code></pre></td></tr></table></figure><p>我们的标识符和它们的标识符之间不会有冲突，因为 symbol 总是不同的，即使它们有相同的名字。</p><p>……但如果我们处于同样的目的，使用字符串 <code>&quot;id&quot;</code> 而不是用 symbol，那么 <strong>就会</strong> 出现冲突：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><br><span class="hljs-comment">// 我们的脚本使用了 &quot;id&quot; 属性。</span><br>user.<span class="hljs-property">id</span> = <span class="hljs-string">&quot;Our id value&quot;</span>;<br><br><span class="hljs-comment">// ……另一个脚本也想将 &quot;id&quot; 用于它的目的……</span><br><br>user.<span class="hljs-property">id</span> = <span class="hljs-string">&quot;Their id value&quot;</span><br><span class="hljs-comment">// 砰！无意中被另一个脚本重写了 id！</span><br></code></pre></td></tr></table></figure><h3 id="对象字面量中的-symbol"><a href="#对象字面量中的-symbol" class="headerlink" title="对象字面量中的 symbol"></a><a href="https://zh.javascript.info/symbol#dui-xiang-zi-mian-liang-zhong-de-symbol">对象字面量中的 symbol</a></h3><p>如果我们要在对象字面量 <code>&#123;...&#125;</code> 中使用 symbol，则需要使用方括号<code>[]</code>把它括起来。</p><p>就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  [id]: <span class="hljs-number">123</span> <span class="hljs-comment">// 而不是 &quot;id&quot;：123</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这是因为我们需要变量 <code>id</code> 的值作为键，而不是字符串 “id”。</p><h3 id="symbol-在-for…in-中会被跳过"><a href="#symbol-在-for…in-中会被跳过" class="headerlink" title="symbol 在 for…in 中会被跳过"></a><a href="https://zh.javascript.info/symbol#symbol-zai-forin-zhong-hui-bei-tiao-guo">symbol 在 for…in 中会被跳过</a></h3><p>symbol 属性不参与 <code>for..in</code> 循环。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  [id]: <span class="hljs-number">123</span><br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) <span class="hljs-title function_">alert</span>(key); <span class="hljs-comment">// name, age（没有 symbol）</span><br><br><span class="hljs-comment">// 使用 symbol 任务直接访问</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Direct: &quot;</span> + user[id]); <span class="hljs-comment">// Direct: 123</span><br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">Object.keys(user)</a> 也会忽略它们。这是一般“隐藏符号属性”原则的一部分。如果另一个脚本或库遍历我们的对象，它不会意外地访问到符号属性。</p><p>相反，<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 会同时复制字符串和 symbol 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-keyword">let</span> user = &#123;<br>  [id]: <span class="hljs-number">123</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, user);<br><br><span class="hljs-title function_">alert</span>( clone[id] ); <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>这里并不矛盾，就是这样设计的。这里的想法是当我们克隆或者合并一个 object 时，通常希望 <strong>所有</strong> 属性被复制（包括像 <code>id</code> 这样的 symbol）。</p><h3 id="全局-symbol"><a href="#全局-symbol" class="headerlink" title="全局 symbol"></a><a href="https://zh.javascript.info/symbol#quan-ju-symbol">全局 symbol</a></h3><p>有时我们想要名字相同的 symbol 具有相同的实体。例如，应用程序的不同部分想要访问的 symbol <code>&quot;id&quot;</code> 指的是完全相同的属性。</p><p>为了实现这一点，这里有一个 <strong>全局 symbol 注册表</strong>。我们可以在其中创建 symbol 并在稍后访问它们，它可以确保每次访问相同名字的 symbol 时，返回的都是相同的 symbol。</p><p>要从注册表中读取（不存在则创建）symbol，请使用 <code>Symbol.for(key)</code>。</p><p>该调用会检查全局注册表，如果有一个描述为 <code>key</code> 的 symbol，则返回该 symbol，否则将创建一个新 symbol（<code>Symbol(key)</code>），并通过给定的 <code>key</code> 将其存储在注册表中。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 从全局注册表中读取</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>); <span class="hljs-comment">// 如果该 symbol 不存在，则创建它</span><br><br><span class="hljs-comment">// 再次读取（可能是在代码中的另一个位置）</span><br><span class="hljs-keyword">let</span> idAgain = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-comment">// 相同的 symbol</span><br><span class="hljs-title function_">alert</span>( id === idAgain ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>注册表内的 symbol 被称为 <strong>全局 symbol</strong>。如果我们想要一个应用程序范围内的 symbol，可以在代码中随处访问 —— 这就是它们的用途。</p><p><strong>这听起来像 Ruby</strong></p><p>在一些编程语言中，例如 Ruby，每个名字都有一个 symbol。</p><p>正如我们所看到的，在 JavaScript 中，全局 symbol 也是这样的。</p><h3 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor"></a><a href="https://zh.javascript.info/symbol#symbolkeyfor">Symbol.keyFor</a></h3><p>我们已经看到，对于全局 symbol，<code>Symbol.for(key)</code> 按名字返回一个 symbol。相反，通过全局 symbol 返回一个名字，我们可以使用 <code>Symbol.keyFor(sym)</code>：</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 通过 name 获取 symbol</span><br><span class="hljs-keyword">let</span> sym = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-keyword">let</span> sym2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-comment">// 通过 symbol 获取 name</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(sym) ); <span class="hljs-comment">// name</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(sym2) ); <span class="hljs-comment">// id</span><br></code></pre></td></tr></table></figure><p><code>Symbol.keyFor</code> 内部使用全局 symbol 注册表来查找 symbol 的键。所以它不适用于非全局 symbol。如果 symbol 不是全局的，它将无法找到它并返回 <code>undefined</code>。</p><p>也就是说，所有 symbol 都具有 <code>description</code> 属性。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> globalSymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-keyword">let</span> localSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(globalSymbol) ); <span class="hljs-comment">// name，全局 symbol</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(localSymbol) ); <span class="hljs-comment">// undefined，非全局</span><br><br><span class="hljs-title function_">alert</span>( localSymbol.<span class="hljs-property">description</span> ); <span class="hljs-comment">// name</span><br></code></pre></td></tr></table></figure><h2 id="系统-symbol"><a href="#系统-symbol" class="headerlink" title="系统 symbol"></a><a href="https://zh.javascript.info/symbol#xi-tong-symbol">系统 symbol</a></h2><p>JavaScript 内部有很多“系统” symbol，我们可以使用它们来微调对象的各个方面。</p><p>它们都被列在了 <a href="https://tc39.github.io/ecma262/#sec-well-known-symbols">众所周知的 symbol</a> 表的规范中：</p><ul><li><code>Symbol.hasInstance</code></li><li><code>Symbol.isConcatSpreadable</code></li><li><code>Symbol.iterator</code></li><li><code>Symbol.toPrimitive</code></li><li>……</li></ul><p>例如，<code>Symbol.toPrimitive</code> 允许我们将对象描述为原始值转换。我们很快就会看到它的使用。</p><p>当我们研究相应的语言特征时，我们对其他的 symbol 也会慢慢熟悉起来。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/symbol#zong-jie">总结</a></h3><p><code>symbol</code> 是唯一标识符的基本类型</p><p>symbol 是使用带有可选描述（name）的 <code>Symbol()</code> 调用创建的。</p><p>symbol 总是不同的值，即使它们有相同的名字。如果我们希望同名的 symbol 相等，那么我们应该使用全局注册表：<code>Symbol.for(key)</code> 返回（如果需要的话则创建）一个以 <code>key</code> 作为名字的全局 symbol。使用 <code>Symbol.for</code> 多次调用 <code>key</code> 相同的 symbol 时，返回的就是同一个 symbol。</p><p>symbol 有两个主要的使用场景：</p><ol><li><p>“隐藏” 对象属性。</p><p>如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 symbol 并使用它作为属性的键。symbol 属性不会出现在 <code>for..in</code> 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。</p><p>因此我们可以使用 symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。</p></li><li><p>JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 <code>Symbol.*</code> 访问。我们可以使用它们来改变一些内建行为。例如，在本教程的后面部分，我们将使用 <code>Symbol.iterator</code> 来进行 <a href="https://zh.javascript.info/iterable">迭代</a> 操作，使用 <code>Symbol.toPrimitive</code> 来设置 <a href="https://zh.javascript.info/object-toprimitive">对象原始值的转换</a> 等等。</p></li></ol><p>从技术上说，symbol 不是 100% 隐藏的。有一个内建方法 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols(obj)</a> 允许我们获取所有的 symbol。还有一个名为 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys">Reflect.ownKeys(obj)</a> 的方法可以返回一个对象的 <strong>所有</strong> 键，包括 symbol。但大多数库、内建方法和语法结构都没有使用这些方法。</p><h2 id="四、对象-——-原始值转换"><a href="#四、对象-——-原始值转换" class="headerlink" title="四、对象 —— 原始值转换"></a>四、对象 —— 原始值转换</h2><p>JavaScript 不允许自定义运算符对对象的处理方式。与其他一些编程语言（Ruby，C++）不同）。</p><p>在进行此类运算时，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值）。</p><p>这是一个重要的限制：因为 <code>obj1 + obj2</code>（或者其他数学运算）的结果不能是另一个对象！</p><p>例如，我们无法使用对象来表示向量或矩阵（或成就或其他），把它们相加并期望得到一个“总和”向量作为结果。这样的想法是行不通的。</p><p>因此，由于我们从技术上无法实现此类运算，所以在实际项目中不存在对对象的数学运算。如果你发现有，除了极少数例外，通常是写错了。</p><p>本章将介绍对象是如何转换为原始值的，以及如何对其进行自定义。</p><p>我们有两个目的：</p><ol><li>让我们在遇到类似的对对象进行数学运算的编程错误时，能够更加理解到底发生了什么。</li><li>也有例外，这些操作也可以是可行的。例如日期相减或比较（<code>Date</code> 对象）。我们稍后会遇到它们。</li></ol><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a><a href="https://zh.javascript.info/object-toprimitive#zhuan-huan-gui-ze">转换规则</a></h3><ol><li><code>true</code>和<code>false</code>不会转换为布尔值。只有字符串和数字转换。</li><li>数字转换发生在对象相减或应用数学函数时。例如，<code>Date</code> 对象（将在 <a href="https://zh.javascript.info/date">日期和时间</a> 一章中介绍）可以相减，<code>date1 - date2</code> 的结果是两个日期之间的差值。</li><li>至于字符串转换 —— 通常发生在我们像 <code>alert(obj)</code> 这样输出一个对象和类似的上下文中。</li></ol><p>我们可以使用特殊的对象方法，自己实现字符串和数字的转换。</p><p>现在让我们一起探究技术细节，因为这是深入讨论该主题的唯一方式。</p><h3 id="hint"><a href="#hint" class="headerlink" title="hint"></a><a href="https://zh.javascript.info/object-toprimitive#hint">hint</a></h3><p>JavaScript 是如何决定应用哪种转换的？</p><p>类型转换在各种情况下有三种变体。它们被称为 “hint”，在 <a href="https://tc39.github.io/ecma262/#sec-toprimitive">规范</a> 所述：</p><ul><li><p><code>&quot;string&quot;</code>对象到字符串的转换</p></li><li><p><code>&quot;number&quot;</code>对象到数字的转换</p></li><li><p><code>&quot;default&quot;</code>在少数情况下发生，当运算符“不确定”期望值的类型时。</p></li></ul><p>上面这些规则看起来比较复杂，但在实践中其实挺简单的。</p><p>除了一种情况（<code>Date</code> 对象，我们稍后会讲到）之外，所有内建对象都以和 <code>&quot;number&quot;</code> 相同的方式实现 <code>&quot;default&quot;</code> 转换。我们也可以这样做。</p><p><strong>为了进行转换，JavaScript 尝试查找并调用三个对象方法：</strong></p><ol><li><code>obj[Symbol.toPrimitive](hint)</code> —— 带有 symbol 键 <code>Symbol.toPrimitive</code>（系统 symbol）的方法，如果这个方法存在的话，</li><li>否则，如果 hint 是 <code>&quot;string&quot;</code> —— 尝试调用 <code>obj.toString()</code> 或 <code>obj.valueOf()</code>。</li><li>否则，如果 hint 是 <code>&quot;number&quot;</code> 或 <code>&quot;default&quot;</code> —— 尝试调用 <code>obj.valueOf()</code> 或 <code>obj.toString()</code>。</li></ol><h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a><a href="https://zh.javascript.info/object-toprimitive#symboltoprimitive">Symbol.toPrimitive</a></h3><p>我们从第一个方法开始。有一个名为 <code>Symbol.toPrimitive</code> 的内建 symbol，它被用来给转换方法命名，像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params">hint</span>) &#123;<br>  <span class="hljs-comment">// 这里是将此对象转换为原始值的代码</span><br>  <span class="hljs-comment">// 它必须返回一个原始值</span><br>  <span class="hljs-comment">// hint = &quot;string&quot;、&quot;number&quot; 或 &quot;default&quot; 中的一个</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>Symbol.toPrimitive</code> 方法存在，则它会被用于所有 hint，无需更多其他方法。</p><p>例如，这里 <code>user</code> 对象实现了它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">money</span>: <span class="hljs-number">1000</span>,<br><br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>](hint) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`hint: <span class="hljs-subst">$&#123;hint&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> hint == <span class="hljs-string">&quot;string&quot;</span> ? <span class="hljs-string">`&#123;name: &quot;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>&quot;&#125;`</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-property">money</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 转换演示：</span><br><span class="hljs-title function_">alert</span>(user); <span class="hljs-comment">// hint: string -&gt; &#123;name: &quot;John&quot;&#125;</span><br><span class="hljs-title function_">alert</span>(+user); <span class="hljs-comment">// hint: number -&gt; 1000</span><br><span class="hljs-title function_">alert</span>(user + <span class="hljs-number">500</span>); <span class="hljs-comment">// hint: default -&gt; 1500</span><br></code></pre></td></tr></table></figure><p>从代码中我们可以看到，根据转换的不同，<code>user</code> 变成一个自描述字符串或者一个金额。<code>user[Symbol.toPrimitive]</code> 方法处理了所有的转换情况。</p><h3 id="toString-valueOf"><a href="#toString-valueOf" class="headerlink" title="toString/valueOf"></a><a href="https://zh.javascript.info/object-toprimitive#tostringvalueof">toString/valueOf</a></h3><p>如果没有 <code>Symbol.toPrimitive</code>，那么 JavaScript 将尝试寻找 <code>toString</code> 和 <code>valueOf</code> 方法：</p><ul><li>对于 <code>&quot;string&quot;</code> hint：调用 <code>toString</code> 方法，如果它不存在，则调用 <code>valueOf</code> 方法（因此，对于字符串转换，优先调用 <code>toString</code>）。</li><li>对于其他 hint：调用 <code>valueOf</code> 方法，如果它不存在，则调用 <code>toString</code> 方法（因此，对于数学运算，优先调用 <code>valueOf</code> 方法）。</li></ul><p><code>toString</code> 和 <code>valueOf</code> 方法很早己有了。它们不是 symbol（那时候还没有 symbol 这个概念），而是“常规的”字符串命名的方法。它们提供了一种可选的“老派”的实现转换的方法。</p><p>这些方法必须返回一个原始值。如果 <code>toString</code> 或 <code>valueOf</code> 返回了一个对象，那么返回值会被忽略（和这里没有方法的时候相同）。</p><p>默认情况下，普通对象具有 <code>toString</code> 和 <code>valueOf</code> 方法：</p><ul><li><code>toString</code> 方法返回一个字符串 <code>&quot;[object Object]&quot;</code>。</li><li><code>valueOf</code> 方法返回对象自身。</li></ul><p>下面是一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>&#125;;<br><br><span class="hljs-title function_">alert</span>(user); <span class="hljs-comment">// [object Object]</span><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-title function_">valueOf</span>() === user); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>所以，如果我们尝试将一个对象当做字符串来使用，例如在 <code>alert</code> 中，那么在默认情况下我们会看到 <code>[object Object]</code>。</p><p>让我们实现一下这些方法来自定义转换。</p><p>例如，这里的 <code>user</code> 执行和前面提到的那个 <code>user</code> 一样的操作，使用 <code>toString</code> 和 <code>valueOf</code> 的组合（而不是 <code>Symbol.toPrimitive</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">money</span>: <span class="hljs-number">1000</span>,<br><br>  <span class="hljs-comment">// 对于 hint=&quot;string&quot;</span><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`&#123;name: &quot;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>&quot;&#125;`</span>;<br>  &#125;,<br><br>  <span class="hljs-comment">// 对于 hint=&quot;number&quot; 或 &quot;default&quot;</span><br>  <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">money</span>;<br>  &#125;<br><br>&#125;;<br><br><span class="hljs-title function_">alert</span>(user); <span class="hljs-comment">// toString -&gt; &#123;name: &quot;John&quot;&#125;</span><br><span class="hljs-title function_">alert</span>(+user); <span class="hljs-comment">// valueOf -&gt; 1000</span><br><span class="hljs-title function_">alert</span>(user + <span class="hljs-number">500</span>); <span class="hljs-comment">// valueOf -&gt; 1500</span><br></code></pre></td></tr></table></figure><p>我们可以看到，执行的动作和前面使用 <code>Symbol.toPrimitive</code> 的那个例子相同。</p><p>通常我们希望有一个“全能”的地方来处理所有原始转换。在这种情况下，我们可以只实现 <code>toString</code>，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-title function_">alert</span>(user); <span class="hljs-comment">// toString -&gt; John</span><br><span class="hljs-title function_">alert</span>(user + <span class="hljs-number">500</span>); <span class="hljs-comment">// toString -&gt; John500</span><br></code></pre></td></tr></table></figure><p>如果没有 <code>Symbol.toPrimitive</code> 和 <code>valueOf</code>，<code>toString</code> 将处理所有原始转换。</p><h3 id="转换可以返回任何原始类型"><a href="#转换可以返回任何原始类型" class="headerlink" title="转换可以返回任何原始类型"></a><a href="https://zh.javascript.info/object-toprimitive#zhuan-huan-ke-yi-fan-hui-ren-he-yuan-shi-lei-xing">转换可以返回任何原始类型</a></h3><p>关于所有原始转换方法，有一个重要的点需要知道，就是它们不一定会返回 “hint” 的原始值。</p><p>没有限制 <code>toString()</code> 是否返回字符串，或 <code>Symbol.toPrimitive</code> 方法是否为 <code>&quot;number&quot;</code> hint 返回数字。</p><p>唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。</p><p><strong>历史原因</strong></p><p>由于历史原因，如果 <code>toString</code> 或 <code>valueOf</code> 返回一个对象，则不会出现 error，但是这种值会被忽略（就像这种方法根本不存在）。这是因为在 JavaScript 语言发展初期，没有很好的 “error” 的概念。</p><p>相反，<code>Symbol.toPrimitive</code> 更严格，它 <strong>必须</strong> 返回一个原始值，否则就会出现 error。</p><h3 id="进一步的转换"><a href="#进一步的转换" class="headerlink" title="进一步的转换"></a><a href="https://zh.javascript.info/object-toprimitive#jin-yi-bu-de-zhuan-huan">进一步的转换</a></h3><p>我们已经知道，许多运算符和函数执行类型转换，例如乘法 <code>*</code> 将操作数转换为数字。</p><p>如果我们将对象作为参数传递，则会出现两个运算阶段：</p><ol><li>对象被转换为原始值（通过前面我们描述的规则）。</li><li>如果还需要进一步计算，则生成的原始值会被进一步转换。</li></ol><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-comment">// toString 在没有其他方法的情况下处理所有转换</span><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-title function_">alert</span>(obj * <span class="hljs-number">2</span>); <span class="hljs-comment">// 4，对象被转换为原始值字符串 &quot;2&quot;，之后它被乘法转换为数字 2。</span><br></code></pre></td></tr></table></figure><ol><li>乘法 <code>obj * 2</code> 首先将对象转换为原始值（字符串 “2”）。</li><li>之后 <code>&quot;2&quot; * 2</code> 变为 <code>2 * 2</code>（字符串被转换为数字）。</li></ol><p>二元加法在同样的情况下会将其连接成字符串，因为它更愿意接受字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-title function_">alert</span>(obj + <span class="hljs-number">2</span>); <span class="hljs-comment">// 22（&quot;2&quot; + 2）被转换为原始值字符串 =&gt; 级联</span><br></code></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/object-toprimitive#zong-jie">总结</a></h3><p>对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。</p><p>这里有三种类型（hint）：</p><ul><li><code>&quot;string&quot;</code>（对于 <code>alert</code> 和其他需要字符串的操作）</li><li><code>&quot;number&quot;</code>（对于数学运算）</li><li><code>&quot;default&quot;</code>（少数运算符，通常对象以和 <code>&quot;number&quot;</code> 相同的方式实现 <code>&quot;default&quot;</code> 转换）</li></ul><p>规范明确描述了哪个运算符使用哪个 hint。</p><p>转换算法是：</p><ol><li><p>调用 <code>obj[Symbol.toPrimitive](hint)</code> 如果这个方法存在，</p></li><li><p>否则，如果 hint 是</p></li></ol>   <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;string&quot;</span><br></code></pre></td></tr></table></figure><ul><li>尝试调用 <code>obj.toString()</code> 或 <code>obj.valueOf()</code>，无论哪个存在。</li></ul><ol><li>否则，如果 hint 是</li></ol>   <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;number&quot;</span><br></code></pre></td></tr></table></figure><p>   或者</p>   <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;default&quot;</span><br></code></pre></td></tr></table></figure><ul><li>尝试调用 <code>obj.valueOf()</code> 或 <code>obj.toString()</code>，无论哪个存在。</li></ul><p>所有这些方法都必须返回一个原始值才能工作（如果已定义）。</p><p>在实际使用中，通常只实现 <code>obj.toString()</code> 作为字符串转换的“全能”方法就足够了，该方法应该返回对象的“人类可读”表示，用于日志记录或调试。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 04</title>
    <link href="/2022/08/12/JavaScript-04/"/>
    <url>/2022/08/12/JavaScript-04/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="JavaScript-基础-第四天"><a href="#JavaScript-基础-第四天" class="headerlink" title="JavaScript 基础 - 第四天"></a>JavaScript 基础 - 第四天</h1><h2 id="一、垃圾回收"><a href="#一、垃圾回收" class="headerlink" title="一、垃圾回收"></a>一、垃圾回收</h2><p>对于开发者来说，JavaScript 的内存管理是自动的、无形的。我们创建的原始值、对象、函数……这一切都会占用内存。</p><p>当我们不再需要某个东西时会发生什么？JavaScript 引擎如何发现它并清理它？</p><h3 id="可达性（Reachability）"><a href="#可达性（Reachability）" class="headerlink" title="可达性（Reachability）"></a><a href="https://zh.javascript.info/garbage-collection#ke-da-xing-reachability">可达性（Reachability）</a></h3><p>JavaScript 中主要的内存管理概念是 <strong>可达性</strong>。</p><p>简而言之，“可达值“是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。</p><p>如果一个值可以通过引用链从根访问任何其他值，则认为该值是可达的，这些值被称作 <strong>根（roots）</strong>。</p><p>比方说，如果全局变量中有一个对象，并且该对象有一个属性引用了另一个对象，则 <strong>该</strong> 对象被认为是可达的。而且它引用的内容也是可达的。下面是详细的例子。</p><p>在 JavaScript 引擎中有一个被称作 <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science">垃圾回收器</a>) 的东西在后台执行。它监控着所有对象的状态，并删除掉那些已经不可达的。</p><p>这里是一个最简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// user 具有对这个对象的引用</span><br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122124593.png" alt="image-20220812212453521" style="zoom:50%;" /></p><p>这里的箭头描述了一个对象引用。全局变量 <code>&quot;user&quot;</code> 引用了对象 <code>&#123;name：&quot;John&quot;&#125;</code>（为简洁起见，我们称它为 John）。John 的 <code>&quot;name&quot;</code> 属性存储一个原始值，所以它被写在对象内部。</p><p>如果 <code>user</code> 的值被重写了，这个引用就没了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">user = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122129707.png" alt="image-20220812212903662" style="zoom:50%;" /></p><p>现在 John 变成不可达的了。因为没有引用了，就不能访问到它了。垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。</p><h3 id="两个引用"><a href="#两个引用" class="headerlink" title="两个引用"></a>两个引用</h3><p>现在让我们想象下，我们把 <code>user</code> 的引用复制给 <code>admin</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// user 具有对这个对象的引用</span><br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> admin = user;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122130890.png" alt="image-20220812213046846" style="zoom:50%;" /></p><p>现在如果执行刚刚的那个操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">user = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>user的引用箭头会指向一个空对象，然后原来的John对象仍然可以被 <code>admin</code> 这个全局变量访问到，因此它必须被保留在内存中。如果我们又重写了 <code>admin</code>，对象就会被删除。</p><h3 id="相互关联的对象"><a href="#相互关联的对象" class="headerlink" title="相互关联的对象"></a><a href="https://zh.javascript.info/garbage-collection#xiang-hu-guan-lian-de-dui-xiang">相互关联的对象</a></h3><p>现在来看一个更复杂的例子。这是个家庭：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">marry</span>(<span class="hljs-params">man, woman</span>) &#123;<br>  woman.<span class="hljs-property">husband</span> = man;<br>  man.<span class="hljs-property">wife</span> = woman;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">father</span>: man,<br>    <span class="hljs-attr">mother</span>: woman<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> family = <span class="hljs-title function_">marry</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;, &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Ann&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><code>marry</code> 函数通过让两个对象相互引用使它们“结婚”了，并返回了一个包含这两个对象的新对象。</p><p>由此产生的内存结构：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122208797.png" alt="image-20220812220856765" style="zoom:67%;" /></p><p>到目前为止，所有对象都是可达的。</p><p>现在让我们移除两个引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> family.<span class="hljs-property">father</span>;<br><span class="hljs-keyword">delete</span> family.<span class="hljs-property">mother</span>.<span class="hljs-property">husband</span>;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122211563.png" alt="image-20220812221147533" style="zoom:67%;" /></p><p>仅删除这两个引用中的一个是不够的，因为所有的对象仍然都是可达的。</p><p>但是，如果我们把这两个都删除，那么我们可以看到再也没有对 John 的引用了：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122212756.png" alt="image-20220812221239727" style="zoom:67%;" /></p><p>对外引用不重要，只有传入引用才可以使对象可达。所以，John 现在是不可达的，并且将被从内存中删除，同时 John 的所有数据也将变得不可达。</p><h3 id="无法到达的岛屿"><a href="#无法到达的岛屿" class="headerlink" title="无法到达的岛屿"></a><a href="https://zh.javascript.info/garbage-collection#wu-fa-dao-da-de-dao-yu">无法到达的岛屿</a></h3><p>几个对象相互引用，但外部没有对其任意对象的引用，这些对象也可能是不可达的，并被从内存中删除。</p><p>源对象与上面相同。然后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">family = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>内存内部状态将变成：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122214946.png" alt="image-20220812221424918" style="zoom: 50%;" /></p><p>这个例子展示了可达性概念的重要性。</p><p>显而易见，John 和 Ann 仍然连着，都有传入的引用。但是，这样还不够。</p><p>前面说的 <code>&quot;family&quot;</code> 对象已经不再与根相连，相当于在family引用这一步就把下面的全删了，没有了外部对其的引用，所以它变成了一座“孤岛”，并且将被从内存中删除。</p><h3 id="内部算法"><a href="#内部算法" class="headerlink" title="内部算法"></a><a href="https://zh.javascript.info/garbage-collection#nei-bu-suan-fa">内部算法</a></h3><p>垃圾回收的基本算法被称为 “mark-and-sweep”。</p><p>定期执行以下“垃圾回收”步骤：</p><ul><li>垃圾收集器找到所有的根，并“标记”（记住）它们。</li><li>然后它遍历并“标记”来自它们的所有引用。</li><li>然后它遍历标记的对象并标记 <strong>它们的</strong> 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。</li><li>如此操作，直到所有可达的（从根部）引用都被访问到。</li><li>没有被标记的对象都会被删除。</li></ul><p>例如，使我们的对象有如下的结构：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122217549.png" alt="image-20220812221744508" style="zoom:50%;" /></p><p>我们可以清楚地看到右侧有一个“无法到达的岛屿”。现在我们来看看“标记和清除”垃圾收集器如何处理它。</p><p>第一步标记所有的根：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122225381.png" alt="image-20220812222535340" style="zoom:50%;" /></p><p>然后，我们跟随它们的引用标记它们所引用的对象：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122226193.png" alt="image-20220812222618154" style="zoom:50%;" /></p><p>……如果还有引用的话，继续标记：</p><p>现在，无法通过这个过程访问到的对象被认为是不可达的，并且会被删除。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208122226826.png" alt="image-20220812222656786" style="zoom:50%;" /></p><p>这是垃圾收集工作的概念。JavaScript 引擎做了许多优化，使垃圾回收运行速度更快，并且不会对代码执行引入任何延迟。</p><p>一些优化建议：</p><ul><li><strong>分代收集（Generational collection）</strong>—— 对象被分成两组：“新的”和“旧的”。在典型的代码中，许多对象的生命周期都很短：它们出现、完成它们的工作并很快死去，因此在这种情况下跟踪新对象并将其从内存中清除是有意义的。那些长期存活的对象会变得“老旧”，并且被检查的频次也会降低。</li><li><strong>增量收集（Incremental collection）</strong>—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。<u>因此，引擎将现有的整个对象集拆分为多个部分，然后将这些部分逐一清除。</u>这样就会有很多小型的垃圾收集，而不是一个大型的。这需要它们之间有额外的标记来追踪变化，但是这样会带来许多微小的延迟而不是一个大的延迟。</li><li><strong>闲时收集（Idle-time collection）</strong>—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</li></ul><p>还有其他垃圾回收算法的优化和风格。尽管我想在这里描述它们，但我必须打住了，因为不同的引擎会有不同的调整和技巧。而且，更重要的是，随着引擎的发展，情况会发生变化，所以在没有真实需求的时候，“提前”学习这些内容是不值得的。当然，除非你纯粹是出于兴趣。我在下面给你提供了一些相关链接。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/garbage-collection#zong-jie">总结</a></h3><p>主要需要掌握的内容：</p><ul><li>垃圾回收是自动完成的，我们不能强制执行或是阻止执行。</li><li>当对象是可达状态时，它一定是存在于内存中的。</li><li>被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达，正如我们在上面的例子中看到的那样。</li></ul><h2 id="二、对象方法、”this”"><a href="#二、对象方法、”this”" class="headerlink" title="二、对象方法、”this”"></a>二、对象方法、”this”</h2><p>通常创建对象来表示真实世界中的实体，如用户和订单等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>并且，在现实世界中，用户可以进行 <strong>操作</strong>：如从购物车中挑选某物、登录和注销等。</p><p>在 JavaScript 中，行为（action）由属性中的函数来表示。</p><h3 id="方法示例"><a href="#方法示例" class="headerlink" title="方法示例"></a><a href="https://zh.javascript.info/object-methods#fang-fa-shi-li">方法示例</a></h3><p>语法1：使用函数表达式创建一个函数，并将其指定给对象的 <code>user.sayHi</code> 属性。</p><p>随后我们像这样 <code>user.sayHi()</code> 调用它。用户现在可以说话了！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br>user.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;;<br><br>user.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hello!</span><br></code></pre></td></tr></table></figure><p>语法2：使用预先声明的函数作为方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// 首先，声明函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 然后将其作为一个方法添加</span><br>user.<span class="hljs-property">sayHi</span> = sayHi;<br><br>user.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Hello!</span><br></code></pre></td></tr></table></figure><p><strong>面向对象编程</strong></p><p>当我们在代码中用对象表示实体时，就是所谓的 <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">面向对象编程</a>，简称为 “OOP”。</p><p><strong>语法3：方法简写，最为常用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这些对象作用一样</span><br><br>user = &#123;<br>  <span class="hljs-attr">sayHi</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 方法简写看起来更好，对吧？</span><br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 与 &quot;sayHi: function()&#123;...&#125;&quot; 一样</span><br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>  &#125;，<br>&#125;;<br></code></pre></td></tr></table></figure><p>如上所示，我们可以省略 <code>&quot;function&quot;</code>，只写 <code>sayHi()</code>。</p><p>在几乎所有的情况下，更短的语法是首选的。</p><h3 id="方法中的-“this”"><a href="#方法中的-“this”" class="headerlink" title="方法中的 “this”"></a><a href="https://zh.javascript.info/object-methods#fang-fa-zhong-de-this">方法中的 “this”</a></h3><p><strong>为了访问调用该方法的对象，方法中可以使用 <code>this</code> 关键字。</strong></p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br><br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// &quot;this&quot; 指的是“当前的对象”</span><br>    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br><br>&#125;;<br><br>user.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure><p>在这里 <code>user.sayHi()</code> 执行过程中，<code>this</code> 的值是 <code>user</code>。</p><p>技术上讲，也可以在不使用 <code>this</code> 的情况下，通过外部变量名来引用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br><br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// &quot;user&quot; 替代 &quot;this&quot;</span><br>  &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>但这样的代码是不可靠的。如果我们决定将 <code>user</code> 复制给另一个变量，例如 <code>admin = user</code>，并赋另外的值给 <code>user</code>，那么它将访问到错误的对象。</p><p>下面这个示例证实了这一点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br><br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>( user.<span class="hljs-property">name</span> ); <span class="hljs-comment">// 导致错误</span><br>  &#125;<br><br>&#125;;<br><br><br><span class="hljs-keyword">let</span> admin = user;<br>user = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 重写让其更明显</span><br><br>admin.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// TypeError: Cannot read property &#x27;name&#x27; of null</span><br></code></pre></td></tr></table></figure><p>如果我们在 <code>alert</code> 中以 <code>this.name</code> 替换 <code>user.name</code>，那么代码就会正常运行。</p><h3 id="“this”-不受限制"><a href="#“this”-不受限制" class="headerlink" title="“this” 不受限制"></a><a href="https://zh.javascript.info/object-methods#this-bu-shou-xian-zhi">“this” 不受限制</a></h3><p>在 JavaScript 中，<code>this</code> 关键字与其他大多数编程语言中的不同。JavaScript 中的 <code>this</code> 可以用于任何函数，即使它不是对象的方法。</p><p>下面这样的代码没有语法错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>&#125;<br></code></pre></td></tr></table></figure><p><code>this</code> 的值是在代码运行时计算出来的，它取决于代码上下文。</p><p>例如，这里相同的函数被分配给两个不同的对象，在调用中有着不同的 “this” 值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> admin = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Admin&quot;</span> &#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>&#125;<br><br><span class="hljs-comment">// 在两个对象中使用相同的函数</span><br>user.<span class="hljs-property">f</span> = sayHi;<br>admin.<span class="hljs-property">f</span> = sayHi;<br><br><span class="hljs-comment">// 这两个调用有不同的 this 值</span><br><span class="hljs-comment">// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象</span><br>user.<span class="hljs-title function_">f</span>(); <span class="hljs-comment">// John（this == user）</span><br>admin.<span class="hljs-title function_">f</span>(); <span class="hljs-comment">// Admin（this == admin）</span><br><br>admin[<span class="hljs-string">&#x27;f&#x27;</span>](); <span class="hljs-comment">// Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）</span><br></code></pre></td></tr></table></figure><p><strong>在没有对象的情况下调用：<code>this == undefined</code></strong></p><p>我们甚至可以在没有对象的情况下调用函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>在这种情况下，严格模式下的 <code>this</code> 值为 <code>undefined</code>。如果我们尝试访问 <code>this.name</code>，将会报错。</p><p>在非严格模式的情况下，<code>this</code> 将会是 <strong>全局对象</strong>（浏览器中的 <code>window</code>，我们稍后会在 <a href="https://zh.javascript.info/global-object">全局对象</a> 一章中学习它）。这是一个历史行为，<code>&quot;use strict&quot;</code> 已经将其修复了。</p><p><strong>解除 <code>this</code> 绑定的后果</strong></p><p>如果你经常使用其他的编程语言，那么你可能已经习惯了“绑定 <code>this</code>”的概念，即在对象中定义的方法总是有指向该对象的 <code>this</code>。</p><p>在 JavaScript 中，<code>this</code> 是“自由”的，它的值是在调用时计算出来的，它的值并不取决于方法声明的位置，而是取决于在“点符号前”的是什么对象。</p><p>在运行时对 <code>this</code> 求值的这个概念既有优点也有缺点。一方面，函数可以被重用于不同的对象。另一方面，更大的灵活性造成了更大的出错的可能。</p><p>这里我们的立场并不是要评判编程语言的这个设计是好是坏。而是要了解怎样使用它，如何趋利避害。</p><h3 id="箭头函数没有自己的-“this”"><a href="#箭头函数没有自己的-“this”" class="headerlink" title="箭头函数没有自己的 “this”"></a><a href="https://zh.javascript.info/object-methods#jian-tou-han-shu-mei-you-zi-ji-de-this">箭头函数没有自己的 “this”</a></h3><p>箭头函数有些特别：它们没有自己的 <code>this</code>。如果我们在这样的函数中引用 <code>this</code>，<code>this</code> 值取决于外部“正常的”函数。</p><p>举个例子，这里的 <code>arrow()</code> 使用的 <code>this</code> 来自于外部的 <code>user.sayHi()</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Ilya&quot;</span>,<br>  <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">arrow</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>);<br>    <span class="hljs-title function_">arrow</span>();<br>  &#125;<br>&#125;;<br><br>user.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// Ilya</span><br></code></pre></td></tr></table></figure><p>这是箭头函数的一个特性，当我们并不想要一个独立的 <code>this</code>，反而想从外部上下文中获取时，它很有用。在后面的 <a href="https://zh.javascript.info/arrow-functions">深入理解箭头函数</a> 一章中，我们将深入介绍箭头函数。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/object-methods#zong-jie">总结</a></h3><ul><li>存储在对象属性中的函数被称为“方法”。</li><li>方法允许对象进行像 <code>object.doSomething()</code> 这样的“操作”。</li><li>方法可以将对象引用为 <code>this</code>。</li></ul><p><code>this</code> 的值是在程序运行时得到的。</p><ul><li>一个函数在声明时，可能就使用了 <code>this</code>，但是这个 <code>this</code> 只有在函数被调用时才会有值。</li><li>可以在对象之间复制函数。</li><li>以“方法”的语法调用函数时：<code>object.method()</code>，调用过程中的 <code>this</code> 值是 <code>object</code>。</li></ul><p>请注意箭头函数有些特别：它们没有 <code>this</code>。在箭头函数内部访问到的 <code>this</code> 都是从外部获取的。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a><a href="https://zh.javascript.info/object-methods#tasks">任务</a></h2><h3 id="创建一个计算器"><a href="#创建一个计算器" class="headerlink" title="创建一个计算器"></a><a href="https://zh.javascript.info/object-methods#chuang-jian-yi-ge-ji-suan-qi">创建一个计算器</a></h3><p>重要程度: 5</p><p>创建一个有三个方法的 <code>calculator</code> 对象：</p><ul><li><code>read()</code> 提示输入两个值，并将其保存为对象属性，属性名分别为 <code>a</code> 和 <code>b</code>。</li><li><code>sum()</code> 返回保存的值的和。</li><li><code>mul()</code> 将保存的值相乘并返回计算结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> calculator = &#123;<br>  <span class="hljs-comment">// ……你的代码……</span><br>&#125;;<br><br>calculator.<span class="hljs-title function_">read</span>();<br><span class="hljs-title function_">alert</span>( calculator.<span class="hljs-title function_">sum</span>() );<br><span class="hljs-title function_">alert</span>( calculator.<span class="hljs-title function_">mul</span>() );<br></code></pre></td></tr></table></figure><p>答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> calculator = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">b</span>:<span class="hljs-literal">null</span>,<br>    <span class="hljs-title function_">read</span>(<span class="hljs-params"></span>)&#123;<br>       a=<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入第一个值&quot;</span>) <br>       b=<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入第二个值&quot;</span>) <br>    &#125;,<br>    <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> -(-a-b)<span class="hljs-comment">//为了输出数值对象</span><br>    &#125;,<br>    <span class="hljs-title function_">mul</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> a*b<br>    &#125;,<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params">obj</span>)&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> calculator)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-title function_">alert</span>(<span class="hljs-title function_">isEmpty</span>(calculator))<br>calculator.<span class="hljs-title function_">read</span>();<br><span class="hljs-title function_">alert</span>( calculator.<span class="hljs-title function_">sum</span>() );<br><span class="hljs-title function_">alert</span>( calculator.<span class="hljs-title function_">mul</span>() );<br></code></pre></td></tr></table></figure><h3 id="链式（调用）"><a href="#链式（调用）" class="headerlink" title="链式（调用）"></a><a href="https://zh.javascript.info/object-methods#lian-shi-tiao-yong">链式（调用）</a></h3><p>重要程度: 2</p><p>有一个可以上下移动的 <code>ladder</code> 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ladder = &#123;<br>  <span class="hljs-attr">step</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-title function_">up</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">step</span>++;<br>  &#125;,<br>  <span class="hljs-title function_">down</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">step</span>--;<br>  &#125;,<br>  <span class="hljs-attr">showStep</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 显示当前的 step</span><br>    <span class="hljs-title function_">alert</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">step</span> );<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>现在，如果我们要按顺序执行几次调用，可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ladder.<span class="hljs-title function_">up</span>();<br>ladder.<span class="hljs-title function_">up</span>();<br>ladder.<span class="hljs-title function_">down</span>();<br>ladder.<span class="hljs-title function_">showStep</span>(); <span class="hljs-comment">// 1</span><br>ladder.<span class="hljs-title function_">down</span>();<br>ladder.<span class="hljs-title function_">showStep</span>(); <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>修改 <code>up</code>，<code>down</code> 和 <code>showStep</code> 的代码，让调用可以链接，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ladder.<span class="hljs-title function_">up</span>().<span class="hljs-title function_">up</span>().<span class="hljs-title function_">down</span>().<span class="hljs-title function_">showStep</span>().<span class="hljs-title function_">down</span>().<span class="hljs-title function_">showStep</span>(); <span class="hljs-comment">// 展示 1，然后 0</span><br></code></pre></td></tr></table></figure><p>这种方法在 JavaScript 库中被广泛使用。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>润学笔记</title>
    <link href="/2022/08/09/%E6%B6%A601/"/>
    <url>/2022/08/09/%E6%B6%A601/</url>
    
    <content type="html"><![CDATA[<hr><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208092132268.png" alt="image-20220809213237235"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208092133968.png" alt="image-20220809213357937"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208092136836.png" alt="image-20220809213631788"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Run</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 03</title>
    <link href="/2022/08/06/JavaScript-03/"/>
    <url>/2022/08/06/JavaScript-03/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="JavaScript-基础-第三天"><a href="#JavaScript-基础-第三天" class="headerlink" title="JavaScript 基础 - 第三天"></a>JavaScript 基础 - 第三天</h1><h2 id="一、对象"><a href="#一、对象" class="headerlink" title="一、对象"></a>一、对象</h2><p>JavaScript 中有八种数据类型。</p><p>有七种是原始类型，它们的值只包含一种类型（字符串，数字或者其他）。相反，对象则用来存储键值对或更复杂的实体。</p><p>我们可以通过使用带有可选 <strong>属性列表</strong> 的花括号 <code>&#123;…&#125;</code> 来创建对象。一个属性就是一个键值对（“key: value”），其中键（<code>key</code>）是一个字符串（也叫做属性名），值（<code>value</code>）可以是任何值。</p><p>我们可以把对象想象成一个带有签名文件的文件柜。每一条数据都基于键（<code>key</code>）存储在文件中。这样我们就可以很容易根据文件名（也就是“键”）查找文件或添加/删除文件了。</p><p>我们可以用下面两种语法中的任一种来创建一个空的对象（“空柜子”）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// “构造函数” 的语法</span><br><span class="hljs-keyword">let</span> user = &#123;&#125;;  <span class="hljs-comment">// “字面量” 的语法</span><br></code></pre></td></tr></table></figure><p>通常，我们用花括号。这种方式我们叫做 <strong>字面量</strong>。</p><h3 id="文本和属性"><a href="#文本和属性" class="headerlink" title="文本和属性"></a><a href="https://zh.javascript.info/object#wen-ben-he-shu-xing">文本和属性</a></h3><p>我们可以在创建对象的时候，立即将一些属性以键值对的形式放到 <code>&#123;...&#125;</code> 中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;     <span class="hljs-comment">// 一个对象</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,  <span class="hljs-comment">// 键 &quot;name&quot;，值 &quot;John&quot;</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>        <span class="hljs-comment">// 键 &quot;age&quot;，值 30</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>属性有键（或者也可以叫做“名字”或“标识符”），位于冒号 <code>&quot;:&quot;</code> 的前面，值在冒号的右边。</p><p>在 <code>user</code> 对象中，有两个属性：</p><ol><li>第一个的键是 <code>&quot;name&quot;</code>，值是 <code>&quot;John&quot;</code>。</li><li>第二个的键是 <code>&quot;age&quot;</code>，值是 <code>30</code>。</li></ol><p>生成的 <code>user</code> 对象可以被想象为一个放置着两个标记有 “name” 和 “age” 的文件的柜子。</p><p>我们可以随时添加、删除和读取文件。</p><p>可以使用点符号访问属性值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 读取文件的属性：</span><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">name</span> ); <span class="hljs-comment">// John</span><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">age</span> ); <span class="hljs-comment">// 30</span><br></code></pre></td></tr></table></figure><p>属性的值可以是任意类型，让我们加个布尔类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">user.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>我们可以用 <code>delete</code> 操作符移除属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> user.<span class="hljs-property">age</span>;<br></code></pre></td></tr></table></figure><p>我们也可以用多字词语来作为属性名，但必须给它们加上引号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-string">&quot;likes birds&quot;</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 多词属性名必须加引号</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>列表中的最后一个属性应以逗号结尾：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>这叫做尾随（trailing）或悬挂（hanging）逗号。这样便于我们添加、删除和移动属性，因为所有的行都是相似的。</p><h3 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a><a href="https://zh.javascript.info/object#fang-kuo-hao">方括号</a></h3><p>对于多词属性，点操作就不能用了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这将提示有语法错误</span><br>user.<span class="hljs-property">likes</span> birds = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>JavaScript 理解不了。它认为我们在处理 <code>user.likes</code>，然后在遇到意外的 <code>birds</code> 时给出了语法错误。</p><p>有另一种方法，就是使用方括号，可用于任何字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;;<br><br><span class="hljs-comment">// 设置</span><br>user[<span class="hljs-string">&quot;likes birds&quot;</span>] = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 读取</span><br><span class="hljs-title function_">alert</span>(user[<span class="hljs-string">&quot;likes birds&quot;</span>]); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-keyword">delete</span> user[<span class="hljs-string">&quot;likes birds&quot;</span>];<br></code></pre></td></tr></table></figure><p>现在一切都可行了。<u>请注意方括号中的字符串要放在引号中，单引号或双引号都可以。</u></p><p>方括号同样提供了一种可以通过任意表达式来获取属性名的方式</p><p>在这里，变量 <code>key</code> 可以是程序运行时计算得到的，也可以是根据用户的输入得到的。然后我们可以用它来访问属性。这给了我们很大的灵活性。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//为name属性起一个变量名为key，再通过变量名获取属性值</span><br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><span class="hljs-comment">//第二个参数为初始值</span><br><span class="hljs-comment">//let key = prompt(&quot;What do you want to know about the user?&quot;, &quot;name&quot;);</span><br><br><span class="hljs-keyword">let</span> key = <span class="hljs-string">&#x27;name&#x27;</span><br><br><span class="hljs-comment">// 访问变量</span><br><span class="hljs-title function_">alert</span>( user[key] ); <span class="hljs-comment">// John（如果输入 &quot;name&quot;）</span><br></code></pre></td></tr></table></figure><p>点符号不能以类似的方式使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;name&quot;</span>;<br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">key</span> ) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a><a href="https://zh.javascript.info/object#ji-suan-shu-xing">计算属性</a></h3><p>当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 <strong>计算属性</strong>。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//给属性apple赋予变量名fruit，再为其赋值为5</span><br><span class="hljs-keyword">let</span> fruit = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;Which fruit to buy?&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>);<br><br><span class="hljs-keyword">let</span> bag = &#123;<br>  [fruit]: <span class="hljs-number">5</span>, <span class="hljs-comment">// 属性名是从 fruit 变量中得到的</span><br>&#125;;<br><br><span class="hljs-title function_">alert</span>( bag.<span class="hljs-property">apple</span> ); <span class="hljs-comment">// 5 如果 fruit=&quot;apple&quot;</span><br></code></pre></td></tr></table></figure><p>本质上，这跟下面的语法效果相同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruit = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;Which fruit to buy?&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>);<br><span class="hljs-keyword">let</span> bag = &#123;&#125;;<br><br><span class="hljs-comment">// 从 fruit 变量中获取值</span><br>bag[fruit] = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>我们可以在方括号中使用更复杂的表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruit = <span class="hljs-string">&#x27;apple&#x27;</span>;<br><span class="hljs-keyword">let</span> bag = &#123;<br>  [fruit + <span class="hljs-string">&#x27;Computers&#x27;</span>]: <span class="hljs-number">5</span> <span class="hljs-comment">// bag.appleComputers = 5</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>方括号比点符号更强大。它允许任何属性名和变量，但写起来也更加麻烦。</p><p>所以，大部分时间里，当属性名是已知且简单的时候，就使用点符号。如果我们需要一些更复杂的内容，那么就用方括号。</p><h3 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a><a href="https://zh.javascript.info/object#shu-xing-zhi-jian-xie">属性值简写</a></h3><p>在实际开发中，我们通常用已存在的变量当做属性名。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeUser</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">name</span>: name,<br>    <span class="hljs-attr">age</span>: age,<br>    <span class="hljs-comment">// ……其他的属性</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-title function_">makeUser</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">30</span>);<br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，属性名跟变量名一样。这种通过变量生成属性的应用场景很常见，在这有一种特殊的 <strong>属性值缩写</strong> 方法，使属性名变得更短。</p><p>可以用 <code>name</code> 来代替 <code>name:name</code> 像下面那样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeUser</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    name, <span class="hljs-comment">// 与 name: name 相同</span><br>    age,  <span class="hljs-comment">// 与 age: age 相同</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以把属性名简写方式和正常方式混用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeUser</span>(<span class="hljs-params">name,age</span>)&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        name,<span class="hljs-attr">age</span>:<span class="hljs-number">30</span>,<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> user = <span class="hljs-title function_">makeUser</span>(<span class="hljs-string">&#x27;xm&#x27;</span>)<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(user.<span class="hljs-property">name</span>+user.<span class="hljs-property">age</span>)<br><span class="hljs-comment">//document.write(user[&#x27;name&#x27;]+user[&#x27;age&#x27;])     </span><br></code></pre></td></tr></table></figure><h3 id="属性名称限制"><a href="#属性名称限制" class="headerlink" title="属性名称限制"></a><a href="https://zh.javascript.info/object#shu-xing-ming-cheng-xian-zhi">属性名称限制</a></h3><p>我们已经知道，变量名不能是编程语言的某个保留字，如 “for”、“let”、“return” 等……</p><p>但对象的属性名并不受此限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这些属性都没问题</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">for</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">let</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">return</span>: <span class="hljs-number">3</span><br>&#125;;<br><br><span class="hljs-title function_">alert</span>( obj.<span class="hljs-property">for</span> + obj.<span class="hljs-property">let</span> + obj.<span class="hljs-property">return</span> );  <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><p>简而言之，属性命名没有限制。属性名可以是任何字符串或者 symbol（一种特殊的标志符类型，将在后面介绍）。</p><p>其他类型会被自动地转换为字符串。</p><p>例如，当数字 <code>0</code> 被用作对象的属性的键时，会被转换为字符串 <code>&quot;0&quot;</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&quot;test&quot;</span> <span class="hljs-comment">// 等同于 &quot;0&quot;: &quot;test&quot;</span><br>&#125;;<br><br><span class="hljs-comment">// 都会输出相同的属性（数字 0 被转为字符串 &quot;0&quot;）</span><br><span class="hljs-title function_">alert</span>( obj[<span class="hljs-string">&quot;0&quot;</span>] ); <span class="hljs-comment">// test</span><br><span class="hljs-title function_">alert</span>( obj[<span class="hljs-number">0</span>] ); <span class="hljs-comment">// test (相同的属性)</span><br></code></pre></td></tr></table></figure><p>这里有个小陷阱：一个名为 <code>__proto__</code> 的属性。我们不能将它设置为一个非对象的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">__proto__</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// 分配一个数字</span><br><span class="hljs-title function_">alert</span>(obj.<span class="hljs-property">__proto__</span>); <span class="hljs-comment">// [object Object] —— 值为对象，与预期结果不同</span><br></code></pre></td></tr></table></figure><p>我们从代码中可以看出来，把它赋值为 <code>5</code> 的操作被忽略了。</p><p>我们将在 <a href="https://zh.javascript.info/prototype-inheritance">后续章节</a> 中学习 <code>__proto__</code> 的特殊性质，并给出了解决此问题的方法。</p><h3 id="属性存在性检测，“in”-操作符"><a href="#属性存在性检测，“in”-操作符" class="headerlink" title="属性存在性检测，“in” 操作符"></a><a href="https://zh.javascript.info/object#shu-xing-cun-zai-xing-ce-shi-in-cao-zuo-fu">属性存在性检测，“in” 操作符</a></h3><p>相比于其他语言，JavaScript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！</p><p>读取不存在的属性只会得到 <code>undefined</code>。所以我们可以很容易地判断一个属性是否存在：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;;<br><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">noSuchProperty</span> === fruit ); <span class="hljs-comment">// true 意思是没有这个属性</span><br></code></pre></td></tr></table></figure><p>这里还有一个特别的，检查属性是否存在的操作符 <code>&quot;in&quot;</code>。</p><p>语法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;key&quot;</span> <span class="hljs-keyword">in</span> object<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;age&quot;</span> <span class="hljs-keyword">in</span> user ); <span class="hljs-comment">// true，user.age 存在</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;blabla&quot;</span> <span class="hljs-keyword">in</span> user ); <span class="hljs-comment">// false，user.blabla 不存在。</span><br></code></pre></td></tr></table></figure><p>请注意，<code>in</code> 的左边必须是 <strong>属性名</strong>。通常是一个带引号的字符串。</p><p>如果我们省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><br><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;age&quot;</span>;<br><span class="hljs-title function_">alert</span>( key <span class="hljs-keyword">in</span> user ); <span class="hljs-comment">// true，属性 &quot;age&quot; 存在</span><br></code></pre></td></tr></table></figure><p>为何会有 <code>in</code> 运算符呢？与 <code>undefined</code> 进行比较来判断还不够吗？</p><p>确实，大部分情况下与 <code>undefined</code> 进行比较来判断就可以了。但有一个例外情况，这种比对方式会有问题，但 <code>in</code> 运算符的判断结果仍是对的。</p><p>那就是属性存在，但存储的值是 <code>undefined</code> 的时候：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">test</span>: <span class="hljs-literal">undefined</span><br>&#125;;<br><br><span class="hljs-title function_">alert</span>( obj.<span class="hljs-property">test</span> ); <span class="hljs-comment">// 显示 undefined，所以属性不存在？</span><br><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;test&quot;</span> <span class="hljs-keyword">in</span> obj ); <span class="hljs-comment">// true，属性存在！</span><br></code></pre></td></tr></table></figure><p>这种情况很少发生，因为通常情况下不应该给对象赋值 <code>undefined</code>。我们通常会用 <code>null</code> 来表示未知的或者空的值。因此，<code>in</code> 运算符是代码中的特殊来宾。</p><h3 id="“for-in”-循环"><a href="#“for-in”-循环" class="headerlink" title="“for..in” 循环"></a><a href="https://zh.javascript.info/object#forin">“for..in” 循环</a></h3><p>为了遍历一个对象的所有键（key），可以使用一个特殊形式的循环：<code>for...in</code>。这跟我们在前面学到的 <code>for(;;)</code> 循环是完全不一样的东西。</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> object) &#123;<br>  <span class="hljs-comment">// 对此对象属性中的每个键执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如，让我们列出 <code>user</code> 所有的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) &#123;<br>  <span class="hljs-comment">// keys,可以随便命名，i也可以</span><br>  <span class="hljs-title function_">alert</span>( key );  <span class="hljs-comment">// name, age, isAdmin</span><br>  <span class="hljs-comment">// 属性键的值</span><br>  <span class="hljs-title function_">alert</span>( user[key] ); <span class="hljs-comment">// John, 30, true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="像对象一样排序"><a href="#像对象一样排序" class="headerlink" title="像对象一样排序"></a><a href="https://zh.javascript.info/object#xiang-dui-xiang-yi-yang-pai-xu">像对象一样排序</a></h3><p>对象的属性有顺序吗？</p><p>回答是：“有特别的顺序”：整数属性会被进行排序，其他属性则按照创建的顺序显示。详情如下：</p><p>例如，让我们考虑一个带有电话号码的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> codes = &#123;<br>  <span class="hljs-string">&quot;49&quot;</span>: <span class="hljs-string">&quot;Germany&quot;</span>,<br>  <span class="hljs-string">&quot;41&quot;</span>: <span class="hljs-string">&quot;Switzerland&quot;</span>,<br>  <span class="hljs-string">&quot;44&quot;</span>: <span class="hljs-string">&quot;Great Britain&quot;</span>,<br>  <span class="hljs-comment">// ..,</span><br>  <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;USA&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> code <span class="hljs-keyword">in</span> codes) &#123;<br>  <span class="hljs-title function_">alert</span>(+code); <span class="hljs-comment">// 1, 41, 44, 49</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的“整数属性”指的是一个可以在不做任何更改的情况下与一个整数进行相互转换的字符串，而不是“1sd”这种以数字开头的字符串。但是 “+49” 和 “1.2” 就不行了：</p><p>此外，如果属性名不是整数，那它们就按照创建时的顺序来排序，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Smith&quot;</span><br>&#125;;<br>user.<span class="hljs-property">age</span> = <span class="hljs-number">25</span>; <span class="hljs-comment">// 增加一个</span><br><br><span class="hljs-comment">// 非整数属性是按照创建的顺序来排列的</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> user) &#123;<br>  <span class="hljs-title function_">alert</span>( prop ); <span class="hljs-comment">// name, surname, age</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以，为了解决电话号码的问题，我们可以使用非整数属性名来 <strong>欺骗</strong> 程序。只需要给每个键名加一个加号 <code>&quot;+&quot;</code> 前缀就行了。</p><p>像这样，属性名为“+49”被理解为非整数属性，然后再在便历时通过在属性前加一个算术符号“+”来转换成数字。</p><p>因为是两个<code>+</code>，所以得到的结果依然是正数，同样加两个<code>-</code>，得到的结果是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> codes = &#123;<br>  <span class="hljs-string">&quot;+49&quot;</span>: <span class="hljs-string">&quot;Germany&quot;</span>,<br>  <span class="hljs-string">&quot;+41&quot;</span>: <span class="hljs-string">&quot;Switzerland&quot;</span>,<br>  <span class="hljs-string">&quot;+44&quot;</span>: <span class="hljs-string">&quot;Great Britain&quot;</span>,<br>  <span class="hljs-comment">// ..,</span><br>  <span class="hljs-string">&quot;+1&quot;</span>: <span class="hljs-string">&quot;USA&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> code <span class="hljs-keyword">in</span> codes) &#123;<br>  <span class="hljs-title function_">alert</span>( +code ); <span class="hljs-comment">// 49, 41, 44, 1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/object#zong-jie">总结</a></h3><p>对象是具有一些特殊特性的关联数组。</p><p>它们存储属性（键值对），其中：</p><ul><li>属性的键必须是字符串或者 symbol（通常是字符串）。</li><li>值可以是任何类型。</li></ul><p>我们可以用下面的方法访问属性：</p><ul><li>点符号: <code>obj.property</code>。</li><li>方括号 <code>obj[&quot;property&quot;]</code>，方括号允许从变量中获取键，例如 <code>obj[varWithKey]</code>。</li></ul><p>其他操作：</p><ul><li>删除属性：<code>delete obj.prop</code>。</li><li>检查是否存在给定键的属性：<code>&quot;key&quot; in obj</code>。</li><li>遍历对象：<code>for(let key in obj)</code> 循环。</li></ul><p>我们在这一章学习的叫做“普通对象（plain object）”，或者就叫对象。</p><p>JavaScript 中还有很多其他类型的对象：</p><ul><li><code>Array</code> 用于存储有序数据集合，</li><li><code>Date</code> 用于存储时间日期，</li><li><code>Error</code> 用于存储错误信息。</li><li>……等等。</li></ul><p>它们有着各自特别的特性，我们将在后面学习到。有时候大家会说“Array 类型”或“Date 类型”，但其实它们并不是自身所属的类型，而是属于一个对象类型即 “object”。它们以不同的方式对 “object” 做了一些扩展。</p><p>JavaScript 中的对象非常强大。这里我们只接触了其冰山一角。在后面的章节中，我们将频繁使用对象进行编程，并学习更多关于对象的知识。</p><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a><a href="https://zh.javascript.info/object#tasks">作业</a></h2><h3 id="检查空对象"><a href="#检查空对象" class="headerlink" title="检查空对象"></a><a href="https://zh.javascript.info/object#jian-cha-kong-dui-xiang">检查空对象</a></h3><p>重要程度: 5</p><p>写一个 <code>isEmpty(obj)</code> 函数，当对象没有属性的时候返回 <code>true</code>，否则返回 <code>false</code>。</p><p>答案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj=&#123;&#125;<span class="hljs-comment">//true</span><br><span class="hljs-keyword">let</span> obj=&#123;<br>    <span class="hljs-attr">ff</span>:<span class="hljs-number">2</span><br>&#125;<span class="hljs-comment">//false</span><br><span class="hljs-comment">//函数逻辑：如果能被遍历相当于属性非空</span><br><span class="hljs-keyword">let</span> schedule = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-title function_">alert</span>(<span class="hljs-title function_">schedule</span>())<br></code></pre></td></tr></table></figure><h3 id="对象属性求和"><a href="#对象属性求和" class="headerlink" title="对象属性求和"></a><a href="https://zh.javascript.info/object#dui-xiang-shu-xing-qiu-he">对象属性求和</a></h3><p>重要程度: 5</p><p>我们有一个保存着团队成员工资的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> salaries = &#123;<br>  <span class="hljs-title class_">John</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-title class_">Ann</span>: <span class="hljs-number">160</span>,<br>  <span class="hljs-title class_">Pete</span>: <span class="hljs-number">130</span><br>&#125;<br></code></pre></td></tr></table></figure><p>写一段代码求出我们的工资总和，将计算结果保存到变量 <code>sum</code>。从所给的信息来看，结果应该是 <code>390</code>。</p><p>如果 <code>salaries</code> 是一个空对象，那结果就为 <code>0</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> salaries = &#123;<br>    <span class="hljs-title class_">John</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-title class_">Ann</span>: <span class="hljs-number">160</span>,<br>    <span class="hljs-title class_">Pete</span>: <span class="hljs-number">130</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">obj</span>)&#123;<br>    <span class="hljs-keyword">let</span> end=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj)&#123;<br>        end+=obj[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> end<br>&#125;<br><span class="hljs-title function_">alert</span>(<span class="hljs-title function_">sum</span>(salaries))<br></code></pre></td></tr></table></figure><h3 id="将数值属性值都乘以-2"><a href="#将数值属性值都乘以-2" class="headerlink" title="将数值属性值都乘以 2"></a><a href="https://zh.javascript.info/object#jiang-shu-zhi-shu-xing-zhi-du-cheng-yi-2">将数值属性值都乘以 2</a></h3><p>重要程度: 3</p><p>创建一个 <code>multiplyNumeric(obj)</code> 函数，把 <code>obj</code> 所有的数值属性值都乘以 <code>2</code>。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在调用之前</span><br><span class="hljs-keyword">let</span> menu = &#123;<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">300</span>,<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;My menu&quot;</span><br>&#125;;<br><br><span class="hljs-title function_">multiplyNumeric</span>(menu);<br><br><span class="hljs-comment">// 调用函数之后</span><br>menu = &#123;<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">400</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">600</span>,<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;My menu&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>注意 <code>multiplyNumeric</code> 函数不需要返回任何值，它应该就地修改对象。</p><p>P.S. 用 <code>typeof</code> 检查值类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> menu = &#123;<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">300</span>,<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;My menu&quot;</span>,<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiplyNumeric</span>(<span class="hljs-params">obj</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_">typeof</span>(obj[i])==<span class="hljs-string">&quot;number&quot;</span>)&#123;        <br>            obj[i]*=<span class="hljs-number">2</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-title function_">multiplyNumeric</span>(menu);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> menu)&#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;i&#125;</span>:<span class="hljs-subst">$&#123;menu[i]&#125;</span>\n`</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、对象引用和复制"><a href="#二、对象引用和复制" class="headerlink" title="二、对象引用和复制"></a>二、对象引用和复制</h2><p>对象与原始类型的根本区别之一是，对象是“通过引用”存储和复制的，而原始类型：字符串、数字、布尔值等总是“作为一个整体”复制。</p><p>让我们从原始类型开始，当我们复制一个字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;Hello!&quot;</span>;<br><span class="hljs-keyword">let</span> phrase = message;<br></code></pre></td></tr></table></figure><p>结果我们就有了两个独立的变量，每个都存储着字符串 <code>&quot;Hello!&quot;</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208112313194.png" alt="image-20220811231348104" style="zoom:67%;" /></p><p>但对象不这样。</p><p><strong>赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址” —— 换句话说就是对该对象的“引用”。</strong></p><p>让我们看一个这样的变量的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这是它实际存储在内存中的方式：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208112315077.png" alt="image-20220811231512992" style="zoom:50%;" /></p><p>该对象被存储在内存中的某个位置（在图片的右侧），而变量 <code>user</code>（在左侧）保存的是对其的“引用”。</p><p>我们可以将一个对象变量（例如 <code>user</code>）想象成一张写有对象的地址的纸。</p><p>当我们对对象执行操作时，例如获取一个属性 <code>user.name</code>，JavaScript 引擎会查看该地址中的内容，并在实际对象上执行操作。</p><p><strong>当一个对象变量被复制 —— 引用被复制，而该对象自身并没有被复制。</strong></p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><br><span class="hljs-keyword">let</span> admin = user; <span class="hljs-comment">// 复制引用</span><br></code></pre></td></tr></table></figure><p>现在我们有了两个变量，它们保存的都是对同一个对象的引用，但是其实都是同一个对象：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208112323894.png" alt="image-20220811232300856" style="zoom:50%;" /></p><p>我们可以通过其中任意一个变量来访问该对象并修改它的内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> &#125;;<br><br><span class="hljs-keyword">let</span> admin = user;<br><br>admin.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Pete&#x27;</span>; <span class="hljs-comment">// 通过 &quot;admin&quot; 引用来修改</span><br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;Pete&#x27;，修改能通过 &quot;user&quot; 引用看到</span><br></code></pre></td></tr></table></figure><h3 id="通过引用来比较"><a href="#通过引用来比较" class="headerlink" title="通过引用来比较"></a><a href="https://zh.javascript.info/object-copy#tong-guo-yin-yong-lai-bi-jiao">通过引用来比较</a></h3><p>用<code>==</code>进行比较时，仅当两个变量指向同一个对象时，两者才相等。</p><p>例如，这里 <code>a</code> 和 <code>b</code> 两个变量都引用同一个对象，所以它们相等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = &#123;&#125;;<br><span class="hljs-keyword">let</span> b = a; <span class="hljs-comment">// 复制引用</span><br><br><span class="hljs-title function_">alert</span>( a == b ); <span class="hljs-comment">// true，都引用同一对象</span><br><span class="hljs-title function_">alert</span>( a === b ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>而这里两个独立的对象则并不相等，即使它们看起来很像（都为空）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = &#123;&#125;;<br><span class="hljs-keyword">let</span> b = &#123;&#125;; <span class="hljs-comment">// 两个独立的对象</span><br><br><span class="hljs-title function_">alert</span>( a == b ); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="克隆与合并Object-assign"><a href="#克隆与合并Object-assign" class="headerlink" title="克隆与合并Object.assign"></a><a href="https://zh.javascript.info/object-copy#cloning-and-merging-object-assign">克隆与合并Object.assign</a></h3><p>如果想要复制一个对象，那该怎么做呢？</p><p>我们可以创建一个新对象，通过遍历已有对象的属性，并在原始类型值的层面复制它们，以实现对已有对象结构的复制。</p><p>就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> clone = &#123;&#125;; <span class="hljs-comment">// 新的空对象</span><br><br><span class="hljs-comment">// 将 user 中所有的属性拷贝到其中</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) &#123;<br>  clone[key] = user[key];<br>&#125;<br><br><span class="hljs-comment">// 现在 clone 是带有相同内容的完全独立的对象</span><br>clone.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Pete&quot;</span>; <span class="hljs-comment">// 改变了其中的数据</span><br><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">name</span> ); <span class="hljs-comment">// 原来的对象中的 name 属性依然是 John</span><br></code></pre></td></tr></table></figure><p>我们也可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 方法来达成同样的效果。</p><p>语法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, [src1, src2, src3...])<br></code></pre></td></tr></table></figure><ul><li>第一个参数 <code>dest</code> 是指目标对象。</li><li>更后面的参数 <code>src1, ..., srcN</code>（可按需传递多个参数）是源对象。</li><li>该方法将所有源对象的属性拷贝到目标对象 <code>dest</code> 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中。</li><li>调用结果返回 <code>dest</code>。</li></ul><p>例如，我们可以用它来合并多个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><br><span class="hljs-keyword">let</span> permissions1 = &#123; <span class="hljs-attr">canView</span>: <span class="hljs-literal">true</span> &#125;;<br><span class="hljs-keyword">let</span> permissions2 = &#123; <span class="hljs-attr">canEdit</span>: <span class="hljs-literal">true</span> &#125;;<br><br><span class="hljs-comment">// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(user, permissions1, permissions2);<br><br><span class="hljs-comment">// 现在 user = &#123; name: &quot;John&quot;, canView: true, canEdit: true &#125;</span><br></code></pre></td></tr></table></figure><p>如果被拷贝的属性的属性名已经存在，那么它会被覆盖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(user, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Pete&quot;</span> &#125;);<br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// 现在 user = &#123; name: &quot;Pete&quot; &#125;</span><br></code></pre></td></tr></table></figure><p>我们也可以用 <code>Object.assign</code> 代替 <code>for..in</code> 循环来进行简单克隆：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, user);<br></code></pre></td></tr></table></figure><p>它将 <code>user</code> 中的所有属性拷贝到了一个空对象中，并返回这个新的对象。</p><p>还有其他克隆对象的方法，例如使用 <a href="https://zh.javascript.info/rest-parameters-spread">spread 语法</a> <code>clone = &#123;...user&#125;</code>，在后面的章节中我们会讲到。</p><h2 id="深层克隆"><a href="#深层克隆" class="headerlink" title="深层克隆"></a><a href="https://zh.javascript.info/object-copy#shen-ceng-ke-long">深层克隆</a></h2><p>到现在为止，我们都假设 <code>user</code> 的所有属性均为原始类型。但属性可以是对其他对象的引用。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">sizes</span>: &#123;<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">182</span>,<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">50</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">sizes</span>.<span class="hljs-property">height</span> ); <span class="hljs-comment">// 182</span><br></code></pre></td></tr></table></figure><p>现在这样拷贝 <code>clone.sizes = user.sizes</code> 已经不足够了，因为 <code>user.sizes</code> 是个对象，它会以引用形式被拷贝。因此 <code>clone</code> 和 <code>user</code> 会共用一个 sizes：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">sizes</span>: &#123;<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">182</span>,<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">50</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, user);<br><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">sizes</span> === clone.<span class="hljs-property">sizes</span> ); <span class="hljs-comment">// true，同一个对象</span><br><br><span class="hljs-comment">// user 和 clone 分享同一个 sizes</span><br>user.<span class="hljs-property">sizes</span>.<span class="hljs-property">width</span>++;       <span class="hljs-comment">// 通过其中一个改变属性值</span><br><span class="hljs-title function_">alert</span>(clone.<span class="hljs-property">sizes</span>.<span class="hljs-property">width</span>); <span class="hljs-comment">// 51，能从另外一个获取到变更后的结果</span><br></code></pre></td></tr></table></figure><p>为了解决这个问题，并让 <code>user</code> 和 <code>clone</code> 成为两个真正独立的对象，我们应该使用一个拷贝循环来检查 <code>user[key]</code> 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的“深拷贝”。</p><p>我们可以使用递归来实现它。或者为了不重复造轮子，采用现有的实现，例如 <a href="https://lodash.com/">lodash</a> 库的 <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>。</p><p><strong>使用 const 声明的对象也是可以被修改的</strong></p><p>通过引用存储对象的一个很大的副作用是声明为 <code>const</code> 的对象 <strong>可以</strong> 被修改。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br><br>user.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Pete&quot;</span>; <span class="hljs-comment">// (*)</span><br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// Pete</span><br></code></pre></td></tr></table></figure><p>看起来 <code>(*)</code> 行的代码会触发一个错误，但实际并没有。<code>user</code> 的值是一个常量，它必须始终引用同一个对象，但该对象的属性可以被自由修改。</p><p>换句话说，只有当我们尝试将 <code>user=...</code> 作为一个整体进行赋值时，<code>const user</code> 才会报错。</p><p>也就是说，如果我们真的需要创建常量对象属性，也是可以的，但使用的是完全不同的方法。我们将在 <a href="https://zh.javascript.info/property-descriptors">属性标志和属性描述符</a> 一章中学习它。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/object-copy#zong-jie">总结</a></h2><p>对象通过引用被赋值和拷贝。换句话说，一个变量存储的不是“对象的值”，而是一个对值的“引用”（内存地址）。因此，拷贝此类变量或将其作为函数参数传递时，所拷贝的是引用，而不是对象本身。</p><p>所有通过被拷贝的引用的操作（如添加、删除属性）都作用在同一个对象上。</p><p>为了创建“真正的拷贝”（一个克隆），我们可以使用 <code>Object.assign</code> 来做所谓的“浅拷贝”（嵌套对象被通过引用进行拷贝）或者使用“深拷贝”函数，例如 <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 02</title>
    <link href="/2022/08/05/02/"/>
    <url>/2022/08/05/02/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="JavaScript-基础-第二天"><a href="#JavaScript-基础-第二天" class="headerlink" title="JavaScript 基础 - 第二天"></a>JavaScript 基础 - 第二天</h1><h2 id="一、运算符"><a href="#一、运算符" class="headerlink" title="一、运算符"></a>一、运算符</h2><h3 id="1-1-算术运算符"><a href="#1-1-算术运算符" class="headerlink" title="1.1 算术运算符"></a>1.1 算术运算符</h3><p>加+、减-、乘*、除/、取余%</p><p>优先级：先乘除后加减，括号最先</p><h3 id="1-2-赋值运算符"><a href="#1-2-赋值运算符" class="headerlink" title="1.2 赋值运算符"></a>1.2 赋值运算符</h3><p>=、+=、-=、*=、/=、%=</p><p>将等号右边的值赋予给左边, 要求左边必须是一个容器</p><h3 id="1-3-一元运算符"><a href="#1-3-一元运算符" class="headerlink" title="1.3 一元运算符"></a>1.3 一元运算符</h3><p>自增++、自减—</p><p>经常用于计数来使用。 比如进行10次操作，用它来计算进行了多少次了</p><p>前置和后置单独使用（自己独占一行）没有区别，如果参与运算就有区别：</p><ul><li>前置自增：先自加再使用(记忆口诀:++在前 先加)</li><li>后置自增：先使用再自加(记忆口诀:++在后 后加)</li><li>后置自增由于其内存占用较小问题使用相对较多</li></ul><h3 id="1-4-比较运算符"><a href="#1-4-比较运算符" class="headerlink" title="1.4 比较运算符"></a>1.4 比较运算符</h3><ul><li><code>&gt;、&lt;、&gt;=、&lt;=</code> 这四个比较基础</li><li><code>==</code>左右两边是否相等</li><li><code>===</code>左右两边是否类型和值都相等</li><li><code>！==</code>左右两边是否不全等</li></ul><p>比较结果为boolean类型，即只会得到<code>true</code>和<code>false</code></p><p>注意：</p><ul><li>字符串比较，是比较的字符对应的ASCII码 <ul><li>从左往右依次比较</li><li>如果第一位一样再比较第二位，以此类推  比较的少，了解即可</li></ul></li><li>NaN不等于任何值，包括它本身</li><li>尽量不要比较小数，因为小数有精度问题</li><li>不同类型之间比较会发生隐式转换<ul><li>数据会隐式转换转成number类型再比较</li><li>所以开发中，如果进行准确的比较我们更喜欢用<code>===</code>或者<code>!==</code></li></ul></li></ul><h3 id="1-5-逻辑运算符"><a href="#1-5-逻辑运算符" class="headerlink" title="1.5 逻辑运算符"></a>1.5 逻辑运算符</h3><p>逻辑运算符用来解决多重条件判断</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208051453701.png" alt="image-20220805145300667"></p><ul><li>短路：只存在于 &amp;&amp; 和 || 中，当满足一定条件会让右边代码不执行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208051454560.png" alt="image-20220805145455530"></p><h2 id="二、语句"><a href="#二、语句" class="headerlink" title="二、语句"></a>二、<strong>语句</strong></h2><h3 id="2-1-表达式和语句"><a href="#2-1-表达式和语句" class="headerlink" title="2.1 表达式和语句"></a>2.1 表达式和语句</h3><ul><li><p>区别:</p><ul><li>表达式用来计算出一个值，但语句用来自行以使某件事发生(做什么事)</li><li>表达式： 3 + 4</li><li>语句： alert() 弹出对话框 </li></ul><p>其实某些情况，也可以把表达式理解为语句，因为它是在计算结果，也是做事</p></li></ul><h3 id="2-2-分支语句"><a href="#2-2-分支语句" class="headerlink" title="2.2 分支语句"></a>2.2 分支语句</h3><p>分支语句可以让我们有选择性的执行想要的代码，分支语句包含:</p><ul><li>If分支语句</li><li>三元运算符</li><li>switch 语句</li></ul><p><strong>if语句：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">if(条件 1)&#123;<br>代码 1<br>&#125;else if(条件 2)&#123;<br>代码 2<br>&#125;else if(条件 3)&#123;<br>代码 3<br>&#125;else&#123;<br>代码 n<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>三元运算符：</strong>一般用来取值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">条件？为true执行的代码:为false执行的代码<br></code></pre></td></tr></table></figure><p><strong>switch语句：</strong></p><ul><li>找到跟小括号里数据<strong>全等</strong>的case值，并执行里面对应的代码</li><li>若没有全等 === 的则执行default里的代码</li><li>例：数据若跟值2全等，则执行代码2</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html">switch(data)&#123;<br>case value1:<br>code 1<br>break<br>case value2:<br>code 2<br>break<br>case value3:<br>code 3<br>break<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>switch case语句一般用于等值判断,不适合于区间判断</li><li>switch case一般需要配合break关键字使用 没有break会造成case穿透</li></ol><h3 id="2-3-循环语句"><a href="#2-3-循环语句" class="headerlink" title="2.3 循环语句"></a>2.3 循环语句</h3><p>浏览器打开调试界面，进行<strong>断点调试</strong>：</p><ol><li>按F12打开开发者工具 </li><li>点到sources一栏</li><li>选择代码文件</li></ol><p>断点：在某句代码上加的标记就叫断点，当程序执行到这句有标记的代码时会暂停下来</p><p><strong>while循环：</strong></p><p>跟if语句很像，都要满足小括号里的条件为true才会进入执行代码，当条件为false时跳出循环。</p><p>循环的本质就是以某个变量为起始值，然后不断产生变化量，慢慢靠近终止条件的过程。 所以，循环需要具备三要素:</p><ol><li>变量起始值</li><li>终止条件(没有终止条件，循环会一直执行，造成死循环)</li><li>变量变化量(用自增或者自减)</li></ol><p><strong>for循环：</strong></p><p>把声明起始值、循环条件、变化值写到一起，让人一目了然</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">for(声明记录循环次数的变量；循环条件；变化值)&#123;<br>循环体<br>&#125;<br></code></pre></td></tr></table></figure><p>当如果明确了循环的次数的时候推荐使用for循环</p><p>当不明确循环的次数的时候推荐使用while循环</p><p><strong>循环结束</strong>:</p><ul><li>continue：结束本次循环，继续下次循环</li><li>break：跳出所在的循环</li></ul><p><strong>for循环嵌套：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">for(外部声明记录循环次数的变量；循环条件；变化值)&#123;<br>for(内部声明记录循环次数的变量；循环条件；变化值)&#123;<br>循环体<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h3><h3 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3.1 基本语法"></a>3.1 基本语法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">let 数组名 = [data1,data2,...,data n]<br></code></pre></td></tr></table></figure><ul><li>数组是按顺序保存，所以每个数据都有自己的编号</li><li>计算机中的编号从0开始</li><li>在数组中，数据的编号也叫<strong>索引或下标</strong></li><li>数组可以存储任意类型的数据</li></ul><p><strong>取值语法：</strong></p><ul><li>通过下标取数据</li><li>取出来是什么类型的，就根据这种类型特点来访问</li></ul><p><strong>遍历：</strong></p><p>用循环把数组中每个元素都访问到，一般会用for循环遍历</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> names = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]</span><br><span class="language-javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;names.<span class="hljs-property">length</span>;i++)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(names[i])</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>操作数组：</strong></p><p><strong>增：</strong></p><p><strong>数组.push()</strong>：将一个或多个元素添加到数组的末尾，并返回该数组的新长度 </p><p><strong>arr.unshift(新增的内容)</strong> ：将一个或多个元素添加到数组的<strong>开头</strong>，并返回该数组的新长度</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> arr =  [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">77</span>, <span class="hljs-number">0</span>, <span class="hljs-number">52</span>, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>, <span class="hljs-number">7</span>]</span><br><span class="language-javascript">  arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">17</span>)</span><br><span class="language-javascript">  arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">43</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>)</span><br><span class="language-javascript">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">if</span>(arr[i]&gt;<span class="hljs-number">10</span>)&#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(arr[i])</span><br><span class="language-javascript">          <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;\n&quot;</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>删：</strong></p><p>数组. pop() 方法从数组中删除最后一个元素，并返回该元素的值</p><p>数组. shift() 方法从数组中删除第一个元素，并返回该元素的值</p><p>数组. splice() 方法 删除指定元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">arr.splice(2,4)<br>//第一个参数为要删除的起始位置，第二个参数为要删除的元素个数，可以缺省，会默认删到最后<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> arr =  [<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">77</span>, <span class="hljs-number">30</span>, <span class="hljs-number">52</span>, <span class="hljs-number">50</span>, <span class="hljs-number">25</span>, <span class="hljs-number">7</span>]</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> min=arr[<span class="hljs-number">0</span>]</span><br><span class="language-javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=i;j&lt;arr.<span class="hljs-property">length</span>;j++)&#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span>(arr[j]&gt;arr[i])&#123;</span><br><span class="language-javascript">                min=arr[i]</span><br><span class="language-javascript">                arr[i]=arr[j]</span><br><span class="language-javascript">                arr[j]=min</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>利用js渲染画面案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 1. 利用循环弹出四次输入框， 会得到4个数据，放到数组里面</span></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> arr = []</span><br><span class="language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span>; i++) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// prompt(`请输入第 $&#123;i&#125; 季度的数据`)  ===  123</span></span><br><span class="language-javascript">        arr.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">prompt</span>(<span class="hljs-string">`请输入第 <span class="hljs-subst">$&#123;i&#125;</span> 季度的数据`</span>))</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(arr)</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 注意我们渲染循环的是柱子 </span></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`&lt;div class=&quot;box&quot;&gt;`</span>)</span><br><span class="language-javascript">    <span class="hljs-comment">// 循环4个柱子</span></span><br><span class="language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`</span></span><br><span class="hljs-string"><span class="language-javascript">             &lt;div style=&quot;height: <span class="hljs-subst">$&#123;arr[i]&#125;</span>px;&quot;&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">                 &lt;span&gt;<span class="hljs-subst">$&#123;arr[i]&#125;</span>&lt;/span&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">                &lt;h4&gt;第<span class="hljs-subst">$&#123;i + <span class="hljs-number">1</span>&#125;</span>季度&lt;/h4&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">            &lt;/div&gt;</span></span><br><span class="hljs-string"><span class="language-javascript">        `</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`&lt;/div&gt;`</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在<code>script</code>标签里把css语句写到函数参数里，用<code>$&#123;&#125;</code>把括号外的变量包裹起来。</p><h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><p><strong>函数:</strong></p><p>function，是被设计为执行特定任务的代码块，可以实现代码复用，提高开发效率</p><p><strong>声明语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">function 函数名()&#123;<br>函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">mulTable</span>(<span class="hljs-params">a,b</span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span>x<span class="hljs-subst">$&#123;b&#125;</span>=<span class="hljs-subst">$&#123;a*b&#125;</span>`</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)&#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">mulTable</span>(i,j)</span><br><span class="language-javascript">            <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;\n&quot;</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>函数名命名规范：</strong></p><ul><li>和变量命名基本一致</li><li>尽量小驼峰式命名法</li><li>前缀应该为动词</li><li>命名建议:常用动词约定</li></ul><div class="table-container"><table><thead><tr><th>动词</th><th>含义</th></tr></thead><tbody><tr><td>can</td><td>判断是否可执行某个动作，eg.canShow( )</td></tr><tr><td>has</td><td>判断是否含有某个值，eg.hasShot( )</td></tr><tr><td>is</td><td>判断是否为某个值，eg.isText( )</td></tr><tr><td>get</td><td>获取某个值，eg.getName( )</td></tr><tr><td>set</td><td>设置某个值</td></tr><tr><td>Load</td><td>加载某些数据，eg.loadTable( )</td></tr></tbody></table></div><p><strong>函数传参：</strong></p><p>调用语法：<code>函数名(传递的参数列表)</code></p><p>调用函数时，需要传入几个数据就写几个，用逗号隔开</p><p>形参和实参：</p><ul><li>形参：声明函数时括号里的叫形参</li><li>实参：调用函数时括号里的叫实参</li><li>开发中尽量保持形参和实参个数一致</li><li>两个相同的函数后面的会覆盖前面的函数</li><li>在Javascript中实参的个数和形参的个数可以不一致<ul><li>如果形参过多 会自动填上undefined (了解即可)</li><li>如果实参过多 那么多余的实参会被忽略 (函数内部有一个arguments,以伪数组的形式装着所有的实参)</li></ul></li></ul><p>小技巧：可以通过符号<code>||</code>来指定参数默认值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x,y</span>)&#123;</span><br><span class="language-javascript">        x=x||<span class="hljs-number">0</span></span><br><span class="language-javascript">        y=y||<span class="hljs-number">0</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(x,y)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-title function_">fn</span>()</span><br><span class="language-javascript">    <span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出：0    0</p><pre><code class="hljs">       1    2</code></pre><p><strong>函数返回值：</strong></p><p>当函数需要返回数据出去时，用return关键字</p><p>注意:</p><ul><li>函数内部只能出现 1 次 return，并且 return 后面代码不会再被执行，所以 return 后面的数据不要换行写 </li><li>return会立即结束当前函数</li><li>函数可以没有 return，这种情况函数默认返回值为 undefined</li></ul><p><strong>作用域：</strong></p><p>全局作用域：作用于所有代码执行的环境(整个 <code>script</code> 标签内部)或者一个独立的 js 文件</p><p>局部作用域：作用于函数内的代码环境</p><p>块级作用域：由 { } 包括，只在{ }内有效，例如if语句和for语句里面的{ }等</p><p><strong>变量的作用域：</strong></p><p>全局变量：函数外部用<code>let</code>定义的变量，在任何区域都可以访问和修改</p><p>局部变量：函数内部用<code>let</code>的变量，局部变量只能在当前函数内部访问和修改</p><p>块级变量：{ } 内部的<code>let</code>变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问</p><blockquote><p>注意：</p><ol><li>如果函数内部或者块级作用域内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐 </li><li>但是有一种情况，函数内部的形参可以看做是局部变量。</li></ol></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        name=<span class="hljs-string">&#x27;xmm&#x27;</span></span><br><span class="language-javascript">        num=<span class="hljs-number">100</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;Hi!&#x27;</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>\n`</span>)</span><br><span class="language-javascript">    <span class="hljs-title function_">sayHi</span>()</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出：xmm Hi！</p><p><strong>作用域链：</strong></p><p>采取<strong>就近原则</strong>的方式来查找变量最终的值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span> </span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;22&#x27;</span></span><br><span class="language-javascript">        <span class="hljs-title function_">fn2</span>()</span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> a = <span class="hljs-number">3</span></span><br><span class="language-javascript">            <span class="hljs-title function_">fn3</span>()</span><br><span class="language-javascript">            <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn3</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">let</span> a=<span class="hljs-number">4</span></span><br><span class="language-javascript">                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(a)</span><br><span class="language-javascript">                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(b)</span><br><span class="language-javascript">            &#125; </span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125; </span><br><span class="language-javascript">    <span class="hljs-title function_">fn1</span>()   </span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出为：4 22</p><p><strong>匿名函数：</strong></p><p>将匿名函数赋值给一个变量，并且通过变量名称进行调用</p><p>语法：<code>let fn = function()&#123;&#125;</code></p><p>调用：<code>fn()</code></p><p>立即执行函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;123&quot;</span>)&#125;)()； <span class="hljs-comment">// 方法1 </span></span><br><span class="language-javascript">    (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;456&quot;</span>)&#125;())； <span class="hljs-comment">// 方法2</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意: 多个立即执行函数要用<code>;</code> 隔开，要不然会报错</p><ul><li>立即执行函数可以防止变量污染</li><li>立即执行函数无需另外调用，立即执行</li><li>多个立即执行函数之间用分号隔开</li></ul><p>案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-keyword">function</span> <span class="hljs-title function_">switchSecond</span>(<span class="hljs-params">i</span>)&#123;</span><br><span class="language-javascript">       <span class="hljs-keyword">let</span> hour=i/<span class="hljs-number">3600</span></span><br><span class="language-javascript">       <span class="hljs-keyword">let</span> min=i/<span class="hljs-number">60</span>%<span class="hljs-number">60</span></span><br><span class="language-javascript">       <span class="hljs-keyword">let</span> sec=i%<span class="hljs-number">60</span></span><br><span class="language-javascript">       <span class="hljs-keyword">let</span> args=[<span class="hljs-built_in">parseInt</span>(hour),<span class="hljs-built_in">parseInt</span>(min),<span class="hljs-built_in">parseInt</span>(sec)]</span><br><span class="language-javascript">       <span class="hljs-keyword">return</span> args</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">   <span class="hljs-keyword">let</span> sec = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入想转换的秒&quot;</span>)</span><br><span class="language-javascript">   <span class="hljs-keyword">let</span> args=<span class="hljs-title function_">switchSecond</span>(sec)</span><br><span class="language-javascript">   <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`&lt;div&gt;把秒数转换成几小时几分零几秒&lt;br&gt;&lt;span&gt;<span class="hljs-subst">$&#123;sec&#125;</span>秒转换后是<span class="hljs-subst">$&#123;args[<span class="hljs-number">0</span>]&#125;</span>小时<span class="hljs-subst">$&#123;args[<span class="hljs-number">1</span>]&#125;</span>分钟<span class="hljs-subst">$&#123;args[<span class="hljs-number">2</span>]&#125;</span>秒&lt;span&gt;&lt;div&gt;`</span>)     </span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 01</title>
    <link href="/2022/08/03/JavaScript/"/>
    <url>/2022/08/03/JavaScript/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="JavaScript-基础-第一天"><a href="#JavaScript-基础-第一天" class="headerlink" title="JavaScript 基础 - 第一天"></a>JavaScript 基础 - 第一天</h2><h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><blockquote><p>JavaScript是一门编程语言，HTML和CSS是标记语言。</p></blockquote><p>编程语言分为三大类：机器语言，汇编语言和高级语言。</p><ul><li>机器语言是计算机可以直接识别的语言，汇编语言和机器语言实质上是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，容易识别和记忆。</li><li>高级语言包括了很多编程语言，常用的有C语言、C++、Java、C#、Js等。</li></ul><p>标记语言不用于向计算机发出指令，常用于格式化和链接。标记语言的存在是用来被读取的，他是被动的。</p><blockquote><p>⌘+B    打开/关闭导航栏</p><p>⌥+⇧+光标选中    多行选择</p></blockquote><p><strong>浏览器执行JS：</strong></p><p>浏览器分成两部分：渲染引擎和JS引擎</p><ul><li>渲染引擎：用来解析HTML和CSS，俗称内核。</li><li>JS引擎：也叫JS解释器，用来读取网页中的JS代码，对其处理后运行。</li></ul><p>浏览器本身并不会执行JS代码，而是由JS引擎转化为二进制的机器语言，由计算机来运行。</p><p><strong>JS组成：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208051409617.png" alt="image-20220803182235562" style="zoom:50%;" /></p><ul><li><p>ECMAScript：规定了js基础语法核心知识。</p><ul><li>比如：变量、分支语句、循环语句、对象等等</li></ul></li><li><p>Web APIs :</p><ul><li>DOM 操作文档，比如对页面元素进行移动、大小、添加删除等操作</li><li>BOM 操作浏览器，比如页面弹窗，检测窗口宽度、存储数据到浏览器等等</li></ul></li></ul><p><strong>JS作用：</strong></p><ul><li>网页特效 (监听用户的一些行为让网页作出对应的反馈) </li><li>表单验证 (针对表单数据的合法性进行判断)</li><li>数据交互 (获取后台的数据, 渲染到前端)</li><li>服务端编程 (node.js)</li></ul><p><strong>JS是一门解释性语言：</strong></p><p>计算机无法直接理解除了机器语言以外的语言，所以需要把程序语言翻译成机器语言的工具，即翻译器。</p><ul><li>翻译器翻译的方式有两种：一个是编译，另外一个是解释。</li><li>两种方式之间的区别在于翻译的时间点不用</li><li>编译器是在代码执行之前进行编译，生成中间代码文件</li><li>解释器是在运行时进行即时解释，边解释边执行</li></ul><h4 id="1-1-引入方式"><a href="#1-1-引入方式" class="headerlink" title="1.1 引入方式"></a>1.1 引入方式</h4><p>JavaScript有三种引入方式，类似CSS：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208031829931.png" alt="image-20220803182955896"></p><p><strong>行内形式</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;小明明&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;真棒&#x27;)&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>可以将单行或少量JS代码写在HTML标签的事件属性中，如:onclick</li><li>注意但双引号的使用：在HTML中推荐使用双引号，JS中推荐使用单引号</li><li>后面vue框架会用这种模式</li></ul><h5 id="内嵌形式"><a href="#内嵌形式" class="headerlink" title="内嵌形式"></a>内嵌形式</h5><p>直接写在html文件里，用<code>script</code>标签包住 </p><p><strong>规范</strong>：<code>script</code>标签写在<code>body</code>上面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 内联形式：通过 script 标签包裹 JavaScript 代码 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello,JavaScript！&#x27;</span>);</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>我们将 <code>&lt;script&gt;</code>放在HTML文件的底部附近的原因是浏览器会按照代码在文件中的顺序加载 HTML。 </p><p>如果先加载的 JavaScript 期望修改其下方的 HTML，那么它可能由于 HTML 尚未被加载而失效。 因此，将 JavaScript 代码放在 HTML页面的底部附近通常是最好的策略。</p></blockquote><h5 id="外部形式"><a href="#外部形式" class="headerlink" title="外部形式"></a>外部形式</h5><p>一般将 JavaScript 代码写在独立的以 .js 结尾的文件中，然后通过 <code>script</code> 标签的 <code>src</code> 属性引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// demo.js</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;Hello,JavaScript！&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;demo.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果 <code>script</code> 标签使用 <code>src</code> 属性引入了某 <code>.js</code> 文件，那么标签的代码会被忽略，如下代码所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 外部形式：通过 script 的 src 属性引入独立的 .js 文件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;demo.js&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 此处的代码会被忽略掉！！！！</span></span><br><span class="language-javascript">  <span class="hljs-title function_">alert</span>(<span class="hljs-number">666</span>);  </span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>外部JavaScript会使代码更加有序，更易于复用，且没有了脚本的混合，HTML 也会更加易读，因此这是个好的习惯。</p></blockquote><h4 id="1-2-注释和结束符"><a href="#1-2-注释和结束符" class="headerlink" title="1.2 注释和结束符"></a>1.2 注释和结束符</h4><h5 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h5><p>使用 <code>//</code> 注释单行代码</p><h5 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h5><p>使用 <code>/* */</code> 注释多行代码</p><p><strong>注：编辑器中单行注释的快捷键为 <code>ctrl + /</code></strong>，多行注释为<code>shift+alt+A</code></p><h5 id="结束符"><a href="#结束符" class="headerlink" title="结束符"></a>结束符</h5><p>在 JavaScript 中 <code>;</code> 代表一段代码的结束，多数情况下可以省略 <code>;</code> 使用回车（enter）替代。</p><p>JavaScript 跟 HTML 和 CSS 一样，会忽略【一些】空白符，但是换行符（回车）会被识别成结束符 <code>;</code>，因此在实际开发中有许多人主张书写 JavaScript 代码时省略结束符 <code>;</code></p><p><strong>但为了风格统一，要写结束符就每句都写，要么每句都不写(按照团队要求)</strong></p><h4 id="1-3-输入和输出"><a href="#1-3-输入和输出" class="headerlink" title="1.3 输入和输出"></a>1.3 输入和输出</h4><p>输出和输入也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程。</p><h5 id="输出语法"><a href="#输出语法" class="headerlink" title="输出语法"></a>输出语法</h5><p>JavaScript 可以接收用户的输入，然后再将输入的结果输出：</p><ul><li><code>alert()</code>浏览器弹出警示框</li><li><code>document.wirte()</code>浏览器页面显示，如果输出的内容写的是标签，也会被解析成网页元素</li><li><code>console.log()</code>控制台输出语法，程序员调试使用</li></ul><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>显示一个对话框，向 <code>prompt()</code> 输入任意内容显示在对话框中，用来提示用户输入文字：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span><br><span class="language-javascript">    <span class="hljs-comment">// 1. 输入的任意数字，都会以弹窗形式展示</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;要输出的内容&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;要输出的内容&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 2. 以弹窗形式提示用户输入姓名，注意这里的文字使用英文的引号</span></span><br><span class="language-javascript">    <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入您的姓名:&#x27;</span>);</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h3><p>变量是程序在内存中申请的一块用来存放数据的空间。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// x 符号代表了 5 这个数值</span></span><br><span class="language-javascript">  x = <span class="hljs-number">5</span>;</span><br><span class="language-javascript">  <span class="hljs-comment">// y 符号代表了 6 这个数值</span></span><br><span class="language-javascript">  y = <span class="hljs-number">6</span>;</span><br><span class="language-javascript">    </span><br><span class="language-javascript">  <span class="hljs-comment">//举例： 在 JavaScript 中使用变量可以将某个数据（数值）记录下来！</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 将用户输入的内容保存在 num 这个变量（容器）中</span></span><br><span class="language-javascript">  num = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入一数字!&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 通过 num 变量（容器）将用户输入的内容输出出来</span></span><br><span class="language-javascript">  <span class="hljs-title function_">alert</span>(num);</span><br><span class="language-javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(num);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-声明和赋值"><a href="#2-1-声明和赋值" class="headerlink" title="2.1 声明和赋值"></a>2.1 声明和赋值</h4><p>要想使用变量，首先需要创建变量(专业说法: 声明变量)</p><h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><p>声明(定义)变量有两部分构成：声明关键字<code>let</code>、变量名（标识）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span><br><span class="language-javascript">    <span class="hljs-comment">// let 变量名</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 声明(定义)变量有两部分构成：声明关键字、变量名（标识）</span></span><br><span class="language-javascript">    <span class="hljs-comment">// let 即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语</span></span><br><span class="language-javascript">    <span class="hljs-comment">// age 即变量的名称，也叫标识符</span></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> age;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>let</code> 和 <code>var</code> (variable变量的意思)都是 JavaScript 中的声明变量的关键字，使用关键字声明变量后，计算机会自动为变量分配内存空间，使用变量名来对内存进行访问，推荐使用 <code>let</code> 声明变量！！！</p><blockquote><p>注意：let 不允许多次声明一个变量。</p><p>​            未赋值变量输出为underfined</p><p>​            未声明但赋值的变量依然可以使用</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208042043742.png" alt="image-20220804204345709"></p><h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><p>声明（定义）变量相当于创造了一个空的“容器”，通过赋值向这个容器中添加数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span><br><span class="language-javascript">  <span class="hljs-comment">// 声明(定义)变量有两部分构成：声明关键字、变量名（标识）</span></span><br><span class="language-javascript">  <span class="hljs-comment">// let 即关键字，所谓关键字是系统提供的专门用来声明（定义）变量的词语</span></span><br><span class="language-javascript">  <span class="hljs-comment">// age 即变量的名称，也叫标识符</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> age;</span><br><span class="language-javascript">  <span class="hljs-comment">// 赋值，将 18 这个数据存入了 age 这个“容器”中</span></span><br><span class="language-javascript">  age = <span class="hljs-number">18</span>;</span><br><span class="language-javascript">  <span class="hljs-comment">// 这样 age 的值就成了 18</span></span><br><span class="language-javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(age);</span><br><span class="language-javascript">  </span><br><span class="language-javascript">  <span class="hljs-comment">// 也可以声明和赋值同时进行</span></span><br><span class="language-javascript">  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello world!&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-title function_">alert</span>(str);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-2-关键字"><a href="#2-2-关键字" class="headerlink" title="2.2 关键字"></a>2.2 关键字</h4><p>JavaScript 使用专门的关键字 <code>let</code> 和 <code>var</code> 来声明（定义）变量，在使用时需要注意一些细节：</p><p>以下是使用 <code>let</code> 时的注意事项：</p><ol><li>允许声明和赋值同时进行</li><li>不允许重复声明</li><li>允许同时声明多个变量并赋值</li><li>JavaScript 中内置的一些关键字不能被当做变量名</li></ol><p>以下是使用 <code>var</code> 时的注意事项：</p><ol><li>允许声明和赋值同时进行</li><li>允许重复声明</li><li>允许同时声明多个变量并赋值</li></ol><p>大部分情况使用 <code>let</code> 和 <code>var</code> 区别不大，但是 <code>let</code> 相较 <code>var</code> 更严谨，因此推荐使用 <code>let</code>，后期会更进一步介绍二者间的区别。</p><h4 id="2-3-变量名命名规则"><a href="#2-3-变量名命名规则" class="headerlink" title="2.3 变量名命名规则"></a>2.3 变量名命名规则</h4><p>关于变量的名称（标识符）有一系列的规则需要遵守：</p><ol><li>只能是字母、数字、下划线、$，且不能以数字开头</li><li><strong>字母区分大小写</strong>，如 Age 和 age 是不同的变量</li><li>JavaScript 内部已占用用单词（关键字或保留字）不允许使用</li><li>尽量保证变量具有一定的语义，见字知义，遵守小驼峰命名法</li></ol><p>注：所谓关键字是指 JavaScript 内部使用的词语，如 <code>let</code> 和<code>var</code>，保留字是指 JavaScript 内部目前没有使用的词语，但是将来可能会使用词语。</p><h4 id="2-4-变量扩展——数组"><a href="#2-4-变量扩展——数组" class="headerlink" title="2.4 变量扩展——数组"></a>2.4 变量扩展——数组</h4><p>数组(Array)可以按顺序保存多个数据</p><ul><li>数组是按顺序保存，所以每个数据都有自己的编号</li><li>数组可以存储任意类型的数据</li></ul><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">let names = [&#x27;xm&#x27;,&#x27;ed&#x27;,&#x27;gfb&#x27;,fs]<br></code></pre></td></tr></table></figure><h3 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h3><p>给数据分类是为了更加充分和高效的利用内存，也更加方便程序员的使用数据。</p><p><strong>JavaScript是一种弱类型或者说动态语言</strong>，这意味着不用提前声明变量的类型，在程序运行过程中，类型会根据定义的值被JS引擎自动确定。</p><p>注：通过 typeof 关键字检测数据类型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span><br><span class="language-javascript">    <span class="hljs-comment">// 检测 1 是什么类型数据，结果为 number</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">1</span>);</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JS拥有动态类型，意味着变量的类型是可以改变的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">var x = 6;//x为数字<br>var x = &#x27;Bill&#x27;//x为字符串<br></code></pre></td></tr></table></figure><p>JS数据类型整体分为两大类：</p><ul><li>基本数据类型( Number , String , Boolean , Underfined , Null )</li><li>引用数据类型( object对象, function函数，array数组 )</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208042156147.png" alt="image-20220804215613113"></p><h4 id="3-1-数值类型"><a href="#3-1-数值类型" class="headerlink" title="3.1 数值类型"></a>3.1 数值类型</h4><p>即我们数学中学习到的数字，可以是整数、小数、正数、负数、特殊类型</p><p>JavaScript 中的数值类型与数学中的数字是一样的，分为正数、负数、小数等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> num1 = <span class="hljs-number">3.14</span></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> num2 = <span class="hljs-number">0xd3</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span>)<span class="hljs-comment">//最大数值</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span>)<span class="hljs-comment">//最小数值</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Infinity</span>)<span class="hljs-comment">//无穷大</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(-<span class="hljs-title class_">Infinity</span>)<span class="hljs-comment">//无穷小</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span>)<span class="hljs-comment">//Not A Number非数值，eg.&#x27;pink&#x27;-100</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>isNaN()这个方法用来判断是否为非数字，返回值为true或者false。</p></blockquote><h4 id="3-2-字符串类型"><a href="#3-2-字符串类型" class="headerlink" title="3.2 字符串类型"></a>3.2 字符串类型</h4><p>通过单引号（ <code>&#39;&#39;</code>） 、双引号（ <code>&quot;&quot;</code>）或反引号包裹的数据都叫字符串，单引号和双引号没有本质上的区别，推荐使用单引号。</p><p>注意事项：</p><ol><li><p>无论单引号或是双引号必须成对使用</p></li><li><p><strong>单引号/双引号可以互相嵌套，但是不以自已嵌套自已</strong>，要么外单内双，要么内单外双</p></li><li><p>必要时可以使用转义符 <code>\</code>，输出单引号或双引号</p><p>| 转义符 | 解释说明                 |<br>| ——— | ———————————— |<br>| <code>\n</code>   | 换行符，n是newline的意思 |<br>| <code>\\</code>   | \                        |<br>| <code>\&#39;</code>   | ‘’                       |<br>| <code>\&quot;</code>   | “”                       |<br>| <code>\t</code>   | Tab 缩进                 |<br>| <code>\b</code>   | Blank 空格               |</p></li></ol><p><strong>模版字符串：</strong></p><p>作用：</p><ol><li>拼接字符串和变量</li><li>如果不用它就要一直用“+”拼接，很麻烦</li></ol><p>语法：</p><ol><li>在英文输入模式下按键盘的tab键上方那个键(1左边那个键) </li><li>内容拼接变量时，用${}包住变量</li></ol><h4 id="3-3-布尔类型"><a href="#3-3-布尔类型" class="headerlink" title="3.3 布尔类型"></a>3.3 布尔类型</h4><p>布尔类型数据有两个固定的值 <code>true</code> 和 <code>false</code>，表示肯定的数据用 <code>true</code>，表示否定的数据用 <code>false</code>。</p><p>布尔类型和数字类型相加的时候，<code>true</code>的值为1，<code>false</code>的值为0。</p><h4 id="3-4-undefined"><a href="#3-4-undefined" class="headerlink" title="3.4 undefined"></a>3.4 undefined</h4><p>未定义是比较特殊的类型，只有一个值 undefined，只声明变量，不赋值的情况下，变量的默认值为 undefined，一般很少【直接】为某个变量赋值为 undefined。</p><p><strong>注：JavaScript 中变量的值决定了变量的数据类型。</strong></p><p><strong>工作中的使用场景:</strong></p><p>我们开发中经常声明一个变量，等待传送过来的数据。</p><p>如果我们不知道这个数据是否传递过来，此时我们可以通过检测这个变量是不是undefined，就判断用户是否有数据传递过来。</p><h4 id="3-5-null空类型"><a href="#3-5-null空类型" class="headerlink" title="3.5 null空类型"></a>3.5 null空类型</h4><p><strong>null</strong> <strong>和</strong> <strong>undefined</strong> <strong>区别:</strong></p><ol><li>undefined 表示没有赋值</li><li>null 表示赋值了，但是内容为空</li></ol><p><strong>null</strong> <strong>开发中的使用场景:</strong></p><ul><li>官方解释:把 null 作为尚未创建的对象</li><li>大白话: 将来有个变量里面存放的是一个对象，但是对象还没创建好，可以先给个null</li></ul><h3 id="四、类型转换"><a href="#四、类型转换" class="headerlink" title="四、类型转换"></a>四、类型转换</h3><blockquote><p>理解弱类型语言的特征，掌握显式类型转换的方法</p></blockquote><p>JavaScript是弱数据类型：JavaScript也不知道变量到底属于那种数据类型，只有赋值了才清楚。</p><p>坑：使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算。</p><p>在 JavaScript 中数据被分成了不同的类型，如数值、字符串、布尔值、undefined，在实际编程的过程中，不同数据类型之间存在着转换的关系。</p><h4 id="4-1-隐式转换"><a href="#4-1-隐式转换" class="headerlink" title="4.1 隐式转换"></a>4.1 隐式转换</h4><ul><li>+号两边只要有一个是字符串，都会把另外一个转成字符串</li><li>除了+以外的算术运算符 比如 - * / 等都会把数据转成数字类型</li><li>+号作为正号解析可以转换成Number</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202208050128502.png" alt="image-20220805012849467"></p><p>某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> </span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> num = <span class="hljs-number">13</span>; <span class="hljs-comment">// 数值</span></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> num2 = <span class="hljs-string">&#x27;2&#x27;</span>; <span class="hljs-comment">// 字符串</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 结果为 132</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 原因是将数值 num 转换成了字符串，相当于 &#x27;13&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 然后 + 将两个字符串拼接到了一起</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num + num2);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 结果为 11</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 原因是将字符串 num2 转换成了数值，相当于 2</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 然后数值 13 减去 数值 2</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num - num2);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> a = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入一个数字&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> b = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请再输入一个数字&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-title function_">alert</span>(a + b);</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注：数据类型的隐式转换是 JavaScript 的特征，后续学习中还会遇到，目前先需要理解什么是隐式转换。</p><h4 id="4-2显式转换"><a href="#4-2显式转换" class="headerlink" title="4.2显式转换"></a>4.2显式转换</h4><p>编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。</p><h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><p>通过 <code>Number</code> 显示转换成数值类型，当转换失败时结果为 <code>NaN</code>（Not a Number）即不是一个数字。 </p><ul><li>Number(数据) <ul><li>转成数字类型</li><li>如果字符串内容里有非数字，转换失败时结果为 NaN(Not a Number)即不是一个数字 </li><li>NaN也是number类型的数据，代表非数字</li></ul></li><li><p>parseInt(数据)</p><ul><li>只保留整数</li></ul></li><li><p>parseFloat(数据) </p><ul><li>可以保留小数</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> t = <span class="hljs-string">&#x27;12&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> f = <span class="hljs-number">8</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 显式将字符串 12 转换成数值 12</span></span><br><span class="language-javascript">    t = <span class="hljs-title class_">Number</span>(t);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 检测转换后的类型</span></span><br><span class="language-javascript">    <span class="hljs-comment">// console.log(typeof t);</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(t + f); <span class="hljs-comment">// 结果为 20</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 并不是所有的值都可以被转成数值类型</span></span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-comment">// 将 hello 转成数值是不现实的，当无法转换成</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 数值时，得到的结果为 NaN （Not a Number）</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(str));</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> num = <span class="hljs-number">3.14</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-title class_">Number</span>(num))</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-built_in">parseInt</span>(num))</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-built_in">parseFloat</span>(num))</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h5><p>转换为字符型：</p><ul><li>String(数据)</li><li>变量.toString(进制)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> num = <span class="hljs-title class_">String</span>(<span class="hljs-number">163</span>)</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> num)</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>产品经理Axure</title>
    <link href="/2022/07/26/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86Axure/"/>
    <url>/2022/07/26/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86Axure/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="产品微课"><a href="#产品微课" class="headerlink" title="产品微课"></a>产品微课</h1><h2 id="1-产品经理工作内容"><a href="#1-产品经理工作内容" class="headerlink" title="1. 产品经理工作内容"></a>1. 产品经理工作内容</h2><p><strong>初级产品经理</strong></p><ul><li><p>接需求、画原型、写文档; </p></li><li><p>开会、开会、开会;</p><ul><li><strong>如果你的文档或者需求没有传达清楚，会这样:</strong> 收到设计师、前端、研发、测试的抱怨或投诉(你这需求怎么老 是在变…具体需求到底是什么样子的，能不能一次性说清楚) ;</li></ul></li></ul><p><strong>高级产品经理</strong></p><ol><li>带产品团队、培训新人; </li><li>规划产品发展路线;</li><li>参与设计商业模式;</li><li>负责公司的业务板块; </li></ol><p><strong>产品经理分类</strong></p><ol><li>产品经理分类1：<ol><li>B(Business)端产品经理：重功能；</li><li>C(Customer)端产品经理：重体验；</li></ol></li><li>产品经理分类2：<ol><li>前台产品经理：重体验；</li><li>后台产品经理：重逻辑；</li></ol></li><li>产品经理分类3：<ol><li>APP端产品经理；</li><li>WEB端产品经理；</li><li>PC端产品经理；</li><li>区别：不同的交互思想，不同的设计规范；</li></ol></li></ol><h2 id="2-产品经理的日常产出物"><a href="#2-产品经理的日常产出物" class="headerlink" title="2. 产品经理的日常产出物"></a>2. 产品经理的日常产出物</h2><ol><li><p>产品经理的日常五类产出物：</p><ol><li><p>流程图；</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207261940177.png" alt="image-20220726192518946"></p></li><li><p>产品结构图；</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207261941069.png" alt="image-20220726194158039"></p></li><li><p>竞品分析文档；</p><ol><li>竞品的分类;</li><li>竞品的选择;</li><li>竞品信息的采集;</li><li>竞品分析文档的撰写;</li></ol></li><li><p>需求列表；</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207261944263.png" alt="image-20220726194415238"></p><ol><li>原型；</li></ol></li></ol><h2 id="3-流程图介绍及分类"><a href="#3-流程图介绍及分类" class="headerlink" title="3. 流程图介绍及分类"></a>3. 流程图介绍及分类</h2><ol><li><p>流程图的三种分类：</p><ol><li><p>业务流程图；</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207261945226.png" alt="image-20220726194506186"></p></li><li><p>页面流程图；</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207261945752.png" alt="image-20220726194527721"></p></li><li><p>数据流程图；（泳道图）</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207261946518.png" alt="image-20220726194603486"></p></li></ol></li><li><p>流程图注意事项：</p><ol><li>流程图有开始和结束；</li><li>注意，不能出现交叉线；</li><li>不同的操作使用不同的图形；</li><li>出现判定时，一定有是和否两种情况；</li></ol></li><li><p>Process on流程图快捷键</p><p><strong>通用</strong></p><p>|   键位   |                            功能                            |<br>| :———: | :————————————————————————————: |<br>|   Alt    |            按住Alt，通过数据可以对页面进行拖动             |<br>|   Ctrl   | 按住Ctrl，点击一个图形，将其添加到选择图形中，或者从中移除 |<br>|    L     |                          插入连线                          |<br>| Alt+(+/) |                       视图放大或缩小                       |<br>|    T     |                          插入文本                          |<br>|    I     |                          插入图片                          |</p><p><strong>图形被选中时</strong></p><p>| 箭头 (←↑↓→)            | 将选中图形向左、向上、向下、向右移动 |<br>| ——————————— | —————————————————— |<br>| Ctrl+Shift+B           | 格式刷                               |<br>| 调整图形大小时按住Ctrl | 调整图形大小，并且约束比例           |<br>| Ctrl+D                 | 复用                                 |<br>| Ctrl+[                 | 将选中的图形置于底层                 |<br>| Ctrl+shift+]           | 将选中的图形上移一层                 |<br>| Ctrl+shift+[           | 将选中的图形下移一层                 |<br>| Ctrl+L                 | 锁定选中的图形                       |<br>| Ctrl+shift+L           | 将选中的图形解锁                     |<br>| Ctrl+G                 | 组合选中的图形                       |<br>| Ctrl+shift+G           | 将选中的图形取消组合                 |</p></li></ol><h2 id="4-原型的概念及分类"><a href="#4-原型的概念及分类" class="headerlink" title="4. 原型的概念及分类"></a>4. 原型的概念及分类</h2><ol><li><p>三种原型：</p><ol><li><p>草图原型：手绘图稿，修改方便，规划的早期使用;</p></li><li><p>低保真原型：简单交互，无设计图，无需配色，黑白灰即可，产品经理做产品规划及评审的阶段使用;</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207262005346.png" alt="image-20220726200544323"></p></li><li><p>高保真原型：复杂交互，有设计图，需要有图片设计功底，做公开演示时候常用。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207262006901.png" alt="image-20220726200620876"></p></li></ol></li><li><p>Axure简介：用于快速制作原型的软件，它在无需编码的情况下构建低、高保真的原型，只需拖、拉、编辑即可完成;</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">原型:<br>介绍：用线条、图形描绘出的产品框架，也称线框图，是需求和功能的<br>具体化表象;<br>作用：1、因为原型是需求和功能的具体化表象，所以原型可以辅助产品经理 与领导、UI、和技术进行沟通; 2、因为原型相对于手稿而言，信息含量更丰富。<br></code></pre></td></tr></table></figure></li></ol><ol><li>对产品经理的要求：使用Axure制作低保真原型；</li></ol><h2 id="5-Axure常用功能介绍"><a href="#5-Axure常用功能介绍" class="headerlink" title="5. Axure常用功能介绍"></a>5. Axure常用功能介绍</h2><p><strong>鼠标操作</strong></p><ol><li>选择：与“相交选中”相比，建议大家都使用“包含选中”——选择范围更为精确，不容易误操作；</li><li>缩放：按住shift键，可以实现等比例缩放；</li><li>对齐、分布：快速实现页面布局；</li></ol><p><strong>演示操作</strong></p><ol><li><p>预览：产品经理跟项目组同事演示原型时使用；<strong>预览原型时，点击站点导航处的小箭头，可以看到所有带交互的元件</strong></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207272048443.png" alt="产品必会的30个Axure使用技巧"></p></li><li><p>发布：产品经理将原型文件共享给项目组同事时，可以使用；</p><ol><li>发布功能中，可以设置预览选项：发布 → 预览选项 → 配置 → 标志；</li></ol></li><li><p>共享：需要登录个人账号之后使用；</p><ol><li>作用：给面试官发原型；或者，当你不想给别人发源文件，但是又需要共享原型的时候，可以使用；</li></ol></li><li><p>拖动页面名称</p><p>鼠标选择左侧画板里的页面名称，直接拖入画布里，会出现页面名称的按钮框，可以用来做流程图，点击页面名称按钮框，会直接跳转到对应页面。</p></li></ol><h2 id="6-产品结构图"><a href="#6-产品结构图" class="headerlink" title="6. 产品结构图"></a>6. 产品结构图</h2><p><strong>分类</strong></p><ul><li><p>产品功能结构图:专注在功能模块，再逐级延展;</p></li><li><p>产品信息结构图:产品需要承载的信息;</p></li><li><p>产品结构图:功能与信息的集合，将功能和信息呈现在不同的页面;</p></li></ul><h3 id="产品功能结构图"><a href="#产品功能结构图" class="headerlink" title="产品功能结构图"></a><strong>产品功能结构图</strong></h3><ol><li>功能结构图，侧重点在于功能；就是将产品功能按照从属关系，绘制出来。</li><li>制作方法：<ol><li>先根据产品的一级页面(比如微信有四个:微信、通讯录、发现、我)找出产品主功能模块，然后按照层级归属关系详叙该功能模块提供的下一级功能模块或功能;</li><li><strong>在描述一个功能名称的时候，建议使用“动词+名词”的方式，这种描述方式更容易被大家所理解。</strong> 例如:将“名字”改为“设置名字”或者“查看并设置名字”;</li></ol></li><li>适用场景：<ol><li>在产品规划初期，考虑产品功能细节时使用；</li></ol></li><li>示例：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207271201015.png" alt="image-20220727120148978"></li></ol><h3 id="产品信息结构图"><a href="#产品信息结构图" class="headerlink" title="产品信息结构图"></a>产品信息结构图</h3><ol><li><p>概念：指脱离产品的实际页面，将产品的<strong>数据</strong>抽象出来，组合分类的图表;</p></li><li><p>作用：</p><ul><li><p>帮助梳理复杂内容的信息组成，避免信息内容在展示过程中出现遗漏、混乱、重复; </p></li><li><p>作为开发工程师建立数据库的参考依据; </p></li><li><p>信息结构图主要适用于产品信息构成比较复杂需要考虑优化的情况，如内容型产品 (博客、web门户网站等)，产品的信息结构对于用户体验就十分重要，需要用信息结 构图作为工具进行分析思考;</p></li></ul></li></ol><ol><li>示例：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207271208238.png" alt="image-20220727120806199"></li></ol><h3 id="产品结构图："><a href="#产品结构图：" class="headerlink" title="产品结构图："></a><strong>产品结构图：</strong></h3><ul><li><p>概念:产品结构图是综合展示产品信息和功能逻辑的图表，简单说产品结构图就是产品原型的简化表达。</p></li><li><p>作用:</p><ul><li>它能够在前期的需求评审中或其他类似场景中作为产品原型的替代; </li><li>其实现成本低，能够快速对产品功能结构进行增、删、改操作，减少PM在这个过程中的实现成本;</li></ul></li><li><p>方法:功能 + 信息;先列出一级页面，再列出页面中的功能和信息，逐级展开;</p></li><li><p>注意:</p><ul><li>重点功能和页面，重点制作，层级尽量深;</li><li><p>结构层级尽量细致;</p></li><li><p>产品经理一定要会制作产品结构图；信息结构图，以了解为主，如果需要制作，更多的是考虑产品中的信息字段；</p></li></ul></li><li><p>结构图和原型的关系</p><ul><li><strong>先有结构图，后有原型</strong></li></ul></li><li><p>产品结构图的使用场景：</p><ol><li>做产品规划时使用，通过结果图梳理产品框架，再进行产品设计；</li><li>竞品分析时，也需要制作产品结构图；</li></ol></li><li><p>Xmind软件使用：建议记住常用操作的快捷键；</p><p>| 快捷键（Mac）        | 描述（以下的文件，都指的是Xmind文件） |<br>| —————————— | ——————————————————- |<br>| Command + N          | 建立新的文件                          |<br>| Command + O          | 打开文件                              |<br>| Command + S          | 保存当前文件                          |<br>| Command +  Shift + S | 保存全部文件                          |<br>| Command + W          | 关闭当前文件                          |<br>| Command +  Shift + W | 关闭全部文件                          |<br>| Command + Z          | 返回上一步（撤销）                    |<br>| Command + Y          | 重做                                  |<br>| Command + X          | 剪切                                  |<br>| Command + C          | 复制                                  |<br>| Command + V          | 粘贴                                  |<br>| Delete               | 删除                                  |<br>| Command + A          | 选择全部节点                          |<br>| Command +  Shift + A | 选择同级节点                          |<br>| Command + Alt  + A   | 选择子节点                            |<br>| Command + +          | 放大                                  |<br>| Command + -          | 缩小                                  |<br>| Command + =          | 正常大小                              |<br>| Command + ]          | 插入摘要                              |<br>| Enter                | 在下方添加同级别的节点                |<br>| Tab                  | 添加子节点                            |<br>| Shift + Enter        | 在上方添加同级别的节点                |<br>| Command +  Enter     | 添加当前节点的父节点                  |<br>| Command + I          | 插入图片                              |<br>| Command +  Shift + H | 插入超链接                            |<br>| Command + B          | 添加外框                              |<br>| Command + L          | 添加关联                              |<br>| F2                   | 编辑节点内容                          |<br>| F3                   | 给当前节点添加标签                    |<br>| F4                   | 给当前节点添加备注                    |<br>| +                    | 展开当前节点                          |<br>| -                    | 收缩当前节点                          |<br>| *                    | 展开所有节点                          |</p></li></ul><h2 id="7-Axure基本操作"><a href="#7-Axure基本操作" class="headerlink" title="7. Axure基本操作"></a>7. Axure基本操作</h2><div class="table-container"><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>⌘+Enter</td><td>添加新界面</td></tr><tr><td>⇧+上下左右键</td><td>一次调整十个像素</td></tr><tr><td>⌃多选</td><td>可以选中多个组件</td></tr><tr><td>⇧</td><td>等比例缩放</td></tr><tr><td>双击</td><td>编辑文字</td></tr></tbody></table></div><p><strong>矩形和图片</strong></p><ol><li>矩形的圆角设置：<ol><li>拖动矩形元件左上方的黄色小三角；</li><li>在“检视 - 样式 - 圆角半径”中进行设置；</li></ol></li><li>图片的导入：<ol><li>原尺寸导入图片：当图片元件的四角为黄色的小正方形时，导入图片为原尺寸；</li><li>根据给定尺寸导入图片：当图片元件的四角为白色的小正方形时，导入的图片会根据给定尺寸进行压缩；</li></ol></li></ol><p><strong>文本框</strong></p><ol><li>文本框：<ol><li>注意，可以设置文本类型，以及边框的可见性、提示文字的隐藏触发；</li><li>拖拽文本框元件后，右侧面板里可选择不同的文本框类型，选择不同的类型可以达到不同的效果。如：<ol><li>密码格式：输入的内容会被隐藏</li><li>数字格式：只能输入数字</li><li>文件格式：可以选择文件</li><li>日期格式：可以直接选择日期</li></ol></li><li>另外，文本框里的预置文字，可以直接在右侧“提示文字”框输入。</li></ol></li><li>下拉框：<ol><li>可以批量设置选项；</li></ol></li><li>单选、复选：<ol><li>如果要制作单选的效果，需要设置单选按钮组（选中全部的选项，右键，选择“设置单选按钮组”）；</li></ol></li></ol><p><strong>页面快照</strong></p><p>拖动页面快照到画布里，选择对应的页面，会出现页面预览，点击可进入对应页面。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207272101441.png" alt="产品必会的30个Axure使用技巧"></p><p><strong>常用交互</strong></p><ol><li><p>鼠标悬停、鼠标按下、选中、禁用：</p><ol><li>检视 - 属性 - 形状 - 交互样式设置；</li><li>选中：为了设置选中的交互效果，要先设置选中的效果，再添加选中的交互事件；</li><li>当我们需要给某个元件添加交互动作时，需要给元件命名；</li></ol></li><li><p>设置toggle效果——<strong>实现点击时显示，再次点击时隐藏</strong></p><ol><li><p>检视 - 属性 - 交互 - 鼠标单击时 - 选中 - true下拉框改为toggle就可以；</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207272102075.png" alt="产品必会的30个Axure使用技巧"></p></li></ol></li><li><p><strong>一个元件上添加多个事件</strong></p><p>同一个元件会出现多种 case，如点击登录按钮后出现的多种情况。虽然可以通过添加条件判断来做区分，但是一般比较费时。不那么严格的情况下，我们可以将多个事件添加同一个元件上，对事件进行命名来区分。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207272044206.png" alt="产品必会的30个Axure使用技巧"></p></li><li><p><strong>按住 Ctrl，将鼠标放在元件的边缘，移动鼠标，就可以旋转部件</strong></p></li></ol><p><strong>元件库和母版</strong></p><ol><li><p>元件库、母版最大的作用：</p><ol><li><p>极大的提高原型制作效率；</p></li><li><p>最好的元件库，都是自己做的；</p></li><li><p><strong>在网站上找Icon</strong></p><p>搜索自己需要的Icon类型，点击复制SVG，粘贴进Axure面板里，点击鼠标右键，选择“转化成矢量图”，就可以对Icon进行颜色的填充与修改了。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207272145020.png" alt="产品必会的30个Axure使用技巧"></p></li></ol></li><li><p><strong>重复的元件可以转化成母版</strong></p><ul><li><p>使用到母版元件一样的元件时，直接在母版区拖进画布使用。</p></li><li><p>双击母版元件，就会进入到母版编辑窗口，修改后的元件会同步到所有母版元件。</p></li></ul><p><strong>注意：</strong></p><ul><li>使用母版元件时，元件里所有的样式和交互都是一样的。实际工作中，肯定存在不同交互，这时可以<strong>“点击鼠标右键——脱离母版”，</strong>然后对这个元件单独操作。</li><li>不要把元件过多的组合变成母板，元件组合越是越多，越可能需要在母版的元件上做修改。</li></ul></li></ol><p><strong>常见的原型规范</strong></p><ol><li><p>在企业中制作原型时，只制作iOS端原型；</p><p>web 原型大小：1440×900/1200×900，app 原型尺寸：375×667</p></li><li><p>产品经理在制作原型时，需要遵循的规范（移动端）：</p><ol><li>手机框大小：375*667px；<ol><li>某些页面比较长，比如说淘宝首页，这个时候，可以忽略667的限制；</li></ol></li><li>状态栏，高度20px；</li><li>导航栏，高度44px；</li><li>标签栏，高度49px；字体大小10，图标大小25*25；</li><li>一级按钮，高度40px；</li><li>推荐材料《iOS交互设计规范》；</li></ol></li></ol><p><strong>页面流程图、泳道图</strong></p><ol><li>使用Axure可以制作页面流程图；</li><li>使用Axure可以制作泳道图；</li></ol><p><strong>动态面板</strong>——固定到浏览器的某个位置</p><p>比如：将弹窗在屏幕中间显示、导航固定在顶部。都可以通过固定到浏览器实现。</p><p>步骤如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207272047039.png" alt="产品必会的30个Axure使用技巧"></p><h2 id="8-Axure交互操作"><a href="#8-Axure交互操作" class="headerlink" title="8. Axure交互操作"></a>8. Axure交互操作</h2><p>用axure做交互设计主要需理解它的两个方面逻辑：即<strong>事件与动作。</strong></p><p><strong>事件：即触发机制。也就是说，在用户做什么行为的时候，触发了后面所设置的一系列动作。</strong>要想做好AXURE的交互设计，必须需要熟练掌握axure都有哪些交互事件。只有灵活的应用这些事件，才可能快速灵活的掌握原型。这些事件，大部分是针对鼠标的动作。另外有一些是针对元件的状态和键盘产生的动作。</p><p>axure的所有交互设计，都是通过这个逻辑来完成的:</p><p>设置事件 $\rightarrow$添加动作$\rightarrow$设置动作的具体选项</p><p>设置了事件后，必须要设定对应的动作。如果有多个动作，则需要排列好所有已加入的动作。<strong>动作一共分为五大类，即：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use/202207271853062.png" alt="image-20220727185344990"></p><p>这里面用的最多的动作，主要就是链接类和元件类。其中又数以下几个用的频率最高，基本上常用的原型中的交互，80%以上用的最多的就是以下三种的组合应用：</p><ul><li><p><strong>打开链接</strong></p></li><li><p><strong>显示/隐藏</strong></p></li><li><p><strong>设置面板状态</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>产品经理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>产品经理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习第四周</title>
    <link href="/2022/07/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E5%91%A8/"/>
    <url>/2022/07/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E5%91%A8/</url>
    
    <content type="html"><![CDATA[<hr><p>上篇主要介绍了贝叶斯分类器，从贝叶斯公式到贝叶斯决策论，再到通过极大似然法估计类条件概率，贝叶斯分类器的训练就是参数估计的过程。朴素贝叶斯则是“属性条件独立性假设”下的特例，它避免了假设属性联合分布过于经验性和训练集不足引起参数估计较大偏差两个大问题，最后介绍的拉普拉斯修正将概率值进行平滑处理。本篇将介绍另一个当选为数据挖掘十大算法之一的<strong>EM算法</strong>。</p><h1 id="8、EM算法"><a href="#8、EM算法" class="headerlink" title="8、EM算法"></a><strong>8、EM算法</strong></h1><p>EM（Expectation-Maximization）算法是一种常用的估计参数隐变量的利器，也称为“期望最大算法”，是数据挖掘的十大经典算法之一。EM算法主要应用于训练集样本不完整即存在隐变量时的情形（例如某个属性值未知），通过其独特的“两步走”策略能较好地估计出隐变量的值。</p><h2 id="8-1-EM算法思想"><a href="#8-1-EM算法思想" class="headerlink" title="8.1 EM算法思想"></a><strong>8.1 EM算法思想</strong></h2><p>EM是一种迭代式的方法，它的基本思想就是：若样本服从的分布参数θ已知，则可以根据已观测到的训练样本推断出隐变量Z的期望值（E步），若Z的值已知则运用最大似然法估计出新的θ值（M步）。重复这个过程直到Z和θ值不再发生变化。</p><p>简单来讲：假设我们想估计A和B这两个参数，在开始状态下二者都是未知的，但如果知道了A的信息就可以得到B的信息，反过来知道了B也就得到了A。可以考虑首先赋予A某种初值，以此得到B的估计值，然后从B的当前值出发，重新估计A的取值，这个过程一直持续到收敛为止。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843bf53eb2.png" alt="1.png"></p><p>现在再来回想聚类的代表算法K-Means：【首先随机选择类中心=&gt;将样本点划分到类簇中=&gt;重新计算类中心=&gt;不断迭代直至收敛】，不难发现这个过程和EM迭代的方法极其相似，事实上，若将样本的类别看做为“隐变量”（latent variable）Z，类中心看作样本的分布参数θ，K-Means就是通过EM算法来进行迭代的，与我们这里不同的是，K-Means的目标是最小化样本点到其对应类中心的距离和，上述为极大化似然函数。</p><h2 id="8-2-EM算法数学推导"><a href="#8-2-EM算法数学推导" class="headerlink" title="8.2 EM算法数学推导"></a><strong>8.2 EM算法数学推导</strong></h2><p>在上篇极大似然法中，当样本属性值都已知时，我们很容易通过极大化对数似然，接着对每个参数求偏导计算出参数的值。但当存在隐变量时，就无法直接求解，此时我们通常最大化已观察数据的对数“边际似然”（marginal likelihood）。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843bfd84d2.png" alt="2.png"></p><p>这时候，通过边缘似然将隐变量Z引入进来，对于参数估计，现在与最大似然不同的只是似然函数式中多了一个未知的变量Z，也就是说我们的目标是找到适合的θ和Z让L(θ)最大，这样我们也可以分别对未知的θ和Z求偏导，再令其等于0。</p><p>然而观察上式可以发现，和的对数（ln(x1+x2+x3)）求导十分复杂，那能否通过变换上式得到一种求导简单的新表达式呢？这时候 Jensen不等式就派上用场了，先回顾一下高等数学凸函数的内容：</p><p><strong>Jensen’s inequality</strong>：过一个凸函数上任意两点所作割线一定在这两点间的函数图象的上方。理解起来也十分简单，对于凸函数f(x)’’&gt;0，即曲线的变化率是越来越大单调递增的，所以函数越到后面增长越厉害，这样在一个区间下，函数的均值就会大一些了。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843c064c72.png" alt="3.png"></p><p>因为ln(*)函数为凹函数，故可以将上式“和的对数”变为“对数的和”，这样就很容易求导了。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843c3490ad.png" alt="4.png"></p><p>接着求解Qi和θ：首先固定θ（初始值），通过求解Qi使得J（θ，Q）在θ处与L（θ）相等，即求出L（θ）的下界；然后再固定Qi，调整θ，最大化下界J（θ，Q）。不断重复两个步骤直到稳定。通过jensen不等式的性质，Qi的计算公式实际上就是后验概率：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843c21276c.png" alt="5.png"></p><p>通过数学公式的推导，简单来理解这一过程：固定θ计算Q的过程就是在建立L（θ）的下界，即通过jenson不等式得到的下界（E步）；固定Q计算θ则是使得下界极大化（M步），从而不断推高边缘似然L（θ）。从而循序渐进地计算出L（θ）取得极大值时隐变量Z的估计值。</p><p>EM算法也可以看作一种“坐标下降法”，首先固定一个值，对另外一个值求极值，不断重复直到收敛。这时候也许大家就有疑问，问什么不直接这两个家伙求偏导用梯度下降呢？这时候就是坐标下降的优势，有些特殊的函数，例如曲线函数z=y^2+x^2+x^2y+xy+…，无法直接求导，这时如果先固定其中的一个变量，再对另一个变量求极值，则变得可行。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843c34e7ff.png" alt="6.png"></p><h2 id="8-3-EM算法流程"><a href="#8-3-EM算法流程" class="headerlink" title="8.3 EM算法流程"></a><strong>8.3 EM算法流程</strong></h2><p>看完数学推导，算法的流程也就十分简单了，这里有两个版本，版本一来自西瓜书，周天使的介绍十分简洁；版本二来自于大牛的博客。结合着数学推导，自认为版本二更具有逻辑性，两者唯一的区别就在于版本二多出了红框的部分，这里我也没得到答案，欢迎骚扰讨论~</p><p><strong>版本一：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843c0e19db.png" alt="7.png"></p><p><strong>版本二：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc843c34775b.png" alt="8.png"></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习第三周</title>
    <link href="/2022/07/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%91%A8/"/>
    <url>/2022/07/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%91%A8/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="7、贝叶斯分类器"><a href="#7、贝叶斯分类器" class="headerlink" title="7、贝叶斯分类器"></a><strong>7、贝叶斯分类器</strong></h1><p>贝叶斯分类器是一种概率框架下的统计学习分类器，对分类任务而言，假设在相关概率都已知的情况下，贝叶斯分类器考虑如何基于这些概率为样本判定最优的类标。在开始介绍贝叶斯决策论之前，我们首先来回顾下概率论基础知识：</p><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p><strong>一、全概率公式&amp;贝叶斯公式</strong></p><p>在介绍先验、后验概率之前我们先来复习一下全概率公式和贝叶斯公式</p><p><strong>全概率公式：</strong>设事件$B_1,B_2,…,B_n$构成一个完备事件组，即它们两两不相容，和为全集且$P(B_i)&gt;0$ ，则对任一事件$A$有：</p><script type="math/tex; mode=display">P(A)=\sum^n_{i=1}P(B_i)P(A|B_i)</script><p>可以看出，全概率公式是“由因推果”的思想，当知道某件事的原因后，推断由某个原因导致这件事发生的概率为多少。</p><p><strong>贝叶斯公式：</strong>符号定义与全概率公式相同，则：</p><script type="math/tex; mode=display">P(B_i|A)=\frac{P(B_i)P(A|B_i)}{P(A)}=\frac{P(B_i)P(A|B_i)}{\sum^n_{i=1}P(B_i)P(A|B_i)}</script><p>可以看出，贝叶斯公式是“由果溯因”的思想，当知道某件事的结果后，由结果推断这件事是由各个原因导致的概率为多少。</p><p><strong>二、先验概率&amp;后验概率</strong></p><p><strong>先验概率(prior probability)：</strong>指根据以往经验和分析。在实验或采样前就可以得到的概率。</p><p><strong>后验概率(posterior probability)：</strong>指某件事已经发生，想要计算这件事发生的原因是由某个因素引起的概率。</p><p>可以看出，先验概率就是事先可估计的概率分布，而后验概率类似贝叶斯公式“由果溯因”的思想。下面我们通过PRML(Pattern Recognition and Machine Learning)这本书中的例子来理解一下上面的定义。</p><p>假设我们现在有两个盒子，分别为红色和蓝色。在红色盒子中放着2个苹果和6个橙子，在蓝色盒子中放着1个橙子和3个苹果，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-15d6cca9e407d3bfa11404a6169821cd_r.jpg" alt="preview"></p><p>图中绿色表示苹果，橙色代表橙子。假设我们每次实验的时候会随机从某个盒子里挑出一个水果，随机变量B(box)表示挑出的是哪个盒子，并且P(B=blue) = 0.6(蓝色盒子被选中的概率)，P(B=red) = 0.4(红色盒子被选中的概率)。随机变量F(fruit)表示挑中的是哪种水果，F的取值为”a (apple)”和”o (orange)”。</p><p>现在假设我们已经得知某次实验中挑出的水果是orange，那么这个orange是从红色盒子里挑出的概率是多大呢？依据贝叶斯公式有：</p><script type="math/tex; mode=display">P(B=red|F=o)=\frac{P(F=o|B=red)P(B=red)}{P(F=o)}=\frac{3}{4}\times \frac{4}{10}\times \frac{20}{9}=\frac{2}{3}</script><p>同时，由概率的加法规则我们可以得到：</p><script type="math/tex; mode=display">P(B=blue|F=o)=1-\frac{2}{3}=\frac{1}{3}</script><p>在上面的计算过程中，我们将$P(B=red)$或者说 $P(B)$称为先验概率(prior probability)，因为我们在得到F是“a”或者“o”之前，就可以得到 $P(B)$。同理，将$P(B=red|F=o)$和$P(=blue|F=o)$称为后验概率，因为我们在完整的一次实验之后也就是得到了F的具体取值之后才能得到这个概率。</p><h2 id="7-1-贝叶斯决策论"><a href="#7-1-贝叶斯决策论" class="headerlink" title="7.1 贝叶斯决策论"></a><strong>7.1 贝叶斯决策论</strong></h2><p>在机器学习训练模型的过程中，往往我们都试图去优化一个风险函数，因此在概率框架下我们也可以为贝叶斯定义“<strong>条件风险</strong>”(conditional risk)。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd15db94-20220704215035193.png" alt="2.png"></p><p>我们的任务就是寻找一个判定准则最小化所有样本的条件风险总和，因此就有了<strong>贝叶斯判定准则</strong>(Bayes decision rule):为最小化总体风险，只需在每个样本上选择那个使得条件风险最小的类标。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd308600.png" alt="3.png"></p><p>若损失函数$λ$取0-1损失，则有：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220714170548970.png" alt="image-20220714170548970"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd37c502.png" alt="4.png"></p><p>即对于每个样本$x$，选择其后验概率$P(c | x)$最大所对应的类标，能使得总体风险函数最小，从而将原问题转化为估计后验概率$P(c | x)$。一般这里有两种策略来对后验概率进行估计：</p><pre><code class="hljs">* 判别式模型：直接对 P(c | x)进行建模求解。例我们前面所介绍的决策树、神经网络、SVM都是属于判别式模型。* 生成式模型：通过先对联合分布P(x,c)建模，从而进一步求解 P(c | x)。</code></pre><p>贝叶斯分类器就属于生成式模型，基于贝叶斯公式对后验概率$P(c | x) $进行一项神奇的变换，巴拉拉能量…. $P(c | x)$变身：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd501ad3.png" alt="5.png"></p><p>对于给定的样本$x，P(x)$与类标无关，$P(c)$称为类先验概率，$p(x | c )$称为类条件概率。这时估计后验概率$P(c | x)$就变成为估计类先验概率和类条件概率的问题。</p><p>对于类先验概率$P(c)，p(c)$就是样本空间中各类样本所占的比例，根据大数定理(当样本足够多时，频率趋于稳定等于其概率)，这样当训练样本充足时，$p(c)$可以使用各类出现的频率来代替。因此只剩下类条件概率$p(x | c )$，它表达的意思是在类别$c$中出现$x$的概率，它涉及到属性的联合概率问题，若只有一个离散属性还好，当属性多时采用频率估计起来就十分困难，因此这里一般采用极大似然法进行估计。</p><h2 id="7-2-极大似然法"><a href="#7-2-极大似然法" class="headerlink" title="7.2 极大似然法"></a><strong>7.2 极大似然法</strong></h2><p>极大似然估计(Maximum Likelihood Estimation，简称MLE)，是一种根据数据采样来估计概率分布的经典方法。常用的策略是先假定总体具有某种确定的概率分布，再基于训练样本对概率分布的参数进行估计。运用到类条件概率p(x | c )中，假设p(x | c )服从一个参数为θ的分布，问题就变为根据已知的训练样本来估计θ。极大似然法的核心思想就是：估计出的参数使得已知样本出现的概率最大，即使得训练数据的似然最大。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd70fb73.png" alt="7.png"></p><p>所以，贝叶斯分类器的训练过程就是参数估计。总结最大似然法估计参数的过程，一般分为以下四个步骤：</p><pre><code class="hljs">* 1.写出似然函数；* 2.对似然函数取对数，并整理；* 3.求导数，令偏导数为0，得到似然方程组；* 4.解似然方程组，得到所有参数即为所求。</code></pre><p>例如：假设样本属性都是连续值，p(x | c )服从一个多维高斯分布，则通过MLE计算出的参数刚好分别为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd705729-20220704215050820.png" alt="8.png"></p><p>上述结果看起来十分合乎实际，但是采用最大似然法估计参数的效果很大程度上依赖于作出的假设是否合理，是否符合潜在的真实数据分布。这就需要大量的经验知识，搞统计越来越值钱也是这个道理，大牛们掐指一算比我们搬砖几天更有效果。</p><h2 id="7-3-朴素贝叶斯分类器"><a href="#7-3-朴素贝叶斯分类器" class="headerlink" title="7.3 朴素贝叶斯分类器"></a><strong>7.3 朴素贝叶斯分类器</strong></h2><p>不难看出：原始的贝叶斯分类器最大的问题在于联合概率密度函数的估计，首先需要根据经验来假设联合概率分布，其次当属性很多时，训练样本往往覆盖不够，参数的估计会出现很大的偏差。为了避免这个问题，朴素贝叶斯分类器(naive Bayes classifier)采用了“属性条件独立性假设”，即样本数据的所有属性之间相互独立。这样类条件概率p(x | c )可以改写为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd55e102.png" alt="9.png"></p><p>这样，为每个样本估计类条件概率变成为每个样本的每个属性估计类条件概率。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fd6678cd.png" alt="10.png"></p><p>相比原始贝叶斯分类器，朴素贝叶斯分类器基于单个的属性计算类条件概率更加容易操作，需要注意的是：若某个属性值在训练集中和某个类别没有一起出现过，这样会抹掉其它的属性信息，因为该样本的类条件概率被计算为0。因此在估计概率值时，常常用进行平滑(smoothing)处理，拉普拉斯修正(Laplacian correction)就是其中的一种经典方法，具体计算方法如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc83fe54aaed.png" alt="11.png"></p><p>当训练集越大时，拉普拉斯修正引入的影响越来越小。对于贝叶斯分类器，模型的训练就是参数估计，因此可以事先将所有的概率储存好，当有新样本需要判定时，直接查表计算即可。</p><p>针对朴素贝叶斯，人们觉得它too sample，sometimes too naive！因此又提出了半朴素的贝叶斯分类器，具体有SPODE、TAN、贝叶斯网络等来刻画属性之间的依赖关系，此处不进行深入，等哪天和贝叶斯邂逅了再回来讨论。在此鼎鼎大名的贝叶斯介绍完毕，下一篇将介绍这一章剩下的内容—EM算法，朴素贝叶斯和EM算法同为数据挖掘的十大经典算法，想着还是单独介绍吧~</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS布局</title>
    <link href="/2022/06/30/CSS%E5%B8%83%E5%B1%80/"/>
    <url>/2022/06/30/CSS%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h1><p><a class="btn" href="url" title="title">text</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端&amp;CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS基础</title>
    <link href="/2022/06/30/CSS/"/>
    <url>/2022/06/30/CSS/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.  概述"></a>1.  概述</h2><p>==CSS 是一门语言，用于控制网页表现。==我们之前介绍过W3C标准。W3C标准规定了网页是由以下组成：</p><ul><li>结构：HTML</li><li>表现：CSS</li><li>行为：JavaScript</li></ul><p>CSS也有一个专业的名字：==Cascading Style Sheet（层叠样式表）。==</p><p>如下面的代码， <code>style</code> 标签中定义的就是css代码。该代码描述了将 div 标签的内容的字体颜色设置为 红色。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello CSS~<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-CSS导入方式"><a href="#2-CSS导入方式" class="headerlink" title="2.  CSS导入方式"></a>2.  CSS导入方式</h2><p>css 导入方式其实就是 css 代码和 html 代码的结合方式。CSS 导入 HTML有三种方式：</p><ul><li><p>内联样式：在标签内部使用style属性，属性值是css属性键值对</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span>&gt;</span>Hello CSS<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>给方式只能作用在这一个标签上，如果其他的标签也想使用同样的样式，那就需要在其他标签上写上相同的样式。复用性太差。</p></blockquote></li><li><p>内部样式：定义<code>&lt;style&gt;</code>标签，在标签内部定义css样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>这种方式可以做到在该页面中复用。</p></blockquote></li><li><p>外部样式：定义link标签，引入外部的css文件</p><p>编写一个css文件。名为：demo.css，内容如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>在html中引入 css 文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>  <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;demo.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>这种方式可以在多个页面进行复用。其他的页面想使用同样的样式，只需要使用 <code>link</code> 标签引入该css文件。</p></blockquote></li></ul><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">span</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../css/demo.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span>&gt;</span>hello css<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello css <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello css<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>引入方式</th><th>书写位置</th><th>作用范围</th><th>使用场景</th></tr></thead><tbody><tr><td>内联式</td><td>CSS写在style标签中</td><td>当前页面</td><td>小案例</td></tr><tr><td>外联式</td><td>CSS写在单独的css文件中，通过link标签引入</td><td>多个页面</td><td>项目中</td></tr><tr><td>行内式</td><td>CSS写在标签的style属性中</td><td>当前标签</td><td>配合js使用</td></tr></tbody></table></div><h2 id="3-css-选择器"><a href="#3-css-选择器" class="headerlink" title="3.  css 选择器"></a>3.  css 选择器</h2><h4 id="3-1-CSS选择器介绍"><a href="#3-1-CSS选择器介绍" class="headerlink" title="3.1    CSS选择器介绍"></a>3.1    CSS选择器介绍</h4><p>➢ 选择器的作用:</p><ul><li>选择页面中对应的标签(找她)，方便后续设置样式(改她)</li></ul><p>➢ 注意点:</p><ol><li>标签选择器选择的是一类标签，而不是单独某一个</li><li>标签选择器无论嵌套关系有多深，都能找到对应的标签</li></ol><p>css 选择器就是选取需设置样式的元素（标签），比如如下css代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码中的 <code>div</code> 就是 css 中的<strong>选择器</strong>。</p><p>下面讲四种选择器：</p><ol><li><p>元素选择器</p><p>格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">元素名称&#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">div &#123;<br>color:red<br>&#125;  /*该代码表示将页面中所有的div标签的内容的颜色设置为红色*/<br></code></pre></td></tr></table></figure></li><li><p>id选择器：通过id属性值，找到页面中带有这个id属性值的标签，设置样式</p><p>格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#id</span>属性值&#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure><p>例子：</p><p>html代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>hello css2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#name</span>&#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<span class="hljs-comment">/*该代码表示将页面中所有的id属性值是 name 的标签的内容的颜色设置为红色*/</span><br></code></pre></td></tr></table></figure><p>➢ 注意点:</p><ol><li>所有标签上都有id属性</li><li>id属性值类似于身份证号码，<strong><u>在一个页面中是唯一的，不可重复的!</u></strong> </li><li>一个标签上只能有一个id属性值</li><li>一个id选择器只能选中一个标签        </li></ol></li></ol><p>​                3. 类选择器：通过类名，找到页面中所有带有这个类名的标签，设置样式</p><p>格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.class</span>属性值&#123;<span class="hljs-attribute">color</span>: red;&#125;<br></code></pre></td></tr></table></figure><p>例子：</p><p>html代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls&quot;</span>&gt;</span><br>  hello css3<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br><span class="hljs-selector-class">.cls</span>&#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br>&lt;/style&gt;<span class="hljs-comment">/*该代码表示将页面中所有的class属性值是 cls 的标签的内容的颜色设置为红色*/</span><br></code></pre></td></tr></table></figure><p>➢ 注意点:</p><ol><li>所有标签上都有class属性，class属性的属性值称为类名(类似于名字)</li><li>类名可以由数字、字母、下划线、中划线组成，但不能以数字或者中划线开头 </li><li>一个标签可以同时有多个类名，类名之间以空格隔开</li><li>类名可以重复，一个类选择器可以同时选中多个标签</li></ol><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-id">#name</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: blue;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.cls</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: pink;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>div2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls&quot;</span>&gt;</span>div3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls&quot;</span>&gt;</span>span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>补充：类与id的区别</strong></p><p>​                ➢ class类名与id属性值的区别</p><ul><li><p>class类名相当于姓名，可以重复，一个标签可以同时有多个class类名</p></li><li><p>id属性值相当于身份证号码，不可重复，一个标签只能有一个id属性值</p></li></ul><p>  ➢ 类选择器与id选择器的区别</p><ul><li><p>类选择器以 <strong>.</strong> 开头</p></li><li><p>id选择器以 <strong>#</strong> 开头</p></li></ul><p>  ➢ 实际开发的情况</p><ul><li>类选择器用的最多</li><li>id一般配合js使用，除非特殊情况，否则不要使用id设置样式</li><li>实际开发中会遇到<strong>冗余代码的抽取</strong> (可以将一些公共的代码抽取到一个公共的类中去)</li></ul><p>​                4.    <strong>通配符选择器</strong></p><p>​    ➢ 结构：<strong>*</strong> { css属性名:属性值; }</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">*&#123;<br><span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;<br><span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    ➢ 作用：找到页面中所有的标签，设置样式</p><p>​    ➢ 注意点：</p><ol><li>开发中使用极少，只会在极特殊情况下才会用到</li><li>可能会用于去除标签默认的margin和padding</li></ol><h4 id="3-2-复合选择器"><a href="#3-2-复合选择器" class="headerlink" title="3.2    复合选择器"></a>3.2    复合选择器</h4><ol><li><p>后代选择器：选择器1 选择器2 {}</p><ul><li>在选择器1所找到标签的后代(儿子、孙子、重孙子…)中，找到满足选择器2的标签，设置样式</li><li>后代选择器中，选择器与选择器之前通过 空格 隔开</li></ul></li><li><p>子代选择器：选择器1 &gt; 选择器2 {}</p><ul><li>在选择器1所找到标签的子代(儿子)中，找到满足选择器2的标签，设置样式</li><li>子代只包括儿子</li></ul></li><li><p>并集选择器：选择器1， 选择器2 {}</p><ul><li>找到 选择器1 和 选择器2 选中的标签，设置样式</li><li>并集选择器中的每组选择器通常一行写一个，提高代码的可读性</li></ul></li><li><p>交集选择器：选择器1选择器2{}</p><ul><li>(既又原则)找到页面中 <strong>既</strong> 能被选择器1选中，<strong>又</strong> 能被选择器2选中的标签，设置样式</li><li>交集选择器中的选择器之间是紧挨着的，没有东西分隔</li><li>交集选择器中如果有标签选择器，标签选择器必须写在最前面</li></ul></li><li><p>hover伪类选择器：选择器:hover{}</p><ul><li>作用：选中鼠标<strong>悬停</strong>在元素上的<strong>状态</strong>，设置样式</li><li>伪类选择器选中的元素的<strong>某种状态</strong></li></ul></li><li><p>Emmet语法：通过简写语法，快速生成代码</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630205721152.png" alt="image-20220630205721152"></p></li></ol><p>总结：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630205845231.png" alt="image-20220630205845231"></p><h2 id="4-字体和文本样式"><a href="#4-字体和文本样式" class="headerlink" title="4.    字体和文本样式"></a>4.    <strong>字体和文本样式</strong></h2><h3 id="4-1-字体样式"><a href="#4-1-字体样式" class="headerlink" title="4.1    字体样式"></a>4.1    字体样式</h3><ul><li><p>字体大小:font-size</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">*&#123;<br><span class="hljs-attribute">font-size</span>:<span class="hljs-number">16px</span>//谷歌浏览器默认文字大小是<span class="hljs-number">16px</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>字体粗细:font-weight </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br><span class="hljs-attribute">font-weight</span>:normal;//关键字取值<br><span class="hljs-attribute">font-weight</span>:bold;//关键字取值<br><span class="hljs-attribute">font-weight</span>:<span class="hljs-number">400</span>;//正常<br><span class="hljs-attribute">font-weight</span>:<span class="hljs-number">700</span>;//加粗<br>&#125;<br></code></pre></td></tr></table></figure><p>纯数字取值为100-900的整百数。</p><p>​            ➢ 注意点:</p><ol><li><ul><li>不是所有字体都提供了九种粗细，因此部分取值页面中无变化</li><li>实际开发中以:正常、加粗两种取值使用最多。</li></ul></li></ol></li><li><p>字体样式:font-style</p><ul><li>取值:<ul><li>正常(默认值):normal</li><li>倾斜:italic</li></ul></li></ul></li><li><p>字体类型:font-family </p><ul><li><p>常见取值：具体字体1,具体字体2,具体字体3,具体字体4,…,字体系列</p><ul><li>从左往右按照顺序查找，如果电脑中未安装该字体，则显示下一个字体</li><li>如果都不支持，此时会根据操作系统，显示最后字体系列的默认字体</li><li>如果字体名称中存在多个单词，推荐使用引号包裹</li><li>最后一项字体系列不需要引号包裹</li></ul></li><li><p>常见字体系列</p><p>➢ <strong>无衬线字体</strong>(sans-serif)</p><ol><li><p>特点:文字笔画粗细均匀，并且首尾无装饰 </p></li><li><p>场景:网页中大多采用无衬线字体</p></li><li><p>常见该系列字体:黑体、Arial</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630191140059.png" alt="image-20220630191140059"></p></li></ol><p>➢ <strong>衬线字体</strong>(serif)</p><ol><li><p>特点:文字笔画粗细不均，并且首尾有笔锋装饰</p></li><li><p>场景:报刊书籍中应用广泛</p></li><li><p>常见该系列字体:宋体、Times New Roman</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630191309645.png" alt="image-20220630191309645"></p></li></ol><p>➢ <strong>等宽字体</strong>(monospace)</p><ol><li><p>特点:每个字母或文字的宽度相等</p></li><li><p>场景:一般用于程序代码编写，有利于代码的阅读和编写</p></li><li><p>常见该系列字体:Consolas、fira code</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630191338758.png" alt="image-20220630191338758"></p></li></ol></li></ul></li><li><p>字体类型:font属性连写</p><ul><li>取值：font : style weight size family;</li><li>只能省略前两个，如果省略了相当于设置了默认值</li><li>如果需要同时设置单独和连写形式，单独的只能写在连写的下面或里面</li></ul></li></ul><p><strong>样式的层叠问题</strong></p><p>➢ 问题:</p><ul><li>给同一个标签设置了相同的样式，此时浏览器会如何渲染呢?</li></ul><p>➢ 结果:</p><ul><li>如果给同一个标签设置了相同的属性，此时样式会层叠(覆盖)，写在最下面的会生效</li></ul><h3 id="4-2-文本样式"><a href="#4-2-文本样式" class="headerlink" title="4.2    文本样式"></a>4.2    文本样式</h3><ol><li><p>文本缩进:text-indent</p><p>取值：</p><ul><li>数字+px</li><li>数字+em（推荐:1em = 当前标签的font-size的大小）</li></ul></li><li><p>文本水平对齐方式:text-align</p><p>取值：left（左对齐）、center（居中对齐）、right（右对齐）</p><p>注意：如果需要让文本水平居中，<code>text-align：center</code>属性需要给文本所在标签(文本的父元素)设置 </p><p>text-align : center 能让哪些元素水平居中? </p><ul><li><p>文本</p></li><li><p>span标签、a标签</p></li><li>input标签、img标签</li></ul></li><li><p>文本修饰:text-decoration</p><p>开发中会使用 <code>text-decoration : none ;</code>清除<code>a</code>标签默认的下划线</p><p>取值：</p><ol><li>underline下划线</li><li>Line-through删除线</li><li>overline上划线</li><li>None无装饰线</li></ol></li></ol><h3 id="4-3-line-height行高"><a href="#4-3-line-height行高" class="headerlink" title="4.3    line-height行高"></a>4.3    line-height行高</h3><ul><li>➢  作用:控制一行的上下行间距</li><li>➢  属性名:<code>line-height</code></li><li>➢  取值:<ul><li>数字+px</li><li>倍数(当前标签font-size的倍数)</li></ul></li><li>➢  应用:<ol><li>让单行文本垂直居中可以设置 <code>line-height : 文字父元素高度</code></li><li>网页精准布局时，会设置<code>line-height : 1</code> 可以取消上下间距</li></ol></li><li>➢  行高与font连写的注意点:<ul><li>如果同时设置了行高和font连写，注意覆盖问题</li><li>font : style weight size/line-height family ;</li></ul></li></ul><h4 id="标签水平居中方法"><a href="#标签水平居中方法" class="headerlink" title="标签水平居中方法"></a>标签水平居中方法</h4><p>➢ 如果需要让div、p、h(大盒子)水平居中? </p><ul><li>可以通过<code>margin : 0 auto ;</code>实现</li></ul><p>➢ 注意点:</p><ol><li>如果需要让 div、p、h(大盒子) 水平居中，直接给当前元素本身设置即可</li><li><code>margin:0 auto</code> 一般针对于固定宽度的盒子，如果大盒子没有设置宽度，此时会默认占满父元素的宽度</li></ol><h3 id="4-4-Chrome浏览器提示工具"><a href="#4-4-Chrome浏览器提示工具" class="headerlink" title="4.4    Chrome浏览器提示工具"></a>4.4    Chrome浏览器提示工具</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630200307488.png" alt="image-20220630200307488"></p><h2 id="5-背景相关属性"><a href="#5-背景相关属性" class="headerlink" title="5.    背景相关属性"></a>5.    背景相关属性</h2><h4 id="5-5-1-背景颜色"><a href="#5-5-1-背景颜色" class="headerlink" title="5.5.1    背景颜色"></a>5.5.1    背景颜色</h4><p><strong>颜色常见取值：</strong></p><p>➢ 属性名:</p><ul><li><p>如:文字颜色:color</p></li><li><p>如:背景颜色:background-color</p></li></ul><p>➢ 属性值:</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630200501828.png" alt="image-20220630200501828"></p><p>1:完全不透明，0:完全透明，.5半透明</p><ul><li>背景颜色默认值是<strong>透明</strong>: rgba(0,0,0,0) 、transparent</li><li>背景颜色不会影响盒子大小，并且还能看清盒子的大小和位置，一般在布局中会习惯先给盒子设置背景颜色</li></ul><h4 id="5-5-2-背景图片"><a href="#5-5-2-背景图片" class="headerlink" title="5.5.2    背景图片"></a>5.5.2    背景图片</h4><p>取值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;图片的路径&#x27;</span>);<br></code></pre></td></tr></table></figure><p>➢ 注意点:</p><ul><li>背景图片中url中可以省略引号</li><li>背景图片默认是在水平和垂直方向平铺的</li><li>背景图片仅仅是指给盒子起到装饰效果，类似于背景颜色，是不能撑开盒子</li></ul><h4 id="5-5-3-背景平铺"><a href="#5-5-3-背景平铺" class="headerlink" title="5.5.3    背景平铺"></a>5.5.3    背景平铺</h4><p>属性名：<code>background-repeat</code></p><p>取值：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630210700177.png" alt="image-20220630210700177"></p><h4 id="5-5-4-背景位置"><a href="#5-5-4-背景位置" class="headerlink" title="5.5.4    背景位置"></a>5.5.4    背景位置</h4><p>属性名：<code>background-position:水平方向位置 垂直方向位置</code></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630210907348.png" alt="image-20220630210907348"></p><ul><li>方位名词取值和坐标取值可以混使用，第一个取值表示水平，第二个取值表示垂直</li></ul><h4 id="5-5-5-背景相关属性连写"><a href="#5-5-5-背景相关属性连写" class="headerlink" title="5.5.5    背景相关属性连写"></a>5.5.5    背景相关属性连写</h4><p>➢  属性名:<code>background</code></p><p>➢  属性值:</p><ul><li>单个属性值的合写，取值之间以空格隔开 </li></ul><p>➢ 书写顺序:</p><ul><li>推荐:<code>background:color image repeat position</code></li></ul><p>➢  省略问题:</p><ul><li>可以按照需求省略</li><li>特殊情况:在pc端，如果盒子大小和背景图片大小一样，此时可以直接写 <code>background:url()</code></li></ul><p>➢  注意点</p><ul><li>如果需要设置单独的样式和连写<ul><li>要么把单独的样式写在连写的下面</li><li>要么把单独的样式写在连写的里面</li></ul></li></ul><p><strong><code>img</code>标签和背景图片的区别：</strong></p><p>➢ 需求:需要在网页中展示一张图片的效果? </p><p>➢ 方法一:直接写上img标签即可</p><ul><li>img标签是一个标签，不设置宽高默认会以原尺寸显示 </li></ul><p>➢ 方法二:div标签 + 背景图片</p><ul><li>需要设置div的宽高，因为背景图片只是装饰的CSS样式，不能撑开div标签</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端&amp;CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML</title>
    <link href="/2022/06/29/HTML/"/>
    <url>/2022/06/29/HTML/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.  介绍"></a>1.  介绍</h2><p>HTML 是一门语言，所有的网页都是用HTML 这门语言编写出来，HTML也有专业的解释：</p><p>==HTML(HyperText Markup Language)：超文本标记语言：==</p><ul><li><p>超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容</p><p>如我们看到的一些页面，我们除了能看到一些文字，同时也有大量的图片展示；有些网页也有视频，音频等。这种展示效果超越了文本展示的限制。</p></li><li><p>标记语言：由标签构成的语言</p><p>之前学习的XML就是标记语言，由一个一个的标签组成，HTML 也是由标签组成 。我们在浏览器页面右键可以查看页面的源代码。</p></li></ul><p>这些标签不像XML那样可以自定义，==HTML中的标签都是预定义好的，运行在浏览器上并由浏览器解析，==然后展示出对应的效果。</p><p>简单的给大家聊一下开发流程：</p><p>以后我们是通过Java程序从数据库中查询出来数据，然后交给页面进行展示，这样用户就能通过在浏览器通过页面看到数据。</p><p>==W3C标准：==</p><p>W3C是万维网联盟，这个组成是用来定义标准的。他们规定了一个网页是由三部分组成，分别是：</p><ul><li>结构：对应的是 HTML 语言</li><li>表现：对应的是 CSS 语言</li><li>行为：对应的是 JavaScript 语言</li></ul><p>HTML定义页面的整体结构；CSS是用来美化页面，让页面看起来更加美观；JavaScript可以使网页动起来，比如轮播图也就是多张图片自动的进行切换等效果。</p><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.  快速入门"></a>2.  快速入门</h2><p>使用VS Code来编写网页源代码，创建网页的步骤：</p><ul><li><p>新建文件，后缀名改为 .html</p></li><li><p>编写 HTML 结构标签</p><p>HTML 是由一个一个的标签组成的，但是它也用于表示结构的标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>html标签:网页的整体</li><li>head标签:网页的头部</li><li>body标签:网页的身体</li><li>title标签:网页的标题</li></ul></li></ul><h4 id="VS-Code的基本快捷键："><a href="#VS-Code的基本快捷键：" class="headerlink" title="VS Code的基本快捷键："></a>VS Code的基本快捷键：</h4><ol><li><p>快速生成标签:需要生成标签的首字母 + tab</p></li><li><p>保存文件:⌘ + s</p></li><li><p>注释：⌘+/</p></li><li><p>换行：⌘+回车键</p></li><li><p>复制本行：⇧+⌥+上下方向键</p></li><li><p>快速复制一整行:⌘ + c</p><p>快速粘贴一整行:⌘ + v</p><p>快速删除(剪切)一整行:⌘ + x</p></li><li><p>快速查看网页效果:右击 → Open in Default Browser</p><ul><li>快捷键:⌘+O，⌘+L</li><li>注意:<strong>必须安装了**</strong>open in browser<strong> </strong>插件**</li></ul></li><li><p>快速生成结构标签:! + tab</p><ul><li>注意1:!必须是英文的，中文!无效</li><li>注意2:必须保证当前文件后缀名是.html，否则无效</li><li>VS Code自动生成的骨架多了其他标签，之后会介绍</li></ul></li></ol><p>==总结：==</p><ul><li><p>HTML 文件以.htm或.html为扩展名</p></li><li><p>HTML 结构标签</p></li><li><p>HTML 标签不区分大小写</p><p>如 <code>font</code> 写成 <code>Font</code> 也是一样可以展示出对应的效果的。</p></li><li><p>HTML 标签属性值 单双引皆可</p><p>如color属性值使用双引号也是可以的。<font color="red"></font> </p></li><li><p>HTML 语法松散</p><p>比如 font 标签不加结束标签也是可以展示出效果的。但是建议同学们在写的时候还是不要这样做，严格按照要求去写。</p></li></ul><h2 id="3-基础标签"><a href="#3-基础标签" class="headerlink" title="3.  基础标签"></a>3.  基础标签</h2><p>基础标签就是一些和文字相关的标签，接下来我们挨个进行讲解：</p><h3 id="3-1-基础标签"><a href="#3-1-基础标签" class="headerlink" title="3.1    基础标签"></a>3.1    基础标签</h3><div class="table-container"><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;h1&gt;  ~  &lt;h6&gt;</td><td>定义标题，h1最大，h6最小</td></tr><tr><td>&lt;font&gt;</td><td>定义文本的字体、字体尺寸、字体颜色</td></tr><tr><td>&lt;b&gt;、<strong></td><td>加粗</td></tr><tr><td>&lt;i&gt;、<em></td><td>倾斜</td></tr><tr><td>&lt;u&gt;、<ins></td><td>下划线</td></tr><tr><td><s>、<del></td><td>删除线</td></tr><tr><td>&lt;center&gt;</td><td>居中</td></tr><tr><td>&lt;p&gt;</td><td>段落</td></tr><tr><td>&lt;br&gt;</td><td>文本换行</td></tr><tr><td>&lt;hr&gt;</td><td>定义水平线</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>HTML 原代码</th><th>显示结果</th><th>描述</th></tr></thead><tbody><tr><td>\&lt;</td><td>&lt;</td><td>小于号或显示标记</td></tr><tr><td>\&amp;gt ;</td><td>&gt;</td><td>大于号或显示标记</td></tr><tr><td>\&amp;</td><td>&amp;</td><td>可用于显示其它特殊字符</td></tr><tr><td>\&quot;</td><td>“</td><td>引号</td></tr><tr><td>\&reg;</td><td>®</td><td>已注册</td></tr><tr><td>\&copy;</td><td>©</td><td>版权</td></tr><tr><td>\&trade;</td><td>™</td><td>商标</td></tr><tr><td>\&nbsp;</td><td></td><td>不断行的空白</td></tr></tbody></table></div><h3 id="3-2-字体标签"><a href="#3-2-字体标签" class="headerlink" title="3.2  字体标签"></a>3.2  字体标签</h3><p>font：字体标签</p><ul><li><p>face 属性：用来设置字体。如 “楷体”、”宋体”等</p></li><li><p>color 属性：设置文字颜色。颜色有三种表示方式</p><ul><li><p><strong>英文单词</strong>：red,pink,blue…</p></li><li><p><strong>rgb(值1,值2,值3)</strong>：值的取值范围：0~255  </p><p>此种方式也就是三原色（红绿蓝）设置方式。 例如： rgb(255,0,0)。</p><p>这种书写起来比较麻烦，一般不用。</p></li><li><p><strong>#值1值2值3</strong>：值的范围：00~FF</p><p>这种方式是rgb方式的简化写法，以后基本都用此方式。</p><p>值1表示红色的范围，值2表示绿色的范围，值3表示蓝色范围。例如： #ff0000</p></li></ul></li><li><p>size 属性：设置文字大小</p></li></ul><p>代码演示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;楷体&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;#ff0000&quot;</span>&gt;</span>传智教育<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>==注意：==</p><p>font 标签已经不建议使用了，以后如果要改变文字字体，大小，颜色可以使用 CSS 进行设置。</p></blockquote><h2 id="4-图片、音频、视频标签"><a href="#4-图片、音频、视频标签" class="headerlink" title="4.  图片、音频、视频标签"></a>4.  图片、音频、视频标签</h2><ul><li><p>img：定义图片</p><ul><li><p>src：规定显示图像的 URL（统一资源定位符）</p></li><li><p>Alt：替换文本，当图片加载失败时显示</p></li><li><p>height：图像的高度</p></li><li><p>width：图像的宽度</p></li><li><p>title：当鼠标悬停时显示的文本</p></li></ul></li><li><p>audio：定义音频。支持的音频格式：MP3、WAV、OGG </p><ul><li>src：规定音频的 URL</li><li>controls：显示播放控件</li></ul></li><li>video：定义视频。支持的音频格式：MP4, WebM、OGG<ul><li>src：规定视频的 URL</li><li>controls：显示播放控件</li><li>Autoplay：自动播放</li><li>loop：循环播放</li></ul></li></ul><p><strong>尺寸单位：</strong></p><p>height属性和width属性有两种设置方式：</p><ul><li>像素：单位是px</li><li>百分比。占父标签的百分比。例如宽度设置为 50%，意思就是占它的父标签宽度的一般（50%）</li><li>如果只设置二者中的一个，会自动设置等比例缩放</li></ul><p><strong>资源路径：</strong></p><p>图片，音频，视频标签都有src属性，而src是用来指定对应的图片，音频，视频文件的路径。此处的图片，音频，视频就称为资源。资源路径有如下两种设置方式：</p><ul><li><p>绝对路径：完整路径</p><p>这里的绝对路径是网络中的绝对路径。 格式为： 协议://ip地址:端口号/资源名称。</p><p>如：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">&lt;img src=<span class="hljs-string">&quot;https://th.bing.com/th/id/R33674725d9ae34f86e3835ae30b20afe?rik=Pb3C9e5%2b%2b3a9Vw&amp;riu=http%3a%2f%2fwww.desktx.com%2fd%2ffile%2fwallpaper%2fscenery%2f20180626%2f4c8157d07c14a30fd76f9bc110b1314e.jpg&amp;ehk=9tpmnrrRNi0eBGq3CnhwvuU8PPmKuy1Yma0zL%2ba14T0%3d&amp;risl=&amp;pid=ImgRaw&quot;</span> width=<span class="hljs-string">&quot;300&quot;</span> height=<span class="hljs-string">&quot;400&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>这里src属性的值就是网络中的绝对路径。</p></li><li><p>相对路径：相对位置关系</p><p>找页面和其他资源的相对路径。</p><blockquote><p>./    表示当前路径</p><p>../   表示上一级路径</p><p>../../   表示上两级路径</p></blockquote></li></ul><h2 id="5-超链接标签"><a href="#5-超链接标签" class="headerlink" title="5.  超链接标签"></a>5.  超链接标签</h2><p>➢ 显示特点:</p><ul><li>a标签默认文字有下划线</li><li>a标签从未点击过，默认文字显示蓝色</li><li>a标签点击过之后，文字显示为紫色(清除浏览器历史记录可恢复蓝色)</li></ul><p><code>a</code> 标签属性：</p><ul><li><p>href：指定目标网页路径</p><ul><li><p>外部链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;www.baidu.com&#x27;</span>&gt;</span>百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>内部链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;./target.html&#x27;</span>&gt;</span>jump<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>target：指定打开资源的方式</p><ul><li>_self：默认值，在当前页面打开，覆盖原网页</li><li>_blank：在新窗口中跳转，保留原网页</li></ul></li></ul><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.itcast.cn&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_self&quot;</span>&gt;</span>点我有惊喜<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>空链接(拓展补充)</p><p> ➢ 代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;#&#x27;</span>&gt;</span>空链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>➢ 功能:</p><ul><li>点击之后回到网页顶部</li><li>开发中不确定该链接最终跳转位置，用空链接占个位置</li></ul><h2 id="6-列表标签"><a href="#6-列表标签" class="headerlink" title="6.  列表标签"></a>6.  列表标签</h2><p>HTML 中列表定义如下：</p><div class="table-container"><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;ol&gt;</td><td>定义有序列表</td></tr><tr><td>&lt;ul&gt;</td><td>定义无序列表</td></tr><tr><td>&lt;li&gt;</td><td>定义列表项</td></tr></tbody></table></div><ul><li>type：设置符号的类型</li><li>ul和ol标签中只允许嵌套li标签</li><li>li标签中可以嵌套任意内容</li></ul><p>自定义列表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">标签名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">dl</td><td style="text-align:center">表示整体，用于包裹dt和dd</td></tr><tr><td style="text-align:center">dt</td><td style="text-align:center">表示列表主题</td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">表示每一项内容</td></tr></tbody></table></div><ul><li><p>dl标签中只允许嵌套dt/dd标签</p></li><li><p>dt/dd标签中可以嵌套任意内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>主题<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>第一行<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>第二行<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>第三行<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220629170316314.png" alt="image-20220629170316314"></p></li></ul><ul><li>有序列表中的 <code>type</code> 属性用来指定标记的标号的类型（数字、字母、罗马数字等）</li></ul><ul><li>无序列表中的 <code>type</code> 属性用来指定标记的形状</li></ul><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;A&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>咖啡<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>茶<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>牛奶<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;circle&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>咖啡<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>茶<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>牛奶<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="7-表格标签"><a href="#7-表格标签" class="headerlink" title="7.  表格标签"></a>7.  表格标签</h2><p>表格可以使用如下标签定义</p><ul><li><p>table ：定义表格</p><ul><li><p>border：规定表格边框的宽度</p></li><li><p>width ：规定表格的宽度</p></li><li><p>cellpadding：定义内容和单元格的距离</p></li><li><p>cellspacing：规定单元格之间的空白，如果指定为0，则单元格的线会合为一条。</p></li></ul></li><li><p>tr ：定义行</p><ul><li>align：定义表格行的内容对齐方式</li><li>bgcolor：背景色</li></ul></li><li><p>td ：定义单元格</p><ul><li><p>rowspan：规定单元格可纵跨的行数，即宽几格</p></li><li><p>colspan：规定单元格可横跨的列数，即长几格</p></li><li><p>bgcolor：背景色</p></li></ul></li><li>th：定义表头单元格，通常用于表格第一行，默认内部文字加粗并居中显示</li><li>caption：表示表格整体大标题，默认在表格整体顶部居中加粗显示</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220629170618484.png" alt="image-20220629170618484" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220629194844009.png" alt="image-20220629194844009"></p><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>序号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>品牌logo<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>品牌名称<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>企业名称<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>010<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/三只松鼠.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>三只松鼠<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>三只松鼠<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>009<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/优衣库.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>优衣库<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>优衣库<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>008<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/小米.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;60&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>小米<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>小米科技有限公司<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630165613904.png" alt="image-20220630165613904"></p><p>作业效果：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630165809961.png" alt="image-20220630165809961"></p><p>代码实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500px&quot;</span> <span class="hljs-attr">cellpading</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>优秀学生信息表格<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;60px&quot;</span>&gt;</span>年级<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>学号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>班级<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100px&quot;</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>高三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>赵四<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>120<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>三年三班<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>110<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>三年二班<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;40px&quot;</span>&gt;</span>评语<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>你们都很优秀<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span>        <br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="8-布局标签"><a href="#8-布局标签" class="headerlink" title="8.  布局标签"></a>8.  布局标签</h2><p>没有语义的布局标签；<code>div</code>和<code>span</code></p><p><code>div</code>标签在浏览器上会有换行的效果，而 <code>span</code> 标签在浏览器上没有换行效果。</p><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>我是span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>语义化标签：</p><ul><li>header:网页头部</li><li>nav:网页导航</li><li>footer:网页底部</li><li>aside:网页侧边栏</li><li>section:网页区块</li><li>article:网页文章</li></ul><p>对应的部署位置：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630161910453.png" alt="image-20220630161910453"  /></p><h2 id="9-表单标签"><a href="#9-表单标签" class="headerlink" title="9.  表单标签"></a>9.  表单标签</h2><p>表单标签效果大家其实都不陌生，像登陆页面、注册页面等都是表单。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220629194955811.png" alt="image-20220629194955811" style="zoom:50%;" /></p><p>像这样的表单就是用来采集用户输入的数据，然后将数据发送到服务端，服务端会对数据库进行操作，比如注册就是将数据保存到数据库中，而登陆就是根据用户名和密码进行数据库的查询操作。</p><p>表单是很重要的标签，需要大家重点来学习。</p><h3 id="9-1-表单标签概述"><a href="#9-1-表单标签概述" class="headerlink" title="9.1  表单标签概述"></a>9.1  表单标签概述</h3><blockquote><p>表单：在网页中主要负责数据采集功能，使用<form>标签定义表单</p><p>表单项(元素)：不同类型的 input 元素、下拉列表、文本域等</p></blockquote><p><code>form</code> 是表单标签，它在页面上没有任何展示的效果。需要借助于表单项标签来展示不同的效果。</p><h3 id="9-2-form标签属性"><a href="#9-2-form标签属性" class="headerlink" title="9.2  form标签属性"></a>9.2  form标签属性</h3><ul><li><p><strong>action：规定当提交表单时向何处发送表单数据，该属性值就是URL</strong></p><p>以后会将数据提交到服务端，该属性需要书写服务端的URL。而今天我们可以书写 <code>#</code> ，表示提交到当前页面来看效果。</p></li><li><p><strong>method ：规定用于发送表单数据的方式</strong></p><p>method取值有如下两种：</p><ul><li>get：默认值。如果不设置method属性则默认就是该值<ul><li>请求参数会拼接在URL后边</li><li>url的长度有限制 4KB</li></ul></li><li>post：<ul><li>浏览器会将数据放到http请求消息体中</li><li>请求参数无限制的</li></ul></li></ul></li></ul><h3 id="9-3-代码演示"><a href="#9-3-代码演示" class="headerlink" title="9.3  代码演示"></a>9.3  代码演示</h3><p>由于表单标签在页面上没有任何展示的效果，所以在演示的过程是会先使用 <code>input</code> 这个表单项标签展示输入框效果。</p><p>从效果可以看到页面有一个输入框，用户可以在数据框中输入自己想输入的内容，点击提交按钮以后会将数据发送到服务端，当然现在肯定不能实现。现在我们可以将 <code>form</code> 标签的 <code>action</code> 属性值设置为 <code>#</code> ，将其将数据提交到当前页面。还需要注意一点，要想提交数据，<code>input</code> 输入框必须设置 <code>name</code> 属性。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们可以看到在浏览器的地址栏的URL后拼接了我们提交的数据。<code>username</code> 就是输入框 <code>name</code> 属性值，而 <code>hehe</code> 就是我们在输入框输入的内容。</p><h2 id="10-表单项标签"><a href="#10-表单项标签" class="headerlink" title="10.  表单项标签"></a>10.  表单项标签</h2><p>表单项标签有很多，不同的表单项标签有不同的展示效果。表单项标签可以分为以下三个：</p><p><code>&lt;input&gt;</code>：表单项，通过<code>type</code>属性控制输入形式</p><p><code>name</code>属性：当前控件的含义，提交之后可以告诉后端发送过去的数据是什么含义</p><p><code>value</code>属性：当前控件的值，用于提交选项</p><p><code>input</code> 标签有个 <code>type</code> 属性。 <code>type</code> 属性的取值不同，展示的效果也不一样：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630144931962.png" alt="image-20220630144931962"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630145614571.png" alt="image-20220630145614571"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 昵称：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br>              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mima&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 性别：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span> =<span class="hljs-string">&quot;男&quot;</span>&gt;</span>男<br>                      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;女&quot;</span> <span class="hljs-attr">checked</span>&gt;</span>女<br>              <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">checked</span>&gt;</span>敲代码<br>                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span>熬夜<br>                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span>掉头发<br>              <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;普通按钮&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p><code>&lt;select&gt;</code>：定义下拉列表，\<option> 定义列表项 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;BeiJing&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;shanghai&quot;</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;GuangZhou&quot;</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><code>&lt;textarea&gt;</code>：文本域</p><p>它可以输入多行文本，而 <code>input</code> 数据框只能输入一行文本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;desc&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>==注意：==</p><ul><li>以上标签项的内容要想提交，必须得定义 <code>name</code> 属性。</li><li>每一个标签都有id属性，id属性值是唯一的标识。</li><li>单选框、复选框、下拉列表需要使用 <code>value</code> 属性指定提交的值。</li></ul></blockquote><p><strong>代码演示：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>密码：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>        性别：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>        爱好：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span> 旅游<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span> 电影<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span> 游戏<br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>        头像：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>        城市:<br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;shanghai&quot;</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>        个人描述：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;desc&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;免费注册&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;重置&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;一个按钮&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在浏览器的效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630155359721.png" alt="image-20220630155359721" style="zoom:50%;" /></p><p>图中的文字内容都以<code>label</code>的形式给出，换行用<code>&lt;br&gt;</code>。</p><p><strong>label标签</strong></p><p>场景：常用于绑定内容与表单标签的关系</p><p>标签名：<code>label</code></p><p>使用方法1:</p><ol><li><p>使用<code>label</code>标签把内容(如:文本)包裹起来 </p></li><li><p>在表单<code>input</code>标签上添加<code>id</code>属性，对应<code>label</code>标签中的<code>for</code>属性</p></li><li><p>在<code>label</code>标签的<code>for</code>属性中设置对应的<code>id</code>属性值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p>使用方法2:</p><ol><li><p>直接使用<code>label</code>标签，把内容(如:文本)和表单标签一起包裹起来 </p></li><li><p>需要把<code>label</code>标签的<code>for</code>属性删除即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>text<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="11-转义字符"><a href="#11-转义字符" class="headerlink" title="11.    转义字符"></a>11.    转义字符</h2><p> 场景:在网页中展示特殊符号效果时，需要使用字符实体替代 </p><p>结构:<code>&amp;字符对应英文;</code></p><p>常见字符实体：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220630162334944.png" alt="image-20220630162334944"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端&amp;HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python第一周</title>
    <link href="/2022/06/28/Python%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
    <url>/2022/06/28/Python%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="第-1-章-起步"><a href="#第-1-章-起步" class="headerlink" title="第 1 章    起步"></a>第 1 章    起步</h1><h2 id="1-1-搭建编程环境"><a href="#1-1-搭建编程环境" class="headerlink" title="1.1　搭建编程环境"></a>1.1　搭建编程环境</h2><h3 id="1-1-1-Sublime-Text简介"><a href="#1-1-1-Sublime-Text简介" class="headerlink" title="1.1.1　Sublime Text简介"></a>1.1.1　Sublime Text简介</h3><p>Sublime Text是一款简单的文本编辑器，可以在任何现代操作系统中安装。你几乎能直接在Sublime Text中执行所有程序。在Sublime Text中执行程序时，代码将在其内嵌的终端会话中运行，让你能够轻松地看到输 出。</p><h2 id="1-2-在Mac系统中搭建Python编程环境"><a href="#1-2-在Mac系统中搭建Python编程环境" class="headerlink" title="1.2　在Mac系统中搭建Python编程环境"></a>1.2　在Mac系统中搭建Python编程环境</h2><p>大多数macOS系统默认安装了Python。确定安装了Python后，你还需安装Sublime Text，并确保其配置正确无误。</p><p>打开终端，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 -V<br></code></pre></td></tr></table></figure><p>查看python版本。</p><p>如果要退出Python并返回到终端窗口， 可按Ctrl + D或执行命令exit() 。</p><h2 id="1-3-运行Hello-World程序"><a href="#1-3-运行Hello-World程序" class="headerlink" title="1.3　运行Hello World程序"></a>1.3　运行Hello World程序</h2><h3 id="1-3-1-运行程序hello-world-py"><a href="#1-3-1-运行程序hello-world-py" class="headerlink" title="1.3.1    运行程序hello_world.py"></a>1.3.1    运行程序hello_world.py</h3><p>编写第一个程序前，在系统中创建一个名为python_work的文件夹，用于存储你开发的项目。文件名和文件夹名称最好使用小写字母，并使用下划线代替空格，因为Python采用了这些命名约定。</p><p>启动Sublime Text，将文件起名hello_world.py并保存在项目文件夹中，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello Python world!&quot;</span>)<br></code></pre></td></tr></table></figure><p>在macOS系统中用<strong>Command + B</strong>来运行程序，在Sublime Text的底部，将出现一个终端窗口，其中包含如下输出：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Hello Python world!<br><span class="hljs-string">[Finished in 0.1s]</span><br></code></pre></td></tr></table></figure><h2 id="1-4-从终端运行Python程序"><a href="#1-4-从终端运行Python程序" class="headerlink" title="1.4　从终端运行Python程序"></a>1.4　从终端运行Python程序</h2><p>1.4.1    运行Python程序</p><p>在终端会话中，可以使用终端命令cd （表示change directory，即切换目录 ）在文件系统中导航。使用命令ls（表示list，即列表 ）可以显示当前目录中所有未隐藏的文件。</p><p>为运行程序hello_world.py，请打开一个新的终端窗口，并执行下面的命 令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">v@VdeMacBook-Pro ~ % cd ./python_work <br>v@VdeMacBook-Pro python_work % ls<br>hello_world.pyuntitled<br>v@VdeMacBook-Pro python_work % python3 hello_world.py <br>hello Python world<br></code></pre></td></tr></table></figure><h1 id="第-2-章-变量和简单数据类型"><a href="#第-2-章-变量和简单数据类型" class="headerlink" title="第 2 章　变量和简单数据类型"></a>第 2 章　变量和简单数据类型</h1><h2 id="2-1-运行hello-world-py时发生的情况"><a href="#2-1-运行hello-world-py时发生的情况" class="headerlink" title="2.1　运行hello_world.py时发生的情况"></a>2.1　运行hello_world.py时发生的情况</h2><p>运行文件hello_world.py时，末尾的.py指出这是一个Python程序，因此编辑器将使用Python解释器来运行它。Python解释器读取整个程序，确定其中每个单词的含义。<u>例如，看到后面跟着圆括号的单词print 时，解释器就将圆括号中的内容打印到屏幕。</u></p><h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2　变量"></a>2.2　变量</h2><p>在程序中可随时修改变量的值，而Python将始终记录变量的<strong>最新值</strong>。</p><h3 id="2-2-1-变量的命名和使用"><a href="#2-2-1-变量的命名和使用" class="headerlink" title="2.2.1　变量的命名和使用"></a>2.2.1　变量的命名和使用</h3><p>在Python中使用变量时，需要遵守一些规则和指南。</p><p>变量名只能包含<strong>字母、数字和下划线</strong>。</p><ul><li>变量名能以字母或下划线打头，但不能以数字打头。例如，可将变量命名为message_1 ，但不能将其命名为1_message 。 </li><li>变量名不能包含空格，但能使用下划线来分隔其中的单词。例如， 变量名greeting_message 可行，但变量名greeting message 会引发错误。 </li><li>不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如print 。 </li><li>变量名应既简短又具有描述性。例如，name 比n好，student_name 比s_n 好，name_length 比 length_of_persons_name 好。 </li><li>慎用小写字母l 和大写字母O ，因为它们可能被人错看成数字1 和0 。</li></ul><p>注意：就目前而言，应使用小写的Python变量名。虽然在变量名中使用大写字母不会导致错误，但是大写字母在变量名中有特殊含义，这将在本书后面讨论。</p><h3 id="2-2-2-变量是标签"><a href="#2-2-2-变量是标签" class="headerlink" title="2.2.2　变量是标签"></a>2.2.2　变量是标签</h3><p>变量常被描述为可用于存储值的盒子。Python内部表示变量的的定义是，变量是可以赋给值的标签，也可以说变量指向特定的值。</p><h2 id="2-3-字符串"><a href="#2-3-字符串" class="headerlink" title="2.3　字符串"></a>2.3　字符串</h2><p>字符串就是一系列字符。在Python中，用<strong>引号括起的都是字符串</strong>，其中的引号可以是单引号，也可以是双引号，这种灵活性让你能够在字符串中包含引号和撇号：</p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk"><span class="hljs-string">&#x27;I told my friend, &quot;Python is my favorite language!&quot;&#x27;</span> <span class="hljs-comment">&quot;The language &#x27;Python&#x27; is named after Monty Python, not the snake.&quot;</span> <span class="hljs-comment">&quot;One of Python&#x27;s strengths is its diverse and supportive community.&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-1-使用方法修改字符串的大小写"><a href="#2-3-1-使用方法修改字符串的大小写" class="headerlink" title="2.3.1　使用方法修改字符串的大小写"></a>2.3.1　使用方法修改字符串的大小写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;ada lovelace&quot;</span> <br><span class="hljs-built_in">print</span>(name.title())//首字母大写<br><span class="hljs-built_in">print</span>(name.upper())//全部大写<br><span class="hljs-built_in">print</span>(name.lower())//全部小写<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Ada Lovelace</span><br><span class="hljs-attribute">ADA LOVELACE </span><br><span class="hljs-attribute">ada lovelace</span><br></code></pre></td></tr></table></figure><h3 id="2-3-2-在字符串中使用变量"><a href="#2-3-2-在字符串中使用变量" class="headerlink" title="2.3.2　在字符串中使用变量"></a>2.3.2　在字符串中使用变量</h3><p>要<strong>在字符串中插入变量的值，可在前引号前加上字母f</strong> ，再将要插入的变量放在花括号内。这样，当Python显示字符串时，将把每个变量都替换为其值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">first_name=<span class="hljs-string">&quot;ada&quot;</span><br>last_name=<span class="hljs-string">&quot;lovelace&quot;</span><br>full_name=<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;first_name&#125;</span> <span class="hljs-subst">&#123;last_name&#125;</span>&quot;</span><br><span class="hljs-built_in">print</span>(full_name)<br></code></pre></td></tr></table></figure><p>f是format（设置格式）的简写，因为Python 通过把花括号内的变量替换为其值来设置字符串的格式。上述代码的输出如下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ada lovelace</span><br></code></pre></td></tr></table></figure><p>练习2-3：个性化消息 　</p><p>用变量表示一个人的名字，并向其显示一 条消息。显示的消息应非常简单，下面是一个例子。</p><p>Hello Eric, would you like to learn some Python today?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name=<span class="hljs-string">&quot;eric&quot;</span><br>word=<span class="hljs-string">f&quot;Hello <span class="hljs-subst">&#123;name&#125;</span>, would you like to learn some Python today?&quot;</span><br><span class="hljs-built_in">print</span>(word)<br></code></pre></td></tr></table></figure><h3 id="2-3-3-使用制表符或换行符来添加空白"><a href="#2-3-3-使用制表符或换行符来添加空白" class="headerlink" title="2.3.3　使用制表符或换行符来添加空白"></a>2.3.3　使用制表符或换行符来添加空白</h3><p>在编程中，空白泛指任何非打印字符，如空格、制表符和换行符。你可以使用空白来组织输出，让用户阅读起来更容易。</p><div class="table-container"><table><thead><tr><th style="text-align:center">制表符</th><th style="text-align:center">\t</th></tr></thead><tbody><tr><td style="text-align:center">换行符</td><td style="text-align:center">\n</td></tr><tr><td style="text-align:center">换行后添加一个制表符</td><td style="text-align:center">\n\t</td></tr></tbody></table></div><h3 id="2-3-4-删除空白"><a href="#2-3-4-删除空白" class="headerlink" title="2.3.4　删除空白"></a>2.3.4　删除空白</h3><p>Python能够找出字符串开头和末尾多余的空白。要确保字符串末尾没有空白，可使用方法rstrip() 。</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">favorite_language = <span class="hljs-string">&#x27;python &#x27;</span> </span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">favorite_language</span><br>&#x27;python &#x27; <br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">favorite_language.rstrip()</span><br>&#x27;python&#x27; <br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">favorite_language</span><br>&#x27;python &#x27;<br></code></pre></td></tr></table></figure><p>对变量favorite_language 调用方法rstrip() 后，这个多余的空格被删除了。然而，这种删除只是暂时的，接下来再次询问favorite_language 的值时，你会发现这个字符串与输入时一样，依然包含多余的空白。</p><p><strong>要永久删除这个字符串中的空白，必须将删除操作的结果关联到变量：</strong></p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">favorite_language = <span class="hljs-string">&#x27;python &#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">favorite_language = favorite_language.rstrip() &gt;&gt;&gt; favorite_language <span class="hljs-string">&#x27;python&#x27;</span></span><br></code></pre></td></tr></table></figure><p>你还可以剔除字符串开头的空白，或者同时剔除字符串两边的空白。为 此，可分别使用方法lstrip() 和strip()。</p><h3 id="2-3-5-使用字符串时避免语法错误"><a href="#2-3-5-使用字符串时避免语法错误" class="headerlink" title="2.3.5　使用字符串时避免语法错误"></a>2.3.5　使用字符串时避免语法错误</h3><p>语法错误 是一种你时不时会遇到的错误。程序中包含非法的Python代码 时，就会导致语法错误。例如，在用单引号括起的字符串中，如果包含 撇号，就将导致错误。这是因为这会导致Python将第一个单引号和撇号 之间的内容视为一个字符串，进而将余下的文本视为Python代码，从而 引发错误。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">message</span> = <span class="hljs-string">&quot;One of Python&#x27;s strengths is its diverse community.&quot;</span> <br>pr<span class="hljs-meta">int</span>(<span class="hljs-keyword">message</span>)<br></code></pre></td></tr></table></figure><p>撇号位于两个双引号之间，因此Python解释器能够正确地理解这个字符 串。然而，如果使用单引号，Python将无法正确地确定字符串的结束位置：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">message = <span class="hljs-symbol">&#x27;One</span> <span class="hljs-keyword">of</span> Python<span class="hljs-symbol">&#x27;s</span> strengths <span class="hljs-keyword">is</span> its diverse community.&#x27; <br>print(message)<br></code></pre></td></tr></table></figure><p>注意 　编写程序时，编辑器的语法高亮功能可帮助你快速找出某 些语法错误。看到Python代码以普通句子的颜色显示，或者普通句 子以Python代码的颜色显示时，就可能意味着文件中存在引号不匹 配的情况。</p><h2 id="2-4-数"><a href="#2-4-数" class="headerlink" title="2.4　数"></a>2.4　数</h2><p>在编程中，经常使用数来记录得分、表示可视化数据、存储Web应用信 息，等等。Python能根据数的用法以不同的方式处理它们。鉴于整数使 用起来最简单，下面就先来看看Python是如何管理它们的。</p><h3 id="2-4-1-整数"><a href="#2-4-1-整数" class="headerlink" title="2.4.1　整数"></a>2.4.1　整数</h3><ul><li><p>在Python中，可对整数执行加（+ ）减（- ）乘（* ）除（/ ）运算。</p></li><li><p>在终端会话中，Python直接返回运算结果。Python使用两个乘号表示乘 方运算。</p></li><li><p>Python还支持运算次序，因此可在同一个表达式中使用多种运算。还可 以使用圆括号来修改运算次序，让Python按你指定的次序执行运算。</p></li></ul><h3 id="2-4-2-浮点数"><a href="#2-4-2-浮点数" class="headerlink" title="2.4.2　浮点数"></a>2.4.2　浮点数</h3><p>Python将所有带小数点的数称为浮点数 。</p><p>从很大程度上说，使用浮点数时无须考虑其行为。你只需输入要使用的数，Python通常会按你期望的方式处理它们，但需要注意的是，结果包含的小数位数可能是不确定的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">0.2</span>+<span class="hljs-number">0.1</span><br><span class="hljs-number">0.30000000000000004</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">3</span>*<span class="hljs-number">0.1</span><br><span class="hljs-number">0.30000000000000004</span><br></code></pre></td></tr></table></figure><h3 id="2-4-3-整数和浮点数"><a href="#2-4-3-整数和浮点数" class="headerlink" title="2.4.3　整数和浮点数"></a>2.4.3　整数和浮点数</h3><ul><li>将任意两个数相除时，结果总是浮点数，即便这两个数都是整数且能整除。</li><li>在其他任何运算中，如果一个操作数是整数，另一个操作数是浮点数， 结果也总是浮点数。</li></ul><h3 id="2-4-4-数中的下划线"><a href="#2-4-4-数中的下划线" class="headerlink" title="2.4.4　数中的下划线"></a>2.4.4　数中的下划线</h3><p>书写很大的数时，可使用下划线将其中的数字分组，使其更清晰易读：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>universe_age = <span class="hljs-number">14_000_000_000</span><br></code></pre></td></tr></table></figure><p>当你打印这种使用下划线定义的数时，Python不会打印其中的下划线：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(universe_age) <span class="hljs-number">14000000000</span><br></code></pre></td></tr></table></figure><p>这是因为存储这种数时，Python会忽略其中的下划线。将数字分组时， 即便不是将每三位分成一组，也不会影响最终的值。在Python看 来，1000 与1_000 没什么不同，1_000 与10_00 也没什么不同。这种表示法适用于整数和浮点数，但只有Python 3.6和更高的版本支持。</p><h3 id="2-4-5-同时给多个变量赋值"><a href="#2-4-5-同时给多个变量赋值" class="headerlink" title="2.4.5　同时给多个变量赋值"></a>2.4.5　同时给多个变量赋值</h3><p>可在一行代码中给多个变量赋值，这有助于缩短程序并提高其可读性。 这种做法最常用于将一系列数赋给一组变量。</p><p>例如，下面演示了如何将变量x 、y 和z 都初始化为零：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x,y,z=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-built_in">print</span>(y)<br><span class="hljs-built_in">print</span>(z)<br></code></pre></td></tr></table></figure><p>Python将<strong>按顺序将每个值赋给对应的变量。只要变量和值的个数相同，Python就能正确地将它们关联起来。</strong></p><h3 id="2-4-6-常量"><a href="#2-4-6-常量" class="headerlink" title="2.4.6　常量"></a>2.4.6　常量</h3><p>常量类似于变量，但<strong>其值在程序的整个生命周期内保持不变</strong>。Python没有内置的常量类型，但Python程序员会使用全大写来指出应将某个变量 视为常量，其值应始终不变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">MAX_CONNECTIONS = <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><p><u>在代码中，要指出某个特定的变量视为常量，可将其字母全部大写。</u></p><h2 id="2-5-注释"><a href="#2-5-注释" class="headerlink" title="2.5　注释"></a>2.5　注释</h2><h3 id="2-5-1-如何编写注释"><a href="#2-5-1-如何编写注释" class="headerlink" title="2.5.1　如何编写注释"></a>2.5.1　如何编写注释</h3><p>在Python中，注释用井号（# ）标识。井号后面的内容都会被Python解释器忽略，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 向大家问好。 </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello Python people!&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-5-2-该编写什么样的注释"><a href="#2-5-2-该编写什么样的注释" class="headerlink" title="2.5.2　该编写什么样的注释"></a>2.5.2　该编写什么样的注释</h3><h2 id="2-6-Python之禅"><a href="#2-6-Python之禅" class="headerlink" title="2.6　Python之禅"></a>2.6　Python之禅</h2><p>在解释器中执行命令import this 。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220628185501196.png" alt="image-20220628185501196"></p><p>经验丰富的程序员倡导尽可能避繁就简。Python社区的理念都包含在 Tim Peters撰写的“Python之禅”中。</p><h2 id="2-7-小结"><a href="#2-7-小结" class="headerlink" title="2.7　小结"></a>2.7　小结</h2><p>在本章中，你学习了：如何使用变量；如何创建描述性变量名以及如何消除名称错误和语法错误；字符串是什么，以及如何使用小写、大写和 首字母大写方式显示字符串；使用空白来显示整洁的输出，以及如何剔 除字符串中多余的空白；如何使用整数和浮点数；一些使用数值数据的 方式。你还学习了如何编写说明性注释，让代码对你和其他人来说更容 易理解。最后，你了解了让代码尽可能简单的理念。</p><p>在第3章，你将学习如何在被称为列表 的变量中存储一系列信息，以及如何通过遍历列表来操作其中的信息。</p><h1 id="第-3-章-列表简介"><a href="#第-3-章-列表简介" class="headerlink" title="第 3 章　列表简介"></a>第 3 章　列表简介</h1><h2 id="3-1-列表是什么"><a href="#3-1-列表是什么" class="headerlink" title="3.1　列表是什么"></a>3.1　列表是什么</h2><p>列表由一系列按特定顺序排列的元素组成。列表通常包含多个元素，因此给列表指定一个表示复数的名称（如letters 、digits 或names ）是个不错的主意。</p><p>在Python中，用方括号（[] ）表示列表，并用逗号分隔其中的元素。下面是一个简单的列表示例，其中包含几种自行车：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">bicycles = [<span class="hljs-string">&#x27;trek&#x27;</span>, <span class="hljs-string">&#x27;cannondale&#x27;</span>, <span class="hljs-string">&#x27;redline&#x27;</span>, <span class="hljs-string">&#x27;specialized&#x27;</span>]<br></code></pre></td></tr></table></figure><p>Python将打印列表的固定格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">&#x27;trek&#x27;</span>, <span class="hljs-string">&#x27;cannondale&#x27;</span>, <span class="hljs-string">&#x27;redline&#x27;</span>, <span class="hljs-string">&#x27;specialized&#x27;</span>]<br></code></pre></td></tr></table></figure><p>鉴于这不是你要让用户看到的输出，下面来学习如何访问列表元素。</p><h3 id="3-1-1-访问列表元素"><a href="#3-1-1-访问列表元素" class="headerlink" title="3.1.1　访问列表元素"></a>3.1.1　访问列表元素</h3><p>列表是有序集合，因此要访问列表元素，可指出列表的名称，再指出元素的索引，并将后者放在方括号内。</p><p>例如，下面的代码从列表bicycles 中提取第一款自行车：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(bicycles[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h3 id="3-1-2-索引从0而不是1开始"><a href="#3-1-2-索引从0而不是1开始" class="headerlink" title="3.1.2　索引从0而不是1开始"></a>3.1.2　索引从0而不是1开始</h3><p>Python为访问最后一个列表元素提供了一种特殊语法。<strong>通过将索引指定为-1 ，可让Python返回最后一个列表元素：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">bicycles = [<span class="hljs-string">&#x27;trek&#x27;</span>, <span class="hljs-string">&#x27;cannondale&#x27;</span>, <span class="hljs-string">&#x27;redline&#x27;</span>, <span class="hljs-string">&#x27;specialized&#x27;</span>] <span class="hljs-built_in">print</span>(bicycles[-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>这段代码返回’specialized’ 。</p><p>这种语法很有用，因为你经常需要在不知道列表长度的情况下访问最后的元素。这种约定也适用于其他负数索引。例如，索引-2 返回倒数第二个列表元素，索引-3 返回倒数第三个列表元素，依此类推。</p><h2 id="3-2-修改、添加和删除元素"><a href="#3-2-修改、添加和删除元素" class="headerlink" title="3.2　修改、添加和删除元素"></a>3.2　修改、添加和删除元素</h2><p>你创建的大多数列表将是动态的，这意味着列表创建后，将随着程序的运行增删元素。</p><h3 id="3-2-1-修改列表元素"><a href="#3-2-1-修改列表元素" class="headerlink" title="3.2.1　修改列表元素"></a>3.2.1　修改列表元素</h3><p>修改列表元素，指定列表名和要修改的元素的索引，再指定该元素的新值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">motorcycles = [<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br>motorcycles[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;ducati&#x27;</span><br><span class="hljs-built_in">print</span>(motorcycles)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-symbol">&#x27;ducati</span>&#x27;, <span class="hljs-symbol">&#x27;yamaha</span>&#x27;, <span class="hljs-symbol">&#x27;suzuki</span>&#x27;]<br></code></pre></td></tr></table></figure><h3 id="3-2-2-在列表中添加和删除元素"><a href="#3-2-2-在列表中添加和删除元素" class="headerlink" title="3.2.2　在列表中添加和删除元素"></a>3.2.2　在列表中添加和删除元素</h3><p>1）<strong>在列表末尾添加元素</strong>：方法append() 可以将元素添加到列表末尾，而不影响列表中的其他所有元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">motorcycles = [<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br>motorcycles.append(<span class="hljs-string">&#x27;ducati&#x27;</span>) <br><span class="hljs-built_in">print</span>(motorcycles)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<span class="hljs-symbol">&#x27;honda</span>&#x27;, <span class="hljs-symbol">&#x27;yamaha</span>&#x27;, <span class="hljs-symbol">&#x27;suzuki</span>&#x27;, <span class="hljs-symbol">&#x27;ducati</span>&#x27;]<br></code></pre></td></tr></table></figure><p>方法append() 让动态地创建列表易如反掌。</p><p>例如，你可以先创建 一个空列表，再使用一系列函数调用append() 来添加元素。</p><p>2）<strong>使用方法insert() 可在列表的任何位置添加新元素</strong>：为此，你需要指定新元素的索引和值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">motorcycles = [<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br>motorcycles.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;ducati&#x27;</span>) <br></code></pre></td></tr></table></figure><p>方法 insert() 在索引0 处添加空间，并将值’ducati’ 存储到这个地 方。这种操作将列表中既有的每个元素都右移一个位置。</p><p>3）<strong>使用del 语句删除元素</strong></p><p>如果知道要删除的元素在列表中的位置，可使用del 语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> motorcycles[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>4）<strong>使用方法pop() 删除末尾元素</strong></p><p>有时候，你要将元素从列表中删除，并接着使用它的值。例如，你可能要将用户从活跃成员列表中删除，并将其加入到非活跃成员列表中。</p><p>方法pop() 删除列表末尾的元素，并让你能够接着使用它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">motorcycles = [<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br>last_owned = motorcycles.pop() <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The last motorcycle I owned was a <span class="hljs-subst">&#123;last_owned.title()&#125;</span>.&quot;</span>)<br></code></pre></td></tr></table></figure><p>5）弹出列表中任何位置处的元素</p><p>可以使用pop() 来删除列表中任意位置的元素，只需在圆括号中指定要删除元素的索引即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">first_owned = motorcycles.pop(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>6）根据值删除元素</p><p>有时候，你不知道要从列表中删除的值所处的位置。如果只知道要 删除的元素的值，可使用方法remove() 。</p><p>例如，假设要从列表motorcycles 中删除值’ducati’ 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">motorcycles.remove(<span class="hljs-string">&#x27;ducati&#x27;</span>) <br></code></pre></td></tr></table></figure><p>注意：方法remove() 只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来确保将每个值都删除。</p><h2 id="3-3-组织列表"><a href="#3-3-组织列表" class="headerlink" title="3.3　组织列表"></a>3.3　组织列表</h2><h3 id="3-3-1-使用方法sort-对列表永久排序"><a href="#3-3-1-使用方法sort-对列表永久排序" class="headerlink" title="3.3.1　使用方法sort() 对列表永久排序"></a>3.3.1　使用方法sort() 对列表永久排序</h3><p>按字母顺序排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cars.sort()<br></code></pre></td></tr></table></figure><p>列表顺序被永久改变，<strong>再也无法恢复到原来的排列顺序</strong>。按与字母顺序相反的顺序排列列表元素，只需向sort() 方法传递参数reverse=True 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cars.sort(reverse=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h3 id="3-3-2-使用函数sorted-对列表临时排序"><a href="#3-3-2-使用函数sorted-对列表临时排序" class="headerlink" title="3.3.2　使用函数sorted() 对列表临时排序"></a>3.3.2　使用函数sorted() 对列表临时排序</h3><p>要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使用函数sorted() 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">cars = [<span class="hljs-string">&#x27;bmw&#x27;</span>, <span class="hljs-string">&#x27;audi&#x27;</span>, <span class="hljs-string">&#x27;toyota&#x27;</span>, <span class="hljs-string">&#x27;subaru&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(cars))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(cars,reverse=<span class="hljs-literal">True</span>))<br></code></pre></td></tr></table></figure><p>注意：在并非所有的值都是小写时，按字母顺序排列列表要复杂些。决定排列顺序时，有多种解读大写字母的方式，要指定准确的排列顺序，可能比我们这里所做的要复杂。</p><h3 id="3-3-3-倒着打印列表"><a href="#3-3-3-倒着打印列表" class="headerlink" title="3.3.3　倒着打印列表"></a>3.3.3　倒着打印列表</h3><p>要反转列表元素的排列顺序，可使用方法reverse() 。</p><p>注意，reverse() 不是按与字母顺序相反的顺序排列列表元素，而只是反转列表元素的排列顺序，方法reverse() 永久性地修改列表元素的排列顺序，但可随时恢复 到原来的排列顺序，只需对列表再次调用reverse() 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cars.reverse() <br></code></pre></td></tr></table></figure><h3 id="3-3-4-确定列表的长度"><a href="#3-3-4-确定列表的长度" class="headerlink" title="3.3.4　确定列表的长度"></a>3.3.4　确定列表的长度</h3><p>使用函数len() 可快速获悉列表的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">len</span>(cars)<br></code></pre></td></tr></table></figure><h1 id="第-4-章-操作列表"><a href="#第-4-章-操作列表" class="headerlink" title="第 4 章　操作列表"></a>第 4 章　操作列表</h1><p>在第3章，你学习了如何创建简单的列表，还学习 了如何操作列表元素。在本章中，你将学习如何遍历 整个列表。</p><h2 id="4-1-遍历整个列表"><a href="#4-1-遍历整个列表" class="headerlink" title="4.1　遍历整个列表"></a>4.1　遍历整个列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">magicians = [<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;david&#x27;</span>, <span class="hljs-string">&#x27;carolina&#x27;</span>]<br><span class="hljs-keyword">for</span> magician <span class="hljs-keyword">in</span> magicians:<br><span class="hljs-built_in">print</span>(magician)<br></code></pre></td></tr></table></figure><h2 id="4-2-创建数值列表"><a href="#4-2-创建数值列表" class="headerlink" title="4.2　创建数值列表"></a>4.2　创建数值列表</h2><h3 id="4-2-1-使用函数range"><a href="#4-2-1-使用函数range" class="headerlink" title="4.2.1　使用函数range()"></a>4.2.1　使用函数range()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>):<br><span class="hljs-built_in">print</span>(value)<br></code></pre></td></tr></table></figure><p>在这个示例中，range() 只打印数1～4。</p><p><u>这是编程语言中常见的差一行为的结果</u>。函数range() 让Python从指定的第一个值开始数， 并在到达你指定的第二个值时停止。因为它在第二个值处停止，所以输出不包含该值（这里为5）。</p><p>要打印数1～5，需要使用range(1,6) 。</p><h3 id="4-2-2-使用range-创建数字列表"><a href="#4-2-2-使用range-创建数字列表" class="headerlink" title="4.2.2　使用range() 创建数字列表"></a>4.2.2　使用range() 创建数字列表</h3><p>要创建数字列表，可使用函数list() 将range() 的结果直接转换为列表。如果将range() 作为list() 的参数，输出将是一个数字列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)) <br><span class="hljs-built_in">print</span>(numbers)<br></code></pre></td></tr></table></figure><p><strong>使用函数range() 时，还可指定步长</strong>。为此，可给这个函数指定第 三个参数，Python将根据这个步长来生成数。</p><p>例如，下面的代码打印1～10的偶数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">even_numbers = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>)) <br><span class="hljs-built_in">print</span>(even_numbers)<br></code></pre></td></tr></table></figure><p>下面的代码演示了如何将前10个整数的平方加入一个列表中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">squares=[]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>):<br>squares.append(i**<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(squares)<br></code></pre></td></tr></table></figure><h3 id="4-2-3-对数字列表执行简单的统计计算"><a href="#4-2-3-对数字列表执行简单的统计计算" class="headerlink" title="4.2.3　对数字列表执行简单的统计计算"></a>4.2.3　对数字列表执行简单的统计计算</h3><p>有几个专门用于处理数字列表的Python函数。例如，你可以轻松地找出数字列表的<strong>最大值、最小值和总和：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt; digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]<br>&gt;&gt;&gt; min(digits)<br>0<br>&gt;&gt;&gt; max(digits)<br>9<br>&gt;&gt;&gt; <span class="hljs-built_in">sum</span>(digits)<br>45<br></code></pre></td></tr></table></figure><h3 id="4-2-4-列表解析"><a href="#4-2-4-列表解析" class="headerlink" title="4.2.4　列表解析"></a>4.2.4　列表解析</h3><p>列表解析将for循环和创建新元素的代码合并成一行，并自动附加新元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">squares=[i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>)]<br><span class="hljs-built_in">print</span>(squares)<br></code></pre></td></tr></table></figure><p>要使用这种语法，首先指定一个描述性的列表名，如squares 。然后定义一个表达式，用于生成要存储到列表中的值。接下来，编写一个for 循环，用于给表达式提供值。</p><h2 id="4-3-使用列表的一部分"><a href="#4-3-使用列表的一部分" class="headerlink" title="4.3　使用列表的一部分"></a>4.3　使用列表的一部分</h2><h3 id="4-3-1-切片"><a href="#4-3-1-切片" class="headerlink" title="4.3.1　切片"></a>4.3.1　切片</h3><p>要创建切片，可指定要使用的第一个元素和最后一个元素的索引。 与函数range() 一样，Python在到达第二个索引之前的元素后停止。要输出列表中的前三个元素，需要指定索引0和3，这将返回索引为0、1和2的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">players = [<span class="hljs-string">&#x27;charles&#x27;</span>, <span class="hljs-string">&#x27;martina&#x27;</span>, <span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;florence&#x27;</span>, <span class="hljs-string">&#x27;eli&#x27;</span>]<br><span class="hljs-built_in">print</span>(players[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p>如果没有指定第一个索引，Python将自动从列表开头开始。要让切片终止于列表末尾，也可使用类似的语法。</p><p>注意 　可在表示切片的方括号内指定第三个值。这个值告诉 Python在指定范围内每隔多少元素提取一个。</p><h3 id="4-3-2-遍历切片"><a href="#4-3-2-遍历切片" class="headerlink" title="4.3.2　遍历切片"></a>4.3.2　遍历切片</h3><p>如果要遍历列表的部分元素，可在for 循环中使用切片。下面的示例遍历前三名队员，并打印他们的名字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">players = [<span class="hljs-string">&#x27;charles&#x27;</span>, <span class="hljs-string">&#x27;martina&#x27;</span>, <span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;florence&#x27;</span>, <span class="hljs-string">&#x27;eli&#x27;</span>]<br><span class="hljs-keyword">for</span> player <span class="hljs-keyword">in</span> players[:<span class="hljs-number">3</span>]:<br><span class="hljs-built_in">print</span>(player.title())<br></code></pre></td></tr></table></figure><h3 id="4-3-3-复制列表"><a href="#4-3-3-复制列表" class="headerlink" title="4.3.3　复制列表"></a>4.3.3　复制列表</h3><p>要复制列表，可创建一个包含整个列表的切片，方法是同时省略起 始索引和终止索引（[:] ）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_foods = [<span class="hljs-string">&#x27;pizza&#x27;</span>, <span class="hljs-string">&#x27;falafel&#x27;</span>, <span class="hljs-string">&#x27;carrot cake&#x27;</span>] <br>friend_foods = my_foods[:]<br></code></pre></td></tr></table></figure><p>如果直接用=赋值，相当于赋的指针，两个指针仍然指向同一个变量。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven&amp;Mabtis</title>
    <link href="/2022/06/25/Maven-Mabtis/"/>
    <url>/2022/06/25/Maven-Mabtis/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="Maven-amp-MyBatis"><a href="#Maven-amp-MyBatis" class="headerlink" title="Maven&amp;MyBatis"></a>Maven&amp;MyBatis</h1><h2 id="1-Maven"><a href="#1-Maven" class="headerlink" title="1.Maven"></a>1.Maven</h2><p>Maven是专门用于管理和构建Java项目的工具，它的主要功能有：</p><ul><li><p>提供了一套标准化的项目结构</p></li><li><p>提供了一套标准化的构建流程（编译，测试，打包，发布……）</p></li><li><p>提供了一套依赖管理机制</p></li></ul><p><strong>标准化的项目结构：</strong></p><p>项目结构我们都知道，每一个开发工具（IDE）都有自己不同的项目结构，它们互相之间不通用。我再eclipse中创建的目录，无法在idea中进行使用，这就造成了很大的不方便。</p><p>而Maven提供了一套标准化的项目结构，所有的IDE使用Maven构建的项目完全一样，所以IDE创建的Maven项目可以通用。如下图右边就是Maven构建的项目结构。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623155158400.png" alt="image-20220623155158400"></p><p><strong>标准化的构建流程：</strong></p><p>我们开发一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。</p><p><strong>依赖管理：</strong></p><p>依赖管理其实就是管理你项目所依赖的第三方资源（jar包、插件）。如之前我们项目中需要使用JDBC和Druid的话，就需要去网上下载对应的依赖包，复制到项目中，还要将jar包加入工作环境这一系列的操作。如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623155540981.png" alt="image-20220623155540981"></p><p>而Maven使用标准的 ==坐标== 配置来管理各种依赖，只需要简单的配置就可以完成依赖管理。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623155827703.png" alt="image-20220623155827703"></p><p>如上图右边所示就是mysql驱动包的坐标，在项目中只需要写这段配置，其他都不需要我们担心，Maven都帮我们进行操作了。</p><p>市面上有很多构建工具，而Maven依旧还是主流构建工具。</p><h3 id="1-1-Maven简介"><a href="#1-1-Maven简介" class="headerlink" title="1.1  Maven简介"></a>1.1  Maven简介</h3><blockquote><p>==Apache Maven== 是一个项目管理和构建==工具==，它基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。</p><p>官网 ：<a href="http://maven.apache.org/">http://maven.apache.org/</a> </p></blockquote><p>通过上面的描述大家只需要知道Maven是一个工具即可。Apache 是一个开源组织，将来我们会学习很多Apache提供的项目。</p><h4 id="1-1-1-Maven模型"><a href="#1-1-1-Maven模型" class="headerlink" title="1.1.1  Maven模型"></a>1.1.1  Maven模型</h4><ul><li>项目对象模型 (Project Object Model)</li><li>依赖管理模型(Dependency)</li><li>插件(Plugin)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623160058779.png" alt="image-20220623160058779"></p><p>如上图所示就是Maven的模型，紫色框框起来的部分是用来完成 <code>标准化构建流程</code> 。如我们需要编译，Maven提供了一个编译插件供我们使用，我们需要打包，Maven就提供了一个打包插件提供我们使用等。</p><p>项目对象模型就是将我们自己抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623160434238.png" alt="image-20220623160434238"></p><p>依赖管理模型则是使用坐标来描述当前项目依赖哪儿些第三方jar包，上述Maven模型图中还有一部分是仓库。如何理解仓库呢？</p><h4 id="1-1-2-仓库"><a href="#1-1-2-仓库" class="headerlink" title="1.1.2  仓库"></a>1.1.2  仓库</h4><p>大家想想这样的场景，我们创建Maven项目，在项目中使用坐标来指定项目的依赖，那么依赖的jar包到底存储在什么地方呢？其实依赖jar包是存储在我们的本地仓库中。而项目运行时从本地仓库中拿需要的依赖jar包。</p><p><strong>仓库分类：</strong></p><ul><li><p>本地仓库：自己计算机上的一个目录</p></li><li><p>中央仓库：由Maven团队维护的全球唯一的仓库</p><ul><li>地址： <a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></li></ul></li><li><p>远程仓库(私服)：一般由公司团队搭建的私有仓库</p><p>今天我们只学习远程仓库的使用，并不会搭建。</p></li></ul><p>当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包：</p><ul><li><p>如果有，则在项目直接引用;</p></li><li><p>如果没有，则去中央仓库中下载对应的jar包到本地仓库。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623160547513.png" alt="image-20220623160547513"></p><p>如果还可以搭建远程仓库，将来jar包的查找顺序则变为：</p><blockquote><p>本地仓库 —&gt; 远程仓库—&gt; 中央仓库</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623160614307.png" alt="image-20220623160614307"></p><h3 id="1-2-Maven安装配置"><a href="#1-2-Maven安装配置" class="headerlink" title="1.2  Maven安装配置"></a>1.2  Maven安装配置</h3><ul><li><p>解压 apache-maven-3.6.1.rar 既安装完成</p><blockquote><p>建议解压缩到没有中文、特殊字符的路径下。如课程中解压缩到 <code>D:\software</code> 下。</p></blockquote><p>解压缩后的目录结构如下：</p><ul><li>bin目录 ： 存放的是可执行命令。mvn 命令重点关注。</li><li>conf目录 ：存放Maven的配置文件。<code>settings.xml</code> 配置文件后期需要修改。</li><li>lib目录 ：存放Maven依赖的jar包。Maven也是使用java开发的，所以它也依赖其他的jar包。</li></ul></li><li><p>配置环境变量 MAVEN_HOME 为安装路径的bin目录</p><p><code>此电脑</code> 右键  —&gt;  <code>高级系统设置</code>  —&gt;  <code>高级</code>  —&gt;  <code>环境变量</code></p><p>在系统变量处新建一个变量 <code>MAVEN_HOME</code></p><p>在 <code>Path</code> 中进行配置</p><p>打开命令提示符输入mvn -version进行验证，出现success表示安装成功</p></li><li><p>配置本地仓库</p><p>修改 conf/settings.xml 中的 <localRepository> 为一个指定目录作为本地仓库，用来存储jar包。</p></li><li><p>配置阿里云私服</p><p>中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。</p><p>修改 conf/settings.xml 中的 <mirrors>标签，为其添加如下子标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>          <br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="1-3-Maven基本使用"><a href="#1-3-Maven基本使用" class="headerlink" title="1.3  Maven基本使用"></a>1.3  Maven基本使用</h3><h4 id="1-3-1-Maven-常用命令"><a href="#1-3-1-Maven-常用命令" class="headerlink" title="1.3.1  Maven 常用命令"></a>1.3.1  Maven 常用命令</h4><blockquote><ul><li><p>compile ：编译</p></li><li><p>clean：清理</p></li><li><p>test：测试</p></li><li><p>package：打包</p></li><li><p>install：安装</p></li></ul></blockquote><h4 id="1-3-2-Maven-生命周期"><a href="#1-3-2-Maven-生命周期" class="headerlink" title="1.3.2  Maven 生命周期"></a>1.3.2  Maven 生命周期</h4><p>Maven 构建项目生命周期描述的是一次构建过程经历经历了多少个事件</p><p>Maven 对项目构建的生命周期划分为3套：</p><ul><li>clean ：清理工作。</li><li>default ：核心工作，例如编译，测试，打包，安装等。</li><li>site ： 产生报告，发布站点等。这套声明周期一般不会使用。</li></ul><p>同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。例如默认（default）生命周期如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623160943179.png" alt="image-20220623160943179"></p><p>当我们执行 <code>install</code>（安装）命令时，它会先执行 <code>compile</code>命令，再执行 <code>test</code> 命令，再执行 <code>package</code> 命令，最后执行 <code>install</code> 命令。</p><p>当我们执行 <code>package</code> （打包）命令时，它会先执行 <code>compile</code> 命令，再执行 <code>test</code> 命令，最后执行 <code>package</code> 命令。</p><p>默认的生命周期也有对应的很多命令，其他的一般都不会使用，我们只关注常用的。</p><h3 id="1-4-IDEA使用Maven"><a href="#1-4-IDEA使用Maven" class="headerlink" title="1.4  IDEA使用Maven"></a>1.4  IDEA使用Maven</h3><p>以后开发中我们肯定会在高级开发工具中使用Maven管理项目，而我们常用的高级开发工具是IDEA，所以接下来我们会讲解Maven在IDEA中的使用。</p><h4 id="1-4-1-Maven-坐标详解"><a href="#1-4-1-Maven-坐标详解" class="headerlink" title="1.4.1  Maven 坐标详解"></a>1.4.1  Maven 坐标详解</h4><p><strong>什么是坐标？</strong></p><ul><li>Maven 中的坐标是==资源的唯一标识==</li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul><p><strong>Maven 坐标主要组成</strong></p><ul><li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</li><li>artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）</li><li>version：定义当前项目版本号</li></ul><p>如下图就是使用坐标表示一个项目：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623161206142.png" alt="image-20220623161206142"></p><blockquote><p>==注意：==</p><ul><li>上面所说的资源可以是插件、依赖、当前项目。</li><li>我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。</li></ul></blockquote><h4 id="1-4-2-IDEA-导入-Maven项目"><a href="#1-4-2-IDEA-导入-Maven项目" class="headerlink" title="1.4.2  IDEA 导入 Maven项目"></a>1.4.2  IDEA 导入 Maven项目</h4><p>大家在学习时可能需要看老师的代码，当然也就需要将老师的代码导入到自己的IDEA中。我们可以通过以下步骤进行项目的导入：</p><ul><li><p>选择右侧Maven面板，点击 + 号</p></li><li><p>选中对应项目的pom.xml文件，双击即可</p></li><li><p>如果没有Maven面板，选择</p><p>View —&gt; Appearance —&gt; Tool Window Bars</p></li></ul><p><strong>配置 Maven-Helper 插件</strong> </p><ul><li><p>选择 IDEA中 File —&gt; Settings</p></li><li><p>选择 Plugins</p></li><li><p>搜索 Maven，选择第一个 Maven Helper，点击Install安装，弹出面板中点击Accept</p></li><li><p>重启 IDEA</p></li></ul><p>安装完该插件后可以通过 选中项目右键进行相关命令操作。</p><h3 id="1-5-依赖管理"><a href="#1-5-依赖管理" class="headerlink" title="1.5  依赖管理"></a>1.5  依赖管理</h3><h4 id="1-5-1-使用坐标引入jar包"><a href="#1-5-1-使用坐标引入jar包" class="headerlink" title="1.5.1  使用坐标引入jar包"></a>1.5.1  使用坐标引入jar包</h4><p><strong>使用坐标引入jar包的步骤：</strong></p><ul><li><p>在项目的 pom.xml 中编写 <dependencies> 标签</p></li><li><p>在 <dependencies> 标签中 使用 <dependency> 引入坐标</p></li><li><p>定义坐标的 groupId，artifactId，version</p></li><li><p>点击刷新按钮，使坐标生效</p></li></ul><blockquote><p> 注意：</p><ul><li>具体的坐标我们可以到如下网站进行搜索</li><li><a href="https://mvnrepository.com/">https://mvnrepository.com/</a></li></ul></blockquote><p>==<strong>快捷方式导入jar包的坐标：</strong>==</p><p>每次需要引入jar包，都去对应的网站进行搜索是比较麻烦的，接下来给大家介绍一种快捷引入坐标的方式</p><ul><li><p>在 pom.xml 中 按 alt + insert，选择 Dependency</p></li><li><p>在弹出的面板中搜索对应坐标，然后双击选中对应坐标</p></li><li><p>点击刷新按钮，使坐标生效</p></li></ul><p><strong>自动导入设置：</strong></p><p>上面每次操作都需要点击刷新按钮，让引入的坐标生效。当然我们也可以通过设置让其自动完成</p><ul><li><p>选择 IDEA中 File —&gt; Settings</p></li><li><p>在弹出的面板中找到 Build Tools</p></li><li><p>选择 Any changes，点击 ok 即可生效</p></li></ul><h4 id="1-5-2-依赖范围"><a href="#1-5-2-依赖范围" class="headerlink" title="1.5.2  依赖范围"></a>1.5.2  依赖范围</h4><p>通过设置坐标的依赖范围(scope)，可以设置对应jar包的作用范围：编译环境、测试环境、运行环境。</p><p>如下图所示给 <code>junit</code> 依赖通过 <code>scope</code> 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623161514148.png" alt="image-20220623161514148"></p><p>那么 <code>scope</code> 都可以有哪些取值呢？</p><div class="table-container"><table><thead><tr><th><strong>依赖范围</strong></th><th>编译classpath</th><th>测试classpath</th><th>运行classpath</th><th>例子</th></tr></thead><tbody><tr><td><strong>compile</strong></td><td>Y</td><td>Y</td><td>Y</td><td>logback</td></tr><tr><td><strong>test</strong></td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td><strong>provided</strong></td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td><strong>runtime</strong></td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr><tr><td><strong>system</strong></td><td>Y</td><td>Y</td><td>-</td><td>存储在本地的jar包</td></tr></tbody></table></div><ul><li>compile ：作用于编译环境、测试环境、运行环境。</li><li>test ： 作用于测试环境。典型的就是Junit坐标，以后使用Junit时，都会将scope指定为该值</li><li>provided ：作用于编译环境、测试环境。我们后面会学习 <code>servlet-api</code> ，在使用它时，必须将 <code>scope</code> 设置为该值，不然运行时就会报错</li><li>runtime  ： 作用于测试环境、运行环境。jdbc驱动一般将 <code>scope</code> 设置为该值，当然不设置也没有任何问题 </li></ul><blockquote><p>注意：</p><ul><li>如果引入坐标不指定 <code>scope</code> 标签时，默认就是 compile  值。以后大部分jar包都是使用默认值。</li></ul></blockquote><h2 id="2-Mybatis"><a href="#2-Mybatis" class="headerlink" title="2.Mybatis"></a>2.Mybatis</h2><h3 id="2-1-Mybatis概述"><a href="#2-1-Mybatis概述" class="headerlink" title="2.1  Mybatis概述"></a>2.1  Mybatis概述</h3><h4 id="2-1-1-Mybatis概念"><a href="#2-1-1-Mybatis概念" class="headerlink" title="2.1.1  Mybatis概念"></a>2.1.1  Mybatis概念</h4><blockquote><ul><li><p>MyBatis 是一款优秀的==持久层框架==，用于简化 JDBC 开发</p></li><li><p>MyBatis 本是 Apache 的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github</p></li><li><p>官网：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a> </p></li></ul></blockquote><p><strong>持久层：</strong></p><ul><li><p>负责将数据到保存到数据库的那一层代码。</p><p>以后开发我们会将操作数据库的Java代码作为持久层。而Mybatis就是对jdbc代码进行了封装。</p></li><li><p>JavaEE三层架构：表现层、业务层、持久层</p><p>三层架构在后期会给大家进行讲解，今天先简单的了解下即可。</p></li></ul><p><strong>框架：</strong></p><ul><li>框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型</li><li>在框架的基础之上构建软件编写更加高效、规范、通用、可扩展</li></ul><p>举例给大家简单的解释一下什么是半成品软件。大家小时候应该在公园见过给石膏娃娃涂鸦，石膏娃娃就是一个半成品。你可以在这个半成品的基础上进行不同颜色的涂鸦。</p><p>了解了什么是Mybatis后，接下来说说以前 <code>JDBC代码</code> 的缺点以及Mybatis又是如何解决的。</p><h4 id="2-1-2-JDBC-缺点"><a href="#2-1-2-JDBC-缺点" class="headerlink" title="2.1.2  JDBC 缺点"></a>2.1.2  JDBC 缺点</h4><p>下面是 JDBC 代码，我们通过该代码分析都存在什么缺点：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623161819227.png" alt="image-20220623161819227"></p><ul><li><p>硬编码</p><ul><li><p>注册驱动、获取连接</p><p>上图标1的代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要将Mysql数据库换成其他的关系型数据库的话，这四个地方都需要修改，如果放在此处就意味着要修改我们的源代码。</p></li><li><p>SQL语句</p><p>上图标2的代码。如果表结构发生变化，SQL语句就要进行更改。这也不方便后期的维护。</p></li></ul></li><li><p>操作繁琐</p><ul><li><p>手动设置参数</p></li><li><p>手动封装结果集</p><p>上图标4的代码是对查询到的数据进行封装，而这部分代码是没有什么技术含量，而且特别耗费时间的。</p></li></ul></li></ul><h4 id="2-1-3-Mybatis-优化"><a href="#2-1-3-Mybatis-优化" class="headerlink" title="2.1.3  Mybatis 优化"></a>2.1.3  Mybatis 优化</h4><ul><li>硬编码可以配置到==配置文件==</li><li>操作繁琐的地方mybatis都==自动完成==</li></ul><p>如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623161927456.png" alt="image-20220623161927456"></p><h3 id="2-2-Mybatis快速入门"><a href="#2-2-Mybatis快速入门" class="headerlink" title="2.2  Mybatis快速入门"></a>2.2  Mybatis快速入门</h3><p><strong>需求：查询user表中所有的数据</strong></p><ul><li><p>创建user表，添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database mybatis;<br>use mybatis;<br><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> tb_user;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_user(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>username <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>password <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>),<br>addr <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>)<br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_user <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_user <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;234&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-string">&#x27;天津&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_user <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-string">&#x27;11&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;西安&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>创建模块，导入坐标</p><p>在创建好的模块中的 pom.xml 配置文件中添加依赖的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mybatis 依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--mysql 驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.46<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--junit 单元测试--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 添加slf4j日志api --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 添加logback-classic依赖 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 添加logback-core依赖 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：需要在项目的 resources 目录下创建logback的配置文件</p></li><li><p>编写 MyBatis 核心配置文件 — &gt; 替换连接信息 解决硬编码问题</p><p>在模块下的 resources 目录下创建mybatis的配置文件 <code>mybatis-config.xml</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.itheima.pojo&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--数据库连接信息--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--数据库连接信息--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--加载sql映射文件--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;UserMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编写 SQL 映射文件 —&gt; 统一管理sql语句，解决硬编码问题</p><p>在模块的 <code>resources</code> 目录下创建映射配置文件 <code>UserMapper.xml</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.User&quot;</span>&gt;</span><br>        select * from tb_user;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>编码</p><ul><li><p>在 <code>com.itheima.pojo</code> 包下创建 User类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> String gender;<br>    <span class="hljs-keyword">private</span> String addr;<br>    <br>    <span class="hljs-comment">//省略了 setter 和 getter</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 <code>com.itheima</code> 包下编写 MybatisDemo 测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//1. 加载mybatis的核心配置文件，获取 SqlSessionFactory</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br><br>        <span class="hljs-comment">//2. 获取SqlSession对象，用它来执行sql</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>        <span class="hljs-comment">//3. 执行sql</span><br>        List&lt;User&gt; users = sqlSession.selectList(<span class="hljs-string">&quot;test.selectAll&quot;</span>); <span class="hljs-comment">//参数是一个字符串，该字符串必须是映射配置文件的namespace.id</span><br>        System.out.println(users);<br>        <span class="hljs-comment">//4. 释放资源</span><br>        sqlSession.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><p><strong>解决SQL映射文件的警告提示：</strong></p><p>在入门案例映射配置文件中存在报红的情况。问题如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624131703334.png" alt="image-20220624131703334"></p><ul><li>产生的原因：Idea和数据库没有建立连接，不识别表信息。但是大家一定要记住，它并不影响程序的执行。</li><li>解决方式：在Idea中配置MySQL数据库连接。</li></ul><p>IDEA中配置MySQL数据库连接</p><ul><li><p>点击IDEA右边框的 <code>Database</code> ，在展开的界面点击 <code>+</code> 选择 <code>Data Source</code> ，再选择 <code>MySQL</code></p></li><li><p>在弹出的界面进行基本信息的填写</p></li><li><p>点击完成后就能看到数据库界面</p><p>而此界面就和 <code>navicat</code> 工具一样可以进行数据库的操作。也可以编写SQL语句</p></li></ul><h3 id="2-3-Mapper代理开发"><a href="#2-3-Mapper代理开发" class="headerlink" title="2.3  Mapper代理开发"></a>2.3  Mapper代理开发</h3><h4 id="2-3-1-Mapper代理开发概述"><a href="#2-3-1-Mapper代理开发概述" class="headerlink" title="2.3.1  Mapper代理开发概述"></a>2.3.1  Mapper代理开发概述</h4><p>之前我们写的代码是基本使用方式，它也存在硬编码的问题，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624131830769.png" alt="image-20220624131830769"></p><p>这里调用 <code>selectList()</code> 方法传递的参数是映射配置文件中的 namespace.id值。这样写也不便于后期的维护。如果使用 Mapper 代理方式（如下图）则不存在硬编码问题。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624134743717.png" alt="image-20220624134743717"></p><p>通过上面的描述可以看出 Mapper 代理方式的目的：</p><ul><li>解决原生方式中的硬编码</li><li>简化后期执行SQL</li></ul><p>Mybatis 官网也是推荐使用 Mapper 代理的方式。</p><h4 id="2-3-2-使用Mapper代理要求"><a href="#2-3-2-使用Mapper代理要求" class="headerlink" title="2.3.2  使用Mapper代理要求"></a>2.3.2  使用Mapper代理要求</h4><p>使用Mapper代理方式，必须满足以下要求：</p><ul><li><p>定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624135545113.png" alt="image-20220624135545113" style="zoom:50%;" /></p></li><li><p>设置SQL映射文件的namespace属性为Mapper接口全限定名</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624135611903.png" alt="image-20220624135611903"></p></li><li><p>在 Mapper 接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624135757618.png" alt="image-20220624135757618"></p></li></ul><h4 id="2-3-3-案例代码实现"><a href="#2-3-3-案例代码实现" class="headerlink" title="2.3.3  案例代码实现"></a>2.3.3  案例代码实现</h4><ul><li><p>在 <code>com.itheima.mapper</code> 包下创建 UserMapper接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    List&lt;User&gt; <span class="hljs-title function_">selectAll</span><span class="hljs-params">()</span>;<br>    User <span class="hljs-title function_">selectById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 <code>resources</code> 下创建 <code>com/itheima/mapper</code> 目录，并在该目录下创建 UserMapper.xml 映射配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    namespace:名称空间。必须是对应接口的全限定名</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.User&quot;</span>&gt;</span><br>        select *<br>        from tb_user;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在 <code>com.itheima</code> 包下创建 MybatisDemo2 测试类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Mybatis 代理开发</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisDemo2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">//1. 加载mybatis的核心配置文件，获取 SqlSessionFactory</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br><br>        <span class="hljs-comment">//2. 获取SqlSession对象，用它来执行sql</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>        <span class="hljs-comment">//3. 执行sql</span><br>        <span class="hljs-comment">//3.1 获取UserMapper接口的代理对象</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        List&lt;User&gt; users = userMapper.selectAll();<br><br>        System.out.println(users);<br>        <span class="hljs-comment">//4. 释放资源</span><br>        sqlSession.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>==注意：==</p><p>如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载。也就是将核心配置文件的加载映射配置文件的配置修改为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--加载sql映射文件--&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt;--&gt;</span><br>    <span class="hljs-comment">&lt;!--Mapper代理方式--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.itheima.mapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-4-核心配置文件"><a href="#2-4-核心配置文件" class="headerlink" title="2.4  核心配置文件"></a>2.4  核心配置文件</h3><p>核心配置文件中现有的配置之前已经给大家进行了解释，而核心配置文件中还可以配置很多内容。我们可以通过查询官网看可以配置的内容</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624140201708.png" alt="image-20220624140201708"></p><p>接下来我们先对里面的一些配置进行讲解。</p><h4 id="2-4-1-多环境配置"><a href="#2-4-1-多环境配置" class="headerlink" title="2.4.1  多环境配置"></a>2.4.1  多环境配置</h4><p>在核心配置文件的 <code>environments</code> 标签中其实是可以配置多个 <code>environment</code> ，使用 <code>id</code> 给每段环境起名，在 <code>environments</code> 中使用 <code>default=&#39;环境id&#39;</code> 来指定使用哪段配置。我们一般就配置一个 <code>environment</code> 即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--数据库连接信息--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--数据库连接信息--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1234&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-4-2-类型别名"><a href="#2-4-2-类型别名" class="headerlink" title="2.4.2  类型别名"></a>2.4.2  类型别名</h4><p>在映射配置文件中的 <code>resultType</code> 属性需要配置数据封装的类型（类的全限定名）。而每次这样写是特别麻烦的，Mybatis 提供了 <code>类型别名</code>(typeAliases) 可以简化这部分的书写。</p><p>首先需要现在核心配置文件中配置类型别名，也就意味着给pojo包下所有的类起了别名（别名就是类名），不区分大小写。内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--name属性的值是实体类所在包--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.itheima.pojo&quot;</span>/&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过上述的配置，我们就可以简化映射配置文件中 <code>resultType</code> 属性值的编写</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>        select * from tb_user;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="Mybatis练习"><a href="#Mybatis练习" class="headerlink" title="Mybatis练习"></a>Mybatis练习</h1><p><strong>目标</strong></p><blockquote><ul><li>能够使用映射配置文件实现CRUD操作</li><li>能够使用注解实现CRUD操作</li></ul></blockquote><h2 id="1-配置文件实现CRUD"><a href="#1-配置文件实现CRUD" class="headerlink" title="1.配置文件实现CRUD"></a>1.配置文件实现CRUD</h2><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624145701637.png" alt="image-20220624145701637"></p><p>如上图所示产品原型，里面包含了品牌数据的 <code>查询</code> 、<code>按条件查询</code>、<code>添加</code>、<code>删除</code>、<code>批量删除</code>、<code>修改</code> 等功能，而这些功能其实就是对数据库表中的数据进行CRUD操作。接下来我们就使用Mybatis完成品牌数据的增删改查操作。以下是我们要完成功能列表：</p><blockquote><ul><li>查询<ul><li>查询所有数据</li><li>查询详情</li><li>条件查询</li></ul></li><li>添加</li><li>修改<ul><li>修改全部字段</li><li>修改动态字段</li></ul></li><li>删除<ul><li>删除一个</li><li>批量删除</li></ul></li></ul></blockquote><p>我们先将必要的环境准备一下。</p><h3 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1  环境准备"></a>1.1  环境准备</h3><ul><li><p>数据库表（tb_brand）及数据准备</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除tb_brand表</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> tb_brand;<br><span class="hljs-comment">-- 创建tb_brand表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_brand<br>(<br>    <span class="hljs-comment">-- id 主键</span><br>    id           <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    <span class="hljs-comment">-- 品牌名称</span><br>    brand_name   <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-comment">-- 企业名称</span><br>    company_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-comment">-- 排序字段</span><br>    ordered      <span class="hljs-type">int</span>,<br>    <span class="hljs-comment">-- 描述信息</span><br>    description  <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>    <span class="hljs-comment">-- 状态：0：禁用  1：启用</span><br>    status       <span class="hljs-type">int</span><br>);<br><span class="hljs-comment">-- 添加数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_brand (brand_name, company_name, ordered, description, status)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;三只松鼠&#x27;</span>, <span class="hljs-string">&#x27;三只松鼠股份有限公司&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;好吃不上火&#x27;</span>, <span class="hljs-number">0</span>),<br>       (<span class="hljs-string">&#x27;华为&#x27;</span>, <span class="hljs-string">&#x27;华为技术有限公司&#x27;</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#x27;</span>, <span class="hljs-number">1</span>),<br>       (<span class="hljs-string">&#x27;小米&#x27;</span>, <span class="hljs-string">&#x27;小米科技有限公司&#x27;</span>, <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;are you ok&#x27;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p>实体类 Brand</p><p>在 <code>com.itheima.pojo</code> 包下创建 Brand 实体类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Brand</span> &#123;<br>    <span class="hljs-comment">// id 主键</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-comment">// 品牌名称</span><br>    <span class="hljs-keyword">private</span> String brandName;<br>    <span class="hljs-comment">// 企业名称</span><br>    <span class="hljs-keyword">private</span> String companyName;<br>    <span class="hljs-comment">// 排序字段</span><br>    <span class="hljs-keyword">private</span> Integer ordered;<br>    <span class="hljs-comment">// 描述信息</span><br>    <span class="hljs-keyword">private</span> String description;<br>    <span class="hljs-comment">// 状态：0：禁用  1：启用</span><br>    <span class="hljs-keyword">private</span> Integer status;<br>    <br>    <span class="hljs-comment">//省略 setter and getter。自己写时要补全这部分代码</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>编写测试用例</p><p>测试代码需要在 <code>test/java</code> 目录下创建包及测试用例。项目结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624151011848.png" alt="image-20220624151011848" style="zoom:50%;" /></p></li><li><p>安装 MyBatisX 插件</p><ul><li><p>MybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。</p></li><li><p>主要功能</p><ul><li>XML映射配置文件 和 接口方法 间相互跳转</li><li>根据接口方法生成 statement </li></ul></li><li><p>安装方式</p><p>在IDEA内安装。</p><blockquote><p>注意：安装完毕后需要重启IDEA</p></blockquote></li><li><p>插件效果</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624151214375.png" alt="image-20220624151214375"></p><p>红色头绳的表示映射配置文件，蓝色头绳的表示mapper接口。在mapper接口点击红色头绳的小鸟图标会自动跳转到对应的映射配置文件，在映射配置文件中点击蓝色头绳的小鸟图标会自动跳转到对应的mapper接口。也可以在mapper接口中定义方法，自动生成映射配置文件中的 <code>statement</code> ，如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624151250630.png" alt="image-20220624151250630"></p></li></ul></li></ul><h3 id="1-2-查询所有数据"><a href="#1-2-查询所有数据" class="headerlink" title="1.2  查询所有数据"></a>1.2  查询所有数据</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624161818058.png" alt="image-20220624161818058"></p><p>如上图所示就页面上展示的数据，而这些数据需要从数据库进行查询。接下来我们就来讲查询所有数据功能，而实现该功能我们分以下步骤进行实现：</p><ul><li><p>编写接口方法：Mapper接口</p><ul><li><p>参数：无</p><p>查询所有数据功能是不需要根据任何条件进行查询的，所以此方法不需要参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Brand&gt; <span class="hljs-title function_">selectAll</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li><li><p>结果：List<Brand></p><p>我们会将查询出来的每一条数据封装成一个 <code>Brand</code> 对象，而多条数据封装多个 <code>Brand</code> 对象，需要将这些对象封装到List集合中返回。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;brand&quot;</span>&gt;</span><br>select *<br>        from tb_brand;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>执行方法、测试</p></li></ul></li></ul><h4 id="1-2-1-编写接口方法"><a href="#1-2-1-编写接口方法" class="headerlink" title="1.2.1  编写接口方法"></a>1.2.1  编写接口方法</h4><p>在 <code>com.itheima.mapper</code> 包写创建名为 <code>BrandMapper</code> 的接口。并在该接口中定义 <code>List&lt;Brand&gt; selectAll()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BrandMapper</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询所有</span><br><span class="hljs-comment">     */</span><br>    List&lt;Brand&gt; <span class="hljs-title function_">selectAll</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-2-编写SQL语句"><a href="#1-2-2-编写SQL语句" class="headerlink" title="1.2.2  编写SQL语句"></a>1.2.2  编写SQL语句</h4><p>在 <code>reources</code> 下创建 <code>com/itheima/mapper</code> 目录结构，并在该目录下创建名为 <code>BrandMapper.xml</code> 的映射配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mapper.BrandMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;brand&quot;</span>&gt;</span><br>        select *<br>        from tb_brand;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-2-3-编写测试方法"><a href="#1-2-3-编写测试方法" class="headerlink" title="1.2.3  编写测试方法"></a>1.2.3  编写测试方法</h4><p>在 <code>MybatisTest</code> 类中编写测试查询所有的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br><br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br><br>    <span class="hljs-comment">//4. 执行方法</span><br>    List&lt;Brand&gt; brands = brandMapper.selectAll();<br>    System.out.println(brands);<br><br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：现在我们感觉测试这部分代码写起来特别麻烦，我们可以先忍忍。以后我们只会写上面的第3步的代码，其他的都不需要我们来完成。</p></blockquote><p>执行测试方法结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624163322311.png" alt="image-20220624163322311"></p><p>从上面结果我们看到了问题，有些数据封装成功了，而有些数据并没有封装成功。为什么这样呢？</p><p>这个问题可以通过两种方式进行解决：</p><ul><li>给字段起别名</li><li>使用resultMap定义字段和属性的映射关系</li></ul><h4 id="1-2-4-起别名解决上述问题"><a href="#1-2-4-起别名解决上述问题" class="headerlink" title="1.2.4  起别名解决上述问题"></a>1.2.4  起别名解决上述问题</h4><p>从上面结果可以看到 <code>brandName</code> 和 <code>companyName</code> 这两个属性的数据没有封装成功，查询 实体类 和 表中的字段 发现，在实体类中属性名是 <code>brandName</code> 和 <code>companyName</code> ，而表中的字段名为 <code>brand_name</code> 和 <code>company_name</code>，如下图所示 。那么我们只需要保持这两部分的名称一致这个问题就迎刃而解。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624164419703.png" alt="image-20220624164419703"></p><p>我们可以在写sql语句时给这两个字段起别名，将别名定义成和属性名一致即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;brand&quot;</span>&gt;</span><br>    select<br>    id, brand_name as brandName, company_name as companyName, ordered, description, status<br>    from tb_brand;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>而上面的SQL语句中的字段列表书写麻烦，如果表中还有更多的字段，同时其他的功能也需要查询这些字段时就显得我们的代码不够精炼。Mybatis提供了<code>sql</code> 片段可以提高sql的复用性。</p><p><strong>SQL片段：</strong></p><ul><li><p>将需要复用的SQL片段抽取到 <code>sql</code> 标签中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;brand_column&quot;</span>&gt;</span><br>id, brand_name as brandName, company_name as companyName, ordered, description, status<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><p>id属性值是唯一标识，引用时也是通过该值进行引用。</p></li><li><p>在原sql语句中进行引用</p><p>使用 <code>include</code> 标签引用上述的 SQL 片段，而 <code>refid</code> 指定上述 SQL 片段的id值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;brand&quot;</span>&gt;</span><br>    select<br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;brand_column&quot;</span> /&gt;</span><br>    from tb_brand;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="1-2-5-使用resultMap解决上述问题"><a href="#1-2-5-使用resultMap解决上述问题" class="headerlink" title="1.2.5  使用resultMap解决上述问题"></a>1.2.5  使用resultMap解决上述问题</h4><p>起别名 + sql片段的方式可以解决上述问题，但是它也存在问题。如果还有功能只需要查询部分字段，而不是查询所有字段，那么我们就需要再定义一个 SQL 片段，这就显得不是那么灵活。</p><p>那么我们也可以使用resultMap来定义字段和属性的映射关系的方式解决上述问题。</p><ul><li><p>在映射配置文件中使用resultMap定义 字段 和 属性 的映射关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;brand&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            id：完成主键字段的映射</span><br><span class="hljs-comment">                column：表的列名</span><br><span class="hljs-comment">                property：实体类的属性名</span><br><span class="hljs-comment">            result：完成一般字段的映射</span><br><span class="hljs-comment">                column：表的列名</span><br><span class="hljs-comment">                property：实体类的属性名</span><br><span class="hljs-comment">        --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;brand_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;brandName&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;company_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;companyName&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：在上面只需要定义 字段名 和 属性名 不一样的映射，而一样的则不需要专门定义出来。</p></blockquote></li><li><p>SQL语句正常编写</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="1-2-6-小结"><a href="#1-2-6-小结" class="headerlink" title="1.2.6  小结"></a>1.2.6  小结</h4><p>实体类属性名 和 数据库表列名 不一致，不能自动封装数据</p><ul><li>==起别名：==在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样<ul><li>可以定义 <sql>片段，提升复用性 </li><li>缺点：不灵活</li></ul></li><li>==resultMap：==定义<resultMap> 完成不一致的属性名和列名的映射<ul><li>定义<code>&lt;resultMap&gt;</code>标签</li><li>在<code>&lt;select&gt;</code>标签中，使用<resultMap> 属性替换<resultType> 属性</li></ul></li></ul><p>而我们最终选择使用 resultMap的方式。查询映射配置文件中查询所有的 statement 书写如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;brand&quot;</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            id：完成主键字段的映射</span><br><span class="hljs-comment">                column：表的列名</span><br><span class="hljs-comment">                property：实体类的属性名</span><br><span class="hljs-comment">            result：完成一般字段的映射</span><br><span class="hljs-comment">                column：表的列名</span><br><span class="hljs-comment">                property：实体类的属性名</span><br><span class="hljs-comment">        --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;brand_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;brandName&quot;</span>/&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;company_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;companyName&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-3-查询详情"><a href="#1-3-查询详情" class="headerlink" title="1.3  查询详情"></a>1.3  查询详情</h3><p>有些数据的属性比较多，在页面表格中无法全部实现，而只会显示部分，而其他属性数据的查询可以通过 <code>查看详情</code> 来进行查询，如上图所示。</p><p>查看详情功能实现步骤：</p><ul><li><p>编写接口方法：Mapper接口</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220624201503587.png" alt="image-20220624201503587"></p><ul><li><p>参数：id</p><p>查看详情就是查询某一行数据，所以需要根据id进行查询。而id以后是由页面传递过来。</p></li><li><p>结果：Brand</p><p>根据id查询出来的数据只要一条，而将一条数据封装成一个Brand对象即可</p></li></ul></li><li><p>编写SQL语句：SQL映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>        select *<br>        from tb_brand<br>        where id<br>         &lt;![CDATA[<br>            &lt;<br>         ]]&gt;<br>         #&#123;id&#125;;<br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ul><li>执行方法、进行测试</li></ul><h4 id="1-3-1-编写接口方法"><a href="#1-3-1-编写接口方法" class="headerlink" title="1.3.1  编写接口方法"></a>1.3.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义根据id查询数据的方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 查看详情：根据Id查询</span><br><span class="hljs-comment">  */</span><br>Brand <span class="hljs-title function_">selectById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-3-2-编写SQL语句"><a href="#1-3-2-编写SQL语句" class="headerlink" title="1.3.2  编写SQL语句"></a>1.3.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写 <code>statement</code>，使用 <code>resultMap</code> 而不是使用 <code>resultType</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand where id = #&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：上述SQL中的 #{id}先这样写，一会我们再详细讲解</p></blockquote><h4 id="1-3-3-编写测试方法"><a href="#1-3-3-编写测试方法" class="headerlink" title="1.3.3  编写测试方法"></a>1.3.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//接收参数，该id以后需要传递过来</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br><br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br><br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br><br>    <span class="hljs-comment">//4. 执行方法</span><br>    <span class="hljs-type">Brand</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> brandMapper.selectById(id);<br>    System.out.println(brand);<br><br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行测试方法结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625114451200.png" alt="image-20220625114451200"></p><h4 id="1-3-4-参数占位符"><a href="#1-3-4-参数占位符" class="headerlink" title="1.3.4  参数占位符"></a>1.3.4  参数占位符</h4><p>查询到的结果很好理解就是id为1的这行数据。而这里我们需要看控制台显示的SQL语句，能看到使用？进行占位。说明我们在映射配置文件中的写的 <code>#&#123;id&#125;</code> 最终会被？进行占位。接下来我们就聊聊映射配置文件中的参数占位符。</p><p>mybatis提供了两种参数占位符：</p><ul><li><p>#{} ：执行SQL时，会将 #{} 占位符替换为？，将来自动设置参数值。从上述例子可以看出使用#{} 底层使用的是 <code>PreparedStatement</code></p></li><li><p>${} ：拼接SQL。底层使用的是 <code>Statement</code>，会存在SQL注入问题。如下图将 映射配置文件中的#{} 替换成 ${} 来看效果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand where id = $&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>重新运行查看结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625114522829.png" alt="image-20220625114522829"></p></li></ul><blockquote><p>===注意：从上面两个例子可以看出，以后开发我们使用 #{} 参数占位符。==</p></blockquote><h4 id="1-3-5-parameterType使用"><a href="#1-3-5-parameterType使用" class="headerlink" title="1.3.5  parameterType使用"></a>1.3.5  parameterType使用</h4><p>对于<strong>有参数的mapper接口方法</strong>，我们在映射配置文件中应该配置 <code>ParameterType</code> 来指定参数类型。只不过该属性都可以省略。如下图：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand where id = $&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-3-6-SQL语句中特殊字段处理"><a href="#1-3-6-SQL语句中特殊字段处理" class="headerlink" title="1.3.6  SQL语句中特殊字段处理"></a>1.3.6  SQL语句中特殊字段处理</h4><p>以后肯定会在SQL语句中写一下特殊字符，比如某一个字段大于某个值。但遇到非转义的字符就会出现报错，因为映射配置文件是xml类型的问题，而 &gt; &lt; 等这些字符在xml中有特殊含义，所以此时我们需要将这些符号进行转义，可以使用以下两种方式进行转义</p><ul><li><p>转义字符</p><p><code>&amp;lt;</code> 就是 <code>&lt;</code> 的转义字符。</p></li><li><p>&lt;![CDATA[内容]]&gt;</p><p>打一个CD回车，会自动出现该格式内容，将需要转义的字符直接打在里面即可。</p><p>字符较少用第一种，字符较多用第二种。</p></li></ul><h3 id="1-4-多条件查询"><a href="#1-4-多条件查询" class="headerlink" title="1.4  多条件查询"></a>1.4  多条件查询</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625114559067.png" alt="image-20220625114559067"></p><p>我们经常会遇到如上图所示的多条件查询，将多条件查询的结果展示在下方的数据列表中。而我们做这个功能需要分析最终的SQL语句应该是什么样，思考两个问题</p><ul><li>条件表达式怎么写</li><li>多个条件表达式如何连接</li></ul><p>条件字段 <code>企业名称</code>  和 <code>品牌名称</code> 需要进行模糊查询，所以条件应该是：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625114642572.png" alt="image-20220625114642572"></p><p>简单的分析后，我们来看功能实现的步骤：</p><ul><li>编写接口方法<ul><li>参数：所有查询条件</li><li>结果：List<Brand></li></ul></li><li><p>在映射配置文件中编写SQL语句</p></li><li><p>编写测试方法并执行</p></li></ul><h4 id="1-4-1-编写接口方法"><a href="#1-4-1-编写接口方法" class="headerlink" title="1.4.1  编写接口方法"></a>1.4.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义多条件查询的方法。</p><p>而该功能有三个参数，我们就需要考虑定义接口时，参数应该如何定义。Mybatis针对多参数有多种实现</p><ul><li><p>使用 <code>@Param(&quot;参数名称&quot;)</code> 标记每一个参数，在映射配置文件中就需要使用 <code>#&#123;参数名称&#125;</code> 进行占位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Brand&gt; <span class="hljs-title function_">selectByCondition</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;status&quot;)</span> <span class="hljs-type">int</span> status, <span class="hljs-meta">@Param(&quot;companyName&quot;)</span> String companyName,<span class="hljs-meta">@Param(&quot;brandName&quot;)</span> String brandName)</span>;<br></code></pre></td></tr></table></figure></li><li><p>将多个参数封装成一个 实体对象 ，将该实体对象作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，==里面的内容必须和实体类属性名保持一致==。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Brand&gt; <span class="hljs-title function_">selectByCondition</span><span class="hljs-params">(Brand brand)</span>;<br></code></pre></td></tr></table></figure></li><li><p>将多个参数封装到map集合中，将map集合作为接口的方法参数。该方式要求在映射配置文件的SQL中使用 <code>#&#123;内容&#125;</code> 时，==里面的内容必须和map集合中键的名称一致==。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">List&lt;Brand&gt; selectByCondition(<span class="hljs-built_in">Map</span> <span class="hljs-built_in">map</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="1-4-2-编写SQL语句"><a href="#1-4-2-编写SQL语句" class="headerlink" title="1.4.2  编写SQL语句"></a>1.4.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写 <code>statement</code>，使用 <code>resultMap</code> 而不是使用 <code>resultType</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByCondition&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand<br>    where status = #&#123;status&#125;<br>    and company_name like #&#123;companyName&#125;<br>    and brand_name like #&#123;brandName&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-4-3-编写测试方法"><a href="#1-4-3-编写测试方法" class="headerlink" title="1.4.3  编写测试方法"></a>1.4.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectByCondition</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//接收参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;华为&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;华为&quot;</span>;<br><br>    <span class="hljs-comment">// 处理参数</span><br>    companyName = <span class="hljs-string">&quot;%&quot;</span> + companyName + <span class="hljs-string">&quot;%&quot;</span>;<br>    brandName = <span class="hljs-string">&quot;%&quot;</span> + brandName + <span class="hljs-string">&quot;%&quot;</span>;<br><br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br><br>    <span class="hljs-comment">//4. 执行方法</span><br><span class="hljs-comment">//方式一 ：接口方法参数使用 @Param 方式调用的方法</span><br>    <span class="hljs-comment">//List&lt;Brand&gt; brands = brandMapper.selectByCondition(status, companyName, brandName);</span><br>    <span class="hljs-comment">//方式二 ：接口方法参数是 实体类对象 方式调用的方法</span><br>     <span class="hljs-comment">//封装对象</span><br>    <span class="hljs-comment">/* Brand brand = new Brand();</span><br><span class="hljs-comment">        brand.setStatus(status);</span><br><span class="hljs-comment">        brand.setCompanyName(companyName);</span><br><span class="hljs-comment">        brand.setBrandName(brandName);*/</span><br>    <br>    <span class="hljs-comment">//List&lt;Brand&gt; brands = brandMapper.selectByCondition(brand);</span><br>    <br>    <span class="hljs-comment">//方式三 ：接口方法参数是 map集合对象 方式调用的方法</span><br>    <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    map.put(<span class="hljs-string">&quot;status&quot;</span> , status);<br>    map.put(<span class="hljs-string">&quot;companyName&quot;</span>, companyName);<br>    map.put(<span class="hljs-string">&quot;brandName&quot;</span> , brandName);<br>    List&lt;Brand&gt; brands = brandMapper.selectByCondition(map);<br>    System.out.println(brands);<br><br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-4-动态SQL"><a href="#1-4-4-动态SQL" class="headerlink" title="1.4.4  动态SQL"></a>1.4.4  动态SQL</h4><p>上述功能实现存在很大的问题。用户在输入条件时，肯定不会所有的条件都填写，这个时候我们的SQL语句就不能那样写的</p><p>例如用户只输入 当前状态 时，SQL语句就是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_brand <span class="hljs-keyword">where</span> status <span class="hljs-operator">=</span> #&#123;status&#125;<br></code></pre></td></tr></table></figure><p>而用户如果只输入企业名称时，SQL语句就是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_brand <span class="hljs-keyword">where</span> company_name <span class="hljs-keyword">like</span> #&#123;companName&#125;<br></code></pre></td></tr></table></figure><p>而用户如果输入了 <code>当前状态</code> 和 <code>企业名称</code> 时，SQL语句又不一样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_brand <span class="hljs-keyword">where</span> status <span class="hljs-operator">=</span> #&#123;status&#125; <span class="hljs-keyword">and</span> company_name <span class="hljs-keyword">like</span> #&#123;companName&#125;<br></code></pre></td></tr></table></figure><p>针对上述的需要，Mybatis对动态SQL有很强大的支撑：</p><blockquote><ul><li><p>if</p></li><li><p>choose (when, otherwise)</p></li><li><p>trim (where, set)</p></li><li><p>foreach</p></li></ul></blockquote><p>我们先学习 if 标签和 where 标签：</p><ul><li><p>if 标签：条件判断</p><ul><li>test 属性：逻辑表达式</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByCondition&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand<br>    where 1=1<br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><br>            and status = #&#123;status&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span><br>            and company_name like #&#123;companyName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;brandName != null and brandName != &#x27;&#x27; &quot;</span>&gt;</span><br>            and brand_name like #&#123;brandName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如上的这种SQL语句就会根据传递的参数值进行动态的拼接。如果此时status和companyName有值那么就会值拼接这两个条件。</p><p>执行结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625114904988.png" alt="image-20220625114904988"></p><p>但是它也存在问题，如果此时给的参数值是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><span class="hljs-comment">// map.put(&quot;status&quot; , status);</span><br>map.put(<span class="hljs-string">&quot;companyName&quot;</span>, companyName);<br>map.put(<span class="hljs-string">&quot;brandName&quot;</span> , brandName);<br></code></pre></td></tr></table></figure><p>拼接的SQL语句就变成了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_brand <span class="hljs-keyword">where</span> <span class="hljs-keyword">and</span> company_name <span class="hljs-keyword">like</span> ? <span class="hljs-keyword">and</span> brand_name <span class="hljs-keyword">like</span> ?<br></code></pre></td></tr></table></figure><p>而上面的语句中 where 关键后直接跟 and 关键字，这就是一条错误的SQL语句。这个就可以使用 where 标签解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from tb_brand where 1=1 and company_name like ? and brand_name like ?<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>where 标签</p><ul><li>作用：<ul><li>替换where关键字</li><li>会动态的去掉第一个条件前的 and </li><li>如果所有的参数没有值则不加where关键字</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByCondition&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><br>            and status = #&#123;status&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span><br>            and company_name like #&#123;companyName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;brandName != null and brandName != &#x27;&#x27; &quot;</span>&gt;</span><br>            and brand_name like #&#123;brandName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：需要给每个条件前都加上 and 关键字。</p></blockquote></li></ul><h3 id="1-5-单个条件（动态SQL）"><a href="#1-5-单个条件（动态SQL）" class="headerlink" title="1.5 单个条件（动态SQL）"></a>1.5 单个条件（动态SQL）</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625114932820.png" alt="image-20220625114932820"></p><p>如上图所示，在查询时只能选择 <code>品牌名称</code>、<code>当前状态</code>、<code>企业名称</code> 这三个条件中的一个，但是用户到底选择哪儿一个，我们并不能确定。这种就属于单个条件的动态SQL语句。 </p><p>这种需求需要使用到  <code>choose（when，otherwise）标签</code>  实现，  而 <code>choose</code> 标签类似于Java 中的switch语句，<code>when</code> 标签类似于Java 中的case语句，<code>otherwise</code> 标签类似于Java 中的default语句。</p><p>通过一个案例来使用这些标签</p><h4 id="1-5-1-编写接口方法"><a href="#1-5-1-编写接口方法" class="headerlink" title="1.5.1  编写接口方法"></a>1.5.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义单条件查询的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 单条件动态查询</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> brand</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">  */</span><br>List&lt;Brand&gt; <span class="hljs-title function_">selectByConditionSingle</span><span class="hljs-params">(Brand brand)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-5-2-编写SQL语句"><a href="#1-5-2-编写SQL语句" class="headerlink" title="1.5.2  编写SQL语句"></a>1.5.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写 <code>statement</code>，使用 <code>resultMap</code> 而不是使用 <code>resultType</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByConditionSingle&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;brandResultMap&quot;</span>&gt;</span><br>    select *<br>    from tb_brand<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><span class="hljs-comment">&lt;!--相当于switch--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--相当于case--&gt;</span><br>                status = #&#123;status&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;companyName != null and companyName != &#x27;&#x27; &quot;</span>&gt;</span><span class="hljs-comment">&lt;!--相当于case--&gt;</span><br>                company_name like #&#123;companyName&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--相当于case--&gt;</span><br>                brand_name like #&#123;brandName&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>如果不加where标签，当无参数传入的时候，会出现语法错误，需要加上一个<otherwise> 1=1来作为默认值。</li></ul><h4 id="1-5-3-编写测试方法"><a href="#1-5-3-编写测试方法" class="headerlink" title="1.5.3  编写测试方法"></a>1.5.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectByConditionSingle</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//接收参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;华为&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;华为&quot;</span>;<br><br>    <span class="hljs-comment">// 处理参数</span><br>    companyName = <span class="hljs-string">&quot;%&quot;</span> + companyName + <span class="hljs-string">&quot;%&quot;</span>;<br>    brandName = <span class="hljs-string">&quot;%&quot;</span> + brandName + <span class="hljs-string">&quot;%&quot;</span>;<br><br>    <span class="hljs-comment">//封装对象</span><br>    <span class="hljs-type">Brand</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Brand</span>();<br>    <span class="hljs-comment">//brand.setStatus(status);</span><br>    brand.setCompanyName(companyName);<br>    <span class="hljs-comment">//brand.setBrandName(brandName);</span><br><br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br>    <span class="hljs-comment">//4. 执行方法</span><br>    List&lt;Brand&gt; brands = brandMapper.selectByConditionSingle(brand);<br>    System.out.println(brands);<br><br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行测试方法结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625115019803-20220625190611225.png" alt=""></p><h3 id="1-6-添加数据"><a href="#1-6-添加数据" class="headerlink" title="1.6  添加数据"></a>1.6  添加数据</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625115056454.png" alt="image-20220625115056454"></p><p>如上图是我们平时在添加数据时展示的页面，而我们在该页面输入想要的数据后添加 <code>提交</code> 按钮，就会将这些数据添加到数据库中。接下来我们就来实现添加数据的操作。</p><ul><li><p>编写接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Brand brand)</span>;<br></code></pre></td></tr></table></figure><p>参数：除了id之外的所有的数据。id对应的是表中主键值，而主键我们是 ==自动增长== 生成的。</p></li><li><p>编写SQL语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span><br>    insert into tb_brand (brand_name, company_name, ordered, description, status)<br>    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ul><li>编写测试方法并执行</li></ul><p>明确了该功能实现的步骤后，接下来我们进行具体的操作。</p><h4 id="1-6-1-编写接口方法"><a href="#1-6-1-编写接口方法" class="headerlink" title="1.6.1  编写接口方法"></a>1.6.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义添加方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 添加</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Brand brand)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-6-2-编写SQL语句"><a href="#1-6-2-编写SQL语句" class="headerlink" title="1.6.2  编写SQL语句"></a>1.6.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写添加数据的 <code>statement</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span><br>    insert into tb_brand (brand_name, company_name, ordered, description, status)<br>    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-6-3-编写测试方法"><a href="#1-6-3-编写测试方法" class="headerlink" title="1.6.3  编写测试方法"></a>1.6.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAdd</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//接收参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;波导手机&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;波导&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">description</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;手机中的战斗机&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ordered</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-comment">//封装对象</span><br>    <span class="hljs-type">Brand</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Brand</span>();<br>    brand.setStatus(status);<br>    brand.setCompanyName(companyName);<br>    brand.setBrandName(brandName);<br>    brand.setDescription(description);<br>    brand.setOrdered(ordered);<br><br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>    <span class="hljs-comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true); //设置自动提交事务，这种情况不需要手动提交事务了</span><br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br>    <span class="hljs-comment">//4. 执行方法</span><br>    brandMapper.add(brand);<br>    <span class="hljs-comment">//提交事务</span><br>    sqlSession.commit();<br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625115255092.png" alt="image-20220625115255092"></p><h4 id="1-6-4-添加-主键返回"><a href="#1-6-4-添加-主键返回" class="headerlink" title="1.6.4  添加-主键返回"></a>1.6.4  添加-主键返回</h4><p>在数据添加成功后，有时候需要获取插入数据库数据的主键（主键是自增长）。</p><p>比如：添加订单和订单项，一个订单对应多个订单项，并通过主键对两个表进行绑定。</p><p>订单数据存储在订单表中，订单项存储在订单项表中。</p><ul><li><p>添加订单数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addOrder&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    insert into tb_brand (brand_name, company_name, ordered, description, status)<br>    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>添加订单项数据，订单项中需要设置所属订单的id</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addOrder&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    insert into tb_brand (brand_name, company_name, ordered, description, status)<br>    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>明白了什么时候 <code>主键返回</code> 。接下来我们简单模拟一下，在添加完数据后打印id属性值，能打印出来说明已经获取到了。</p><p>我们将上面添加品牌数据的案例中映射配置文件里 <code>statement</code> 进行修改，如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    insert into tb_brand (brand_name, company_name, ordered, description, status)<br>    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>在 insert 标签上添加如下属性：</p><ul><li>useGeneratedKeys：是够获取自动增长的主键值。true表示获取</li><li>keyProperty  ：指定将获取到的主键值封装到哪个属性里</li></ul></blockquote><h3 id="1-7-修改"><a href="#1-7-修改" class="headerlink" title="1.7  修改"></a>1.7  修改</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625120113867.png" alt="image-20220625120113867"></p><p>如图所示是修改页面，用户在该页面书写需要修改的数据，点击 <code>提交</code> 按钮，就会将数据库中对应的数据进行修改。注意一点，如果哪个输入框没有输入内容，我们是将表中数据对应字段值替换为空白还是保留字段之前的值？答案肯定是保留之前的数据。</p><p>接下来我们就具体来实现</p><h4 id="1-7-1-编写接口方法"><a href="#1-7-1-编写接口方法" class="headerlink" title="1.7.1  编写接口方法"></a>1.7.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义修改方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 修改</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Brand brand)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>上述方法参数 Brand 就是封装了需要修改的数据，而id肯定是有数据的，这也是和添加方法的区别。</p></blockquote><h4 id="1-7-2-编写SQL语句"><a href="#1-7-2-编写SQL语句" class="headerlink" title="1.7.2  编写SQL语句"></a>1.7.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写修改数据的 <code>statement</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><br>    update tb_brand<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span><br>            brand_name = #&#123;brandName&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;companyName != null and companyName != &#x27;&#x27;&quot;</span>&gt;</span><br>            company_name = #&#123;companyName&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ordered != null&quot;</span>&gt;</span><br>            ordered = #&#123;ordered&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;description != null and description != &#x27;&#x27;&quot;</span>&gt;</span><br>            description = #&#123;description&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;status != null&quot;</span>&gt;</span><br>            status = #&#123;status&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where id = #&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><em>set</em> 标签可以用于动态包含需要更新的列，忽略其它不更新的列。</p><p>并且可以动态识别“，”，自动修改sql语法错误。</p></blockquote><h4 id="1-7-3-编写测试方法"><a href="#1-7-3-编写测试方法" class="headerlink" title="1.7.3  编写测试方法"></a>1.7.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//接收参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;波导手机&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;波导&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">description</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;波导手机,手机中的战斗机&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ordered</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><br>    <span class="hljs-comment">//封装对象</span><br>    <span class="hljs-type">Brand</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Brand</span>();<br>    brand.setStatus(status);<br>    <span class="hljs-comment">//        brand.setCompanyName(companyName);</span><br>    <span class="hljs-comment">//        brand.setBrandName(brandName);</span><br>    <span class="hljs-comment">//        brand.setDescription(description);</span><br>    <span class="hljs-comment">//        brand.setOrdered(ordered);</span><br>    brand.setId(id);<br><br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>    <span class="hljs-comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br>    <span class="hljs-comment">//4. 执行方法</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> brandMapper.update(brand);<br>    System.out.println(count);<br>    <span class="hljs-comment">//提交事务</span><br>    sqlSession.commit();<br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行测试方法结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625120806918.png" alt="image-20220625120806918"></p><p>从结果中SQL语句可以看出，只修改了 <code>status</code>  字段值，因为我们给的数据中只给Brand实体对象的 <code>status</code> 属性设置值了。这就是 <code>set</code> 标签的作用。</p><h3 id="1-8-删除一行数据"><a href="#1-8-删除一行数据" class="headerlink" title="1.8  删除一行数据"></a>1.8  删除一行数据</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625120834937.png" alt="image-20220625120834937"></p><p>如上图所示，每行数据后面都有一个 <code>删除</code> 按钮，当用户点击了该按钮，就会将改行数据删除掉。那我们就需要思考，这种删除是根据什么进行删除呢？是通过主键id删除，因为id是表中数据的唯一标识。</p><p>接下来就来实现该功能。</p><h4 id="1-8-1-编写接口方法"><a href="#1-8-1-编写接口方法" class="headerlink" title="1.8.1  编写接口方法"></a>1.8.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义根据id删除方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 根据id删除</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-8-2-编写SQL语句"><a href="#1-8-2-编写SQL语句" class="headerlink" title="1.8.2  编写SQL语句"></a>1.8.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写删除一行数据的 <code>statement</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteById&quot;</span>&gt;</span><br>    delete from tb_brand where id = #&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-8-3-编写测试方法"><a href="#1-8-3-编写测试方法" class="headerlink" title="1.8.3  编写测试方法"></a>1.8.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//接收参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br><br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>    <span class="hljs-comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br>    <span class="hljs-comment">//4. 执行方法</span><br>    brandMapper.deleteById(id);<br>    <span class="hljs-comment">//提交事务</span><br>    sqlSession.commit();<br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行过程只要没报错，直接到数据库查询数据是否还存在。</p><h3 id="1-9-批量删除"><a href="#1-9-批量删除" class="headerlink" title="1.9  批量删除"></a>1.9  批量删除</h3><p>用户可以选择多条数据，然后点击上面的 <code>删除</code> 按钮，就会删除数据库中对应的多行数据。</p><h4 id="1-9-1-编写接口方法"><a href="#1-9-1-编写接口方法" class="headerlink" title="1.9.1  编写接口方法"></a>1.9.1  编写接口方法</h4><p>在 <code>BrandMapper</code> 接口中定义删除多行数据的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 批量删除</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteByIds</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ids)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>参数是一个数组，数组中存储的是多条数据的id</p></blockquote><h4 id="1-9-2-编写SQL语句"><a href="#1-9-2-编写SQL语句" class="headerlink" title="1.9.2  编写SQL语句"></a>1.9.2  编写SQL语句</h4><p>在 <code>BrandMapper.xml</code> 映射配置文件中编写删除多条数据的 <code>statement</code>。</p><p>编写SQL时需要<strong>遍历数组</strong>来拼接SQL语句。Mybatis 提供了 <code>foreach</code> 标签供我们使用。</p><p><strong>foreach 标签</strong></p><p>用来迭代任何可迭代的对象（如数组，集合）。</p><ul><li><p>collection 属性：</p><ul><li><p>mybatis会将数组参数，封装为一个Map集合。</p><ul><li><p>默认：array = 数组，固定搭配</p></li><li><p>使用@Param注解改变map集合的默认key的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteByIds</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ids&quot;)</span> <span class="hljs-type">int</span>[] ids)</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>item 属性：本次迭代获取到的元素。</p></li><li><p>separator 属性：集合项迭代之间的分隔符。<code>foreach</code> 标签不会错误地添加多余的分隔符。也就是最后一次迭代不会加分隔符。</p></li><li><p>open 属性：该属性值是在拼接SQL语句之前拼接的语句，只会拼接一次</p></li><li><p>close 属性：该属性值是在拼接SQL语句拼接后拼接的语句，只会拼接一次</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">![](https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625115019803-20220625190611225.png)<span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByIds&quot;</span>&gt;</span><br>    delete from tb_brand where id<br>    in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;array&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    ;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>假如数组中的id数据是{1,2,3}，那么拼接后的sql语句就是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> tb_brand <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></blockquote><h4 id="1-9-3-编写测试方法"><a href="#1-9-3-编写测试方法" class="headerlink" title="1.9.3  编写测试方法"></a>1.9.3  编写测试方法</h4><p>在 <code>test/java</code> 下的 <code>com.itheima.mapper</code>  包下的 <code>MybatisTest类中</code> 定义测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteByIds</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//接收参数</span><br>    <span class="hljs-type">int</span>[] ids = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br><br>    <span class="hljs-comment">//1. 获取SqlSessionFactory</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>    <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>    <span class="hljs-comment">//2. 获取SqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br>    <span class="hljs-comment">//SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br>    <span class="hljs-comment">//3. 获取Mapper接口的代理对象</span><br>    <span class="hljs-type">BrandMapper</span> <span class="hljs-variable">brandMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BrandMapper.class);<br>    <span class="hljs-comment">//4. 执行方法</span><br>    brandMapper.deleteByIds(ids);<br>    <span class="hljs-comment">//提交事务</span><br>    sqlSession.commit();<br>    <span class="hljs-comment">//5. 释放资源</span><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-10-Mybatis参数传递"><a href="#1-10-Mybatis参数传递" class="headerlink" title="1.10  Mybatis参数传递"></a>1.10  Mybatis参数传递</h3><p>Mybatis 接口方法中可以接收各种各样的参数，如下：</p><ul><li><p>多个参数：封装为Map集合</p><p>Map.put(“arg0”,参数值1);</p><p>Map.put(“arg1”,参数值2);</p></li><li><p>单个参数：单个参数又可以是如下类型</p><ul><li>POJO 类型</li><li>Map 集合类型</li><li>Collection 集合类型</li><li>List 集合类型</li><li>Array 类型</li><li>其他类型</li></ul></li></ul><h4 id="1-10-1-多个参数"><a href="#1-10-1-多个参数" class="headerlink" title="1.10.1  多个参数"></a>1.10.1  多个参数</h4><p>如下面的代码，就是接收两个参数，而接收多个参数需要使用 <code>@Param</code> 注解，那么为什么要加该注解呢？这个问题要弄明白就必须来研究Mybatis 底层对于这些参数是如何处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String username,<span class="hljs-meta">@Param(&quot;password&quot;)</span> String password)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>select *<br>    from tb_user<br>    where <br>    username=#&#123;username&#125;<br>    and password=#&#123;password&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们在接口方法中定义多个参数，Mybatis 会将这些参数封装成 Map 集合对象，值就是参数值，而键在没有使用 <code>@Param</code> 注解时有以下命名规则：</p><ul><li><p>以 arg 开头  ：第一个参数就叫 arg0，第二个参数就叫 arg1，以此类推。如：</p><blockquote><p>map.put(“arg0”，参数值1);</p><p>map.put(“arg1”，参数值2);</p></blockquote></li><li><p>以 param 开头 ： 第一个参数就叫 param1，第二个参数就叫 param2，依次类推。如：</p><blockquote><p>map.put(“param1”，参数值1);</p><p>map.put(“param2”，参数值2);</p></blockquote></li></ul><p><strong>代码验证：</strong></p><ul><li><p>在 <code>UserMapper</code> 接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User <span class="hljs-title function_">select</span><span class="hljs-params">(String username,String password)</span>;<br></code></pre></td></tr></table></figure></li><li><p>在 <code>UserMapper.xml</code> 映射配置文件中定义SQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>select *<br>    from tb_user<br>    where <br>    username=#&#123;arg0&#125;<br>    and password=#&#123;arg1&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>select *<br>    from tb_user<br>    where <br>    username=#&#123;param1&#125;<br>    and password=#&#123;param2&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>运行代码结果如下</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625122349015.png" alt="image-20220625122349015"></p><p>在映射配合文件的SQL语句中使用用 <code>arg</code> 开头的和 <code>param</code> 书写，代码的可读性会变的特别差，此时可以使用 <code>@Param</code> 注解。</p></li></ul><p>在接口方法参数上使用 <code>@Param</code> 注解，Mybatis 会将 <code>arg</code> 开头的键名替换为对应注解的属性值。</p><p><strong>代码验证：</strong></p><ul><li><p>在 <code>UserMapper</code> 接口中定义如下方法，在 <code>username</code> 参数前加上 <code>@Param</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String username, String password)</span>;<br></code></pre></td></tr></table></figure><p>Mybatis 在封装 Map 集合时，键名就会变成如下：</p><blockquote><p>map.put(“username”，参数值1);</p><p>map.put(“arg1”，参数值2);</p><p>map.put(“param1”，参数值1);</p><p>map.put(“param2”，参数值2);</p></blockquote></li><li><p>在 <code>UserMapper.xml</code> 映射配置文件中定义SQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>select *<br>    from tb_user<br>    where <br>    username=#&#123;username&#125;<br>    and password=#&#123;param2&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>运行程序结果没有报错。而如果将 <code>#&#123;&#125;</code> 中的 <code>username</code> 还是写成  <code>arg0</code> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>select *<br>    from tb_user<br>    where <br>    username=#&#123;arg0&#125;<br>    and password=#&#123;param2&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>运行程序则可以看到错误</p></li></ul><p>==结论：以后接口参数是多个时，在每个参数上都使用 <code>@Param</code> 注解。这样代码的可读性更高。==</p><h4 id="1-10-2-单个参数"><a href="#1-10-2-单个参数" class="headerlink" title="1.10.2  单个参数"></a>1.10.2  单个参数</h4><ul><li><p>POJO 类型</p><p>直接使用。要求 <code>属性名</code> 和 <code>参数占位符名称</code> 一致</p></li><li><p>Map 集合类型</p><p>直接使用。要求 <code>map集合的键名</code> 和 <code>参数占位符名称</code> 一致</p></li><li><p>Collection 集合类型</p><p>Mybatis 会将集合封装到 map 集合中，如下：</p><blockquote><p>map.put(“arg0”，collection集合);</p><p>map.put(“collection”，collection集合;</p></blockquote><p>==可以使用 <code>@Param</code> 注解替换map集合中默认的 arg 键名。==</p></li><li><p>List 集合类型</p><p>Mybatis 会将集合封装到 map 集合中，如下：</p><blockquote><p>map.put(“arg0”，list集合);</p><p>map.put(“collection”，list集合);</p><p>map.put(“list”，list集合);</p></blockquote><p>==可以使用 <code>@Param</code> 注解替换map集合中默认的 arg 键名。==</p></li><li><p>Array 类型</p><p>Mybatis 会将集合封装到 map 集合中，如下：</p><blockquote><p>map.put(“arg0”，数组);</p><p>map.put(“array”，数组);</p></blockquote><p>==可以使用 <code>@Param</code> 注解替换map集合中默认的 arg 键名。==</p></li><li><p>其他类型</p><p>比如int类型，<code>参数占位符名称</code> 叫什么都可以。尽量做到见名知意</p></li></ul><h2 id="2-注解实现CRUD"><a href="#2-注解实现CRUD" class="headerlink" title="2.注解实现CRUD"></a>2.注解实现CRUD</h2><p>使用注解开发会比配置文件开发更加方便。官方建议简单sql语句用注解，复杂sql语句用xml，如下就是使用注解进行开发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(value = &quot;select * from tb_user where id = #&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>==注意：==</p><ul><li>注解是用来替换映射配置文件方式配置的，所以使用了注解，就不需要再映射配置文件中书写对应的 <code>statement</code></li></ul></blockquote><p>Mybatis 针对 CURD 操作都提供了对应的注解，已经做到见名知意。如下：</p><ul><li>查询 ：@Select</li><li>添加 ：@Insert</li><li>修改 ：@Update</li><li>删除 ：@Delete</li></ul><p>接下来我们做一个案例来使用 Mybatis 的注解开发</p><p><strong>代码实现：</strong></p><ul><li><p>将之前案例中 <code>UserMapper.xml</code> 中的 根据id查询数据 的 <code>statement</code> 注释掉</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625122837575.png" alt="image-20220625122837575"></p></li><li><p>在 <code>UserMapper</code> 接口的 <code>selectById</code> 方法上添加注解</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625123001529.png" alt="image-20220625123001529"></p></li><li><p>运行测试程序也能正常查询到数据</p></li></ul><p>我们课程上只演示这一个查询的注解开发，其他的同学们下来可以自己实现，都是比较简单。</p><p>==注意：==在官方文档中 <code>入门</code> 中有这样的一段话：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625123028441.png" alt="image-20220625123028441"></p><p>所以，==注解完成简单功能，配置文件完成复杂功能。==</p><p>而我们之前写的动态 SQL 就是复杂的功能，如果用注解使用的话，就需要使用到 Mybatis 提供的SQL构建器来完成，而对应的代码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220625123108905.png" alt="image-20220625123108905"></p><p>上述代码将java代码和SQL语句融到了一块，使得代码的可读性大幅度降低。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC</title>
    <link href="/2022/06/25/JDBC/"/>
    <url>/2022/06/25/JDBC/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="1-JDBC概述"><a href="#1-JDBC概述" class="headerlink" title="1.JDBC概述"></a>1.JDBC概述</h2><p>在开发中我们使用的是java语言，那么势必要通过java语言操作数据库中的数据。这就是接下来要学习的JDBC。</p><h3 id="1-1-JDBC概念"><a href="#1-1-JDBC概念" class="headerlink" title="1.1  JDBC概念"></a>1.1  JDBC概念</h3><blockquote><p>JDBC   就是使用Java语言操作关系型数据库的一套API</p><p>全称：( Java DataBase Connectivity ) Java 数据库连接</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622201049290.png" alt="image-20220622201049290"></p><p>我们开发的同一套Java代码是无法操作不同的关系型数据库，因为每一个关系型数据库的底层实现细节都不一样。如果这样，问题就很大了，在公司中可以在开发阶段使用的是MySQL数据库，而上线时公司最终选用oracle数据库，我们就需要对代码进行大批量修改，这显然并不是我们想看到的。<u>我们要做到的是同一套Java代码操作不同的关系型数据库，而此时sun公司就指定了一套标准接口（JDBC）</u>，JDBC中定义了所有操作关系型数据库的规则。众所周知接口是无法直接使用的，我们需要使用接口的实现类，而这套实现类（称之为：驱动）就由各自的数据库厂商给出。</p><h3 id="1-2-JDBC本质"><a href="#1-2-JDBC本质" class="headerlink" title="1.2  JDBC本质"></a>1.2  JDBC本质</h3><ul><li>官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口</li><li>各个数据库厂商去实现这套接口，提供数据库驱动jar包</li><li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类</li></ul><h3 id="1-3-JDBC好处"><a href="#1-3-JDBC好处" class="headerlink" title="1.3  JDBC好处"></a>1.3  JDBC好处</h3><ul><li>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发</li><li>可随时替换底层数据库，访问数据库的Java代码基本不变</li></ul><p>以后编写操作数据库的代码只需要面向JDBC（接口），操作哪儿个关系型数据库就需要导入该数据库的驱动包，如需要操作MySQL数据库，就需要再项目中导入MySQL数据库的驱动包。如下图就是MySQL驱动包</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622201530771.png" alt="image-20220622201530771"></p><h2 id="2-JDBC快速入门"><a href="#2-JDBC快速入门" class="headerlink" title="2.JDBC快速入门"></a>2.JDBC快速入门</h2><p>先来看看通过Java操作数据库的流程</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622201600057.png" alt="image-20220622201600057" style="zoom:50%;" /></p><p>第一步：编写Java代码</p><p>第二步：Java代码将SQL发送到MySQL服务端</p><p>第三步：MySQL服务端接收到SQL语句并执行该SQL语句</p><p>第四步：将SQL语句执行的结果返回给Java代码</p><h3 id="2-1-编写代码步骤"><a href="#2-1-编写代码步骤" class="headerlink" title="2.1  编写代码步骤"></a>2.1  编写代码步骤</h3><ul><li><p>创建工程，导入驱动jar包</p></li><li><p>注册驱动</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br></code></pre></td></tr></table></figure></li><li><p>获取连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Connection conn <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br></code></pre></td></tr></table></figure><p>Java代码需要发送SQL给MySQL服务端，就需要先建立连接</p></li><li><p>定义SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">String <span class="hljs-keyword">sql</span> <span class="hljs-operator">=</span>  “<span class="hljs-keyword">update</span>…” ;<br></code></pre></td></tr></table></figure></li><li><p>获取执行SQL对象</p><p>执行SQL语句需要SQL执行对象，而这个执行对象就是Statement对象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Statement stmt <span class="hljs-operator">=</span> conn.createStatement();<br></code></pre></td></tr></table></figure></li><li><p>执行SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">stmt.executeUpdate(<span class="hljs-keyword">sql</span>);  <br></code></pre></td></tr></table></figure></li><li><p>处理返回结果</p></li><li><p>释放资源</p></li></ul><h3 id="2-2-具体操作"><a href="#2-2-具体操作" class="headerlink" title="2.2  具体操作"></a>2.2  具体操作</h3><ul><li><p>创建新的空的项目</p></li><li><p>定义项目的名称，并指定位置</p></li><li><p>对项目进行设置，JDK版本、编译版本</p></li><li><p>创建模块，指定模块的名称及位置</p></li><li><p>导入驱动包</p><p>将mysql的驱动包放在模块下的lib目录（随意命名）下，并将该jar包添加为库文件</p></li><li><p>在添加为库文件的时候，有如下三个选项</p><ul><li>Global Library  ： 全局有效</li><li>Project Library :   项目有效</li><li>Module Library ： 模块有效</li></ul></li><li><p>在src下创建类</p></li><li><p>编写代码如下</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDBC快速入门</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JDBCDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1. 注册驱动</span><br>        <span class="hljs-comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br>        <span class="hljs-comment">//2. 获取连接</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/db1&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>        <span class="hljs-comment">//3. 定义sql</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = 2000 where id = 1&quot;</span>;<br>        <span class="hljs-comment">//4. 获取执行sql的对象 Statement</span><br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br>        <span class="hljs-comment">//5. 执行sql</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql);<span class="hljs-comment">//受影响的行数</span><br>        <span class="hljs-comment">//6. 处理结果</span><br>        System.out.println(count);<br>        <span class="hljs-comment">//7. 释放资源</span><br>        stmt.close();<br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-JDBC-API详解"><a href="#3-JDBC-API详解" class="headerlink" title="3.JDBC API详解"></a>3.JDBC API详解</h2><h3 id="3-1-DriverManager"><a href="#3-1-DriverManager" class="headerlink" title="3.1  DriverManager"></a>3.1  DriverManager</h3><p>DriverManager（驱动管理类）作用：</p><ul><li><p>注册驱动</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622202121538.png" alt="image-20220622202121538"></p><p>registerDriver方法是用于注册驱动的，但是我们之前做的入门案例并不是这样写的。而是如下实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br></code></pre></td></tr></table></figure><p>我们查询MySQL提供的Driver类，看它是如何实现的，源码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622202228288.png" alt="image-20220622202228288"></p><p>在该类中的静态代码块中已经执行了 <code>DriverManager</code> 对象的 <code>registerDriver()</code> 方法进行驱动的注册了，那么我们只需要加载 <code>Driver</code> 类，该静态代码块就会执行。而 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code> 就可以加载 <code>Driver</code> 类。</p><blockquote><p>==提示：==</p><ul><li>MySQL 5之后的驱动包，可以省略注册驱动的步骤</li><li>自动加载jar包中META-INF/services/java.sql.Driver文件中的驱动类</li></ul></blockquote></li><li><p>获取数据库连接</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622202410055.png" alt="image-20220622202410055"></p><p>参数说明：</p><ul><li><p>url ： 连接路径</p><blockquote><p>语法：jdbc:mysql://ip地址(域名):端口号/数据库名称?参数键值对1&amp;参数键值对2…</p><p>示例：jdbc:mysql://127.0.0.1:3306/db1</p><p>==细节：==</p><ul><li><p>如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称?参数键值对</p></li><li><p>配置 useSSL=false 参数，禁用安全连接方式，解决警告提示</p></li></ul></blockquote></li><li><p>user ：用户名</p></li><li><p>poassword ：密码</p></li></ul></li></ul><h3 id="3-2-Connection"><a href="#3-2-Connection" class="headerlink" title="3.2  Connection"></a>3.2  Connection</h3><p>Connection（数据库连接对象）作用：</p><ul><li>获取执行 SQL 的对象</li><li>管理事务</li></ul><h4 id="3-2-1-获取执行对象"><a href="#3-2-1-获取执行对象" class="headerlink" title="3.2.1  获取执行对象"></a>3.2.1  获取执行对象</h4><ul><li><p>普通执行SQL对象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Statement createStatement()<br></code></pre></td></tr></table></figure><p>入门案例中就是通过该方法获取的执行对象。</p></li><li><p>预编译SQL的执行SQL对象：防止SQL注入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">PreparedStatement  prepareStatement(<span class="hljs-keyword">sql</span>)<br></code></pre></td></tr></table></figure><p>通过这种方式获取的 <code>PreparedStatement</code> SQL语句执行对象是我们一会重点要进行讲解的，它可以防止SQL注入。</p></li><li><p>执行存储过程的对象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">CallableStatement prepareCall(<span class="hljs-keyword">sql</span>)<br></code></pre></td></tr></table></figure><p>通过这种方式获取的 <code>CallableStatement</code> 执行对象是用来执行存储过程的，而存储过程在MySQL中不常用，所以这个我们将不进行讲解。</p></li></ul><h4 id="3-2-2-事务管理"><a href="#3-2-2-事务管理" class="headerlink" title="3.2.2  事务管理"></a>3.2.2  事务管理</h4><p>先回顾一下MySQL事务管理的操作：</p><ul><li>开启事务 ： BEGIN; 或者 START TRANSACTION;</li><li>提交事务 ： COMMIT;</li><li>回滚事务 ： ROLLBACK;</li></ul><blockquote><p>MySQL默认是自动提交事务</p></blockquote><p>接下来学习JDBC事务管理的方法。</p><p>Connection几口中定义了3个对应的方法：</p><ul><li><p>开启事务</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622203024093.png" alt="image-20220622203024093"></p><p>参与autoCommit 表示是否自动提交事务，true表示自动提交事务，false表示手动提交事务。而开启事务需要将该参数设为为false。</p></li><li><p>提交事务</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622203126286.png" alt="image-20220622203126286"></p></li><li><p>回滚事务</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622203144676.png" alt="image-20220622203144676"></p></li></ul><p>具体代码实现如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * JDBC API 详解：Connection</span><br><span class="hljs-comment"> */</span><br>public class JDBCDemo3_Connection &#123;<br><br>    public <span class="hljs-keyword">static</span> void main(String[] args) throws Exception &#123;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1.</span> 注册驱动<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2.</span> 获取连接：如果连接的是本机mysql并且端口是默认的 <span class="hljs-number">3306</span> 可以简化书写<br>        String url <span class="hljs-operator">=</span> &quot;jdbc:mysql:///db1?useSSL=false&quot;;<br>        String username <span class="hljs-operator">=</span> &quot;root&quot;;<br>        String password <span class="hljs-operator">=</span> &quot;1234&quot;;<br>        Connection conn <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">3.</span> 定义<span class="hljs-keyword">sql</span><br>        String sql1 <span class="hljs-operator">=</span> &quot;update account set money = 3000 where id = 1&quot;;<br>        String sql2 <span class="hljs-operator">=</span> &quot;update account set money = 3000 where id = 2&quot;;<br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">4.</span> 获取执行<span class="hljs-keyword">sql</span>的对象 Statement<br>        Statement stmt <span class="hljs-operator">=</span> conn.createStatement();<br><br>        try &#123;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>开启事务<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br>            conn.setAutoCommit(<span class="hljs-literal">false</span>);<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">5.</span> 执行<span class="hljs-keyword">sql</span><br>            <span class="hljs-type">int</span> count1 <span class="hljs-operator">=</span> stmt.executeUpdate(sql1);<span class="hljs-operator">/</span><span class="hljs-operator">/</span>受影响的行数<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">6.</span> 处理结果<br>            System.out.println(count1);<br>            <span class="hljs-type">int</span> i <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-operator">/</span><span class="hljs-number">0</span>;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">5.</span> 执行<span class="hljs-keyword">sql</span><br>            <span class="hljs-type">int</span> count2 <span class="hljs-operator">=</span> stmt.executeUpdate(sql2);<span class="hljs-operator">/</span><span class="hljs-operator">/</span>受影响的行数<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">6.</span> 处理结果<br>            System.out.println(count2);<br><br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>提交事务<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>程序运行到此处，说明没有出现任何问题，则需求提交事务<br>            conn.commit();<br>        &#125; catch (Exception e) &#123;<br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>回滚事务<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br>            <span class="hljs-operator">/</span><span class="hljs-operator">/</span>程序在出现异常时会执行到这个地方，此时就需要回滚事务<br>            conn.rollback();<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">7.</span> 释放资源<br>        stmt.close();<br>        conn.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-Statement"><a href="#3-3-Statement" class="headerlink" title="3.3  Statement"></a>3.3  Statement</h3><h4 id="3-3-1-概述"><a href="#3-3-1-概述" class="headerlink" title="3.3.1  概述"></a>3.3.1  概述</h4><p>Statement对象的作用就是用来执行SQL语句。而针对不同类型的SQL语句使用的方法也不一样。</p><ul><li><p>执行DDL、DML语句</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622203316093.png" alt="image-20220622203316093"></p></li><li><p>执行DQL语句</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622203332042.png" alt="image-20220622203332042"></p><p>该方法涉及到了 <code>ResultSet</code> 对象，而这个对象我们还没有学习，一会再重点讲解。</p></li></ul><h4 id="3-3-2-代码实现"><a href="#3-3-2-代码实现" class="headerlink" title="3.3.2  代码实现"></a>3.3.2  代码实现</h4><ul><li><p>执行DML语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 执行DML语句</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDML</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>    <span class="hljs-comment">//1. 注册驱动</span><br>    <span class="hljs-comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br>    <span class="hljs-comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>    <span class="hljs-comment">//3. 定义sql</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = 3000 where id = 1&quot;</span>;<br>    <span class="hljs-comment">//4. 获取执行sql的对象 Statement</span><br>    <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br>    <span class="hljs-comment">//5. 执行sql</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql);<span class="hljs-comment">//执行完DML语句，受影响的行数</span><br>    <span class="hljs-comment">//6. 处理结果</span><br>    <span class="hljs-comment">//System.out.println(count);</span><br>    <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;修改成功~&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;修改失败~&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//7. 释放资源</span><br>    stmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>执行DDL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 执行DDL语句</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDDL</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>    <span class="hljs-comment">//1. 注册驱动</span><br>    <span class="hljs-comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br>    <span class="hljs-comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>    <span class="hljs-comment">//3. 定义sql</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;drop database db2&quot;</span>;<br>    <span class="hljs-comment">//4. 获取执行sql的对象 Statement</span><br>    <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br>    <span class="hljs-comment">//5. 执行sql</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stmt.executeUpdate(sql);<span class="hljs-comment">//执行完DDL语句，可能是0</span><br>    <span class="hljs-comment">//6. 处理结果</span><br>    System.out.println(count);<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    stmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>以后开发很少使用java代码操作DDL语句</li></ul></blockquote></li></ul><h3 id="3-4-ResultSet"><a href="#3-4-ResultSet" class="headerlink" title="3.4  ResultSet"></a>3.4  ResultSet</h3><h4 id="3-4-1-概述"><a href="#3-4-1-概述" class="headerlink" title="3.4.1  概述"></a>3.4.1  概述</h4><p>ResultSet（结果集对象）作用：</p><ul><li>==封装了SQL查询语句的结果。==</li></ul><p>而执行了DQL语句后就会返回该对象，对应执行DQL语句的方法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ResultSet  executeQuery(<span class="hljs-keyword">sql</span>)：执行DQL 语句，返回ResultSet 对象<br></code></pre></td></tr></table></figure><p>那么我们就需要从 <code>ResultSet</code> 对象中获取我们想要的数据。<code>ResultSet</code> 对象提供了操作查询结果数据的方法，如下：</p><blockquote><p>boolean  next()</p><ul><li>将光标从当前位置向前移动一行 </li><li>判断当前行是否为有效行</li></ul><p>方法返回值说明：</p><ul><li>true  ： 有效航，当前行有数据</li><li>false ： 无效行，当前行没有数据</li></ul><p>xxx  getXxx(参数)：获取数据</p><ul><li>xxx : 数据类型；如： int getInt(参数) ；String getString(参数)</li><li>参数<ul><li>int类型的参数：列的编号，从1开始</li><li>String类型的参数： 列的名称 </li></ul></li></ul></blockquote><p>如下图为执行SQL语句后的结果</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622204148614.png" alt="image-20220622204148614"></p><p>一开始光标指定于第一行前，如图所示红色箭头指向于表头行。当我们调用了 <code>next()</code> 方法后，光标就下移到第一行数据，并且方法返回true，此时就可以通过 <code>getInt(&quot;id&quot;)</code> 获取当前行id字段的值，也可以通过 <code>getString(&quot;name&quot;)</code> 获取当前行name字段的值。如果想获取下一行的数据，继续调用 <code>next()</code>  方法，以此类推。</p><h4 id="3-4-2-代码实现"><a href="#3-4-2-代码实现" class="headerlink" title="3.4.2  代码实现"></a>3.4.2  代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 执行DQL</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testResultSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>    <span class="hljs-comment">//1. 注册驱动</span><br>    <span class="hljs-comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br>    <span class="hljs-comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br>    <span class="hljs-comment">//3. 定义sql</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from account&quot;</span>;<br>    <span class="hljs-comment">//4. 获取statement对象</span><br>    <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br>    <span class="hljs-comment">//5. 执行sql</span><br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(sql);<br>    <span class="hljs-comment">//6. 处理结果， 遍历rs中的所有数据</span><br>    <span class="hljs-comment">/* // 6.1 光标向下移动一行，并且判断当前行是否有数据</span><br><span class="hljs-comment">        while (rs.next())&#123;</span><br><span class="hljs-comment">            //6.2 获取数据  getXxx()</span><br><span class="hljs-comment">            int id = rs.getInt(1);</span><br><span class="hljs-comment">            String name = rs.getString(2);</span><br><span class="hljs-comment">            double money = rs.getDouble(3);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            System.out.println(id);</span><br><span class="hljs-comment">            System.out.println(name);</span><br><span class="hljs-comment">            System.out.println(money);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            System.out.println(&quot;--------------&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        &#125;*/</span><br>    <span class="hljs-comment">// 6.1 光标向下移动一行，并且判断当前行是否有数据</span><br>    <span class="hljs-keyword">while</span> (rs.next())&#123;<br>        <span class="hljs-comment">//6.2 获取数据  getXxx()</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-type">double</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> rs.getDouble(<span class="hljs-string">&quot;money&quot;</span>);<br><br>        System.out.println(id);<br>        System.out.println(name);<br>        System.out.println(money);<br><br>        System.out.println(<span class="hljs-string">&quot;--------------&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    rs.close();<br>    stmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-案例"><a href="#3-5-案例" class="headerlink" title="3.5  案例"></a>3.5  案例</h3><ul><li><p>需求：查询account账户表数据，封装为Account对象中，并且存储到ArrayList集合中</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622205059589.png" alt="image-20220622205059589"></p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 查询account账户表数据，封装为Account对象中，并且存储到ArrayList集合中</span><br><span class="hljs-comment">  * 1. 定义实体类Account</span><br><span class="hljs-comment">  * 2. 查询数据，封装到Account对象中</span><br><span class="hljs-comment">  * 3. 将Account对象存入ArrayList集合中</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testResultSet2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>    <span class="hljs-comment">//1. 注册驱动</span><br>    <span class="hljs-comment">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br>    <span class="hljs-comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br><br>    <span class="hljs-comment">//3. 定义sql</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from account&quot;</span>;<br><br>    <span class="hljs-comment">//4. 获取statement对象</span><br>    <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br><br>    <span class="hljs-comment">//5. 执行sql</span><br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(sql);<br><br>    <span class="hljs-comment">// 创建集合</span><br>    List&lt;Account&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>   <br>    <span class="hljs-comment">// 6.1 光标向下移动一行，并且判断当前行是否有数据</span><br>    <span class="hljs-keyword">while</span> (rs.next())&#123;<br>        <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br><br>        <span class="hljs-comment">//6.2 获取数据  getXxx()</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-type">double</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> rs.getDouble(<span class="hljs-string">&quot;money&quot;</span>);<br><br>        <span class="hljs-comment">//赋值</span><br>        account.setId(id);<br>        account.setName(name);<br>        account.setMoney(money);<br><br>        <span class="hljs-comment">// 存入集合</span><br>        list.add(account);<br>    &#125;<br><br>    System.out.println(list);<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    rs.close();<br>    stmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-6-PreparedStatement"><a href="#3-6-PreparedStatement" class="headerlink" title="3.6  PreparedStatement"></a>3.6  PreparedStatement</h3><blockquote><p>PreparedStatement作用：</p><ul><li>预编译SQL语句并执行：预防SQL注入问题</li></ul></blockquote><p>对上面的作用中SQL注入问题大家肯定不理解。那我们先对SQL注入进行说明.</p><h4 id="3-6-1-SQL注入"><a href="#3-6-1-SQL注入" class="headerlink" title="3.6.1  SQL注入"></a>3.6.1  SQL注入</h4><blockquote><p>SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p></blockquote><p>在今天资料下的 <code>day03-JDBC\资料\2. sql注入演示</code> 中修改 <code>application.properties</code> 文件中的用户名和密码，文件内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">1234</span><br></code></pre></td></tr></table></figure><p>在登陆数据库时，用户名随意写，密码写成 <code>&#39; or &#39;1&#39; =&#39;1</code></p><p>在逻辑判断时，会将输入的密码与数据库中存储的密码进行比对，相同则为true，不同登录失败，但如果密码写成上述形式，则逻辑判断永远为true，数据库就产生了安全漏洞。</p><p>当然现在市面上的系统都不会存在这种问题了，所以大家也不要尝试用这种方式去试其他的系统。</p><p>那么该如何解决呢？这里就可以将SQL执行对象 <code>Statement</code> 换成 <code>PreparedStatement</code> 对象。</p><h4 id="3-6-2-代码模拟SQL注入问题"><a href="#3-6-2-代码模拟SQL注入问题" class="headerlink" title="3.6.2  代码模拟SQL注入问题"></a>3.6.2  代码模拟SQL注入问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLogin</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>    <span class="hljs-comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br><br>    <span class="hljs-comment">// 接收用户输入 用户名和密码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sjdljfld&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from tb_user where username = &#x27;&quot;</span>+name+<span class="hljs-string">&quot;&#x27; and password = &#x27;&quot;</span>+pwd+<span class="hljs-string">&quot;&#x27;&quot;</span>;<br>    <span class="hljs-comment">// 获取stmt对象</span><br>    <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement();<br>    <span class="hljs-comment">// 执行sql</span><br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(sql);<br>    <span class="hljs-comment">// 判断登录是否成功</span><br>    <span class="hljs-keyword">if</span>(rs.next())&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录成功~&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录失败~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    rs.close();<br>    stmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码是将用户名和密码拼接到sql语句中，拼接后的sql语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;sjdljfld&#x27;</span> <span class="hljs-keyword">and</span> password <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure><p>从上面语句可以看出条件 <code>username = &#39;sjdljfld&#39; and password = &#39;&#39;</code> 不管是否满足，而 <code>or</code> 后面的 <code>&#39;1&#39; = &#39;1&#39;</code> 是始终满足的，最终条件是成立的，就可以正常的进行登陆了。</p><p>接下来我们来学习PreparedStatement对象.</p><h4 id="3-6-3-PreparedStatement概述"><a href="#3-6-3-PreparedStatement概述" class="headerlink" title="3.6.3  PreparedStatement概述"></a>3.6.3  PreparedStatement概述</h4><blockquote><p>PreparedStatement作用：</p><ul><li>预编译SQL语句并执行：预防SQL注入问题</li></ul></blockquote><ul><li><p>获取 PreparedStatement 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SQL语句中的参数值，使用？占位符替代</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from user where username = ? and password = ?&quot;</span>;<br><span class="hljs-comment">// 通过Connection对象获取，并传入对应的sql语句</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br></code></pre></td></tr></table></figure></li><li><p>设置参数值</p><p>==上面的sql语句中参数使用 ? 进行占位，在之前肯定要设置这些 ?  的值。==</p><blockquote><p>PreparedStatement对象：setXxx(参数1，参数2)：给 ? 赋值</p><ul><li><p>Xxx：数据类型 ； 如 setInt (参数1，参数2)</p></li><li><p>参数：</p><ul><li><p>参数1： ？的位置编号，从1 开始</p></li><li><p>参数2： ？的值</p></li></ul></li></ul></blockquote></li><li><p>执行SQL语句</p><blockquote><p>executeUpdate();  执行DDL语句和DML语句（增删改）</p><p>executeQuery();  执行DQL语句（查询）</p><p>==注意：==</p><ul><li>调用这两个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了。</li></ul></blockquote></li></ul><h4 id="3-6-4-使用PreparedStatement改进"><a href="#3-6-4-使用PreparedStatement改进" class="headerlink" title="3.6.4  使用PreparedStatement改进"></a>3.6.4  使用PreparedStatement改进</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPreparedStatement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>    <span class="hljs-comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:///db1?useSSL=false&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br><br>    <span class="hljs-comment">// 接收用户输入 用户名和密码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;<br><br>    <span class="hljs-comment">// 定义sql</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from tb_user where username = ? and password = ?&quot;</span>;<br>    <span class="hljs-comment">// 获取pstmt对象</span><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>    <span class="hljs-comment">// 设置？的值</span><br>    pstmt.setString(<span class="hljs-number">1</span>,name);<br>    pstmt.setString(<span class="hljs-number">2</span>,pwd);<br>    <span class="hljs-comment">// 执行sql</span><br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> pstmt.executeQuery();<br>    <span class="hljs-comment">// 判断登录是否成功</span><br>    <span class="hljs-keyword">if</span>(rs.next())&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录成功~&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录失败~&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//7. 释放资源</span><br>    rs.close();<br>    pstmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行上面语句就可以发现不会出现SQL注入漏洞问题了。那么PreparedStatement又是如何解决的呢？它是将特殊字符进行了转义，转义的SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;sjdljfld&#x27;</span> <span class="hljs-keyword">and</span> password <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;\&#x27;</span><span class="hljs-keyword">or</span> \<span class="hljs-string">&#x27;1\&#x27;</span> <span class="hljs-operator">=</span> \<span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="3-6-5-PreparedStatement原理"><a href="#3-6-5-PreparedStatement原理" class="headerlink" title="3.6.5  PreparedStatement原理"></a>3.6.5  PreparedStatement原理</h4><blockquote><p>PreparedStatement 好处：</p><ul><li>预编译SQL，性能更高</li><li>防止SQL注入：==将敏感字符进行转义==</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623130238598.png" alt="image-20220623130238598"></p><p>Java代码操作数据库流程如图所示：</p><ul><li><p>将sql语句发送到MySQL服务器端</p></li><li><p>MySQL服务端会对sql语句进行如下操作</p><ul><li><p>检查SQL语句</p><p>检查SQL语句的语法是否正确。</p></li><li><p>编译SQL语句。将SQL语句编译成可执行的函数。</p><p>检查SQL和编译SQL花费的时间比执行SQL的时间还要长。如果我们只是重新设置参数，那么检查SQL语句和编译SQL语句将不需要重复执行。这样就提高了性能。</p></li><li><p>执行SQL语句</p></li></ul></li></ul><p>接下来我们通过查询日志来看一下原理。</p><ul><li><p>开启预编译功能</p><p>在代码中编写url时需要加上以下参数。而我们之前根本就没有开启预编译功能，只是解决了SQL注入漏洞。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">useServerPrepStmts<span class="hljs-operator">=</span><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>配置MySQL执行日志（重启mysql服务后生效）</p><p>在mysql配置文件（my.ini）中添加如下配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">log-output</span>=FILE<br><span class="hljs-attr">general-log</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">general_log_file</span>=<span class="hljs-string">&quot;D:\mysql.log&quot;</span><br><span class="hljs-attr">slow-query-log</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">slow_query_log_file</span>=<span class="hljs-string">&quot;D:\mysql_slow.log&quot;</span><br><span class="hljs-attr">long_query_time</span>=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>java测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * PreparedStatement原理</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">   */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPreparedStatement2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br><br>    <span class="hljs-comment">//2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写</span><br>    <span class="hljs-comment">// useServerPrepStmts=true 参数开启预编译功能</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1234&quot;</span>;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br><br>    <span class="hljs-comment">// 接收用户输入 用户名和密码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;</span>;<br><br>    <span class="hljs-comment">// 定义sql</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from tb_user where username = ? and password = ?&quot;</span>;<br><br>    <span class="hljs-comment">// 获取pstmt对象</span><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br><br>    Thread.sleep(<span class="hljs-number">10000</span>);<br>    <span class="hljs-comment">// 设置？的值</span><br>    pstmt.setString(<span class="hljs-number">1</span>,name);<br>    pstmt.setString(<span class="hljs-number">2</span>,pwd);<br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 执行sql</span><br>    rs = pstmt.executeQuery();<br><br>    <span class="hljs-comment">// 设置？的值</span><br>    pstmt.setString(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;aaa&quot;</span>);<br>    pstmt.setString(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;bbb&quot;</span>);<br>    <span class="hljs-comment">// 执行sql</span><br>    rs = pstmt.executeQuery();<br><br>    <span class="hljs-comment">// 判断登录是否成功</span><br>    <span class="hljs-keyword">if</span>(rs.next())&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录成功~&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录失败~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    rs.close();<br>    pstmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>执行SQL语句，查看 <code>D:\mysql.log</code> 日志如下:</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623130459944.png" alt="image-20220623130459944"></p><p>上图中第三行中的 <code>Prepare</code> 是对SQL语句进行预编译。第四行和第五行是执行了两次SQL语句，而第二次执行前并没有对SQL进行预编译。</p></li></ul><blockquote><p>==小结：==</p><ul><li>在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）</li><li>执行时就不用再进行这些步骤了，速度更快</li><li>如果sql模板一样，则只需要进行一次检查、编译</li></ul></blockquote><h2 id="4-数据库连接池"><a href="#4-数据库连接池" class="headerlink" title="4.数据库连接池"></a>4.数据库连接池</h2><h3 id="4-1-数据库连接池简介"><a href="#4-1-数据库连接池简介" class="headerlink" title="4.1  数据库连接池简介"></a>4.1  数据库连接池简介</h3><blockquote><ul><li><p>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</p></li><li><p>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；</p></li><li><p>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</p></li><li>好处<ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul></li></ul></blockquote><p>之前我们代码中使用连接是没有使用都创建一个Connection对象，使用完毕就会将其销毁。这样重复创建销毁的过程是特别耗费计算机的性能的及消耗时间的。</p><p>而数据库使用了数据库连接池后，就能达到Connection对象的复用，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623130721912.png" alt="image-20220623130721912"></p><p>连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池；这样就可以起到资源重用，也节省了频繁创建连接销毁连接所花费的时间，从而提升了系统响应的速度。</p><h3 id="4-2-数据库连接池实现"><a href="#4-2-数据库连接池实现" class="headerlink" title="4.2  数据库连接池实现"></a>4.2  数据库连接池实现</h3><ul><li><p>标准接口：==DataSource==</p><p>官方(SUN) 提供的数据库连接池标准接口，由第三方组织实现此接口。该接口提供了获取连接的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p>那么以后就不需要通过 <code>DriverManager</code> 对象获取 <code>Connection</code> 对象，而是通过连接池（DataSource）获取 <code>Connection</code> 对象。</p></li><li><p>常见的数据库连接池</p><ul><li>DBCP</li><li>C3P0</li><li>Druid</li></ul><p>我们现在使用更多的是Druid，它的性能比其他两个会好一些。</p></li><li><p>Druid（德鲁伊）</p><ul><li><p>Druid连接池是阿里巴巴开源的数据库连接池项目 </p></li><li><p>功能强大，性能优秀，是Java语言最好的数据库连接池之一</p></li></ul></li></ul><h3 id="4-3-Driud使用"><a href="#4-3-Driud使用" class="headerlink" title="4.3  Driud使用"></a>4.3  Driud使用</h3><blockquote><ul><li>导入jar包 druid-1.1.12.jar</li><li>定义配置文件</li><li>加载配置文件</li><li>获取数据库连接池对象</li><li>获取连接</li></ul></blockquote><p>现在通过代码实现，首先需要先将druid的jar包放到项目下的lib下并添加为库文件</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623152049955.png" alt="image-20220623152049955"></p><p>项目结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623152109789.png" alt="image-20220623152109789"></p><p>编写配置文件如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driverClassName</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=true</span><br><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">password</span>=<span class="hljs-string">1234</span><br><span class="hljs-comment"># 初始化连接数量</span><br><span class="hljs-attr">initialSize</span>=<span class="hljs-string">5</span><br><span class="hljs-comment"># 最大连接数</span><br><span class="hljs-attr">maxActive</span>=<span class="hljs-string">10</span><br><span class="hljs-comment"># 最大等待时间</span><br><span class="hljs-attr">maxWait</span>=<span class="hljs-string">3000</span><br></code></pre></td></tr></table></figure><p>使用druid的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Druid数据库连接池演示</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DruidDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1.导入jar包</span><br>        <span class="hljs-comment">//2.定义配置文件</span><br>        <span class="hljs-comment">//3. 加载配置文件</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jdbc-demo/src/druid.properties&quot;</span>));<br>        <span class="hljs-comment">//4. 获取连接池对象</span><br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);<br><br>        <span class="hljs-comment">//5. 获取数据库连接 Connection</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        System.out.println(connection); <span class="hljs-comment">//获取到了连接后就可以继续做其他操作了</span><br><br>        <span class="hljs-comment">//System.out.println(System.getProperty(&quot;user.dir&quot;));</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-JDBC练习"><a href="#5-JDBC练习" class="headerlink" title="5.JDBC练习"></a>5.JDBC练习</h2><h3 id="5-1-需求"><a href="#5-1-需求" class="headerlink" title="5.1  需求"></a>5.1  需求</h3><p>完成商品品牌数据的增删改查操作</p><ul><li>查询：查询所有数据</li><li>添加：添加品牌</li><li>修改：根据id修改</li><li>删除：根据id删除</li></ul><h3 id="5-2-案例实现"><a href="#5-2-案例实现" class="headerlink" title="5.2  案例实现"></a>5.2  案例实现</h3><h4 id="5-2-1-环境准备"><a href="#5-2-1-环境准备" class="headerlink" title="5.2.1  环境准备"></a>5.2.1  环境准备</h4><ul><li><p>数据库表 <code>tb_brand</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除tb_brand表</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> tb_brand;<br><span class="hljs-comment">-- 创建tb_brand表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_brand (<br>    <span class="hljs-comment">-- id 主键</span><br>    id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>    <span class="hljs-comment">-- 品牌名称</span><br>    brand_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-comment">-- 企业名称</span><br>    company_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-comment">-- 排序字段</span><br>    ordered <span class="hljs-type">int</span>,<br>    <span class="hljs-comment">-- 描述信息</span><br>    description <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>    <span class="hljs-comment">-- 状态：0：禁用  1：启用</span><br>    status <span class="hljs-type">int</span><br>);<br><span class="hljs-comment">-- 添加数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_brand (brand_name, company_name, ordered, description, status)<br><span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;三只松鼠&#x27;</span>, <span class="hljs-string">&#x27;三只松鼠股份有限公司&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;好吃不上火&#x27;</span>, <span class="hljs-number">0</span>),<br>       (<span class="hljs-string">&#x27;华为&#x27;</span>, <span class="hljs-string">&#x27;华为技术有限公司&#x27;</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#x27;</span>, <span class="hljs-number">1</span>),<br>       (<span class="hljs-string">&#x27;小米&#x27;</span>, <span class="hljs-string">&#x27;小米科技有限公司&#x27;</span>, <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;are you ok&#x27;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p>在pojo包下实体类 Brand</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 品牌</span><br><span class="hljs-comment"> * alt + 鼠标左键：整列编辑</span><br><span class="hljs-comment"> * 在实体类中，基本数据类型建议使用其对应的包装类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Brand</span> &#123;<br>    <span class="hljs-comment">// id 主键</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-comment">// 品牌名称</span><br>    <span class="hljs-keyword">private</span> String brandName;<br>    <span class="hljs-comment">// 企业名称</span><br>    <span class="hljs-keyword">private</span> String companyName;<br>    <span class="hljs-comment">// 排序字段</span><br>    <span class="hljs-keyword">private</span> Integer ordered;<br>    <span class="hljs-comment">// 描述信息</span><br>    <span class="hljs-keyword">private</span> String description;<br>    <span class="hljs-comment">// 状态：0：禁用  1：启用</span><br>    <span class="hljs-keyword">private</span> Integer status;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBrandName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> brandName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBrandName</span><span class="hljs-params">(String brandName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.brandName = brandName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCompanyName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> companyName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCompanyName</span><span class="hljs-params">(String companyName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.companyName = companyName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getOrdered</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ordered;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOrdered</span><span class="hljs-params">(Integer ordered)</span> &#123;<br>        <span class="hljs-built_in">this</span>.ordered = ordered;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getDescription</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> description;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDescription</span><span class="hljs-params">(String description)</span> &#123;<br>        <span class="hljs-built_in">this</span>.description = description;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getStatus</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStatus</span><span class="hljs-params">(Integer status)</span> &#123;<br>        <span class="hljs-built_in">this</span>.status = status;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Brand&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, brandName=&#x27;&quot;</span> + brandName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, companyName=&#x27;&quot;</span> + companyName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, ordered=&quot;</span> + ordered +<br>                <span class="hljs-string">&quot;, description=&#x27;&quot;</span> + description + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, status=&quot;</span> + status +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="5-2-2-查询所有"><a href="#5-2-2-查询所有" class="headerlink" title="5.2.2  查询所有"></a>5.2.2  查询所有</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 查询所有</span><br><span class="hljs-comment">   * 1. SQL：select * from tb_brand;</span><br><span class="hljs-comment">   * 2. 参数：不需要</span><br><span class="hljs-comment">   * 3. 结果：List&lt;Brand&gt;</span><br><span class="hljs-comment">   */</span><br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">//1. 获取Connection</span><br>    <span class="hljs-comment">//3. 加载配置文件</span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jdbc-demo/src/druid.properties&quot;</span>));<br>    <span class="hljs-comment">//4. 获取连接池对象</span><br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);<br><br>    <span class="hljs-comment">//5. 获取数据库连接 Connection</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>    <span class="hljs-comment">//2. 定义SQL</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from tb_brand;&quot;</span>;<br>    <span class="hljs-comment">//3. 获取pstmt对象</span><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>    <span class="hljs-comment">//4. 设置参数</span><br>    <span class="hljs-comment">//5. 执行SQL</span><br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> pstmt.executeQuery();<br>    <span class="hljs-comment">//6. 处理结果 List&lt;Brand&gt; 封装Brand对象，装载List集合</span><br>    <span class="hljs-type">Brand</span> <span class="hljs-variable">brand</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    List&lt;Brand&gt; brands = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (rs.next())&#123;<br>        <span class="hljs-comment">//获取数据</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;brand_name&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;company_name&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ordered</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;ordered&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">description</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;description&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-string">&quot;status&quot;</span>);<br>        <span class="hljs-comment">//封装Brand对象</span><br>        brand = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Brand</span>();<br>        brand.setId(id);<br>        brand.setBrandName(brandName);<br>        brand.setCompanyName(companyName);<br>        brand.setOrdered(ordered);<br>        brand.setDescription(description);<br>        brand.setStatus(status);<br><br>        <span class="hljs-comment">//装载集合</span><br>        brands.add(brand);<br>    &#125;<br>    System.out.println(brands);<br>    <span class="hljs-comment">//7. 释放资源</span><br>    rs.close();<br>    pstmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-3-添加数据"><a href="#5-2-3-添加数据" class="headerlink" title="5.2.3  添加数据"></a>5.2.3  添加数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 添加</span><br><span class="hljs-comment">  * 1. SQL：insert into tb_brand(brand_name, company_name, ordered, description, status) values(?,?,?,?,?);</span><br><span class="hljs-comment">  * 2. 参数：需要，除了id之外的所有参数信息</span><br><span class="hljs-comment">  * 3. 结果：boolean</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAdd</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 接收页面提交的参数</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;香飘飘&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;香飘飘&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ordered</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">description</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;绕地球一圈&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//1. 获取Connection</span><br>    <span class="hljs-comment">//3. 加载配置文件</span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jdbc-demo/src/druid.properties&quot;</span>));<br>    <span class="hljs-comment">//4. 获取连接池对象</span><br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);<br>    <span class="hljs-comment">//5. 获取数据库连接 Connection</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>    <span class="hljs-comment">//2. 定义SQL</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into tb_brand(brand_name, company_name, ordered, description, status) values(?,?,?,?,?);&quot;</span>;<br>    <span class="hljs-comment">//3. 获取pstmt对象</span><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>    <span class="hljs-comment">//4. 设置参数</span><br>    pstmt.setString(<span class="hljs-number">1</span>,brandName);<br>    pstmt.setString(<span class="hljs-number">2</span>,companyName);<br>    pstmt.setInt(<span class="hljs-number">3</span>,ordered);<br>    pstmt.setString(<span class="hljs-number">4</span>,description);<br>    pstmt.setInt(<span class="hljs-number">5</span>,status);<br><br>    <span class="hljs-comment">//5. 执行SQL</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> pstmt.executeUpdate(); <span class="hljs-comment">// 影响的行数</span><br>    <span class="hljs-comment">//6. 处理结果</span><br>    System.out.println(count &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    pstmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-4-修改数据"><a href="#5-2-4-修改数据" class="headerlink" title="5.2.4  修改数据"></a>5.2.4  修改数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 修改</span><br><span class="hljs-comment">  * 1. SQL：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     update tb_brand</span><br><span class="hljs-comment">         set brand_name  = ?,</span><br><span class="hljs-comment">         company_name= ?,</span><br><span class="hljs-comment">         ordered     = ?,</span><br><span class="hljs-comment">         description = ?,</span><br><span class="hljs-comment">         status      = ?</span><br><span class="hljs-comment">     where id = ?</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   * 2. 参数：需要，所有数据</span><br><span class="hljs-comment">   * 3. 结果：boolean</span><br><span class="hljs-comment">   */</span><br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 接收页面提交的参数</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">brandName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;香飘飘&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">companyName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;香飘飘&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ordered</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">description</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;绕地球三圈&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">//1. 获取Connection</span><br>    <span class="hljs-comment">//3. 加载配置文件</span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jdbc-demo/src/druid.properties&quot;</span>));<br>    <span class="hljs-comment">//4. 获取连接池对象</span><br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);<br>    <span class="hljs-comment">//5. 获取数据库连接 Connection</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>    <span class="hljs-comment">//2. 定义SQL</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; update tb_brand\n&quot;</span> +<br>        <span class="hljs-string">&quot;         set brand_name  = ?,\n&quot;</span> +<br>        <span class="hljs-string">&quot;         company_name= ?,\n&quot;</span> +<br>        <span class="hljs-string">&quot;         ordered     = ?,\n&quot;</span> +<br>        <span class="hljs-string">&quot;         description = ?,\n&quot;</span> +<br>        <span class="hljs-string">&quot;         status      = ?\n&quot;</span> +<br>        <span class="hljs-string">&quot;     where id = ?&quot;</span>;<br><br>    <span class="hljs-comment">//3. 获取pstmt对象</span><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br><br>    <span class="hljs-comment">//4. 设置参数</span><br>    pstmt.setString(<span class="hljs-number">1</span>,brandName);<br>    pstmt.setString(<span class="hljs-number">2</span>,companyName);<br>    pstmt.setInt(<span class="hljs-number">3</span>,ordered);<br>    pstmt.setString(<span class="hljs-number">4</span>,description);<br>    pstmt.setInt(<span class="hljs-number">5</span>,status);<br>    pstmt.setInt(<span class="hljs-number">6</span>,id);<br><br>    <span class="hljs-comment">//5. 执行SQL</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> pstmt.executeUpdate(); <span class="hljs-comment">// 影响的行数</span><br>    <span class="hljs-comment">//6. 处理结果</span><br>    System.out.println(count &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    pstmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-5-删除数据"><a href="#5-2-5-删除数据" class="headerlink" title="5.2.5  删除数据"></a>5.2.5  删除数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 删除</span><br><span class="hljs-comment">  * 1. SQL：</span><br><span class="hljs-comment">            delete from tb_brand where id = ?</span><br><span class="hljs-comment">  * 2. 参数：需要，id</span><br><span class="hljs-comment">  * 3. 结果：boolean</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeleteById</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 接收页面提交的参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">//1. 获取Connection</span><br>    <span class="hljs-comment">//3. 加载配置文件</span><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    prop.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;jdbc-demo/src/druid.properties&quot;</span>));<br>    <span class="hljs-comment">//4. 获取连接池对象</span><br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> DruidDataSourceFactory.createDataSource(prop);<br>    <span class="hljs-comment">//5. 获取数据库连接 Connection</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>    <span class="hljs-comment">//2. 定义SQL</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; delete from tb_brand where id = ?&quot;</span>;<br>    <span class="hljs-comment">//3. 获取pstmt对象</span><br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>    <span class="hljs-comment">//4. 设置参数</span><br>    pstmt.setInt(<span class="hljs-number">1</span>,id);<br>    <span class="hljs-comment">//5. 执行SQL</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> pstmt.executeUpdate(); <span class="hljs-comment">// 影响的行数</span><br>    <span class="hljs-comment">//6. 处理结果</span><br>    System.out.println(count &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//7. 释放资源</span><br>    pstmt.close();<br>    conn.close();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb&amp;Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习第二周</title>
    <link href="/2022/06/24/week02/"/>
    <url>/2022/06/24/week02/</url>
    
    <content type="html"><![CDATA[<hr><p>上篇主要介绍和讨论了线性模型。首先从最简单的最小二乘法开始，讨论输入属性有一个和多个的情形，接着通过广义线性模型延伸开来，将预测连续值的回归问题转化为分类问题，从而引入了对数几率回归，最后线性判别分析LDA将样本点进行投影，多分类问题实质上通过划分的方法转化为多个二分类问题进行求解。本篇将讨论另一种被广泛使用的分类算法—决策树（Decision Tree）。</p><h1 id="4、决策树"><a href="#4、决策树" class="headerlink" title="4、决策树"></a><strong>4、决策树</strong></h1><h2 id="4-1-决策树基本概念"><a href="#4-1-决策树基本概念" class="headerlink" title="4.1 决策树基本概念"></a><strong>4.1 决策树基本概念</strong></h2><p>决策树是一种机器学习的方法。决策树的生成算法有ID3, C4.5和C5.0等。决策树是一种树形结构，其中每个内部节点表示一个属性上的判断，每个分支代表一个判断结果的输出，最后每个叶节点代表一种分类结果。</p><p>决策树是一种十分常用的分类方法，需要监管学习，监管学习就是给出一堆样本，每个样本都有一组属性和一个分类结果，也就是分类结果已知，那么通过学习这些样本得到一个决策树，这个决策树能够对新的数据给出正确的分类。这里通过一个简单的例子来说明决策树的构成思路：</p><p>给出如下的一组数据，一共有十个样本（学生数量），每个样本有分数，出勤率，回答问题次数，作业提交率四个属性，最后判断这些学生是否是好学生。最后一列给出了人工分类结果。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-ed38beb4538a90f2b961233b18acc1ca_1440w.jpg" alt="img"></p><p>然后用这一组附带分类结果的样本可以训练出多种多样的决策树，这里为了简化过程，我们假设决策树为二叉树，且类似于下图：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-ff4fe0d16ec17c5520837b3aad52ed54_1440w.jpg" alt="img"></p><p>通过学习上表的数据，可以设置A，B，C，D，E的具体值，而A，B，C，D，E则称为阈值。当然也可以有和上图完全不同的树形，比如下图这种的：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-8f6407e5ab5a58b2913aef6a332090f6_1440w.jpg" alt="img"></p><p>所以决策树的生成主要分以下两步，这两步通常通过学习已经知道分类结果的样本来实现。</p><ol><li><p>节点的分裂：一般当一个节点所代表的属性无法给出判断时，则选择将这一节点分成2个子节点（如果不是二叉树的情况会分成n个子节点）。</p></li><li><p>阈值的确定：选择适当的阈值使得分类错误率最小 （Training Error）。</p></li></ol><p>在上图的决策树中，决策过程的每一次判定都是对某一属性的“测试”，决策最终结论则对应最终的判定结果。一般一颗决策树包含：一个根节点、若干个内部节点和若干个叶子节点，易知：</p><pre><code class="hljs">* 每个非叶节点表示一个特征属性测试。* 每个分支代表这个特征属性在某个值域上的输出。* 每个叶子节点存放一个类别。* 每个节点包含的样本集合通过属性测试被划分到子节点中，根节点包含样本全集。</code></pre><h2 id="4-2-决策树的构造"><a href="#4-2-决策树的构造" class="headerlink" title="4.2 决策树的构造"></a><strong>4.2 决策树的构造</strong></h2><p>决策树的构造是一个递归的过程，有三种情形会导致递归返回：</p><p>(1) 当前结点包含的样本<u>全属于同一类别</u>，这时直接将该节点标记为叶节点，并设为相应的类别；</p><p>(2) 当前属性集为空，或是所有样本在所有属性上取值相同，无法划分，这时将该节点标记为叶节点，并将其类别设为该节点所含样本最多的类别；</p><p>(3) 当前结点包含的样本集合为空，不能划分，这时也将该节点标记为叶节点，并将其类别设为父节点中所含样本最多的类别。算法的基本流程如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ecc27fe-20220625223316135.png" alt="2.png" style="zoom:150%;" /></p><p>举个例子，首先将所有数据点分成两组，将相似的数据点分在一组，然后在每个组内重复二进制分割过程，以此来生成决策树。生成结果是，每个后续的叶子节点将具有更少但更同质的数据点。决策树的基础是通过树中的不同路径隔离出“幸存者”群体，属于这些路径的任何人都将被预测为可能的“幸存者”。</p><p>重复划分数据以获得同质数据组的过程被称为递归分区。它仅涉及两个步骤，如下面所示：</p><p>步骤1：识别将数据点分解成最均匀的两个组的二分问题。</p><p>步骤2：对于每个叶节点重复步骤1，直到达到终止标准。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//u=468529240,2161184244&amp;fm=173&amp;s=798C34720B2341205AD514DA0000E0B1&amp;w=640&amp;h=311&amp;img.jpeg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//u=1283713208,3337743947&amp;fm=173&amp;s=4DAA307203BA5021424100DA0000E0B2&amp;w=640&amp;h=311&amp;img.jpeg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//u=91869356,1158323049&amp;fm=173&amp;s=4DA834720372582208F02DDA000050B2&amp;w=640&amp;h=311&amp;img.jpeg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//u=93050560,1795077123&amp;fm=173&amp;s=4DA830720332582358F5B0CA000050B2&amp;w=640&amp;h=311&amp;img.jpeg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//u=1741801751,280438553&amp;fm=173&amp;s=5DA830728BAA500B18E4D5CA0000E0B2&amp;w=640&amp;h=311&amp;img.jpeg" alt="img"></p><p>有各种可能的终止标准：</p><p>- 当叶子节点的数据点都是相同的预测类别/值时终止</p><p>- 当叶片节点包含的数据点少于五个时终止</p><p>- 当进一步的分支在超出最小阈值范围的情况下也无法提高同质性时终止</p><p>使用交叉验证来选择终止标准，以确保决策树可以为新数据绘制准确的预测路径。</p><p>决策树应用广泛，可以处理关于分类分组（例如男性与女性），也可以处理连续值问题（例如收入）。如果问题是连续值问题，它可以将结果分为几组，例如比较“高于平均水平”和“低于平均值”的不同值。</p><p>在标准决策树中，可能的答案只能有2个，例如“是”或“否”。如果想测试三个或更多的答案（“是”，“否”，“有时”），可以给树添加更多分支，如下图，在“是”和“不是”的二分支延伸出一个“有时”和“否”的分支。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//u=628979622,698225812&amp;fm=173&amp;s=05A87C32099ED4C80A692CDA000080B1&amp;w=543&amp;h=409&amp;img.jpeg" alt="img"></p><p>可以看出：决策树学习的关键在于如何选择划分属性，不同的划分属性得出不同的分支结构，从而影响整颗决策树的性能。属性划分的目标是让各个划分出来的子节点尽可能地“纯”，即属于同一类别。因此下面便是介绍量化纯度的具体方法，决策树最常用的算法有三种：ID3，C4.5和CART。</p><h3 id="4-2-1-ID3算法"><a href="#4-2-1-ID3算法" class="headerlink" title="4.2.1 ID3算法"></a><strong>4.2.1 ID3算法</strong></h3><p>ID3算法由==增熵（Entropy）原理==来决定哪个做父节点，哪个节点需要分裂。对于一组数据，熵越小说明分类结果越好。熵定义如下：</p><script type="math/tex; mode=display">Entropy＝- sum [p(x_i) * log2(P(x_i) ]</script><p>其中$p(x_i) $为$x_i$出现的概率。假如是2分类问题，当A类和B类各占50%的时候，</p><script type="math/tex; mode=display">Entropy = - （0.5*log_2( 0.5)+0.5*log_2( 0.5))= 1</script><p>当只有A类，或只有B类的时候，</p><script type="math/tex; mode=display">Entropy= - （1*log_2( 1）+0）=0</script><p>综上，使用信息增益为准则来选择划分属性，“==信息熵==”(information entropy)是度量样本结合纯度的常用指标，假定当前样本集合$D$中第$k$类样本所占比例为$p_k$，则样本集合$D$的信息熵定义为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ec515a5-20220625223524206.png" alt="3.png">因为$log_21=0$，易知只有一个类别时，信息熵为0，纯度最高。</p><p>所以当$Entropy$最大为1的时候，是分类效果最差的状态，当它最小为0的时候，是完全分类的状态。因为熵等于零是理想状态，一般实际情况下，熵介于0和1之间。</p><p>熵的不断最小化，实际上就是提高分类正确率的过程。</p><p>比如上表中的4个属性：单一地通过以下语句分类：</p><ol><li><p>分数小于70为【不是好学生】：分错1个</p></li><li><p>出勤率大于70为【好学生】：分错3个</p></li><li><p>问题回答次数大于9为【好学生】：分错2个</p></li><li><p>作业提交率大于80%为【好学生】：分错2个</p></li></ol><p>最后发现分数小于70为【不是好学生】这条分错最少，也就是熵最小，所以应该选择这条为父节点进行树的生成，当然分数也可以选择大于71，大于72等等，出勤率也可以选择小于60，65等等，总之会有很多类似上述1~4的条件，最后选择分类错最少即熵最小的那个条件。而当分裂父节点时道理也一样，分裂有很多选择，针对每一个选择，与分裂前的分类错误率比较，留下那个提高最大的选择，即熵减最大的选择。</p><p>假定通过属性划分样本集$D$，产生了$V$个分支节点，$D^v$表示其中第$v$个分支节点，易知：分支节点包含的样本数越多，表示该分支节点的影响力越大。故可以计算出划分后相比原始数据集$D$获得的“信息增益”（information gain）。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ec3e067.png" alt="4.png"></p><p>信息增益越大，表示使用该属性划分样本集$D$的效果越好，因此ID3算法在递归过程中，每次选择==最大信息增益的属性==作为当前的划分属性。</p><h3 id="4-2-2-C4-5算法"><a href="#4-2-2-C4-5算法" class="headerlink" title="4.2.2 C4.5算法"></a><strong>4.2.2 C4.5算法</strong></h3><p>通过对ID3的学习，可以知道ID3存在一个问题，那就是越细小的分割分类错误率越小，所以ID3会越分越细，比如以第一个属性为例：设阈值小于70可将样本分为2组，但是分错了1个。如果设阈值小于70，再加上阈值等于95，那么分错率降到了0，但是这种分割显然只对训练数据有用，对于新的数据没有意义，这就是所说的过度学习（Overfitting）。</p><p>分割太细了，训练数据的分类可以达到0错误率，但是因为新的数据和训练数据不同，所以面对新的数据分错率反倒上升了。决策树是通过分析训练数据，得到数据的统计信息，而不是专为训练数据量身定做。</p><p>就比如给人做衣服，叫来10个人做参考，做出一件10个人都能穿的衣服，然后叫来另外5个和前面10个人身高差不多的，这件衣服也能穿。但是当你为10个人每人做一件正好合身的衣服，那么这10件衣服除了那个量身定做的人，别人都穿不了。</p><p>所以为了避免分割太细，c4.5对ID3进行了改进，C4.5中，优化项要除以分割太细的代价，这个比值叫做==信息增益率==，显然<u>分割太细分母增加，信息增益率会降低。除此之外，其他的原理和ID3相同</u>。</p><p>首先使用ID3算法计算出信息增益高于平均水平的候选属性，接着C4.5计算这些候选属性的增益率，增益率定义为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ec69647.png" alt="5.png"></p><h3 id="4-2-3-CART算法"><a href="#4-2-3-CART算法" class="headerlink" title="4.2.3 CART算法"></a><strong>4.2.3 CART算法</strong></h3><p>CART是一个二叉树，也是回归树，同时也是分类树，CART的构成简单明了。CART只能将一个父节点分为2个子节点。CART用GINI指数来决定如何分裂：</p><p>GINI指数：总体内包含的类别越杂乱，GINI指数就越大（跟熵的概念很相似）。</p><p>a. 比如出勤率大于70%这个条件将训练数据分成两组：大于70%里面有两类：【好学生】和【不是好学生】，而小于等于70%里也有两类：【好学生】和【不是好学生】。</p><p>b. 如果用分数小于70分来分：则小于70分只有【不是好学生】一类，而大于等于70分有【好学生】和【不是好学生】两类。</p><p>比较a和b，发现b的凌乱程度比a要小，即GINI指数b比a小，所以选择b的方案。以此为例，将所有条件列出来，选择GINI指数最小的方案，这个和熵的概念很类似。基尼指数定义如下：</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec5a2ff.png" alt="6.png"></p><p>进而，使用属性α划分后的基尼指数为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ec62eaf.png" alt="7.png"></p><p>CART还是一个回归树，回归解析用来决定分布是否终止。理想地说每一个叶节点里都只有一个类别时分类应该停止，但是很多数据并不容易完全划分，或者完全划分需要很多次分裂，必然造成很长的运行时间，所以CART可以对每个叶节点里的数据分析其均值方差，当方差小于一定值可以终止分裂，以换取计算成本的降低。</p><p>CART和ID3一样，存在偏向细小分割，即过度学习（过度拟合的问题），为了解决这一问题，需要对特别长的树进行剪枝处理，直接剪掉。</p><p>以上的决策树训练的时候，一般会采取Cross-Validation法：比如一共有10组数据：</p><p>第一次. 1到9做训练数据， 10做测试数据</p><p>第二次. 2到10做训练数据，1做测试数据</p><p>第三次. 1，3到10做训练数据，2做测试数据，以此类推</p><p>做10次，然后大平均错误率。这样称为 10 folds Cross-Validation。</p><p>比如 3 folds Cross-Validation 指的是数据分3份，2份做训练，1份做测试。</p><h2 id="4-3-剪枝处理"><a href="#4-3-剪枝处理" class="headerlink" title="4.3 剪枝处理"></a><strong>4.3 剪枝处理</strong></h2><p>从决策树的构造流程中我们可以直观地看出：不管怎么样的训练集，决策树总是能很好地将各个类别分离开来，这时就会遇到之前提到过的问题：过拟合（overfitting），即太依赖于训=练样本。剪枝（pruning）则是决策树算法对付过拟合的主要手段，剪枝的策略有两种如下：</p><pre><code class="hljs">* 预剪枝（prepruning）：在构造的过程中先评估，再考虑是否分支。* 后剪枝（post-pruning）：在构造好一颗完整的决策树后，自底向上，评估分支的必要性。</code></pre><p>评估指的是性能度量，即决策树的泛化性能。之前提到：可以使用测试集作为学习器泛化性能的近似，因此可以将数据集划分为训练集和测试集。</p><p>预剪枝表示在构造数的过程中，对一个节点考虑是否分支时，首先计算决策树不分支时在测试集上的性能，再计算分支之后的性能，若分支对性能没有提升，则选择不分支（即剪枝）。</p><p>后剪枝则表示在构造好一颗完整的决策树后，从最下面的节点开始，考虑该节点分支对模型的性能是否有提升，若无则剪枝，即将该节点标记为叶子节点，类别标记为其包含样本最多的类别。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ec80d34.png" alt="8.png"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ec9e330.png" alt="9.png"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc728ec9d497.png" alt="10.png"></p><p>上图分别表示不剪枝处理的决策树、预剪枝决策树和后剪枝决策树。预剪枝处理使得决策树的很多分支被剪掉，因此大大降低了训练时间开销，同时降低了过拟合的风险，但另一方面由于剪枝同时剪掉了当前节点后续子节点的分支，因此预剪枝“贪心”的本质阻止了分支的展开，<u>在一定程度上带来了欠拟合的风险</u>。而后剪枝则通常保留了更多的分支，因此==采用后剪枝策略的决策树性能往往优于预剪枝==，但其自底向上遍历了所有节点，并计算性能，训练时间开销相比预剪枝大大提升。</p><h2 id="4-4-连续值与缺失值处理"><a href="#4-4-连续值与缺失值处理" class="headerlink" title="4.4 连续值与缺失值处理"></a><strong>4.4 连续值与缺失值处理</strong></h2><p>对于连续值的属性，若每个取值作为一个分支则显得不可行，因此需要进行离散化处理，常用的方法为二分法，基本思想为：给定样本集D与连续属性α，二分法试图找到一个划分点$t$将样本集$D$在属性$α$上分为$≤t$与$＞t$。</p><pre><code class="hljs">* 首先将α的所有取值按升序排列，所有相邻属性的均值作为候选划分点（n-1个，n为α所有的取值数目）。* 计算每一个划分点划分集合D（即划分为两个分支）后的信息增益。* 选择最大信息增益的划分点作为最优划分点。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72a0968fad.png" alt="11.png"></p><p>现实中常会遇到不完整的样本，即某些属性值缺失。有时若简单采取剔除，则会造成大量的信息浪费，因此在属性值缺失的情况下需要解决两个问题：</p><ol><li>如何选择划分属性。</li><li>给定划分属性，若某样本在该属性上缺失值，如何划分到具体的分支上。</li></ol><p>假定为样本集中的每一个样本都赋予一个权重，根节点中的权重初始化为1，则定义：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72a098f3be.png" alt="12.png"></p><p>对于（1）：通过在样本集$D$中选取在属性$α$上没有缺失值的样本子集，计算在该样本子集上的信息增益，最终的信息增益等于该样本子集划分后信息增益乘以样本子集占样本集的比重。即：</p><p><img src="https://i.loli.net/2018/10/17/5bc72a096ccc3.png" alt="13.png"></p><p>对于（2）：若该样本子集在属性α上的值缺失，则将该样本以不同的权重（即每个分支所含样本比例）划入到所有分支节点中。该样本在分支节点中的权重变为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72a093ed3c.png" alt="14.png"></p><p>​    </p><p>比较常用的决策树有ID3，C4.5和CART（Classification And Regression Tree），CART的分类效果一般优于其他决策树。下面介绍具体步骤。</p><p>ID3: 由增熵（Entropy）原理来决定那个做父节点，那个节点需要分裂。对于一组数据，熵越小说明分类结果越好。熵定义如下：</p><p>Entropy＝- sum [p(x_i) <em> </em>log*2(P(x_i) ]</p><p>其中p(x_i) 为x_i出现的概率。假如是2分类问题，当A类和B类各占50%的时候，</p><p>Entropy = - （0.5<em>log_2( 0.5)+0.5</em>log_2( 0.5))= 1</p><p>当只有A类，或只有B类的时候，</p><p>Entropy= - （1*log_2( 1）+0）=0</p><p>所以当Entropy最大为1的时候，是分类效果最差的状态，当它最小为0的时候，是完全分类的状态。因为熵等于零是理想状态，一般实际情况下，熵介于0和1之间。</p><p>熵的不断最小化，实际上就是提高分类正确率的过程。</p><p>比如上表中的4个属性：单一地通过以下语句分类：</p><p>\1. 分数小于70为【不是好学生】：分错1个</p><p>\2. 出勤率大于70为【好学生】：分错3个</p><p>\3. 问题回答次数大于9为【好学生】：分错2个</p><p>\4. 作业提交率大于80%为【好学生】：分错2个</p><p>最后发现 分数小于70为【不是好学生】这条分错最少，也就是熵最小，所以应该选择这条为父节点进行树的生成，当然分数也可以选择大于71，大于72等等，出勤率也可以选择小于60，65等等，总之会有很多类似上述1~4的条件，最后选择分类错最少即熵最小的那个条件。而当分裂父节点时道理也一样，分裂有很多选择，针对每一个选择，与分裂前的分类错误率比较，留下那个提高最大的选择，即熵减最大的选择。</p><p>C4.5：通过对ID3的学习，可以知道ID3存在一个问题，那就是越细小的分割分类错误率越小，所以ID3会越分越细，比如以第一个属性为例：设阈值小于70可将样本分为2组，但是分错了1个。如果设阈值小于70，再加上阈值等于95，那么分错率降到了0，但是这种分割显然只对训练数据有用，对于新的数据没有意义，这就是所说的过度学习（Overfitting）。</p><p>分割太细了，训练数据的分类可以达到0错误率，但是因为新的数据和训练数据不同，所以面对新的数据分错率反倒上升了。决策树是通过分析训练数据，得到数据的统计信息，而不是专为训练数据量身定做。</p><p>就比如给男人做衣服，叫来10个人做参考，做出一件10个人都能穿的衣服，然后叫来另外5个和前面10个人身高差不多的，这件衣服也能穿。但是当你为10个人每人做一件正好合身的衣服，那么这10件衣服除了那个量身定做的人，别人都穿不了。</p><p>所以为了避免分割太细，c4.5对ID3进行了改进，C4.5中，优化项要除以分割太细的代价，这个比值叫做信息增益率，显然分割太细分母增加，信息增益率会降低。除此之外，其他的原理和ID3相同。</p><p>CART：分类回归树</p><p>CART是一个二叉树，也是回归树，同时也是分类树，CART的构成简单明了。</p><p>CART只能将一个父节点分为2个子节点。CART用GINI指数来决定如何分裂：GINI指数：总体内包含的类别越杂乱，GINI指数就越大（跟熵的概念很相似）。</p><p>a. 比如出勤率大于70%这个条件将训练数据分成两组：大于70%里面有两类：【好学生】和【不是好学生】，而小于等于70%里也有两类：【好学生】和【不是好学生】。</p><p>b. 如果用分数小于70分来分：则小于70分只有【不是好学生】一类，而大于等于70分有【好学生】和【不是好学生】两类。</p><p>比较a和b，发现b的凌乱程度比a要小，即GINI指数b比a小，所以选择b的方案。以此为例，将所有条件列出来，选择GINI指数最小的方案，这个和熵的概念很类似。</p><p>CART还是一个回归树，回归解析用来决定分布是否终止。理想地说每一个叶节点里都只有一个类别时分类应该停止，但是很多数据并不容易完全划分，或者完全划分需要很多次分裂，必然造成很长的运行时间，所以CART可以对每个叶节点里的数据分析其均值方差，当方差小于一定值可以终止分裂，以换取计算成本的降低。</p><p>CART和ID3一样，存在偏向细小分割，即过度学习（过度拟合的问题），为了解决这一问题，对特别长的树进行剪枝处理，直接剪掉。</p><p>以上的决策树训练的时候，一般会采取Cross-Validation法：比如一共有10组数据：</p><p>第一次. 1到9做训练数据， 10做测试数据</p><p>第二次. 2到10做训练数据，1做测试数据</p><p>第三次. 1，3到10做训练数据，2做测试数据，以此类推</p><p>做10次，然后大平均错误率。这样称为 10 folds Cross-Validation。</p><p>比如 3 folds Cross-Validation 指的是数据分3份，2份做训练，1份做测试。</p><h2 id="4-5章节汇总"><a href="#4-5章节汇总" class="headerlink" title="4.5章节汇总"></a>4.5章节汇总</h2><p><strong>一、决策树学习的 3 个步骤：</strong></p><p><strong>1.特征选择</strong></p><p>特征选择决定了使用哪些特征来做判断。在训练数据集中，每个样本的属性可能有很多个，不同属性的作用有大有小。因而特征选择的作用就是筛选出跟分类结果相关性较高的特征，也就是分类能力较强的特征。</p><p>在特征选择中通常使用的准则是：信息增益。</p><p><strong>2.决策树生成</strong></p><p>选择好特征后，就从根节点触发，对节点计算所有特征的信息增益，选择信息增益最大的特征作为节点特征，根据该特征的不同取值建立子节点；对每个子节点使用相同的方式生成新的子节点，直到信息增益很小或者没有特征可以选择为止。</p><p><strong>3.决策树剪枝</strong></p><p>剪枝的主要目的是对抗「过拟合」，通过主动去掉部分分支来降低过拟合的风险。</p><p><strong>二、3种典型的决策树算法</strong></p><p><strong>ID3 算法</strong></p><p>ID3 是最早提出的决策树算法，他就是利用信息增益来选择特征的。</p><p><strong>C4.5 算法</strong></p><p>他是 ID3 的改进版，他不是直接使用信息增益，而是引入“信息增益比”指标作为特征的选择依据。</p><p><strong>CART（Classification and Regression Tree）</strong></p><p>这种算法即可以用于分类，也可以用于回归问题。CART 算法使用了基尼系数取代了信息熵模型。</p><p>三、决策树的优缺点</p><p><strong>优点</strong></p><ul><li>决策树易于理解和解释，可以可视化分析，容易提取出规则；</li><li>可以同时处理标称型和数值型数据；</li><li>比较适合处理有缺失属性的样本；</li><li>能够处理不相关的特征；</li><li>测试数据集时，运行速度比较快；</li><li>在相对短的时间内能够对大型数据源做出可行且效果良好的结果。</li></ul><p><strong>缺点</strong></p><ul><li>容易发生过拟合（随机森林可以很大程度上减少过拟合）；</li><li>容易忽略数据集中属性的相互关联；</li><li>对于那些各类别样本数量不一致的数据，在决策树中，进行属性划分时，不同的判定准则会带来不同的属性选择倾向；信息增益准则对可取数目较多的属性有所偏好（典型代表ID3算法），而增益率准则（CART）则对可取数目较少的属性有所偏好，但CART进行属性划分时候不再简单地直接利用增益率尽心划分，而是采用一种启发式规则）（只要是使用了信息增益，都有这个缺点，如RF）。</li><li>ID3算法计算信息增益时结果偏向数值比较多的特征。</li></ul><p>四、使用限制</p><p>在开始时使用最合适的二分问题分割数据可能不会得到最准确的预测。有时，最初使用没那么有效的分割可能会得到更好的预测。</p><p>为了解决这个问题，我们可以选择组合不同的二分问题来生成多个树，然后使用这些树的聚合来进行预测。这种技术即随机森林。或者，不是随机地组合二分问题，而是策略性地选择，使得每个随后的树的预测精度逐渐增加。然后，取所有树的加权平均预测值。这种技术称为梯度提升决策树。</p><p>虽然随机森林和梯度提升决策树更能产生准确的预测，但其复杂性使得解决方案难以可视化。因此，它们通常被称为“黑匣子”。另一方面，决策树的预测结果可以使用树形图来检查。了解哪些预测因素是重要的，使我们能够制定更有针对性的干预措施。</p><p>五、拓展阅读</p><p><a href="https://blog.csdn.net/jiaoyangwm/article/details/79525237">机器学习实战之决策树</a></p><p><a href="https://mp.weixin.qq.com/s/U62UCAM7rJWfbsyVdhs6-A">决策树和随机森林</a></p><p><a href="https://www.jianshu.com/p/655d8e555494">决策树算法的代码实现</a></p><p>上篇主要讨论了决策树算法。首先从决策树的基本概念出发，引出决策树基于树形结构进行决策，进一步介绍了构造决策树的递归流程以及其递归终止条件，在递归的过程中，划分属性的选择起到了关键作用，因此紧接着讨论了三种评估属性划分效果的经典算法，介绍了剪枝策略来解决原生决策树容易产生的过拟合问题，最后简述了属性连续值/缺失值的处理方法。本篇将讨论现阶段十分热门的另一个经典监督学习算法—神经网络（neural network）。</p><h1 id="5、神经网络"><a href="#5、神经网络" class="headerlink" title="5、神经网络"></a><strong>5、神经网络</strong></h1><p>神经网络的特征就是可以从数据中学习。所谓“从数据中学习”，是指可以由数据自动决定权重参数的值。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-b3388d6a10215958ada3df82d0a61587_r.jpg" alt="preview"></p><p>神经网络的优点是对所有的问题都可以用同样的流程来解决。比如，不管要求解的问题是识别物，还是识别狗，抑或是识别人脸，神经网络都是通过不断地学习所提供的数据，尝试发现待求解的问题的模式。也就是说，与待处理的问题无关，神经网络可以将数据直接作为原始数据，进行“端对端”的学习。</p><blockquote><p>神经网络最重要的用途是分类，为了让大家对分类有个直观的认识，咱们先看几个例子：</p><p>垃圾邮件识别：现在有一封电子邮件，把出现在里面的所有词汇提取出来，送进一个机器里，机器需要判断这封邮件是否是垃圾邮件。<br>疾病判断：病人到医院去做了一大堆肝功、尿检测验，把测验结果送进一个机器里，机器需要判断这个病人是否得病，得的什么病。<br>猫狗分类：有一大堆猫、狗照片，把每一张照片送进一个机器里，机器需要判断这幅照片里的东西是猫还是狗。</p></blockquote><p>向上例这种能自动对输入的东西进行分类的机器，就叫做分类器。</p><p>分类器的输入是一个数值向量，叫做特征(向量)。在第一个例子里，分类器的输入是一堆0、1值，表示字典里的每一个词是否在邮件中出现，比如向量(1，1……)就表示这封邮件里只出现了两个词abandon和abnormal;第二个例子里，分类器的输入是一堆化验指标；第三个例子里，分类器的输入是照片，假如每一张照片都是320<em>240像素的红绿蓝三通道彩色照片，那么分类器的输入就是一个长度为320</em>240*3=230400的向量。</p><p>分类器的输出也是数值。第一个例子中，输出1表示邮件是垃圾邮件，输出0则说明邮件是正常邮件；第二个例子中，输出0表示健康，输出1表示有甲肝Q，输出2表示有乙肝，输出3表示有饼干等等；第三个例子中，输出0表示图片中是狗，输出1表示是猫。</p><p>分类器的目标就是让正确分类的比例尽可能高。一般我们需要首先收集一些样本，人为标记上正确分类结果，然后用这些标记好的数据训练分类器，训练好的分类器就可以在新来的特征向量上工作了。</p><h2 id="5-1-神经元模型"><a href="#5-1-神经元模型" class="headerlink" title="5.1 神经元模型"></a><strong>5.1 神经元模型</strong></h2><h3 id="5-1-1-基本概念"><a href="#5-1-1-基本概念" class="headerlink" title="5.1.1 基本概念"></a>5.1.1 基本概念</h3><p>假设分类器的输入是通过某种途径获得的两个值，输出是0和1，比如分别代表猫和狗。现在有一些样本:<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220626144159265.png" alt="image-20220626144159265"></p><p>最简单地把这两组特征向量分开的方法当然是在两组数据中间画一条竖直线。直线左边是狗，右边是猫，分类器就完成了。以后来了新的向量，凡是落在直线左边的都是狗，落在右边的都是猫。</p><p>一条直线把平面一分为二，一个平面把三维空间一分为二，一个$n-1$维超平面把$n$维空间一分为二，两边分属不同的两类，这种分类器就叫做神经元。</p><p>大家都知道平面上的直线方程是$ax+by+c=0$，等式左边大于零和小于零分别表示点$(x,y)$在直线的一侧还是另一侧，把这个式子推广到n维空间里，直线的高维形式称为超平面，它的方程是:</p><script type="math/tex; mode=display">h=a_1x_1+a_2x_2+...+a_nx_n+a_0</script><p>神经元就是当$h$大于0时输出1，$h$小干0时输出0这么一个模型，它的实质就是把特征空间一切两半，认为两瓣分别属两个类。这个模型有点像人脑中的神经元：从多个感受器接受电信号$x_1,x_2,…,x_n$进行处理(加权相加再偏移一点，即判断输入是否在某条直线$h=0$的一侧)，发出电信号(在正确的那侧发出1.否则不发信号，可以认为是发出0)，这就是它叫神经元的原因。</p><p>当然，上述一条竖直线能分开两类只是我们假设的理想情况，在实际训练神经元的时候，我们并不知道特征是怎么抱团的。神经元有一种学习方法称为Hebb算法：</p><p>先随机选一条直线/平面/超平面，然后把样本一个个拿过来，如果这条直线分错了，说明这个点分错边了，就稍微把直线移动一点，让它靠近这个样本，争取跨过这个样本，让它跑到直线正确的一侧；如果直线分对了，它就暂时停下不动。因此训练神经元的过程就是这条直线不断在跳舞，最终跳到两个类之间的竖直线位置。</p><p>“M-P神经元模型”正是对这一结构进行了抽象，也称“阈值逻辑单元“。</p><p>神经元树突对应于输入部分，每个神经元收到n个其他神经元传递过来的输入信号，这些信号通过带权重的连接传递给细胞体，这些权重又称为连接权（connection weight）。细胞体分为两部分，前一部分计算总输入值（即输入信号的加权和，或者说累积电平），后一部分先计算总输入值与该神经元阈值的差值，然后通过激活函数（activation function）的处理，产生输出从轴突传送给其它神经元。M-P神经元模型如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb7be44-20220626183521735.png" alt="2.png"></p><p>与线性分类十分相似，神经元模型最理想的激活函数也是阶跃函数，即将神经元输入值与阈值的差值映射为输出值1或0，若差值大于零输出1，对应兴奋；若差值小于零则输出0，对应抑制。但阶跃函数不连续，不光滑，故在M-P神经元模型中，也采用Sigmoid函数来近似， Sigmoid函数将较大范围内变化的输入值挤压到 (0,1) 输出值范围内，所以也称为挤压函数（squashing function）。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb40dc5.png" alt="3.png"></p><p>将多个神经元按一定的层次结构连接起来，就得到了神经网络。它是一种包含多个参数的模型，比方说10个神经元两两连接，则有100个参数需要学习（每个神经元有9个连接权以及1个阈值），若将每个神经元都看作一个函数，则整个神经网络就是由这些函数相互嵌套而成。</p><p>总结来说，它的作用就是<u>接受其他多个神经元传入的信号，然后将这些信号汇总成总信号，对比总信号与阈值，如果超过阈值，则产生兴奋信号并输出出去，如果低于阈值，则处于抑制状态。</u></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast.png" alt="这里写图片描述"></p><p>Inputs：输入。</p><p>Weights：权值，权重。</p><p>Bias：偏置，或者称为阈值(Threshold)。</p><p>Activationfunction：激活函数。</p><p>需要掌握的线性代数基础知识：</p><p><a href="https://richyoungcrew.blog.csdn.net/article/details/124108851?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-124108851-blog-83628080.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-124108851-blog-83628080.pc_relevant_paycolumn_v3&amp;utm_relevant_index=2">特征值的通俗解释</a></p><p><a href="https://www.zhihu.com/question/20501504/answer/174887899">人类语言讲述相似矩阵</a></p><p><strong>输入</strong>的是特征向量，通过对其的学习，可以得知，特征向量代表的是变化的方向。或者说，是最能代表这个事物的特征的方向。</p><p>人有性别，身高，手，脚，五官等。电脑有屏幕，键盘，CPU，GPU等。速度有方向。颜色有种类。</p><p>特别是速度的方向，需要找到的是速度改变最大（增加或减少）的方向。（所以后面要求导数）</p><p><strong>权重</strong>就是特征值，输入是特征向量，权重和它相乘，对应的就是特征值。权重有正有负，加强或抑制，同特征值一样。权重的绝对值大小，代表了输入信号对神经元的影响的大小。正如上面的例子，输入一张图片，判断是是猫还是犬。第一层输入的有毛发，爪子，牙齿类型等。第二层有头部，腹部，腿部等。</p><p>牙齿对腿部的影响就会比较小啊，牙齿和腿部之间的权重的绝对值就会小一些，诸如此类。</p><p>我们要割一刀，得有割的角度和方向，而权重，就负责调整方向，这和特征向量的方向是两回事。$n$维空间中，乘以权重就好像是在不断的扭曲空间（空间变换），使不同类别的事物被扭曲到不同的一侧，来找到一个合适的$n−1$维超平面。</p><p><strong>偏置（阈值）</strong>:上面的神经元的图示，我们总是减去 $θ$，说得通俗点，要证明$a&gt;b$可以证明$a − b &gt; 0$。</p><p><a href="https://zhuanlan.zhihu.com/p/25279356">激活函数的作用</a></p><h3 id="5-1-2-神经网络缺点"><a href="#5-1-2-神经网络缺点" class="headerlink" title="5.1.2 神经网络缺点"></a>5.1.2 神经网络缺点</h3><p>MP神经元有几个显著缺点。首先它把直线一侧变为0，另一侧变为1，这东西不可微，不利于数学分析。人们用一个和0-1阶跃函数类似但是更平滑的函数Sigmoid函数来代替它（Sigmoid函数自带一个尺度参数，可以控制神经元对离超平面距离不同的点的响应，这里忽略它），从此神经网络的训练就可以用梯度下降法来构造了，这就是有名的<strong>反向传播算法</strong>。<br>神经元的另一个缺点是：它只能切一刀！你给我说说一刀怎么能把下面这两类分开吧。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220626145728717.png" alt="image-20220626145728717"></p><p>解决办法是多层神经网络，底层神经元的输出是高层神经元的输入。我们可以在中间横着砍一刀，竖着砍一刀，然后把左上和右下的部分合在一起，与右上的左下部分分开；也可以围着左上角的边沿砍10刀把这一部分先挖出来，然后和右下角合并。</p><p>每砍一刀，其实就是使用了一个神经元，把不同砍下的半平面做交、并等运算，就是把这些神经元的输出当作输入，后面再连接一个神经元。这个例子中特征的形状称为异或，这种情况一个神经元搞不定，但是两层神经元就能正确对其进行分类。</p><p>只要你能砍足够多刀，把结果拼在一起，什么奇怪形状的边界神经网络都能够表示，所以说神经网络在理论上可以表示很复杂的函数/空间分布。但是真实的神经网络是否能摆动到正确的位置还要看网络初始值设置、样本容量和分布。</p><p>神经网络神奇的地方在于它的每一个组件非常简单——把空间切一刀+某种激活函数（0-1阶跃、sigmoid、max-pooling），但是可以一层一层级联。输入向量连到许多神经元上，这些神经元的输出又连到一堆神经元上，这一过程可以重复很多次。这和人脑中的神经元很相似：每一个神经元都有一些神经元作为其输入，又是另一些神经元的输入，数值向量就像是电信号，在不同神经元之间传导，每一个神经元只有满足了某种条件才会发射信号到下一层神经元。</p><p>神经网络的训练依靠反向传播算法：最开始输入层输入特征向量，网络层层计算获得输出，输出层发现输出和正确的类号不一样，这时它就让最后一层神经元进行参数调整，最后一层神经元不仅自己调整参数，还会勒令连接它的倒数第二层神经元调整，层层往回退着调整。经过调整的网络会在样本上继续测试，如果输出还是老分错，继续来一轮回退调整，直到网络输出满意为止。</p><p>神经网络举例：</p><p>第一层神经元主要负责识别颜色和简单纹理</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//cbd8ee99581d1a2e22dca8b0e67f84b3_1440w.jpg" alt="img"></p><p>第二层的一些神经元可以识别更加细化的纹理，比如布纹、刻度、叶纹。<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//78fd60058ceabf34d3936ac8fe618c77_1440w.jpg" alt="img"></p><p>第三层的一些神经元负责感受黑夜里的黄色烛光、鸡蛋黄、高光。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//aae832d13b33f15ba97c358fdf7319d2_1440w.jpg" alt="img"></p><p>第四层的一些神经元负责识别萌狗的脸、<a href="https://www.zhihu.com/search?q=七星瓢虫&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A36429105}">七星瓢虫</a>和一堆圆形物体的存在。<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//04468c646e0d456b0fd4772d4e2a993b_1440w.jpg" alt="img"></p><p>第五层的一些神经元可以识别出花、圆形屋顶、键盘、鸟、黑眼圈动物。<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//ab6984020030ff15f9ddb3eb716c7da6_1440w.jpg" alt="img"></p><h2 id="5-2-感知机与多层网络"><a href="#5-2-感知机与多层网络" class="headerlink" title="5.2 感知机与多层网络"></a><strong>5.2 感知机与多层网络</strong></h2><h3 id="5-2-1-什么是感知机"><a href="#5-2-1-什么是感知机" class="headerlink" title="5.2.1 什么是感知机"></a>5.2.1 什么是感知机</h3><p>感知机（Perceptron）是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别。其学习旨在求出将训练数据进行线性划分的分离超平面，为此，导入基于误分类的损失函数，利用<strong>梯度下降法</strong>对损失函数进行极小化，求得感知机模型。它是神经网络与支持向量机的基础。</p><p><strong>感知机的数学定义：</strong> 假设输入空间(特征空间)是 $X\subseteq R^n$ ，输出空间是 y={+1, -1}。输入表示实例的特征向量，对应于输入空间(特征空间)的点；输出 $y\in Y$表示实例的类别。由输入空间到输出空间的如下函数：</p><script type="math/tex; mode=display">f(x)=sign(w\cdot x+b)</script><p>称为感知机。其中$w$和$b$为感知机模型参数，$w\subseteq R^n$ 叫做权值(weight)或权值向量(weight vector)，$b\in R$ 叫作偏置(bias)， $w\cdot x$表示$w$ 和 $x$​的内积。sign是符号函数，即：</p><script type="math/tex; mode=display">sign(x) = \begin{cases}+1, & x\geq 0\\-1, & x<0\end{cases}</script><p><strong>感知机的几何解释：</strong>感知机的几何解释是线性方程：$w\cdot x+b=0$，对应与特征空间$R^n$中的一个超平面$S$，其中$w$是从超平面的法向量，$b$是超平面的截距。</p><p>这个超平面将特征空间划分为两个部分。位于两部分的点(特征向量)分别被分为<strong>正、负两类</strong>。</p><p>因此，超平面S成为分离超平面(separating hyperplane)。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220626164153663.png" alt="image-20220626164153663"></p><p>给定训练集，则感知机的$n+1$个参数（$n$个权重$+1$个阈值）都可以通过学习得到。阈值$\theta$可以看作一个输入值固定为-1的哑结点，权重为$ω_n+1$，即假设有一个固定输入$x_{n+1}=-1$的输入层神经元，其对应的权重为$ω_n+1$，这样就把权重和阈值统一为权重的学习了。简单感知机的结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb3fdf0.png" alt="4.png"></p><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626205116065.png" alt="这里写图片描述"></p><p>该感知器具有两个输入神经元，一个输出神经元。<br>我们知道该模型是可以做与或非运算的。这是因为如果我们要做与或非运算，那么对于输入$x_1,x_2$来说，其取值只能是0或1，而我们的输出</p><script type="math/tex; mode=display">y=f(\sum^2_{i=1}w_ix_i-\theta)</script><p>如果要做与运算，那令阈值$w1=1，w2=1$，$\theta=2$，则只有在$x_1=1，x_2=1$的时候才能激活输出层神经元，输出1，其余情况均输出0。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626211107613.png" alt="这里写图片描述"></p><p>同样，如果做或运算，那令阈值$w_1=1，w_2=1，\theta=1$，则只要有一个输入$x_i=1$，即可激活输出神经元，输出1。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626211115436.png" alt="这里写图片描述"></p><p>如果对$x_1$做非运算，那么可以令阈值$w_1=-0.6，w_2=0，\theta=-0.5$，则如果$x_1=1，x_2=0$，总输入为-0.6，小于阈值，输出0，如果$x_1=0，x_2=0$，总输入为0，大于阈值，输出1。这里的激活函数为阶跃函数。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626211124168.png" alt="这里写图片描述"></p><p>经过观察，可以发现，对于只有输入层与输出层的感知机模型，其只能对线性数据进行划分，对于如下图的异或模型，其实无法准确划分的。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626211325553.png" alt="这里写图片描述"></p><p>因为任何一条线都无法将$(1，0)，(0，1)$划为一类，$(0，0)，(1，1)$划为一类。<br>但如果是两层网络（这里的两层指的是隐层与输出层，因为只有这两层中的节点是有激活函数的），在隐层有两个节点，那么此时就可以得到两条线性函数，再在输出节点汇总之后，将会得到由两条直线围成的一个面，这时就可以成功的将异或问题解决。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626211551053.png" alt="这里写图片描述"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626211600985.png" alt="这里写图片描述"></p><p>因此我们可以看到，随着网络深度的增加，每一层节点个数的增加，都可以加强网络的表达能力，网络的复杂度越高，其表示能力就越强，也就可以表达更复杂的模型。</p><p>通过上面你的示例，我们也可以看到，对网络的学习其实主要是对网络中各个节点之间的连接权值和阈值的学习，即寻找最优的连接权值和阈值从而使得该模型可以达到最优（一般是局部最优）。</p><h3 id="5-2-2-感知机的学习策略"><a href="#5-2-2-感知机的学习策略" class="headerlink" title="5.2.2 感知机的学习策略"></a>5.2.2 感知机的学习策略</h3><p><strong>感知机的线性可分性</strong>：</p><p>能够将数据集的正实例点和负实例点完全正确地划分到超平面的两侧，即对所有的$y_i=+1$的实例$i$，有$w\cdot x_i+b&gt;0$，对所有的$y_i=-1$的实例$i$，有$w\cdot x_i+b&lt;0$，则称数据集为<strong>线性可分数据集(linearly separable data set)</strong>； 否则，数据集线性不可分。</p><p><strong>感知机权重的学习规则：</strong></p><p>对于训练样本$(x，y)$，当该样本进入感知机学习后，会产生一个输出值，若该输出值与样本的真实标记不一致，则感知机会对权重进行调整，若激活函数为阶跃函数，则调整的方法为（基于梯度下降法）：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb3ba63-20220626183500252.png" alt="5.png"></p><p>其中 $η∈(0，1)$称为学习率，可以看出感知机是通过逐个样本输入来更新权重，首先设定好初始权重（一般为随机），逐个地输入样本数据，若输出值与真实标记相同则继续输入下一个样本，若不一致则更新权重，然后再重新逐个检验，直到每个样本数据的输出值都与真实标记相同。容易看出：感知机模型总是能将训练数据的每一个样本都预测正确，和决策树模型总是能将所有训练数据都分开一样，感知机模型很容易产生过拟合问题。</p><p><strong>感知机的权重更新公式</strong>：</p><script type="math/tex; mode=display">w_i\leftarrow w_i+\Delta w_i</script><script type="math/tex; mode=display">\Delta w_i=\eta(y-\hat{y})x_i</script><p>如果预测正确，感知机不发生变化；否则，根据错误程度来调整参数。感知机只有一层功能神经元，学习能力有限，只能解决线性可分问题。</p><p>经证明：若两类模式是<strong>线性可分</strong>的（存在一个超平面能将它们分开），则感知机一定会收敛；否则感知机将会发生振荡。</p><p>使用多层功能神经元，可解决非线性可分问题。隐含层hidden layer：位于输出层和输入层之间的层。</p><p>多层前馈神经网络multi-layer feedforward neural networks：相邻层全连接，同层无连接，不存在跨层连接。多层神经网络的拓扑结构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb58ec6-20220626183453242.png" alt="6.png"></p><p>在神经网络中，隐层和输出层的神经元都是具有激活函数的功能神经元。只需包含一个隐层便可以称为多层神经网络，常用的神经网络称为“多层前馈神经网络”（multi-layer feedforward neural network），该结构满足以下几个特点：</p><pre><code class="hljs">* 每层神经元与下一层神经元之间完全互连* 神经元之间不存在同层连接* 神经元之间不存在跨层连接</code></pre><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb47ff8-20220626183449784.png" alt="7.png"></p><p>根据上面的特点可以得知：这里的“前馈”指的是网络拓扑结构中不存在”环”或”回路”，而不是指该网络只能向前传播而不能向后传播（下节中的BP神经网络正是基于前馈神经网络而增加了反馈调节机制）。</p><p>神经网络的学习过程就是根据训练数据来调整神经元之间的“连接权”以及每个神经元的阈值，换句话说：神经网络所学习到的东西都蕴含在网络的连接权与阈值中。</p><h2 id="5-3-BP神经网络算法"><a href="#5-3-BP神经网络算法" class="headerlink" title="5.3 BP神经网络算法"></a><strong>5.3 BP神经网络算法</strong></h2><p>由上面可以得知：神经网络的学习主要蕴含在权重和阈值中，多层网络使用上面简单感知机的权重调整规则显然不够用了，BP神经网络算法即误差逆传播算法（error BackPropagation）正是为学习多层前馈神经网络而设计，BP神经网络算法是迄今为止最成功的的神经网络学习算法。</p><p>一般而言，只需包含一个足够多神经元的隐层，就能以任意精度逼近任意复杂度的连续函数[Hornik et al.,1989]，故下面以训练单隐层的前馈神经网络为例，介绍BP神经网络的算法思想。</p><p>多层前馈(BP)神经网络：<br>相邻两层是全连接，而层内是没有连接的，跨层之间也没有连接：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//SouthEast-20220626212100699.png" alt="这里写图片描述"></p><p>上图为一个单隐层前馈神经网络的拓扑结构，BP神经网络算法也使用<a href="https://baike.baidu.com/item/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/4864937?fr=aladdin">梯度下降法（gradient descent）</a>，以单个样本的均方误差的负梯度方向对权重进行调节。</p><p>在给定训练数据集的情况下，可以构建一个神经网络来对这些数据进行拟合。</p><p>构建过程主要分为2步：1）前向传播 2）反向求导。</p><p>在前向传播过程中，由输入层向前传送，给定权值和bias矩阵，可以得到给定样本对应的预测值（激活值）；在反向求导过程，通过样本预测值与样本真实值之间的误差来不断修正网络参数，直至收敛。</p><p>可以看出：BP算法首先将误差反向传播给隐层神经元，调节隐层到输出层的连接权重与输出层神经元的阈值；接着根据隐含层神经元的均方误差，来调节输入层到隐含层的连接权值与隐含层神经元的阈值。BP算法基本的推导过程与感知机的推导过程原理是相同的，下面给出调整隐含层到输出层的权重调整规则的推导过程：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb86229-20220626190803201.png" alt="9.png"></p><p>学习率$η∈(0，1)$控制着沿反梯度方向下降的步长，若步长太大则下降太快容易产生震荡，若步长太小则收敛速度太慢，一般地常把$η$设置为0.1，有时更新权重时会将输出层与隐含层设置为不同的学习率。BP算法的基本流程如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72cbb59e99.png" alt="10.png"></p><p>BP算法的更新规则是基于每个样本的预测值与真实类标的均方误差来进行权值调节，即<u>BP算法每次更新只针对于单个样例</u>。需要注意的是：BP算法的最终目标是要最小化整个训练集$D$上的累积误差，即：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72ce222a96.png" alt="11.png"></p><p>如果<u>基于累积误差最小化的更新规则</u>，则得到了累积误差逆传播算法（accumulated error backpropagation），即每次读取全部的数据集一遍，进行一轮学习，从而基于当前的累积误差进行权值调整，因此参数更新的频率相比标准BP算法低了很多，但在很多任务中，尤其是<u>在数据量很大的时候，往往标准BP算法会获得较好的结果</u>。另外对于如何设置隐层神经元个数的问题，至今仍然没有好的解决方案，常使用“试错法”进行调整。</p><p>前面提到，BP神经网络强大的学习能力常常容易造成过拟合问题，有以下两种策略来缓解BP网络的过拟合问题：</p><ul><li>早停：将数据分为训练集与测试集，训练集用于学习，测试集用于评估性能，若在训练过程中，训练集的累积误差降低，而测试集的累积误差升高，则停止训练。</li><li>引入正则化（regularization）：基本思想是在累积误差函数中增加一个用于描述网络复杂度的部分，例如所有权值与阈值的平方和，其中$λ∈(0,1)$用于对累积经验误差与网络复杂度这两项进行折中，常通过交叉验证法来估计。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72ce227ff1.png" alt="12.png"></p><p>拓展阅读：</p><p><a href="https://blog.csdn.net/as091313/article/details/79080583">BP神经网络</a></p><h2 id="5-4-全局最小与局部最小"><a href="#5-4-全局最小与局部最小" class="headerlink" title="5.4 全局最小与局部最小"></a><strong>5.4 全局最小与局部最小</strong></h2><p>模型学习的过程实质上就是一个寻找最优参数的过程，例如BP算法试图通过最速下降来寻找使得累积经验误差最小的权值与阈值，在谈到最优时，一般会提到局部极小（local minimum）和全局最小（global minimum）。</p><pre><code class="hljs">* 局部极小解：参数空间中的某个点，其邻域点的误差函数值均不小于该点的误差函数值。* 全局最小解：参数空间中的某个点，所有其他点的误差函数值均不小于该点的误差函数值。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72ce2803dc.png" alt="13.png"></p><p>要成为局部极小点，只要满足该点在参数空间中的梯度为零。局部极小可以有多个，而全局最小只有一个。全局最小一定是局部极小，但局部最小却不一定是全局最小。显然在很多机器学习算法中，都试图找到目标函数的全局最小。梯度下降法的主要思想就是沿着负梯度方向去搜索最优解，负梯度方向是函数值下降最快的方向，若迭代到某处的梯度为0，则表示达到一个局部最小，参数更新停止。</p><p>因此在现实任务中，通常使用以下策略尽可能地去接近全局最小：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">* 以多组不同参数值初始化多个神经网络，按标准方法训练，迭代停止后，取其中误差最小的解作为最终参数。<br>* 使用“模拟退火”技术，这里不做具体介绍。<br>* 使用随机梯度下降，即在计算梯度时加入了随机因素，使得在局部最小时，计算的梯度仍可能不为0，从而迭代可以继续进行。<br>* 遗传算法genetic algorithm<br>上述技术大多是启发式，理论上尚缺乏保障。<br></code></pre></td></tr></table></figure><h2 id="5-5其他常见神经网络"><a href="#5-5其他常见神经网络" class="headerlink" title="5.5其他常见神经网络"></a>5.5其他常见神经网络</h2><h3 id="5-5-1RBF网络"><a href="#5-5-1RBF网络" class="headerlink" title="5.5.1RBF网络"></a>5.5.1RBF网络</h3><p>RBF（Radial Basis Function径向基函数）网络：一种单隐层前馈神经网络，它使用径向基函数作为隐层神经元的激活函数，而输出层是对隐层神经单元输出的线性组合。</p><p>RBF网络训练过程：1.确定神经元中心，常用随机采样、聚类等；2.利用BP算法来确定参数。</p><h3 id="5-5-2-ART网络"><a href="#5-5-2-ART网络" class="headerlink" title="5.5.2 ART网络"></a>5.5.2 ART网络</h3><p>竞争型学习competitive learning：一种常用的无监督策略，网络的输出神经元互相竞争，每一时刻只有一个竞争获胜的神经元被激活，其他神经元被抑制。又称”胜者通吃“</p><p>ART（Adaptive Resonance Theory自适应谐振理论）网络是竞争型学习的重要代表，该网络由比较层、识别层、识别阈值、重置模块构成。其中，比较层负责接收输入样本并将其传递给识别层神经元，识别层每个神经元对应一个模式类，神经元数目可在训练过程中动态增加以增加新的模式类。</p><p>ART比较好地缓解了竞争学习中的”可塑性-稳定性窘境“，可塑性是指神经网络学习新知识的能力，稳定性是指神经网络在学习新知识时要保持对旧知识的记忆。ART网络可以进行增量学习incremental learning或在线学习online learning。</p><p>增量学习：在学得模型之后，再接收到训练样例时，只需要根据新样例对模型进行更新，不必重新训练整个模型，并且先前学习的有效信息不会被”冲掉“。<br>在线学习：每获得一个新样例就进行一次模型更新，在线学习是增量学习的一个特例。</p><h3 id="5-5-3-SOM网络"><a href="#5-5-3-SOM网络" class="headerlink" title="5.5.3 SOM网络"></a>5.5.3 SOM网络</h3><p>SOM（Self-Organizing Map自组织映射）网络，是一种竞争型学习的无监督神经网络，它能将高维输入数据映射到低维空间中（通常为二维），同时保持数据再高维空间中的拓扑结构，即在高维空间中相似的样本点会被映射到网络输出层中邻近的神经元。</p><h3 id="5-5-4-级联相关网络"><a href="#5-5-4-级联相关网络" class="headerlink" title="5.5.4 级联相关网络"></a>5.5.4 级联相关网络</h3><p>结构自适应网络：不仅将参数作为学习目标，并且将网络的结构也作为学习的目标之一。</p><p>级联相关（Cascade-Correlation）网络，是结构自适应网络的一种重要代表。级联是指建立层次连接的层次结构，在开始训练时网络只有输入层和输出层，处于最小拓扑结构，随着训练进行，新的隐层神经元逐渐加入，从而创建起层级结构，当新的隐层神经元加入时，其输入端连接权值是冻结固定的。相关是指通关最大化新神经元的输出与网络误差之间的相关性来训练相关的参数。</p><p>与一般的神经网络相比，级联相关网络无需设置网络层数、隐层神经元数目，且训练速度快，但是在数据较小时容易过拟合。</p><h3 id="5-5-5-Elman网络"><a href="#5-5-5-Elman网络" class="headerlink" title="5.5.5 Elman网络"></a>5.5.5 Elman网络</h3><p>递归神经网络recurrent neural networks：允许出现环形结构，从而让一些神经元的输出反馈回来作为输入信号。这样的结构与信息反馈过程，使得网络在$t$时刻的输出状态不仅与$t$时刻的输入有关，还与$t-1$时刻的网络状态有关，从而能处理与时间有关的动态变化。</p><p>Elman网络是最常用的递归神经网络之一，其结构如下。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODg5MzQy,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><h3 id="5-5-6-Boltzmann机"><a href="#5-5-6-Boltzmann机" class="headerlink" title="5.5.6 Boltzmann机"></a>5.5.6 Boltzmann机</h3><p>Boltzmann机是一种基于能量的模型，神经元分为两层：显层和隐层，显层用于表示数据的输入和输出，隐层被理解为数据的内在表达。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODg5MzQy,size_16,color_FFFFFF,t_70-20220627210733876.png" alt="在这里插入图片描述"></p><p>标准Boltzmann机是一个全连接图，训练网络的复杂度很高，这使其难以用于解决现实任务，现实常采用受限Boltzmann机。</p><p>受限Boltzmann机常采用对比散度（Contrastive Divergence，简称CD）来进行训练。</p><h2 id="5-6-深度学习"><a href="#5-6-深度学习" class="headerlink" title="5.6 深度学习"></a><strong>5.6 深度学习</strong></h2><p>理论上，参数越多的模型复杂度越高，容量就越大，这意味着它可以完成更为复杂的任务，但一般情况下，复杂模型的训练效率低，易陷入过拟合。计算能力的大幅度提升可以缓解训练过程的低效性，训练数据的大幅增加可降低过拟合风险。</p><p>单隐层的前馈神经网络已具有很强大的学习能力，但从模型的复杂度来看，增加隐层的数目显然比增加隐层的神经元数目更有效。</p><p>多层神经网络难以直接用经典算法进行训练，因为误差在多隐层内逆传播时，往往会发散而不能收敛到稳定状态。</p><p>那要怎么有效地训练多隐层神经网络呢？一般来说有以下两种方法：</p><ul><li><p>无监督逐层训练（unsupervised layer-wise training）：每次训练一层隐节点，把上一层隐节点的输出当作输入来训练，本层隐结点训练好后，输出再作为下一层的输入来训练，这称为预训练（pre-training）。全部预训练完成后，再对整个网络进行微调（fine-tuning）训练。一个典型例子就是深度信念网络（deep belief network，简称DBN）。这种做法其实可以视为把大量的参数进行分组，对每组先找到局部看起来比较好的设置，然后再基于这些局部较优的结果联合起来进行全局寻优。这在利用了模型大量参数提供的自由度的同时，有效地节省了训练开销，</p></li><li><p>权共享（weight sharing）：令同一层神经元使用完全相同的连接权，典型的例子是卷积神经网络（Convolutional Neural Network，简称CNN）。这样做可以大大减少需要训练的参数数目。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72ce28d756.png" alt="14.png"></p><p>深度学习，通过多层处理，逐渐将初始的底层特征表示转化为高层特征表示，用简单模型即可完成复杂的任务。深度学习可理解为特征学习（feature learning）或表示学习（representation learning）。</p><p>无论是DBN还是CNN，都是通过多个隐层来把与输出目标联系不大的初始输入转化为与输出目标更加密切的表示，使原来只通过单层映射难以完成的任务变为可能。即通过多层处理，逐渐将初始的“低层”特征表示转化为“高层”特征表示，从而使得最后可以用简单的模型来完成复杂的学习任务。</p><p>传统任务中，样本的特征需要人类专家来设计，这称为特征工程（feature engineering）。特征好坏对泛化性能有至关重要的影响。而深度学习为全自动数据分析带来了可能，可以自动产生更好的特征。</p><h1 id="6、支持向量机"><a href="#6、支持向量机" class="headerlink" title="6、支持向量机"></a><strong>6、支持向量机</strong></h1><p>支持向量机（Support Vector Machine），简称SVM，是一种经典的二分类模型，属于监督学习算法。</p><p>支持向量机可能是最流行和最受关注的机器学习算法之一，它是一种经典的二分类模型，基本模型定义为特征空间中最大间隔的线性分类器，其学习的优化目标便是间隔最大化，因此支持向量机本身可以转化为一个凸二次规划求解的问题。</p><p><a href="https://so.csdn.net/so/search?q=支持向量机&amp;spm=1001.2101.3001.7020">支持向量机</a>可以说是数学推导过程最复杂的<a href="https://blog.csdn.net/v_JULY_v/article/details/7624837?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165635027116782248597637%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165635027116782248597637&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-7624837-null-null.142^v24^control,157^v15^new_3&amp;utm_term=%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA&amp;spm=1018.2226.3001.4187">算法</a>，<a href="https://blog.csdn.net/weixin_55858423/article/details/119080443?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-119080443-blog-90678747.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-119080443-blog-90678747.pc_relevant_antiscanv2&amp;utm_relevant_index=6">具体推导过程</a>。</p><p><a href="https://blog.csdn.net/lzx159951/article/details/106692871?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165635027116782248597637%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165635027116782248597637&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-106692871-null-null.142^v24^control,157^v15^new_3&amp;utm_term=%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA&amp;spm=1018.2226.3001.4187">参考源代码解析</a></p><h2 id="6-1-函数间隔与几何间隔"><a href="#6-1-函数间隔与几何间隔" class="headerlink" title="6.1 函数间隔与几何间隔"></a><strong>6.1 函数间隔与几何间隔</strong></h2><blockquote><p>支持向量机的目标是确定一个对样本的分类结果最鲁棒的线性<a href="https://so.csdn.net/so/search?q=分类器&amp;spm=1001.2101.3001.7020">分类器</a>，即找到一个具有最大间隔的划分超平面。为此以间隔为优化目标，可将其转化为一个凸二次规划问题。</p></blockquote><p>对于二分类问题，其基本思想就是基于训练集$D$在样本空间中找到一个用来划分的超平面，将不同类别的样本分开。</p><p>但仅仅是将样本分开的话，那么我们可能可以找到许多个划分超平面。如图所示，从几何意义易知，粗线对训练样本局部的扰动的“容忍性”最好（其他的超平面训练样本很容易越界，考虑到噪声等因素，其分类结果很不稳定），也是最鲁棒的（即当新的数据点加入时，超平面对这些点的适应性最强，出错的可能性最小）。于是粗线也就是我们想要的最优划分超平面。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWNoZW5zdXl1,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>我们知道最优划分超平面应该满足超平面同时离两个不同类的样本尽量远这一条件，以下是为了量化“尽量远”进行的概念引申：</p><p><strong>超平面方程</strong>：样本空间中，用来描述超平面的线性方程为：</p><script type="math/tex; mode=display">w^Tx+b=0</script><p>其中$w=(w_1;w_2;…;w_d)$为法向量，决定了超平面的方向；$b$为位移项，决定了超平面与原点之间的距离。</p><p><strong>点到超平面的距离</strong>：样本空间中任意点$x$到超平面$(w,b)$的距离为：</p><script type="math/tex; mode=display">r=\frac{|w^Tx+b|}{||w||}</script><p><strong>约束条件</strong>：假设超平面$(w，b)$能将训练样本正确分类，即对于$(x_i,y_i)\in D$，若$y_i=+1$，则有$w^Tx_i+b&gt;0$；若$y_i=-1$，则有$w^Tx_i+b&lt;0$​，令</p><script type="math/tex; mode=display">\begin{cases}w^Tx_i+b\geq+1, & y_i=+1\\w^Tx_i+b\leq-1, &  y_i=-1\end{cases}</script><p>为超平面将训练样本正确分类的约束条件。</p><h3 id="6-1-1-函数间隔"><a href="#6-1-1-函数间隔" class="headerlink" title="6.1.1 函数间隔"></a><strong>6.1.1 函数间隔</strong></h3><p>假设最合适的分类超平面已找到，如前所述，分类超平面的方程即为：$f(x)=w^Tx+b=0$，也就是说超平面上的点都符合该方程式。</p><p><strong>函数间隔</strong>的定义为：</p><script type="math/tex; mode=display">\hat{\gamma}=yf(x)=y(w^Tx+b)</script><p>而超平面$(w,b)$关于所有样本点$(x_i，y_i)$的函数间隔最小值则为超平面在训练数据集$T$​上的函数间隔：</p><script type="math/tex; mode=display">\hat{\gamma}=min\hat{\gamma},\ (i=1,...,n)</script><p>可以看出：这样定义的函数间隔在处理SVM上会有问题，当超平面的两个参数$w$和$b$同比例改变时，函数间隔也会跟着改变，但是实际上超平面还是原来的超平面，并没有变化。例如：$w_1x_1+w_2x_2+w_3x_3+b=0$其实等价于$2w_1x_1+2w_2x_2+2w_3x_3+2b=0$，但计算的函数间隔却翻了一倍。从而引出了能真正度量点到超平面距离的概念——几何间隔（geometrical margin）。</p><h3 id="6-1-2-几何间隔"><a href="#6-1-2-几何间隔" class="headerlink" title="6.1.2 几何间隔"></a><strong>6.1.2 几何间隔</strong></h3><p><strong>几何间隔</strong>代表的则是数据点到超平面的真实距离，对于超平面$w’x+b=0$，$w$代表的是该超平面的法向量，设$x$为超平面外一点在法向量$w$方向上的投影点，$x$与超平面的距离为$\gamma$，则有：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f697d499.png" alt="5.png"></p><p>为了得到$\gamma$的绝对值，令$\gamma$呈上其对应的类别$y$，即可得到几何间隔的定义：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f696fd10.png" alt="6.png"></p><p>从上述定义可以看出：实质上函数间隔就是$|w’x+b|$，而几何间隔就是函数间隔除以$||w||$，直观来讲就是点到超平面的距离。</p><h2 id="6-2-最大间隔与支持向量"><a href="#6-2-最大间隔与支持向量" class="headerlink" title="6.2 最大间隔与支持向量"></a><strong>6.2 最大间隔与支持向量</strong></h2><p>SVM之所以叫支持向量机，因为其核心理念是：支持向量样本会对识别的问题起关键性作用。那什么是支持向量（Support <a href="https://so.csdn.net/so/search?q=vector&amp;spm=1001.2101.3001.7020">vector</a>）呢？支持向量也就是离分类超平面（Hyper plane）最近的样本点。</p><p>如下图所示，有两类样本数据（橙色和蓝色的小圆点），中间的红线是分类超平面，两条虚线上的点（橙色圆点3个和蓝色圆点2个）是距离超平面最近的点，这些点即为<strong>支持向量</strong>。简单地说，作为支持向量的样本点<strong>非常非常重要</strong>，以至于其他的样本点可以视而不见。而这个分类超平面正是SVM分类器，通过这个分类超平面实现对样本数据一分为二。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzYzMDMy,size_16,color_FFFFFF,t_70-20220628001505170.png" alt="在这里插入图片描述"></p><p>如何找到最合适的分类超平面？依据的原则就是间隔最大化。</p><p>所谓间隔最大化，说的是分类超平面跟两类数据的间隔要尽可能大（即远离两边数据），这就要提到我们前面说到的公平原则。“三八线”要划在课桌正中间，不偏向任何一方，才能保证双方利益最大化。对于分类超平面来说，也就是要位于两类数据的正中间，不偏向任何一类，才能保证离两边数据都尽可能远，从而实现间隔最大化。</p><p>如左下图所示，有两类样本数据（分别用橙色和蓝色的小圆圈表示），我们可通过红色或蓝色两条直线（L1或L2）将这两类样本数据分开。事实上，我们还可以画出很多条直线将两类样本分开，也就是说，存在有多个可行的线性分类器能将两类样本分类。SVM的最终目标是：以间隔最大化为原则找到最合适的那个分类器。<br><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzYzMDMy,size_16,color_FFFFFF,t_70-20220628001732659.png" alt="在这里插入图片描述"></p><p>从直观上看，图中蓝线L2偏向了橙色数据一方，有失<strong>公平原则</strong>，因而不是我们要找的理想的分类器。红线L1则较注重公平，不偏向任何一类数据，从而能较好地确保离两类数据都尽可能远，实现间隔最大化，这样的分类超平面具有更好的泛化性能，分类更加准确，正是我们要找的最合适的分类器。</p><p>我们注意到，图中两条虚线（S1和S2）上的圆点数据即为支持向量（Support vector），它们距离分类超平面最近。现在<u>我们仅保留这些支持向量数据点进行分析</u>（右上图），可以看出两条虚线之间的间隔距离为$\gamma$。依据公平原则，支持向量到分类超平面的距离则为$\gamma /2$，这个值即为分类间隔。间隔最大化，就是最大化这个值$\gamma /2$。</p><p><u>由此可以看出，分类间隔值$\gamma /2$只与支持向量数据点有关，与其他非支持向量数据点无关。</u>这也正好诠释了我们在文中开头说到的：SVM的核心理念是支持向量样本会对识别的问题起关键性作用。也就是说，分类超平面的确定仅取决于支持向量。</p><p>对于给定的训练样本，首先要找到距离分类超平面最近的点（支持向量），再通过最大化这些点之间的间隔来求解。</p><p>通过前面的分析可知：函数间隔不适合用来最大化间隔，因此这里我们要找的最大间隔指的是几何间隔。</p><p>为便于计算，位于分类超平面两侧的数据计算的数值分别取1或-1，以将数据分两类，这两类数据通常也称为正、负样本数据。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzYzMDMy,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>两类数据的函数方程式即为：</p><script type="math/tex; mode=display">正样本：f(x)=w^Tx+b=1\\负样本：f(x)=w^Tx+b=-1</script><p>也就是说任何属于正样本类的数据$x$带入方程式得到的结果$y$计算取值都为1，即$y=1$；任何属于负样本类的数据$x$带入方程式得到的结果$y$计算取值都为-1，即$y=-1$​。</p><p>两个不同类别的支持向量分别到超平面的距离之和</p><script type="math/tex; mode=display">\gamma=\frac{2}{||w||}</script><p>推导过程：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWNoZW5zdXl1,size_16,color_FFFFFF,t_70-20220627230850969.png" alt="在这里插入图片描述"></p><p>于是，最优划分超平面即对应最大间隔的划分超平面，也就是找到满足约束条件的 $w$ 和 $b$ 使得$γ$​ 最大，即：</p><script type="math/tex; mode=display">max_{w,b} \frac{2}{||w||}\\s.t.\ y_i(w^Tx_i+b)\geq1,\ i=1,2,...,m</script><p>最大化$||w||^{-1}$等驾驭最小化$||w||^2$，于是上述条件可重写为：</p><script type="math/tex; mode=display">max_{w,b} \frac{1}{2}||w||^2\\s.t.\ y_i(w^Tx_i+b)\geq1,\ i=1,2,...,m</script><p><img src="https://i.loli.net/2018/10/17/5bc72f6a838c4.png" alt="9.png"></p><p>这里解释一下为什么要用$||w||^2$：由约束条件可知将不会存在错误分类的样本，即不存在欠拟合的问题；那么，上式的优化目标可进一步解释为“最小化$\frac{1}{2}||w||^2$则相当于寻找最不可能过拟合的分类超平面”，为了防止过拟合引入了正则化，即在最小化目标函数中加入分类器的所有参数的模值的平方（不含位移项$b$）。</p><h2 id="6-3-从原始优化问题到对偶问题"><a href="#6-3-从原始优化问题到对偶问题" class="headerlink" title="6.3 从原始优化问题到对偶问题"></a><strong>6.3 从原始优化问题到对偶问题</strong></h2><blockquote><p>对于上述目标函数，接下来我们将采用拉格朗日乘子法得到其对偶问题。由于该对偶问题又为二次规划问题，故采用了SMO算法对其进行求解。</p></blockquote><h3 id="6-3-1-转换对偶问题"><a href="#6-3-1-转换对偶问题" class="headerlink" title="6.3.1 转换对偶问题"></a>6.3.1 转换对偶问题</h3><p>对于上述得到的目标函数，将原来的目标函数转化为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f6978cbb.png" alt="10.png"></p><p>即变为了一个带约束的凸二次规划问题，按书上所说可以使用现成的优化计算包（QP优化包）求解，但由于SVM的特殊性，一般我们将原问题变换为它的<strong>对偶问题</strong>，接着再对其对偶问题进行求解。为什么通过对偶问题进行求解，有下面两个原因：</p><pre><code class="hljs">* 一是因为使用对偶问题更容易求解；* 二是因为通过对偶问题求解出现了向量内积的形式，从而能更加自然地引出核函数。</code></pre><p>以下是拉格朗日乘子法求得其对偶问题的基本步骤：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//20190530105244927.png" alt=""></p><p>对偶问题，顾名思义，可以理解成优化等价的问题，更一般地，是将一个原始目标函数的最小化转化为它的对偶函数最大化的问题。</p><p>对于当前的优化问题，按照上面的步骤，首先我们写出它的朗格朗日函数：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f9332be7.png" alt="11.png"></p><p>上式很容易验证：当其中有一个约束条件不满足时，$L$的最大值为 ∞（只需令其对应的$α$为 $∞$即可）；当所有约束条件都满足时，$L$的最大值为$1/2||w||^2$（此时令所有的$α$为0），因此实际上原问题等价于：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f93321c5.png" alt="12.png"></p><p>由于这个的求解问题不好做，因此一般我们将最小和最大的位置交换一下（需满足KKT条件） ，变成原问题的对偶问题：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f9330967.png" alt="13.png"></p><p>这样就将原问题的求最小变成了对偶问题求最大（用对偶这个词还是很形象），接下来便可以先求$L$对$w$和$b$的极小，再求$L$对$α$的极大。</p><p>（1）首先求$L$对$w$和$b$的极小，分别求$L$关于$w$和$b$的偏导，可以得出：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f9333e66.png" alt="14.png"></p><p>将上述结果代入$L$得到：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f935ae21.png" alt="15.png"></p><p>推导过程：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWNoZW5zdXl1,size_16,color_FFFFFF,t_70-20220628004324967.png" alt="在这里插入图片描述"></p><p>（2）接着$L$关于$α$极大求解$α$。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f9338a9d.png" alt="16.png"></p><p>（3）最后便可以根据求解出的$α$，计算出$w$和$b$，从而得到分类超平面函数。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f93419ca.png" alt="17.png"></p><p>在对新的点进行预测时，实际上就是将数据点$x$代入分类函数$f(x)=w’x+b$中，若$f(x)&gt;0$，则为正类，$f(x)&lt;0$，则为负类，根据前面推导得出的$w$与$b$，分类函数如下所示，此时便出现了上面所提到的内积形式。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc72f9353166.png" alt="18.png"></p><p>这里实际上只需计算新样本与支持向量的内积，因为对于非支持向量的数据点，其对应的拉格朗日乘子一定为0，根据最优化理论（K-T条件），即要求：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//20190530120814493.png" alt="在这里插入图片描述"></p><p>注：KKT条件主要包含三大部分：<br>①：拉格朗日乘子$≥ 0$<br>②：原问题的约束条件<br>③：拉格朗日函数中的拉格朗日乘子项$= 0 $</p><p>因此，根据以上KKT条件，我们可以对$\alpha_i$的取值进行讨论，并得出支持向量机一个重要结论：==训练完成后，大部分的训练样本都不需要保留，最终模型仅与支持向量有关。==</p><p>对于不等式约束$y(w’x+b)-1≥0$，满足：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f933c947.png" alt="19.png">        </p><h3 id="6-3-2-求解对偶问题"><a href="#6-3-2-求解对偶问题" class="headerlink" title="6.3.2 求解对偶问题"></a>6.3.2 求解对偶问题</h3><p><a href="https://blog.csdn.net/shichensuyu/article/details/90678747">SMO推导过程</a></p><h2 id="6-4-核函数"><a href="#6-4-核函数" class="headerlink" title="6.4 核函数"></a><strong>6.4 核函数</strong></h2><blockquote><p>前三节是在样本在其原始样本空间线性可分的假设下进行讨论的，本节针对原始样本空间线性不可分的问题，基于==有限维原始样本空间一定存在一个高维特征空间使样本线性可分==这一定理，引出了原始空间和特征空间的桥梁——核函数的相关概念，并强调==核函数的选择是支持向量机的最大变数。==</p></blockquote><p>将样本从原始样本空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分，令$\phi(x)$表示将$x$​映射后的特征向量，则在特征空间中划分超平面所对应的模型可表示为：</p><script type="math/tex; mode=display">f(x)=w^T\phi(x)+b</script><p>按照同样的方法，先写出新目标函数的拉格朗日函数，接着写出其对偶问题，求$L$关于$w$和$b$的极大，最后运用SOM求解$α$。可以得出：</p><p>（1）原对偶问题变为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730cc68b3b.png" alt="21.png"></p><p>（2）原分类函数变为：<br>​    <img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730cc1b673.png" alt="22.png"></p><p>求解的过程中，只涉及到了高维特征空间中的内积运算，由于特征空间的维数可能会非常大，例如：若原始空间为二维，映射后的特征空间为5维，若原始空间为三维，映射后的特征空间将是19维，之后甚至可能出现无穷维，根本无法进行内积运算了，此时便引出了<strong>核函数</strong>（Kernel）的概念。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730cc49adc.png" alt="23.png"></p><p>因此，核函数可以直接计算隐式映射到高维特征空间后的向量内积，而不需要显式地写出映射后的结果，它虽然完成了将特征从低维到高维的转换，但最终却是在低维空间中完成向量内积计算，与高维特征空间中的计算等效<strong>（低维计算，高维表现）</strong>，从而避免了直接在高维空间无法计算的问题。引入核函数后，原来的对偶问题与分类函数则变为：</p><p>（1）对偶问题：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730cc173b2.png" alt="24.png"></p><p>（2）分类函数：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730cc05959.png" alt="25.png"></p><p>因此，在线性不可分问题中，==核函数的选择成了支持向量机的最大变数==，若选择了不合适的核函数，则意味着将样本映射到了一个不合适的特征空间，则极可能导致性能不佳。同时，核函数需要满足以下这个必要条件：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730ccc468c.png" alt="26.png"></p><p>注：</p><ul><li>半正定矩阵：设$A$为实对称矩阵，若对于每个非零向量$X$，都有$X^TAX\geq0$，则称$A$为半正定矩阵，$X^TAX$为半正定二次型。</li></ul><p>由该定理可以看出，核矩阵是实对称矩阵，==只要一个对称函数对应的核矩阵半正定，它就可以作为核函数==。</p><p>由于核函数的构造十分困难，通常我们都是从一些常用的核函数中选择，下面列出了几种常用的核函数：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730ccc541a.png" alt="27.png"></p><h2 id="6-5-软间隔支持向量机"><a href="#6-5-软间隔支持向量机" class="headerlink" title="6.5 软间隔支持向量机"></a><strong>6.5 软间隔支持向量机</strong></h2><blockquote><p>前面的内容都是基于理论进行的推导，但在现实情况下我们很难确定合适的核函数对样本进行完美分类，故提出了软间隔的概念，允许有尽可能少的样本不满足约束条件。于是在前面的基础上，模型加入了对各个样本松弛变量的考量，并采用6.3节的方法进行求解。</p></blockquote><p>前面的讨论中，我们主要解决了两个问题：当数据线性可分时，直接使用最大间隔的超平面划分；当数据线性不可分时，则通过核函数将数据映射到高维特征空间，使之线性可分。然而在现实问题中，对于某些情形还是很难处理，例如数据中有<strong>噪声</strong>的情形，噪声数据（<strong>outlier</strong>）本身就偏离了正常位置，但是在前面的SVM模型中，我们要求所有的样本数据都必须满足约束，如果不要这些噪声数据还好，当加入这些outlier后导致划分超平面被挤歪了，如下图所示，对支持向量机的泛化性能造成很大的影响。</p><p><img src="https://i.loli.net/2018/10/17/5bc730ccce68e.png" alt="28.png"></p><p>为了解决这一问题，我们需要允许某一些数据点不满足约束，即可以在一定程度上偏移超平面，同时使得不满足约束的数据点尽可能少，这便引出了<strong>“软间隔”支持向量机</strong>的概念</p><pre><code class="hljs">* 允许某些数据点不满足约束y(w&#39;x+b)≥1；* 同时又使得不满足约束的样本尽可能少。</code></pre><p>这样优化目标变为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc730cc6c9fe.png" alt="29.png"></p><p>如同阶跃函数，0/1损失函数虽然表示效果最好，但是数学性质不佳。因此常用其它函数作为“替代损失函数”。</p><p><img src="https://i.loli.net/2018/10/17/5bc730cc5e5a9.png" alt="30.png"></p><p>支持向量机中的损失函数为<strong>hinge损失</strong>，引入<strong>“松弛变量”</strong>，目标函数与约束条件可以写为：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc7317aa3411.png" alt="31.png"></p><p>其中$C$为一个参数，控制着目标函数与新引入正则项之间的权重，这样显然每个样本数据都有一个对应的松弛变量，用以表示该样本不满足约束的程度，将新的目标函数转化为拉格朗日函数得到：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc7317a4c96e.png" alt="32.png"></p><p>按照与之前相同的方法，先让$L$求关于$w$，$b$以及松弛变量的极小，再使用SMO求出$α$，有：</p><p><img src="https://i.loli.net/2018/10/17/5bc7317a6dff2.png" alt="33.png"></p><p>将$w$代入$L$化简，便得到其对偶问题：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5bc7317ab6646.png" alt="34.png"></p><p>对于软间隔支持向量机，KKT条件要求：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//20190530210442677.png" alt="在这里插入图片描述"></p><p>推导过程：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaWNoZW5zdXl1,size_16,color_FFFFFF,t_70-20220628011444870.png" alt="在这里插入图片描述"></p><p>由上图的推导可以看出，软间隔支持向量机的最终模型仅与支持向量有关，即通过hinge损失函数仍保持了稀疏性。</p><p>将“软间隔”下产生的对偶问题与原对偶问题对比可以发现：新的对偶问题只是约束条件中的$α$多出了一个上限$C$，其它的完全相同，因此在引入核函数处理线性不可分问题时，便能使用与“硬间隔”支持向量机完全相同的方法。</p><p>——在此SVM就介绍完毕。</p><h2 id="6-6-SVM优缺点"><a href="#6-6-SVM优缺点" class="headerlink" title="6.6 SVM优缺点"></a>6.6 SVM优缺点</h2><p><strong>优点</strong></p><ul><li>可以解决高维问题，即大型特征空间；</li><li>解决小样本下机器学习问题；</li><li>能够处理非线性特征的相互作用；</li><li>无局部极小值问题；（相对于神经网络等算法）</li><li>无需依赖整个数据；</li><li>泛化能力比较强；</li></ul><p><strong>缺点</strong></p><ul><li>当观测样本很多时，效率并不是很高；</li><li>对非线性问题没有通用解决方案，有时候很难找到一个合适的核函数；</li><li>对于核函数的高维映射解释力不强，尤其是径向基函数；</li><li>常规SVM只支持二分类；</li><li><strong>对缺失数据敏感；</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql语句</title>
    <link href="/2022/06/22/Mysql%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/06/22/Mysql%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="MySQL-语法"><a href="#MySQL-语法" class="headerlink" title="MySQL 语法"></a>MySQL 语法</h1><h2 id="1-Mysql基础"><a href="#1-Mysql基础" class="headerlink" title="1.Mysql基础"></a>1.Mysql基础</h2><h4 id="MySQL登录"><a href="#MySQL登录" class="headerlink" title="MySQL登录"></a>MySQL登录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[root@host]# mysql -u root -p<br>Enter password:******<br></code></pre></td></tr></table></figure><h4 id="退出MySQL"><a href="#退出MySQL" class="headerlink" title="退出MySQL"></a>退出MySQL</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; exit<br>Bye<br></code></pre></td></tr></table></figure><h3 id="1-1-MySQL-数据库操作"><a href="#1-1-MySQL-数据库操作" class="headerlink" title="1.1 MySQL 数据库操作"></a>1.1 MySQL 数据库操作</h3><h4 id="查询所有的数据库"><a href="#查询所有的数据库" class="headerlink" title="查询所有的数据库"></a>查询所有的数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW DATABASES;<br></code></pre></td></tr></table></figure><h4 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use 数据库名称;<br></code></pre></td></tr></table></figure><h4 id="查看当前使用的数据库"><a href="#查看当前使用的数据库" class="headerlink" title="查看当前使用的数据库"></a>查看当前使用的数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select database();<br></code></pre></td></tr></table></figure><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE 数据库名;<br>CREATE DATABASE IF NOT EXISTS 数据库名称;<br></code></pre></td></tr></table></figure><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database &lt;数据库名&gt;;<br>DROP DATABASE IF EXISTS 数据库名称;<br></code></pre></td></tr></table></figure><h3 id="1-2-MySQL-数据类型"><a href="#1-2-MySQL-数据类型" class="headerlink" title="1.2 MySQL 数据类型"></a>1.2 MySQL 数据类型</h3><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小</th><th style="text-align:center">范围（有符号）</th><th style="text-align:center">范围（无符号）</th><th>用途</th></tr></thead><tbody><tr><td style="text-align:center">TINYINT</td><td style="text-align:center">1 Bytes</td><td style="text-align:center">(-128，127)</td><td style="text-align:center">(0，255)</td><td>小整数值</td></tr><tr><td style="text-align:center">SMALLINT</td><td style="text-align:center">2 Bytes</td><td style="text-align:center">(-32 768，32 767)</td><td style="text-align:center">(0，65 535)</td><td>大整数值</td></tr><tr><td style="text-align:center">MEDIUMINT</td><td style="text-align:center">3 Bytes</td><td style="text-align:center">(-8 388 608，8 388 607)</td><td style="text-align:center">(0，16 777 215)</td><td>大整数值</td></tr><tr><td style="text-align:center">INT或INTEGER</td><td style="text-align:center">4 Bytes</td><td style="text-align:center">(-2 147 483 648，2 147 483 647)</td><td style="text-align:center">(0，4 294 967 295)</td><td>大整数值</td></tr><tr><td style="text-align:center">BIGINT</td><td style="text-align:center">8 Bytes</td><td style="text-align:center">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td style="text-align:center">(0，18 446 744 073 709 551 615)</td><td>极大整数值</td></tr><tr><td style="text-align:center">FLOAT</td><td style="text-align:center">4 Bytes</td><td style="text-align:center">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td style="text-align:center">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td>单精度 浮点数值</td></tr><tr><td style="text-align:center">DOUBLE</td><td style="text-align:center">8 Bytes</td><td style="text-align:center">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align:center">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>双精度 浮点数值</td></tr><tr><td style="text-align:center">DECIMAL</td><td style="text-align:center">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td style="text-align:center">依赖于M和D的值</td><td style="text-align:center">依赖于M和D的值</td><td>小数值</td></tr></tbody></table></div><h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p><p>TIMESTAMP类型有专有的自动更新特性。</p><div class="table-container"><table><thead><tr><th>类型</th><th>大小 ( bytes)</th><th>范围</th><th>格式</th><th>用途</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01/9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>‘-838:59:59’/‘838:59:59’</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901/2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00/9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td>YYYYMMDD HHMMSS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table></div><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><div class="table-container"><table><thead><tr><th>类型</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table></div><h3 id="1-3-MySQL数据表操作"><a href="#1-3-MySQL数据表操作" class="headerlink" title="1.3 MySQL数据表操作"></a>1.3 MySQL数据表操作</h3><h4 id="查询当前数据库下所有表名称"><a href="#查询当前数据库下所有表名称" class="headerlink" title="查询当前数据库下所有表名称"></a>查询当前数据库下所有表名称</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TABLES;<br></code></pre></td></tr></table></figure><h4 id="查询表结构（即表的所有列名及其数据类型）"><a href="#查询表结构（即表的所有列名及其数据类型）" class="headerlink" title="查询表结构（即表的所有列名及其数据类型）"></a>查询表结构（即表的所有列名及其数据类型）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESC 表名称;<br></code></pre></td></tr></table></figure><h4 id="创建Table"><a href="#创建Table" class="headerlink" title="创建Table"></a>创建Table</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名 ( <br>  字段名1 数据类型1, <br>  字段名2 数据类型2,<br>  ...<br>字段名n 数据类型n );<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table tb_user (<br>    id int,<br>    username varchar(20),<br>    password varchar(32)<br>);<br></code></pre></td></tr></table></figure><h4 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TABLE table_name ;<br>DROP TABLE IF EXISTS 表名;<br></code></pre></td></tr></table></figure><h4 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 改表名 --<br>ALTER TABLE 表名 RENAME TO 新的表名;<br>-- 将表名student修改为stu<br>alter table student rename to stu;<br><br>-- 加一列 --<br>ALTER TABLE 表名 ADD 列名 数据类型;<br>-- 给stu表添加一列address，该字段类型是varchar(50) alter table stu add address varchar(50);<br><br>-- 改数据类型 --<br>ALTER TABLE 表名 MODIFY 列名 新数据类型;<br>-- 将stu表中的address字段的类型改为 char(50) alter table stu modify address char(50);<br><br>-- 删除列 --<br>ALTER TABLE 表名 DROP 列名;<br>-- 将stu表中的addr字段 删除 alter table stu drop addr;<br><br>-- 修改列名和数据类型 --<br>ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;<br>-- 将stu表中的address字段名改为 addr，类型改为varchar(50) alter table stu change address addr varchar(50);<br></code></pre></td></tr></table></figure><h3 id="1-4-MySQL数据增删改"><a href="#1-4-MySQL数据增删改" class="headerlink" title="1.4 MySQL数据增删改"></a>1.4 MySQL数据增删改</h3><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 给指定列添加数据 --<br>INSERT INTO 表名(列名1,列名2,...) VALUES(值1,值2,...);<br><br>-- 给全部列添加数据 --<br>INSERT INTO 表名 VALUES(值1,值2,...);<br><br>-- 批量添加数据 --<br>INSERT INTO 表名(列名1,列名2,...) VALUES(值1,值2,...),(值1,值2,...),(值1,值2,...)...;<br>INSERT INTO 表名 VALUES(值1,值2,...),(值1,值2,...),(值1,值2,...)...;<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from stu;<br>-- 给指定列添加数据<br>INSERT INTO stu (id, NAME) VALUES (1, &#x27;张三&#x27;);<br>-- 给所有列添加数据，列名的列表可以省略的<br>INSERT INTO stu (id,NAME,sex,birthday,score,email,tel,STATUS) VALUES (2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11- 11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1);<br>INSERT INTO stu VALUES (2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1);<br>-- 批量添加数据<br>INSERT INTO stu VALUES<br>(2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1), (2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1), (2,&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;1999-11-11&#x27;,88.88,&#x27;lisi@itcast.cn&#x27;,&#x27;13888888888&#x27;,1);<br></code></pre></td></tr></table></figure><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE 表名 SET 列名1=值1,列名2=值2,... [WHERE 条件] ;<br>update stu set birthday = &#x27;1999-12-12&#x27;, score = 99.99 where name = &#x27;张三&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>注意:</p><p>​     1. 修改语句中如果不加条件，则将所有数据都修改!</p><ol><li>像上面的语句中的中括号，表示在写sql语句中可以省略这部分</li></ol></blockquote><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM 表名 [WHERE 条件] ;<br><br>-- 删除张三记录<br>delete from stu where name = &#x27;张三&#x27;;<br>-- 删除stu表中所有的数据 <br>delete from stu;<br></code></pre></td></tr></table></figure><h2 id="2-MySQL数据库查询"><a href="#2-MySQL数据库查询" class="headerlink" title="2. MySQL数据库查询"></a>2. MySQL数据库查询</h2><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询多个字段<br>SELECT 字段列表 FROM 表名;<br>SELECT * FROM 表名; -- 查询所有数据<br><br>-- 把查到的结果的重复记录去掉<br>SELECT DISTINCT 字段列表 FROM 表名;<br><br>-- 起别名<br>AS: AS 也可以省略<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select distinct address from stu;<br>select name,math as 数学成绩,english as 英文成绩 from stu;<br>select name,math 数学成绩,english 英文成绩 from stu;<br></code></pre></td></tr></table></figure><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p><strong>where：</strong>数据库中常用的是where关键字，用于在初始表中筛选查询。它是一个约束声明，用于约束数据，在返回结果集之前起作用。</p><p><strong>group by:</strong>   对select查询出来的结果集按照<strong>某个字段或者表达式</strong>进行分组，获得一组组的集合，然后从每组中取出一个指定字段或者表达式的值。</p><p><strong>having：</strong>用于对where和group by查询出来的分组经行过滤，查出满足条件的分组结果。它是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作。</p><p><strong>where</strong> <strong>和</strong> <strong>having</strong> <strong>区别:</strong></p><p>执行时机不一样：where 是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。<br> 可判断的条件不一样：where 不能对聚合函数进行判断，having 可以。</p><p><strong>执行顺序</strong>：where –&gt; group by–&gt; having–&gt;select–&gt;order by</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表名 WHERE 条件列表;<br></code></pre></td></tr></table></figure><p>where子句除了&lt;,&gt;,&lt;=,&gt;=,=,&lt;&gt;或!=以外还可以使用以下运算符：</p><div class="table-container"><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>Between…and…</td><td>在某个范围之内，包含边界</td></tr><tr><td>In(…)</td><td>多选一</td></tr><tr><td>Like 占位符</td><td>模糊查询，_单个任意字符，%多个任意字符_</td></tr><tr><td>Is null</td><td>空</td></tr><tr><td>Is not null</td><td>非空</td></tr><tr><td>And 或 &amp;&amp;</td><td>并且</td></tr><tr><td>Or 或 \</td><td>\</td><td></td><td>或者</td></tr><tr><td>Not 或 !</td><td>不是</td></tr></tbody></table></div><p>在 where like 的条件查询中，SQL 提供了四种匹配方式。</p><ol><li><strong>%</strong>：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。</li><li><strong>_</strong>：表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句。</li><li><strong>[]</strong>：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。</li><li><strong><sup><a href="#fn_" id="reffn_"></a></sup></strong> ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。</li><li>查询内容包含通配符时，由于通配符的缘故，导致我们查询特殊字符 “%”、“_”、“[” 的语句无法正常实现，而把特殊字符用 “[ ]” 括起便可正常查询。可以使用LIKE子句代替等号 <strong>=</strong>。</li></ol><p><strong>UNION 语句</strong>：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据）</p><p><strong>UNION ALL 语句</strong>：用于将不同表中相同列中查询的数据展示出来；（包括重复数据）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 列名称 FROM 表名称 UNION SELECT 列名称 FROM 表名称 ORDER BY 列名称；<br>SELECT 列名称 FROM 表名称 UNION ALL SELECT 列名称 FROM 表名称 ORDER BY 列名称；<br></code></pre></td></tr></table></figure><p>实例解析：</p><p>从 “Websites” 和 “apps” 表中选取所有<strong>不同的</strong>country（只有不同的值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT country FROM Websites<br>UNION<br>SELECT country FROM apps<br>ORDER BY country;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623155025359.png" alt="image-20220623155025359" style="zoom:50%;" /></p><p>使用 UNION ALL 从 “Websites” 和 “apps” 表中选取<strong>所有的</strong>country（也有重复的值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT country FROM Websites<br>UNION ALL<br>SELECT country FROM apps<br>ORDER BY country;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220623154845811.png" alt="image-20220623154845811" style="zoom:50%;" /></p><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] ...;<br>select * from stu order by math desc , english asc ;<br></code></pre></td></tr></table></figure><p>ASC : 升序排列 <strong>(默认值)</strong> </p><p>DESC : 降序排列</p><blockquote><p>注意:如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序</p></blockquote><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>将一列数据作为一个整体，进行纵向计算。</p><p>例如让我们求表中所有数据的数学成绩的总和。这就是对math字段进行纵向求和。</p><p>常用聚合函数：</p><div class="table-container"><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>count(列名)</td><td>返回统计数量(一般选用不为null的列)</td></tr><tr><td>max(列名)</td><td>返回最大值</td></tr><tr><td>min(列名)</td><td>返回最小值</td></tr><tr><td>sum(列名)</td><td>返回求和</td></tr><tr><td>avg(列名)</td><td>返回平均值</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 聚合函数名(列名) FROM 表;<br></code></pre></td></tr></table></figure><blockquote><p>注意:null 值不参与所有聚合函数运算</p></blockquote><p>实例解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(id) from stu;<br>select count(*) from stu;<br></code></pre></td></tr></table></figure><p>上面语句根据某个字段进行统计，如果该字段某一行的值为null的话，将不会被统计。所以可以用count（*）来实现，<em> 表示所有字段数据，一行中也不可能所有的数据都为null，所以建议使用 count(</em>)。</p><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];<br></code></pre></td></tr></table></figure><blockquote><p>注意:分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义</p></blockquote><p>实例解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select sex, avg(math) from stu group by sex;<br></code></pre></td></tr></table></figure><p>查询结果：男生的数学平均分和女生的数学平均分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select sex, avg(math),count(*) from stu where math &gt; 70 group by sex;<br></code></pre></td></tr></table></figure><p>查询结果：不低于70分的男生的数学平均分和女生的数学平均分以及各自的人数。</p><p><strong>group by：分组依据</strong></p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a><strong>分页查询</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表名 LIMIT 起始索引 , 查询条目数;<br></code></pre></td></tr></table></figure><blockquote><p>注意: 上述语句中的起始索引是从0开始</p></blockquote><p>实例解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from stu limit 0 , 3;<br>select * from stu limit 3 , 3;<br>select * from stu limit 6 , 3;<br></code></pre></td></tr></table></figure><p>每页显示3条数据，分别查看第1，2，3页，可推导出公式：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">起始索引 <span class="hljs-operator">=</span> (当前页码 - <span class="hljs-number">1</span>) * 每页显示的条数<br></code></pre></td></tr></table></figure><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>MySQL中使用 REGEXP 操作符来进行正则表达式匹配。</p><div class="table-container"><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td>.</td><td>匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像 ‘[.\n]’ 的模式。</td></tr><tr><td>[…]</td><td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td><sup><a href="#fn_..." id="reffn_...">...</a></sup></td><td>负值字符集合。匹配未包含的任意字符。例如， ‘<sup><a href="#fn_abc" id="reffn_abc">abc</a></sup>‘ 可以匹配 “plain” 中的’p’。</td></tr><tr><td>p1\</td><td>p2\</td><td>p3</td><td>匹配 p1 或 p2 或 p3。例如，’z\</td><td>food’ 能匹配 “z” 或 “food”。’(z\</td><td>f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td>{n}</td><td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td>{n,m}</td><td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td></tr></tbody></table></div><p>查找name字段中以’st’为开头的所有数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name FROM person_tbl WHERE name REGEXP &#x27;^st&#x27;;<br></code></pre></td></tr></table></figure><p>查找name字段中以’ok’为结尾的所有数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name FROM person_tbl WHERE name REGEXP &#x27;ok$&#x27;;<br></code></pre></td></tr></table></figure><p>查找name字段中包含’mar’字符串的所有数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name FROM person_tbl WHERE name REGEXP &#x27;mar&#x27;;<br></code></pre></td></tr></table></figure><p>查找name字段中以元音字符开头或以’ok’字符串结尾的所有数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name FROM person_tbl WHERE name REGEXP &#x27;^[aeiou]|ok$&#x27;;<br></code></pre></td></tr></table></figure><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="1-约束"><a href="#1-约束" class="headerlink" title="1.约束"></a>1.约束</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1  概念"></a>1.1  概念</h3><ul><li><p>约束是作用于表中列上的规则，用于限制加入表的数据</p><p>例如：我们可以给id列加约束，让其值不能重复，不能为null值。</p></li><li><p>约束的存在保证了数据库中数据的正确性、有效性和完整性</p><p>添加约束可以在添加数据的时候就限制不正确的数据，年龄是3000，数学成绩是-5分这样无效的数据，继而保障数据的完整性。</p></li></ul><h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2  分类"></a>1.2  分类</h3><ul><li><p><strong>非空约束： 关键字是 NOT NULL</strong></p><p>保证列中所有的数据不能有null值。</p><p>例如：id列在添加 <code>马花疼</code> 这条数据时就不能添加成功。</p></li><li><p><strong>唯一约束：关键字是  UNIQUE</strong></p><p>保证列中所有数据各不相同。</p><p>例如：id列中三条数据的值都是1，这样的数据在添加时是绝对不允许的。</p></li><li><p><strong>主键约束： 关键字是  PRIMARY KEY</strong></p><p>主键是一行数据的唯一标识，要求非空且唯一。一般我们都会给没张表添加一个主键列用来唯一标识数据。</p><p>例如：上图表中id就可以作为主键，来标识每条数据。那么这样就要求数据中id的值不能重复，不能为null值。</p></li><li><p><strong>检查约束： 关键字是  CHECK</strong> </p><p>保证列中的值满足某一条件。</p><p>例如：我们可以给age列添加一个范围，最低年龄可以设置为1，最大年龄就可以设置为300，这样的数据才更合理些。</p><blockquote><p>注意：MySQL不支持检查约束。</p><p>这样是不是就没办法保证年龄在指定的范围内了？从数据库层面不能保证，以后可以在java代码中进行限制，一样也可以实现要求。</p></blockquote></li><li><p><strong>默认约束： 关键字是   DEFAULT</strong></p><p>保存数据时，未指定值则采用默认值。</p><p>例如：我们在给english列添加该约束，指定默认值是0，这样在添加数据时没有指定具体值时就会采用默认给定的0。</p></li><li><p><strong>外键约束： 关键字是  FOREIGN KEY</strong></p><p>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。</p><p>外键约束现在可能还不太好理解，后面我们会重点进行讲解。</p></li></ul><h3 id="1-3-非空约束"><a href="#1-3-非空约束" class="headerlink" title="1.3  非空约束"></a>1.3  非空约束</h3><ul><li><p>概念</p><p>非空约束用于保证列中所有数据不能有NULL值</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表时添加非空约束</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>   列名 数据类型 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   …<br>); <br><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 建完表后添加非空约束</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 字段名 数据类型 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 字段名 数据类型;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-4-唯一约束"><a href="#1-4-唯一约束" class="headerlink" title="1.4  唯一约束"></a>1.4  唯一约束</h3><ul><li><p>概念</p><p>唯一约束用于保证列中所有数据各不相同</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表时添加唯一约束</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>   列名 数据类型 <span class="hljs-keyword">UNIQUE</span> [AUTO_INCREMENT],<br>   <span class="hljs-comment">-- AUTO_INCREMENT: 当不指定值时自动增长</span><br>   …<br>); <br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>   列名 数据类型,<br>   …<br>   [<span class="hljs-keyword">CONSTRAINT</span>] [约束名称] <span class="hljs-keyword">UNIQUE</span>(列名)<br>); <br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 建完表后添加唯一约束</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 字段名 数据类型 <span class="hljs-keyword">UNIQUE</span>;<br></code></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> INDEX 字段名;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-5-主键约束"><a href="#1-5-主键约束" class="headerlink" title="1.5  主键约束"></a>1.5  主键约束</h3><ul><li><p>概念</p><p>主键是一行数据的唯一标识，要求非空且唯一</p><p>一张表只能有一个主键</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表时添加主键约束</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>   列名 数据类型 <span class="hljs-keyword">PRIMARY</span> KEY [AUTO_INCREMENT],<br>   …<br>); <br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>   列名 数据类型,<br>   [<span class="hljs-keyword">CONSTRAINT</span>] [约束名称] <span class="hljs-keyword">PRIMARY</span> KEY(列名)<br>); <br><br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 建完表后添加主键约束</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY(字段名);<br></code></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-6-默认约束"><a href="#1-6-默认约束" class="headerlink" title="1.6  默认约束"></a>1.6  默认约束</h3><ul><li><p>概念</p><p>保存数据时，未指定值则采用默认值</p></li><li><p>语法</p><ul><li><p>添加约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表时添加默认约束</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>   列名 数据类型 <span class="hljs-keyword">DEFAULT</span> 默认值,<br>   …<br>); <br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 建完表后添加默认约束</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ALTER</span> 列名 <span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> 默认值;<br></code></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ALTER</span> 列名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DEFAULT</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="1-7-约束练习"><a href="#1-7-约束练习" class="headerlink" title="1.7  约束练习"></a>1.7  约束练习</h3><p><strong>根据需求，为表添加合适的约束</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 员工表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp (<br>id <span class="hljs-type">INT</span>,  <span class="hljs-comment">-- 员工id，主键且自增长</span><br>    ename <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>), <span class="hljs-comment">-- 员工姓名，非空且唯一</span><br>    joindate <span class="hljs-type">DATE</span>,  <span class="hljs-comment">-- 入职日期，非空</span><br>    salary <span class="hljs-keyword">DOUBLE</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>),  <span class="hljs-comment">-- 工资，非空</span><br>    bonus <span class="hljs-keyword">DOUBLE</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>)  <span class="hljs-comment">-- 奖金，如果没有将近默认为0</span><br>);<br></code></pre></td></tr></table></figure><p>上面一定给出了具体的要求，我们可以根据要求创建这张表，并为每一列添加对应的约束。建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> emp;<br><br><span class="hljs-comment">-- 员工表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp (<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY auto_increment, <span class="hljs-comment">-- 员工id，主键且自增长</span><br>  ename <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span>, <span class="hljs-comment">-- 员工姓名，非空并且唯一</span><br>  joindate <span class="hljs-type">DATE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> , <span class="hljs-comment">-- 入职日期，非空</span><br>  salary <span class="hljs-keyword">DOUBLE</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> , <span class="hljs-comment">-- 工资，非空</span><br>  bonus <span class="hljs-keyword">DOUBLE</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> <span class="hljs-comment">-- 奖金，如果没有奖金默认为0</span><br>);<br></code></pre></td></tr></table></figure><p>==注意：默认约束只有在不给值时才会采用默认值。如果给了null，那值就是null值。==</p><h3 id="1-8-外键约束"><a href="#1-8-外键约束" class="headerlink" title="1.8  外键约束"></a>1.8  外键约束</h3><h4 id="1-8-1-概述"><a href="#1-8-1-概述" class="headerlink" title="1.8.1  概述"></a>1.8.1  概述</h4><p>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。</p><h4 id="1-8-2-语法"><a href="#1-8-2-语法" class="headerlink" title="1.8.2  语法"></a>1.8.2  语法</h4><ul><li>添加外键约束</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表时添加外键约束</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>   列名 数据类型,<br>   …<br>   [<span class="hljs-keyword">CONSTRAINT</span>] [外键名称] <span class="hljs-keyword">FOREIGN</span> KEY(外键列名) <span class="hljs-keyword">REFERENCES</span> 主表(主表列名) <br>); <br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 建完表后添加外键约束</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> 外键名称 <span class="hljs-keyword">FOREIGN</span> KEY (外键字段名称) <span class="hljs-keyword">REFERENCES</span> 主表名称(主表列名称);<br></code></pre></td></tr></table></figure><ul><li>删除外键约束</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FOREIGN</span> KEY 外键名称;<br></code></pre></td></tr></table></figure><h4 id="1-8-3-练习"><a href="#1-8-3-练习" class="headerlink" title="1.8.3  练习"></a>1.8.3  练习</h4><p>根据上述语法创建员工表和部门表，并添加上外键约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> emp;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> dept;<br><br><span class="hljs-comment">-- 部门表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dept(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>dep_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>addr <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)<br>);<br><span class="hljs-comment">-- 员工表 </span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>age <span class="hljs-type">int</span>,<br>dep_id <span class="hljs-type">int</span>,<br><br><span class="hljs-comment">-- 添加外键 dep_id,关联 dept 表的id主键</span><br><span class="hljs-keyword">CONSTRAINT</span> fk_emp_dept <span class="hljs-keyword">FOREIGN</span> KEY(dep_id) <span class="hljs-keyword">REFERENCES</span> dept(id)<br>);<br></code></pre></td></tr></table></figure><p>添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 添加 2 个部门</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> dept(dep_name,addr) <span class="hljs-keyword">values</span><br>(<span class="hljs-string">&#x27;研发部&#x27;</span>,<span class="hljs-string">&#x27;广州&#x27;</span>),(<span class="hljs-string">&#x27;销售部&#x27;</span>, <span class="hljs-string">&#x27;深圳&#x27;</span>);<br><br><span class="hljs-comment">-- 添加员工,dep_id 表示员工所在的部门</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (NAME, age, dep_id) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;赵六&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">2</span>),<br>(<span class="hljs-string">&#x27;孙七&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-number">2</span>),<br>(<span class="hljs-string">&#x27;周八&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>此时删除 <code>研发部</code> 这条数据，会发现无法删除。</p><p>删除外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">drop</span> <span class="hljs-keyword">FOREIGN</span> key fk_emp_dept;<br></code></pre></td></tr></table></figure><p>重新添加外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">add</span> <span class="hljs-keyword">CONSTRAINT</span> fk_emp_dept <span class="hljs-keyword">FOREIGN</span> key(dep_id) <span class="hljs-keyword">REFERENCES</span> dept(id);<br></code></pre></td></tr></table></figure><h2 id="2-数据库设计"><a href="#2-数据库设计" class="headerlink" title="2.数据库设计"></a>2.数据库设计</h2><h3 id="2-1-数据库设计简介"><a href="#2-1-数据库设计简介" class="headerlink" title="2.1  数据库设计简介"></a>2.1  数据库设计简介</h3><ul><li><p>软件的研发步骤</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622170858978.png" alt="image-20220622170858978"></p></li><li><p>数据库设计概念</p><ul><li>数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS，为这个业务系统构造出最优的数据存储模型。</li><li>建立数据库中的==表结构==以及==表与表之间的关联关系==的过程。</li><li>有哪些表？表里有哪些字段？表和表之间有什么关系？</li></ul></li><li><p>数据库设计的步骤</p><ul><li><p>需求分析（数据是什么? 数据具有哪些属性? 数据与属性的特点是什么）</p></li><li><p>逻辑分析（通过ER图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统）</p><p>如下图就是ER(Entity/Relation)图：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622170936569.png" alt="image-20220622170936569"></p></li><li><p>物理设计（根据数据库自身的特点把逻辑设计转换为物理设计）</p></li><li><p>维护设计（1.对新的需求进行建表；2.表优化）</p></li></ul></li><li><p>表关系</p><ul><li><p>一对一</p><ul><li>如：用户 和 用户详情</li><li>一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能</li></ul></li><li><p>一对多</p><ul><li><p>如：部门 和 员工</p></li><li><p>一个部门对应多个员工，一个员工对应一个部门。</p></li></ul></li><li><p>多对多</p><ul><li><p>如：商品 和 订单</p></li><li><p>一个商品对应多个订单，一个订单包含多个商品。</p></li></ul></li></ul></li></ul><h3 id="2-2-表关系-一对多"><a href="#2-2-表关系-一对多" class="headerlink" title="2.2  表关系(一对多)"></a>2.2  表关系(一对多)</h3><ul><li><p>一对多</p><ul><li>如：部门 和 员工</li><li>一个部门对应多个员工，一个员工对应一个部门。</li></ul></li><li><p>实现方式</p><p>==在多的一方建立外键，指向一的一方的主键==</p></li><li><p>案例</p><p>我们还是以 <code>员工表</code> 和 <code>部门表</code> 举例，经过分析发现，员工表属于多的一方，而部门表属于一的一方，此时我们会在员工表中添加一列（dep_id），指向于部门表的主键（id）：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622171235458.png" alt="image-20220622171235458"></p><p>建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> tb_emp;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> tb_dept;<br><br><span class="hljs-comment">-- 部门表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_dept(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>dep_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>addr <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>)<br>);<br><span class="hljs-comment">-- 员工表 </span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_emp(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>age <span class="hljs-type">int</span>,<br>dep_id <span class="hljs-type">int</span>,<br><br><span class="hljs-comment">-- 添加外键 dep_id,关联 dept 表的id主键</span><br>  <span class="hljs-comment">-- 外键的命名原则通常是fk_从表_主表</span><br><span class="hljs-keyword">CONSTRAINT</span> fk_emp_dept <span class="hljs-keyword">FOREIGN</span> KEY(dep_id) <span class="hljs-keyword">REFERENCES</span> tb_dept(id)<br>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-3-表关系-多对多"><a href="#2-3-表关系-多对多" class="headerlink" title="2.3  表关系(多对多)"></a>2.3  表关系(多对多)</h3><ul><li><p>多对多</p><ul><li>如：商品 和 订单</li><li>一个商品对应多个订单，一个订单包含多个商品</li></ul></li><li><p>实现方式</p><p>==建立第三张中间表，中间表至少包含两个外键，分别关联两方主键==</p></li><li><p>案例</p><p>我们以 <code>订单表</code> 和 <code>商品表</code> 举例，经过分析发现，订单表和商品表都属于多的一方，此时需要创建一个中间表，在中间表中添加订单表的外键和商品表的外键指向两张表的主键：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622171523285.png" alt="image-20220622171523285"></p><p>建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> tb_order_goods;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> tb_order;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> tb_goods;<br><br><span class="hljs-comment">-- 订单表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_order(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>payment <span class="hljs-keyword">double</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br>payment_type TINYINT,<br>status TINYINT<br>);<br><br><span class="hljs-comment">-- 商品表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_goods(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>title <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>price <span class="hljs-keyword">double</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>)<br>);<br><br><span class="hljs-comment">-- 订单商品中间表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_order_goods(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>order_id <span class="hljs-type">int</span>,<br>goods_id <span class="hljs-type">int</span>,<br>count <span class="hljs-type">int</span><br>);<br><br><span class="hljs-comment">-- 建完表后，添加外键</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tb_order_goods <span class="hljs-keyword">add</span> <span class="hljs-keyword">CONSTRAINT</span> fk_order_id <span class="hljs-keyword">FOREIGN</span> key(order_id) <span class="hljs-keyword">REFERENCES</span> tb_order(id);<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> tb_order_goods <span class="hljs-keyword">add</span> <span class="hljs-keyword">CONSTRAINT</span> fk_goods_id <span class="hljs-keyword">FOREIGN</span> key(goods_id) <span class="hljs-keyword">REFERENCES</span> tb_goods(id);<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-4-表关系-一对一"><a href="#2-4-表关系-一对一" class="headerlink" title="2.4  表关系(一对一)"></a>2.4  表关系(一对一)</h3><ul><li><p>一对一</p><ul><li>如：用户 和 用户详情</li><li>一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能</li></ul></li><li><p>实现方式</p><p>==在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)==</p></li><li><p>案例</p><p>我们以 <code>用户表</code> 举例，</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622171708314.png" alt="image-20220622171708314">在真正使用过程中发现 id、photo、nickname、age、gender 字段比较常用，此时就可以将这张表查分成两张表。<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622171737882.png" alt=""></p></li></ul><p>​    建表语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_user_desc (<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>city <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>edu <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>income <span class="hljs-type">int</span>,<br>status <span class="hljs-type">char</span>(<span class="hljs-number">2</span>),<br>des <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>)<br>);<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_user (<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">primary</span> key auto_increment,<br>photo <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>),<br>nickname <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>),<br>age <span class="hljs-type">int</span>,<br>gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>),<br>desc_id <span class="hljs-type">int</span> <span class="hljs-keyword">unique</span>,<br><span class="hljs-comment">-- 添加外键</span><br><span class="hljs-keyword">CONSTRAINT</span> fk_user_desc <span class="hljs-keyword">FOREIGN</span> KEY(desc_id) <span class="hljs-keyword">REFERENCES</span> tb_user_desc(id)<br>);<br></code></pre></td></tr></table></figure><h2 id="3-多表查询"><a href="#3-多表查询" class="headerlink" title="3.多表查询"></a>3.多表查询</h2><p>多表查询顾名思义就是从多张表中一次性的查询出我们想要的数据。我们通过具体的sql演示，先准备环境</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> emp;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> dept;<br><br><br># 创建部门表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dept(<br>        did <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>        dname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>    );<br><br># 创建员工表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp (<br>        id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY AUTO_INCREMENT,<br>        NAME <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>),<br>        gender <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>), <span class="hljs-comment">-- 性别</span><br>        salary <span class="hljs-keyword">DOUBLE</span>, <span class="hljs-comment">-- 工资</span><br>        join_date <span class="hljs-type">DATE</span>, <span class="hljs-comment">-- 入职日期</span><br>        dep_id <span class="hljs-type">INT</span>,<br>        <span class="hljs-keyword">FOREIGN</span> KEY (dep_id) <span class="hljs-keyword">REFERENCES</span> dept(did) <span class="hljs-comment">-- 外键，关联部门表(部门表的主键)</span><br>    );<br><span class="hljs-comment">-- 添加部门数据</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dept (dNAME) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;研发部&#x27;</span>),(<span class="hljs-string">&#x27;市场部&#x27;</span>),(<span class="hljs-string">&#x27;财务部&#x27;</span>),(<span class="hljs-string">&#x27;销售部&#x27;</span>);<br><span class="hljs-comment">-- 添加员工数据</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp(NAME,gender,salary,join_date,dep_id) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-string">&#x27;孙悟空&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">7200</span>,<span class="hljs-string">&#x27;2013-02-24&#x27;</span>,<span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;猪八戒&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">3600</span>,<span class="hljs-string">&#x27;2010-12-02&#x27;</span>,<span class="hljs-number">2</span>),<br>(<span class="hljs-string">&#x27;唐僧&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">9000</span>,<span class="hljs-string">&#x27;2008-08-08&#x27;</span>,<span class="hljs-number">2</span>),<br>(<span class="hljs-string">&#x27;白骨精&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-number">5000</span>,<span class="hljs-string">&#x27;2015-10-07&#x27;</span>,<span class="hljs-number">3</span>),<br>(<span class="hljs-string">&#x27;蜘蛛精&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-number">4500</span>,<span class="hljs-string">&#x27;2011-03-14&#x27;</span>,<span class="hljs-number">1</span>),<br>(<span class="hljs-string">&#x27;小白龙&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">2500</span>,<span class="hljs-string">&#x27;2011-02-14&#x27;</span>,<span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><p>执行下面的多表查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp , dept;  <span class="hljs-comment">-- 从emp和dept表中查询所有的字段数据</span><br></code></pre></td></tr></table></figure><p>结果如下：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622172039381.png" alt="image-20220622172039381"></p><p>这样直接拼接得到的结果就是两个表进行交叉相乘，得到一堆无用数据。所以我们要通过限制员工表中的 <code>dep_id</code> 字段的值和部门表 <code>did</code> 字段的值相等来消除这些无效的数据，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp , dept <span class="hljs-keyword">where</span> emp.dep_id <span class="hljs-operator">=</span> dept.did;<br></code></pre></td></tr></table></figure><p>执行后结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622172251630.png" alt="image-20220622172251630"></p><p>上面语句就是连接查询，那么多表查询都有哪些呢？</p><ul><li><p>连接查询</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622172311348.png" alt="image-20220622172311348"></p><ul><li>内连接查询 ：相当于查询AB交集数据</li><li>外连接查询<ul><li>左外连接查询 ：相当于查询A表所有数据和交集部门数据</li><li>右外连接查询 ： 相当于查询B表所有数据和交集部分数据</li></ul></li></ul></li><li><p>子查询</p></li></ul><h3 id="3-1-内连接查询"><a href="#3-1-内连接查询" class="headerlink" title="3.1  内连接查询"></a>3.1  内连接查询</h3><ul><li>语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 隐式内连接</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>,表<span class="hljs-number">2</span>… <span class="hljs-keyword">WHERE</span> 条件;<br><br><span class="hljs-comment">-- 显示内连接</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [<span class="hljs-keyword">INNER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件;<br></code></pre></td></tr></table></figure><blockquote><p>内连接相当于查询 A B 交集数据</p></blockquote><ul><li><p>案例</p><ul><li><p>隐式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span><br>emp,<br>dept<br><span class="hljs-keyword">WHERE</span><br>emp.dep_id <span class="hljs-operator">=</span> dept.did;<br></code></pre></td></tr></table></figure></li><li><p>查询 emp的 name， gender，dept表的dname</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>emp. NAME,<br>emp.gender,<br>dept.dname<br><span class="hljs-keyword">FROM</span><br>emp,<br>dept<br><span class="hljs-keyword">WHERE</span><br>emp.dep_id <span class="hljs-operator">=</span> dept.did;<br></code></pre></td></tr></table></figure><p>上面语句中使用表名指定字段所属有点麻烦，sql也支持给表在from里指别名，上述语句可以改进为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>t1. NAME,<br>t1.gender,<br>t2.dname<br><span class="hljs-keyword">FROM</span><br>emp t1,<br>dept t2<br><span class="hljs-keyword">WHERE</span><br>t1.dep_id <span class="hljs-operator">=</span> t2.did;<br></code></pre></td></tr></table></figure></li><li><p>显式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">on</span> emp.dep_id <span class="hljs-operator">=</span> dept.did;<br><span class="hljs-comment">-- 上面语句中的inner可以省略，可以书写为如下语句</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp  <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">on</span> emp.dep_id <span class="hljs-operator">=</span> dept.did;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-2-外连接查询"><a href="#3-2-外连接查询" class="headerlink" title="3.2  外连接查询"></a>3.2  外连接查询</h3><ul><li><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 左外连接</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件;<br><br><span class="hljs-comment">-- 右外连接</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件;<br></code></pre></td></tr></table></figure><blockquote><p>左外连接：相当于查询A表所有数据和交集部分数据</p><p>右外连接：相当于查询B表所有数据和交集部分数据</p></blockquote></li><li><p>案例</p><ul><li><p>查询emp表所有数据和对应的部门信息（左外连接）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">on</span> emp.dep_id <span class="hljs-operator">=</span> dept.did;<br></code></pre></td></tr></table></figure><p>结果显示查询到了左表（emp）中所有的数据及两张表能关联的数据。</p></li><li><p>查询dept表所有数据和对应的员工信息（右外连接）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> dept <span class="hljs-keyword">on</span> emp.dep_id <span class="hljs-operator">=</span> dept.did;<br></code></pre></td></tr></table></figure><p>结果显示查询到了右表（dept）中所有的数据及两张表能关联的数据。</p></li></ul></li></ul><h3 id="3-3-子查询"><a href="#3-3-子查询" class="headerlink" title="3.3  子查询"></a>3.3  子查询</h3><ul><li><p>概念</p><p>==查询中嵌套查询，称嵌套查询为子查询。==</p><p>什么是查询中嵌套查询呢？我们通过一个例子来看：</p><p><strong>需求：查询工资高于猪八戒的员工信息。</strong></p><p>来实现这个需求，我们就可以通过二步实现，第一步：先查询出来 猪八戒的工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;猪八戒&#x27;</span><br></code></pre></td></tr></table></figure><p> 第二步：查询工资高于猪八戒的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-number">3600</span>;<br></code></pre></td></tr></table></figure><p>第二步中的3600可以通过第一步的sql查询出来，所以将3600用第一步的sql语句进行替换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;猪八戒&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这就是查询语句中嵌套查询语句。</p></li><li><p>子查询根据查询结果不同，作用不同</p><ul><li>子查询语句结果是单行单列，子查询语句作为条件值，使用 =  !=  &gt;  &lt;  等进行条件判断</li><li>子查询语句结果是<strong><u>多行单列</u></strong>，子查询语句作为条件值，使用 in 等关键字进行条件判断</li><li>子查询语句结果是多行多列，子查询语句作为虚拟表</li><li>即单条结果用=，多条结果用in</li></ul></li><li><p>案例</p><ul><li><p>查询 ‘财务部’ 和 ‘市场部’ 所有的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询 &#x27;财务部&#x27; 或者 &#x27;市场部&#x27; 所有的员工的部门did</span><br><span class="hljs-keyword">select</span> did <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> dname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;财务部&#x27;</span> <span class="hljs-keyword">or</span> dname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;市场部&#x27;</span>;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dep_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> did <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> dname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;财务部&#x27;</span> <span class="hljs-keyword">or</span> dname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;市场部&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>查询入职日期是 ‘2011-11-11’ 之后的员工信息和部门信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询入职日期是 &#x27;2011-11-11&#x27; 之后的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> join_date <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2011-11-11&#x27;</span> ;<br><span class="hljs-comment">-- 将上面语句的结果作为虚拟表和dept表进行内连接查询</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> join_date <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2011-11-11&#x27;</span> ) t1, dept <span class="hljs-keyword">where</span> t1.dep_id <span class="hljs-operator">=</span> dept.did;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-4-案例"><a href="#3-4-案例" class="headerlink" title="3.4  案例"></a>3.4  案例</h3><ul><li>环境准备：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> emp;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> dept;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> job;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> salarygrade;<br><br><span class="hljs-comment">-- 部门表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dept (<br>  did <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY <span class="hljs-keyword">PRIMARY</span> KEY, <span class="hljs-comment">-- 部门id</span><br>  dname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>), <span class="hljs-comment">-- 部门名称</span><br>  loc <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-comment">-- 部门所在地</span><br>);<br><br><span class="hljs-comment">-- 职务表，职务名称，职务描述</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> job (<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>  jname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>  description <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)<br>);<br><br><span class="hljs-comment">-- 员工表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp (<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY, <span class="hljs-comment">-- 员工id</span><br>  ename <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>), <span class="hljs-comment">-- 员工姓名</span><br>  job_id <span class="hljs-type">INT</span>, <span class="hljs-comment">-- 职务id</span><br>  mgr <span class="hljs-type">INT</span> , <span class="hljs-comment">-- 上级领导</span><br>  joindate <span class="hljs-type">DATE</span>, <span class="hljs-comment">-- 入职日期</span><br>  salary <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>), <span class="hljs-comment">-- 工资</span><br>  bonus <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>), <span class="hljs-comment">-- 奖金</span><br>  dept_id <span class="hljs-type">INT</span>, <span class="hljs-comment">-- 所在部门编号</span><br>  <span class="hljs-keyword">CONSTRAINT</span> emp_jobid_ref_job_id_fk <span class="hljs-keyword">FOREIGN</span> KEY (job_id) <span class="hljs-keyword">REFERENCES</span> job (id),<br>  <span class="hljs-keyword">CONSTRAINT</span> emp_deptid_ref_dept_id_fk <span class="hljs-keyword">FOREIGN</span> KEY (dept_id) <span class="hljs-keyword">REFERENCES</span> dept (id)<br>);<br><span class="hljs-comment">-- 工资等级表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> salarygrade (<br>  grade <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,   <span class="hljs-comment">-- 级别</span><br>  losalary <span class="hljs-type">INT</span>,  <span class="hljs-comment">-- 最低工资</span><br>  hisalary <span class="hljs-type">INT</span> <span class="hljs-comment">-- 最高工资</span><br>);<br><br><span class="hljs-comment">-- 添加4个部门</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dept(did,dname,loc) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;教研部&#x27;</span>,<span class="hljs-string">&#x27;北京&#x27;</span>),<br>(<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;学工部&#x27;</span>,<span class="hljs-string">&#x27;上海&#x27;</span>),<br>(<span class="hljs-number">30</span>,<span class="hljs-string">&#x27;销售部&#x27;</span>,<span class="hljs-string">&#x27;广州&#x27;</span>),<br>(<span class="hljs-number">40</span>,<span class="hljs-string">&#x27;财务部&#x27;</span>,<span class="hljs-string">&#x27;深圳&#x27;</span>);<br><br><span class="hljs-comment">-- 添加4个职务</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> job (id, jname, description) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;董事长&#x27;</span>, <span class="hljs-string">&#x27;管理整个公司，接单&#x27;</span>),<br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;经理&#x27;</span>, <span class="hljs-string">&#x27;管理部门员工&#x27;</span>),<br>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;销售员&#x27;</span>, <span class="hljs-string">&#x27;向客人推销产品&#x27;</span>),<br>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;文员&#x27;</span>, <span class="hljs-string">&#x27;使用办公软件&#x27;</span>);<br><br><br><span class="hljs-comment">-- 添加员工</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1001</span>,<span class="hljs-string">&#x27;孙悟空&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1004</span>,<span class="hljs-string">&#x27;2000-12-17&#x27;</span>,<span class="hljs-string">&#x27;8000.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">20</span>),<br>(<span class="hljs-number">1002</span>,<span class="hljs-string">&#x27;卢俊义&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1006</span>,<span class="hljs-string">&#x27;2001-02-20&#x27;</span>,<span class="hljs-string">&#x27;16000.00&#x27;</span>,<span class="hljs-string">&#x27;3000.00&#x27;</span>,<span class="hljs-number">30</span>),<br>(<span class="hljs-number">1003</span>,<span class="hljs-string">&#x27;林冲&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1006</span>,<span class="hljs-string">&#x27;2001-02-22&#x27;</span>,<span class="hljs-string">&#x27;12500.00&#x27;</span>,<span class="hljs-string">&#x27;5000.00&#x27;</span>,<span class="hljs-number">30</span>),<br>(<span class="hljs-number">1004</span>,<span class="hljs-string">&#x27;唐僧&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1009</span>,<span class="hljs-string">&#x27;2001-04-02&#x27;</span>,<span class="hljs-string">&#x27;29750.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">20</span>),<br>(<span class="hljs-number">1005</span>,<span class="hljs-string">&#x27;李逵&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1006</span>,<span class="hljs-string">&#x27;2001-09-28&#x27;</span>,<span class="hljs-string">&#x27;12500.00&#x27;</span>,<span class="hljs-string">&#x27;14000.00&#x27;</span>,<span class="hljs-number">30</span>),<br>(<span class="hljs-number">1006</span>,<span class="hljs-string">&#x27;宋江&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1009</span>,<span class="hljs-string">&#x27;2001-05-01&#x27;</span>,<span class="hljs-string">&#x27;28500.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">30</span>),<br>(<span class="hljs-number">1007</span>,<span class="hljs-string">&#x27;刘备&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1009</span>,<span class="hljs-string">&#x27;2001-09-01&#x27;</span>,<span class="hljs-string">&#x27;24500.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">10</span>),<br>(<span class="hljs-number">1008</span>,<span class="hljs-string">&#x27;猪八戒&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1004</span>,<span class="hljs-string">&#x27;2007-04-19&#x27;</span>,<span class="hljs-string">&#x27;30000.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">20</span>),<br>(<span class="hljs-number">1009</span>,<span class="hljs-string">&#x27;罗贯中&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;2001-11-17&#x27;</span>,<span class="hljs-string">&#x27;50000.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">10</span>),<br>(<span class="hljs-number">1010</span>,<span class="hljs-string">&#x27;吴用&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1006</span>,<span class="hljs-string">&#x27;2001-09-08&#x27;</span>,<span class="hljs-string">&#x27;15000.00&#x27;</span>,<span class="hljs-string">&#x27;0.00&#x27;</span>,<span class="hljs-number">30</span>),<br>(<span class="hljs-number">1011</span>,<span class="hljs-string">&#x27;沙僧&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1004</span>,<span class="hljs-string">&#x27;2007-05-23&#x27;</span>,<span class="hljs-string">&#x27;11000.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">20</span>),<br>(<span class="hljs-number">1012</span>,<span class="hljs-string">&#x27;李逵&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1006</span>,<span class="hljs-string">&#x27;2001-12-03&#x27;</span>,<span class="hljs-string">&#x27;9500.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">30</span>),<br>(<span class="hljs-number">1013</span>,<span class="hljs-string">&#x27;小白龙&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1004</span>,<span class="hljs-string">&#x27;2001-12-03&#x27;</span>,<span class="hljs-string">&#x27;30000.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">20</span>),<br>(<span class="hljs-number">1014</span>,<span class="hljs-string">&#x27;关羽&#x27;</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1007</span>,<span class="hljs-string">&#x27;2002-01-23&#x27;</span>,<span class="hljs-string">&#x27;13000.00&#x27;</span>,<span class="hljs-keyword">NULL</span>,<span class="hljs-number">10</span>);<br><br><br><span class="hljs-comment">-- 添加5个工资等级</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> salarygrade(grade,losalary,hisalary) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>,<span class="hljs-number">7000</span>,<span class="hljs-number">12000</span>),<br>(<span class="hljs-number">2</span>,<span class="hljs-number">12010</span>,<span class="hljs-number">14000</span>),<br>(<span class="hljs-number">3</span>,<span class="hljs-number">14010</span>,<span class="hljs-number">20000</span>),<br>(<span class="hljs-number">4</span>,<span class="hljs-number">20010</span>,<span class="hljs-number">30000</span>),<br>(<span class="hljs-number">5</span>,<span class="hljs-number">30010</span>,<span class="hljs-number">99990</span>);<br></code></pre></td></tr></table></figure><ul><li><p>需求</p><ol><li><p>查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">分析：</span><br><span class="hljs-comment">1. 员工编号，员工姓名，工资 信息在emp 员工表中</span><br><span class="hljs-comment">2. 职务名称，职务描述 信息在 job 职务表中</span><br><span class="hljs-comment">3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">-- 方式一 ：隐式内连接</span><br><span class="hljs-keyword">SELECT</span><br>emp.id,<br>emp.ename,<br>emp.salary,<br>job.jname,<br>job.description<br><span class="hljs-keyword">FROM</span><br>emp,<br>job<br><span class="hljs-keyword">WHERE</span><br>emp.job_id <span class="hljs-operator">=</span> job.id;<br><br><span class="hljs-comment">-- 方式二 ：显式内连接</span><br><span class="hljs-keyword">SELECT</span><br>emp.id,<br>emp.ename,<br>emp.salary,<br>job.jname,<br>job.description<br><span class="hljs-keyword">FROM</span><br>emp<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> job <span class="hljs-keyword">ON</span> emp.job_id <span class="hljs-operator">=</span> job.id;<br></code></pre></td></tr></table></figure></li><li><p>查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">分析：</span><br><span class="hljs-comment">1. 员工编号，员工姓名，工资 信息在emp 员工表中</span><br><span class="hljs-comment">2. 职务名称，职务描述 信息在 job 职务表中</span><br><span class="hljs-comment">3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4. 部门名称，部门位置 来自于 部门表 dept</span><br><span class="hljs-comment">5. dept 和 emp 一对多关系 dept.id = emp.dept_id</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">-- 方式一 ：隐式内连接</span><br><span class="hljs-keyword">SELECT</span><br>emp.id,<br>emp.ename,<br>emp.salary,<br>job.jname,<br>job.description,<br>dept.dname,<br>dept.loc<br><span class="hljs-keyword">FROM</span><br>emp,<br>job,<br>dept<br><span class="hljs-keyword">WHERE</span><br>emp.job_id <span class="hljs-operator">=</span> job.id<br><span class="hljs-keyword">and</span> dept.id <span class="hljs-operator">=</span> emp.dept_id<br>;<br><br><span class="hljs-comment">-- 方式二 ：显式内连接</span><br><span class="hljs-keyword">SELECT</span><br>emp.id,<br>emp.ename,<br>emp.salary,<br>job.jname,<br>job.description,<br>dept.dname,<br>dept.loc<br><span class="hljs-keyword">FROM</span><br>emp<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> job <span class="hljs-keyword">ON</span> emp.job_id <span class="hljs-operator">=</span> job.id<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> dept <span class="hljs-keyword">ON</span> dept.id <span class="hljs-operator">=</span> emp.dept_id<br></code></pre></td></tr></table></figure></li><li><p>查询员工姓名，工资，工资等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">分析：</span><br><span class="hljs-comment">1. 员工姓名，工资 信息在emp 员工表中</span><br><span class="hljs-comment">2. 工资等级 信息在 salarygrade 工资等级表中</span><br><span class="hljs-comment">3. emp.salary &gt;= salarygrade.losalary  and emp.salary &lt;= salarygrade.hisalary</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span><br>emp.ename,<br>emp.salary,<br>t2.<span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span><br>emp,<br>salarygrade t2<br><span class="hljs-keyword">WHERE</span><br>emp.salary <span class="hljs-operator">&gt;=</span> t2.losalary<br><span class="hljs-keyword">AND</span> emp.salary <span class="hljs-operator">&lt;=</span> t2.hisalary<br></code></pre></td></tr></table></figure></li><li><p>查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">分析：</span><br><span class="hljs-comment">1. 员工编号，员工姓名，工资 信息在emp 员工表中</span><br><span class="hljs-comment">2. 职务名称，职务描述 信息在 job 职务表中</span><br><span class="hljs-comment">3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4. 部门名称，部门位置 来自于 部门表 dept</span><br><span class="hljs-comment">5. dept 和 emp 一对多关系 dept.id = emp.dept_id</span><br><span class="hljs-comment">6. 工资等级 信息在 salarygrade 工资等级表中</span><br><span class="hljs-comment">7. emp.salary &gt;= salarygrade.losalary  and emp.salary &lt;= salarygrade.hisalary</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span><br>emp.id,<br>emp.ename,<br>emp.salary,<br>job.jname,<br>job.description,<br>dept.dname,<br>dept.loc,<br>t2.grade<br><span class="hljs-keyword">FROM</span><br>emp<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> job <span class="hljs-keyword">ON</span> emp.job_id <span class="hljs-operator">=</span> job.id<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> dept <span class="hljs-keyword">ON</span> dept.id <span class="hljs-operator">=</span> emp.dept_id<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> salarygrade t2 <span class="hljs-keyword">ON</span> emp.salary <span class="hljs-keyword">BETWEEN</span> t2.losalary <span class="hljs-keyword">and</span> t2.hisalary;<br></code></pre></td></tr></table></figure></li><li><p>查询出部门编号、部门名称、部门位置、部门人数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">分析：</span><br><span class="hljs-comment">1. 部门编号、部门名称、部门位置 来自于部门 dept 表</span><br><span class="hljs-comment">2. 部门人数: 在emp表中 按照dept_id 进行分组，然后count(*)统计数量</span><br><span class="hljs-comment">3. 使用子查询，让部门表和分组后的表进行内连接</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">-- 根据部门id分组查询每一个部门id和员工数</span><br><span class="hljs-keyword">select</span> dept_id, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id;<br><br><span class="hljs-keyword">SELECT</span><br>dept.id,<br>dept.dname,<br>dept.loc,<br>t1.count<br><span class="hljs-keyword">FROM</span><br>dept,<br>(<br><span class="hljs-keyword">SELECT</span><br>dept_id,<br><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) count<br><span class="hljs-keyword">FROM</span><br>emp<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>dept_id<br>) t1<br><span class="hljs-keyword">WHERE</span><br>dept.id <span class="hljs-operator">=</span> t1.dept_id<br></code></pre></td></tr></table></figure></li></ol></li></ul><h2 id="4-事务"><a href="#4-事务" class="headerlink" title="4.事务"></a>4.事务</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1  概述"></a>4.1  概述</h3><blockquote><p>数据库的事务（Transaction）是一种机制、一个操作序列，包含了==一组数据库操作命令==。</p><p>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令==要么同时成功，要么同时失败==。</p><p>事务是一个不可分割的工作逻辑单元。</p></blockquote><p>这些概念不好理解，接下来举例说明，如下图有一张表</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622173237289.png" alt="image-20220622173237289"></p><p>张三和李四账户中各有100块钱，现李四需要转换500块钱给张三，具体的转账操作为</p><ul><li>第一步：查询李四账户余额</li><li>第二步：从李四账户金额 -500</li><li>第三步：给张三账户金额 +500</li></ul><p>现在假设在转账过程中第二步完成后出现了异常第三步没有执行，就会造成李四账户金额少了500，而张三金额并没有多500；这样的系统是有问题的。如果解决呢？使用事务可以解决上述问题</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220622173306403.png" alt="image-20220622173306403"></p><p>从上图可以看到在转账前开启事务，如果出现了异常回滚事务，三步正常执行就提交事务，这样就可以完美解决问题。</p><h3 id="4-2-语法"><a href="#4-2-语法" class="headerlink" title="4.2  语法"></a>4.2  语法</h3><ul><li><p>开启事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br>或者  <br><span class="hljs-keyword">BEGIN</span>;<br></code></pre></td></tr></table></figure></li><li><p>提交事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure></li><li><p>回滚事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">rollback</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-3-代码验证"><a href="#4-3-代码验证" class="headerlink" title="4.3  代码验证"></a>4.3  代码验证</h3><ul><li><p>环境准备</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> account;<br><br><span class="hljs-comment">-- 创建账户表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> account(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">PRIMARY</span> KEY auto_increment,<br>name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>money <span class="hljs-keyword">double</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>)<br>);<br><br><span class="hljs-comment">-- 添加数据</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> account(name,money) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">1000</span>),(<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>不加事务演示问题</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 转账操作</span><br><span class="hljs-comment">-- 1. 查询李四账户金额是否大于500</span><br><br><span class="hljs-comment">-- 2. 李四账户 -500</span><br><span class="hljs-keyword">UPDATE</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">500</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李四&#x27;</span>;<br><br>出现异常了...  <span class="hljs-comment">-- 此处不是注释，在整体执行时会出问题，后面的sql则不执行</span><br><span class="hljs-comment">-- 3. 张三账户 +500</span><br><span class="hljs-keyword">UPDATE</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">500</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br></code></pre></td></tr></table></figure><p>整体执行结果肯定会出问题，我们查询账户表中数据，发现李四账户少了500。</p></li><li><p>添加事务sql如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 开启事务</span><br><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-comment">-- 转账操作</span><br><span class="hljs-comment">-- 1. 查询李四账户金额是否大于500</span><br><br><span class="hljs-comment">-- 2. 李四账户 -500</span><br><span class="hljs-keyword">UPDATE</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">500</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;李四&#x27;</span>;<br><br>出现异常了...  <span class="hljs-comment">-- 此处不是注释，在整体执行时会出问题，后面的sql则不执行</span><br><span class="hljs-comment">-- 3. 张三账户 +500</span><br><span class="hljs-keyword">UPDATE</span> account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">500</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>;<br><br><span class="hljs-comment">-- 提交事务</span><br><span class="hljs-keyword">COMMIT</span>;<br><br><span class="hljs-comment">-- 回滚事务</span><br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><p>上面sql中的执行成功进选择执行提交事务，而出现问题则执行回滚事务的语句。以后我们肯定不可能这样操作，而是在java中进行操作，在java中可以抓取异常，没出现异常提交事务，出现异常回滚事务。</p></li></ul><h3 id="4-4-事务的四大特征"><a href="#4-4-事务的四大特征" class="headerlink" title="4.4  事务的四大特征"></a>4.4  事务的四大特征</h3><ul><li><p>原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败</p></li><li><p>一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态</p></li><li><p>隔离性（Isolation） :多个事务之间，操作的可见性</p></li><li><p>持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</p></li></ul><blockquote><p>==说明：==</p><p>mysql中事务是自动提交的。</p><p>也就是说我们不添加事务执行sql语句，语句执行完毕会自动的提交事务。</p><p>可以通过下面语句查询默认提交方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT @<span class="hljs-meta">@autocommit</span>;<br></code></pre></td></tr></table></figure><p>查询到的结果是1 则表示自动提交，结果是0表示手动提交。当然也可以通过下面语句修改提交方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> @<span class="hljs-variable">@autocommit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb&amp;Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac环境配置java工具</title>
    <link href="/2022/06/21/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/06/21/mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="一、破解intellij-idea"><a href="#一、破解intellij-idea" class="headerlink" title="一、破解intellij idea"></a>一、破解intellij idea</h1><p>IntelliJ IDEA2022.1安装完成后，下面是激活，建议先不要启动IDEA。</p><p>下载激活工具。</p><p>执行 scripts 下的脚本文件，根据自己的电脑系统选择，执行Windows脚本，双击执行当前用户<strong><em>install-current-user.vbs\</em></strong>脚本。Linux和Mac系统用户终端下切换到scripts目录下，执行“<strong><em>bash install.sh\</em></strong>”脚本，看到提示“Success”，表示激活完成。</p><p>启动IntelliJ IDEA2022.1，可以添加激活码，或者添加代理服务器License server地址，如下图：</p><blockquote><p>1、选择License Server，添加代理服务器地址，更多License server地址：<a href="https://link.zhihu.com/?target=http%3A//blog.idejihuo.com/wp-content/uploads/2022/04/jetbrains-license-servers.txt">jetbrains-license-servers</a></p><p>2、选择Activation Code，添加激活码，激活码在线下载：<a href="https://link.zhihu.com/?target=http%3A//www.idejihuo.com/">http://www.idejihuo.com</a></p><p>3、<a href="https://account.jetbrains.com/licenses/assets">教育网优惠</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-a497c25775193d1dcd95506208e8b1f0_r.jpg" alt="preview"></p><p>点击Test Connection测试没有问题的话，点击Acticate激活</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-52b340986d31cca6beb38ba461c72623_r.jpg" alt="preview"></p><blockquote><p>或者直接添加激活码，试过发现格式不对</p><p>温馨提示：本次激活之后，大家可能比较疑惑，IDE使用时间和授权信息没有更改。其实已经是永久激活状态了！只是显示信息没有更改。</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/498068584">参考链接</a></p><h1 id="二、Mac环境配置maven"><a href="#二、Mac环境配置maven" class="headerlink" title="二、Mac环境配置maven"></a>二、Mac环境配置maven</h1><p>Maven 安装及配置大体可以划分为三个步骤：下载、安装和配置。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>打开 Maven 官方下载页面：<a href="https://maven.apache.org/download.cgi#，点击下载链接即可开始下载：">https://maven.apache.org/download.cgi#，点击下载链接即可开始下载：</a></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621150523428.png" alt="image-20220621150523428"></p><p>以 Maven 3.8.6 为例，解压后可以看到文件夹：apache-maven-3.8.6。 进行下一步之前，需要按照官方说明确认 JDK 已安装完成：</p><p>打开命令行终端，输入命令：java -version。</p><p>解压后，目录结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621153003804.png" alt="image-20220621153003804"></p><ul><li>bin目录 ： 存放的是可执行命令，重点关注mvn 命令。 </li><li>conf目录 ：存放Maven的配置文件。</li><li>lib目录 ：存放Maven依赖的jar包。Maven也是使用java开发的，所以它也依赖其他的jar包。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>将文件夹 apache-maven-3.8.6 拷贝或移动至系统目录 /usr/local（也可以根据个人喜好选择其它目录），Maven 安装完成。</p><p><strong>注</strong>：涉及<strong>系统目录或系统文件</strong>的操作，需要 sudo 权限。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Maven 配置文件：/usr/local/apache-maven-3.8.6/conf/settings.xml。</p><h3 id="本地仓库目录"><a href="#本地仓库目录" class="headerlink" title="本地仓库目录"></a>本地仓库目录</h3><p>Maven 本地仓库用于缓存已下载（远程）的 Jar 及相关文件，默认目录为用户主目录（~/.m2/repository），可以配置为其它目录：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">vim settings.xml<br><br>&lt;localRepository&gt;/Users/yurun/workspace/maven&lt;/localRepository&gt;<br></code></pre></td></tr></table></figure><p><strong>Mac下打开/usr/local目录方法：</strong></p><p>Mac下/usr/local目录默认是对于Finder是隐藏，如果需要到/usr/local下去，打开Finder，然后使用command+shift+G，在弹出的目录中填写/usr/local就可以了。</p><h3 id="阿里云仓库镜像"><a href="#阿里云仓库镜像" class="headerlink" title="阿里云仓库镜像"></a>阿里云仓库镜像</h3><p>添加阿里云仓库镜像，加速文件下载（远程）速度。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">vim settings.xml<br><br>&lt;mirror&gt;<br>  &lt;id&gt;aliyunmaven&lt;/id&gt;<br>  &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;<br>  &lt;name&gt;aliyun&lt;/name&gt;<br>  &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;<br>&lt;/mirror&gt;<br></code></pre></td></tr></table></figure><h3 id="系统环境变量"><a href="#系统环境变量" class="headerlink" title="系统环境变量"></a>系统环境变量</h3><p>将 mvn 添加到系统环境变量里：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">vim ~/.bash_profile <br><br>export M2_HOME=/usr/local/apache-maven-3.8.4 <br>export PATH=$PATH:$M2_HOME/bin<br></code></pre></td></tr></table></figure><p><strong>注</strong>：Mac 系统环境变量配置文件支持多个，这里仅以 ~/.bash_profile 为例。 添加完成之后，可以手动执行命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">source ~/.bash_profile<br></code></pre></td></tr></table></figure><p>强制系统环境变量生效；或者也可以关闭/重新打开命令行终端，系统环境变量会自动生效。再次输入命令：mvn -version</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621160120189.png" alt="image-20220621160120189"></p><p><strong>Zsh 添加环境变量</strong></p><p>给 Linux/Unix 系统增加环境变量，是使用 <code>export</code> 命令。</p><p>为了永久性生效，则需要考虑加入到登录的 <code>profile</code>中。</p><p>这个时候要考虑你当前使用的 <code>shell</code>,比如默认的 <code>bash shell</code>，则可编辑用户根目录下的隐藏文件 <code>./bash_profile</code></p><p>对于<code>zsh</code> 而言，需要编辑 <code>.zshrc</code> 这个文件 <code>vi ~/.zshrc</code></p><p>在最后面加上一句</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">export PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/python-2.7.6/</span>bin:<span class="hljs-variable">$PATH</span> <br></code></pre></td></tr></table></figure><p>解释：环境变量中，各个值是以冒号分隔开的。上面的语句表示给 <code>PATH</code> 这个变量重新赋值，让它等于</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">usr</span>/local/python-<span class="hljs-number">2</span>.<span class="hljs-number">7</span>.<span class="hljs-number">6</span>/bin  <br></code></pre></td></tr></table></figure><p>同时后面加上原来的 <code>$PATH</code>。</p><h2 id="IDEA使用Maven"><a href="#IDEA使用Maven" class="headerlink" title="IDEA使用Maven"></a>IDEA使用Maven</h2><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621165347529.png" alt="image-20220621165347529"></p><p><strong>Maven 坐标主要组成</strong></p><ul><li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima） </li><li>artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service） </li><li>version：定义当前项目版本号</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621165541511.png" alt="image-20220621165541511"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621165558114.png" alt="image-20220621165558114"></p><p><strong>使用坐标引入jar包的步骤：</strong></p><ul><li>在项目的 pom.xml 中编写标签</li><li>在标签中使用引入坐标</li><li>定义坐标的 groupId，artifactId，version</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621165752347.png" alt="image-20220621165752347"></p><ul><li><p>点击刷新按钮，使坐标生效，或者在设置Maven里选择任何改动生效</p><blockquote><p>注意：</p><p>具体的坐标我们可以到如下网站进行搜索 <a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p></blockquote></li></ul><p><strong>快捷方式导入jar包的坐标：</strong></p><p>每次需要引入jar包，都去对应的网站进行搜索是比较麻烦的，接下来给大家介绍一种快捷引入坐标的方式 </p><ul><li>在 pom.xml 中 按 alt + insert(Mac:command+N)，选择 Dependency</li><li>在弹出的面板中搜索对应坐标，然后双击选中对应坐标</li></ul><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220621170825271.png" alt="image-20220621170825271"></p><h1 id="三、Mac环境配置Mybatis"><a href="#三、Mac环境配置Mybatis" class="headerlink" title="三、Mac环境配置Mybatis"></a>三、Mac环境配置Mybatis</h1><p>MyBatis 是一款优秀的持久层框架，用于简化 JDBC 开发。</p><ul><li><p>硬编码 </p><ul><li><p>注册驱动、获取连接 </p></li><li><p>SQL语句 </p></li></ul></li></ul><p>这部分代码操作繁琐，而且没什么技术含量，于是采用Mybatis对其进行封装</p><p>优化内容：</p><ul><li>硬编码可以配置到配置文件 </li><li>操作繁琐的地方mybatis都自动完成</li></ul><p><a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=692132">Mac破解安装navicat</a></p><p>navicat：command+R 运行全部</p><p><a href="https://blog.csdn.net/qq_30101647/article/details/121339098?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165581554816780357280161%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165581554816780357280161&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-121339098-null-null.142^v20^control,157^v15^new_3&amp;utm_term=mac%E5%AE%89%E8%A3%85mysql&amp;spm=1018.2226.3001.4187">Mac安装Mysql服务</a></p><p>Intellij：option+Enter 解决异常，control+R运行</p><p>IDEA中配置MySQL数据库连接：</p><ul><li>点击右边框的数据库，在数据源里选择MySQL</li><li>在弹出的界面进行基本信息的填写</li><li>点击完成后进入数据库页面，就能和navicat工具一样进行数据库的操作，编写SQL语句。</li></ul><p>使用 Mapper 代理方式替代selectList()方法传参解决硬编码问题。</p><p>官网上有，照着官网说明安装就行。</p><h1 id="四、安装Python"><a href="#四、安装Python" class="headerlink" title="四、安装Python"></a>四、安装Python</h1><ul><li><p>macOS自带python，只需要将所有的python指令全部换成python3即可。</p></li><li><p>去官网安装一个Sublime Text。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习第一周</title>
    <link href="/2022/06/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0week01/"/>
    <url>/2022/06/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0week01/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h3 id="1-1-什么是机器学习"><a href="#1-1-什么是机器学习" class="headerlink" title="1.1 什么是机器学习"></a>1.1 什么是机器学习</h3><p>类似人类通过对经验的利用对新情况做出有效的决策，计算机通过计算的手段，利用经验来改善系统自身的性能。</p><p>在计算机系统中，”经验”通常以”数据”形式存在，因此机器学习所研究的主要内容，是关于在计算机上从数据中产生”<strong>模型”(model)</strong>的算法，即”学习算法”(learningalgorithm).有了学习算法，我们把经验数据提供给它，它就能基于这些数据产生模型；在面对新的情况时(例如看到一个没剖开的西瓜)，模型会给我们提供相应的判断(例如好瓜).</p><p>如果说计算机科学是研究关于”算法”的学问，那么类似的，可以说机器学习是研究关于”学习算法”的学问.</p><h3 id="1-2-基本术语"><a href="#1-2-基本术语" class="headerlink" title="1.2 基本术语"></a>1.2 基本术语</h3><p>假定我们收集了一批关于西瓜的数据，例如(色泽=青绿；根蒂=蜷缩；敲声=浊响)，(色泽=乌黑；根蒂:稍蜷；敲声=沉闷)，(色泽=浅自；根蒂硬挺；敲声=清脆)…</p><p>每对括号内是一条<strong>记录</strong>，=的意思是”取值为”。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220617192915496.png" alt="image-20220617192915496"></p><p>从数据中学得模型的过程称为<u><strong>“学习”(learning)或”训练”(training)</strong></u>,这个过程通过执行某个学习算法来完成学得模型对应了关于数据的某种潜在的规律，因此亦称<strong><u>“假设”</u></strong>(hypothesis)；这种潜在规律自身，则称为<u><strong>“真相”或”真实”(ground-truth)</strong></u>，学习过程就是为了找出或逼近真相.本书有时将模型称为<u><strong>“学习器”(learner)</strong></u>，可看作学习算法在给定数据和参数空间上的实例化.</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220617200149951-5467313-5467314-5467315.png" alt="image-20220617200149951"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220617200824722-5467707.png" alt="image-20220617200824722"></p><p>学得模型后，使用其进预测的过程称为<u><strong>“测试”(testing)</strong></u>，被预测的样本称为<u><strong>“测试样本”(testingsample)</strong></u>.例如在学得$f$后，对测试例，可得到其预测标记$ν=f(x)$.</p><p><u><strong>“聚类”(clustering)</strong></u>，即将训练集中的西瓜分成若干组，每组称为一个”<u><strong>簇</strong></u>“(cluster)；这些自动形成的簇可能对应一些潜在的概念划分，例如”浅色瓜””深色瓜”，这些概念事先是不知道的，而且学习过程中使用的训练样本通常不拥有标记信息.</p><p>根据<u>训练数据是否拥有标记信息</u>，学习任务可大致划分为两大类”监督学习”(supervisedlearning)和”<strong>无监督学习</strong>“(unsupervisedlearning)，分类和回归是前者的代表，而聚类则是后者的代表.</p><p><u>学得模型适用于新样本的能力</u>，称为”<strong><u>泛化</u></strong>“(generalization)能力.具有强泛化能力的模型能很好地适用于整个样本空间.通常假设样本空间的样本均服从独立同分布，一般而言，训练样本越多，我们得到的关于分布的信息越多，这样就越有可能通过学习获得具有强泛化能力的模型.</p><h3 id="1-3-假设空间"><a href="#1-3-假设空间" class="headerlink" title="1.3 假设空间"></a>1.3 假设空间</h3><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618134035759.png" alt="image-20220618134035759" style="zoom: 50%;" /></p><p>归纳学习有<strong>狭义</strong>与<strong>广义</strong>之分：</p><p>广义的归纳学习大体相当于<u>从样例中学习</u>。</p><p>狭义的归纳学习则要求<u>从训练数据中学得概念(concept)</u>，因此亦称为<u><strong>“概念学习”或”概念形成”</strong></u>。</p><p>举一个西瓜数据集的例子：</p><div class="table-container"><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">色泽</th><th style="text-align:center">根蒂</th><th style="text-align:center">敲声</th><th style="text-align:center">好瓜</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">青绿</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">乌黑</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">青绿</td><td style="text-align:center">硬挺</td><td style="text-align:center">清脆</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">乌黑</td><td style="text-align:center">稍缩</td><td style="text-align:center">沉闷</td><td style="text-align:center">否</td></tr></tbody></table></div><p>这里要学习的目标是”好瓜”，表1.1第一行虽然是好瓜，但这是一个已经见过的瓜，不属于“泛化”的范畴，因此引入一个概念——<u><strong>假设空间</strong></u>，里面包含所有假设。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618104530154.png" alt="image-20220618104530154"></p><p>搜索过程中可以不断删除<u><strong>与正例不一致</strong></u>的假设、和(或)<u><strong>与反例一致</strong></u>的假设，最终获得与训练集一致(即<u>对所有训练样本能够进行正确判断</u>)的假设，这就是我们学得的结果.</p><p>与训练集一致的”假设集合”称之为”版本空间”(versionspace).例如，在西瓜问题中，与表1.1训练集所对应的版本空间如图1.2所示.<a href="https://blog.csdn.net/qq_18433441/article/details/55682732">详细过程</a></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618110202690.png" alt="image-20220618110202690"></p><h3 id="1-4-归纳偏好"><a href="#1-4-归纳偏好" class="headerlink" title="1.4 归纳偏好"></a>1.4 归纳偏好</h3><p>通过学习得到的模型对应了假设空间中的一个假设，但很可能存在有多个与训练集一致的假设，但与它们对应的模型在面临新样本的时候，却会产生不同的输出.</p><p>机器学习算法在学习过程中对某种类型假设的偏好，称为”<strong><u>归纳偏好</u></strong>“(inductivebias),或简称为”偏好”。<u>任何一个有效的机器学习算法必有其归纳偏好</u>。</p><p>“奥卡姆剃刀”(Occam’srazor)原则：”若有多个假设与观察一致，则选最简单的那个。</p><p>在具体的现实问题中，这个假设是否成立，即算法的归纳偏好是否与问题本身匹配，大多数时候直接决定了算法能否取得好的性能.脱离具体问题，空泛地谈论”什么学习算法更好”毫无意义，因为若考虑所有潜在的问题，则所有学习算法都一样好.</p><h3 id="1-5-习题"><a href="#1-5-习题" class="headerlink" title="1.5 习题"></a>1.5 习题</h3><h4 id="1-5-1"><a href="#1-5-1" class="headerlink" title="1.5.1"></a>1.5.1</h4><p><em>表1. 1 中若只包含编号为 1 和 4 的两个样例，试给出相应的版本空间.</em></p><div class="table-container"><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">色泽</th><th style="text-align:center">根蒂</th><th style="text-align:center">敲声</th><th style="text-align:center">好瓜</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">青绿</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">乌黑</td><td style="text-align:center">稍缩</td><td style="text-align:center">沉闷</td><td style="text-align:center">否</td></tr></tbody></table></div><p>表1.1的训练数据集对应的假设空间应该如下：</p><p>搜索过程中可以不断删除与正例不一致的假设、和（或）与反例一致的假设。最终将会获得与训练集一致（即对所有训练样本能够进行正确判断）的假设，这就是我们学得的结果。</p><p>按照上述过程进行学习：</p><p>编号1可以删除：3，5，6，8，9，11-15，17-21，23-30，32-49</p><p>编号4可以删除：3，6，15，21，30，48，即剩余假设空间中无可删除的假设</p><p>学习过后剩余的假设为：</p><p>1，2，4，7，10。</p><p>这就是最后的“假设集合”，也就是<strong>“版本空间”</strong>。</p><p>1 色泽＝＊，根蒂＝＊，敲声＝＊<br>2 色泽＝青绿，根蒂＝＊，敲声＝＊<br>3 色泽＝乌黑，根蒂＝＊，敲声＝＊<br>4 色泽＝＊，根蒂＝蜷缩，敲声＝＊<br>5 色泽＝＊，根蒂＝硬挺，敲声＝＊<br>6 色泽＝＊，根蒂＝稍蜷，敲声＝＊<br>7 色泽＝＊，根蒂＝＊，敲声＝浊响<br>8 色泽＝＊，根蒂＝＊，敲声＝清脆<br>9 色泽＝＊，根蒂＝＊，敲声＝沉闷<br>10 色泽＝青绿，根蒂＝蜷缩，敲声＝＊<br>11 色泽＝青绿，根蒂＝硬挺，敲声＝＊<br>12 色泽＝青绿，根蒂＝稍蜷，敲声＝＊<br>13 色泽＝乌黑，根蒂＝蜷缩，敲声＝＊<br>14 色泽＝乌黑，根蒂＝硬挺，敲声＝＊<br>15 色泽＝乌黑，根蒂＝稍蜷，敲声＝＊<br>16 色泽＝青绿，根蒂＝＊，敲声＝浊响<br>17 色泽＝青绿，根蒂＝＊，敲声＝清脆<br>18 色泽＝青绿，根蒂＝＊，敲声＝沉闷<br>19 色泽＝乌黑，根蒂＝＊，敲声＝浊响<br>20 色泽＝乌黑，根蒂＝＊，敲声＝清脆<br>21 色泽＝乌黑，根蒂＝＊，敲声＝沉闷<br>22 色泽＝＊，根蒂＝蜷缩，敲声＝浊响<br>23 色泽＝＊，根蒂＝蜷缩，敲声＝清脆<br>24 色泽＝＊，根蒂＝蜷缩，敲声＝沉闷<br>25 色泽＝＊，根蒂＝硬挺，敲声＝浊响<br>26 色泽＝＊，根蒂＝硬挺，敲声＝清脆<br>27 色泽＝＊，根蒂＝硬挺，敲声＝沉闷<br>28 色泽＝＊，根蒂＝稍蜷，敲声＝浊响<br>29 色泽＝＊，根蒂＝稍蜷，敲声＝清脆<br>30 色泽＝＊，根蒂＝稍蜷，敲声＝沉闷<br>31 色泽＝青绿，根蒂＝蜷缩，敲声＝浊响<br>32 色泽＝青绿，根蒂＝蜷缩，敲声＝清脆<br>33 色泽＝青绿，根蒂＝蜷缩，敲声＝沉闷<br>34 色泽＝青绿，根蒂＝硬挺，敲声＝浊响<br>35 色泽＝青绿，根蒂＝硬挺，敲声＝清脆<br>36 色泽＝青绿，根蒂＝硬挺，敲声＝沉闷<br>37 色泽＝青绿，根蒂＝稍蜷，敲声＝浊响<br>38 色泽＝青绿，根蒂＝稍蜷，敲声＝清脆<br>39 色泽＝青绿，根蒂＝稍蜷，敲声＝沉闷<br>40 色泽＝乌黑，根蒂＝蜷缩，敲声＝浊响<br>41 色泽＝乌黑，根蒂＝蜷缩，敲声＝清脆<br>42 色泽＝乌黑，根蒂＝蜷缩，敲声＝沉闷<br>43 色泽＝乌黑，根蒂＝硬挺，敲声＝浊响<br>44 色泽＝乌黑，根蒂＝硬挺，敲声＝清脆<br>45 色泽＝乌黑，根蒂＝硬挺，敲声＝沉闷<br>46 色泽＝乌黑，根蒂＝稍蜷，敲声＝浊响<br>47 色泽＝乌黑，根蒂＝稍蜷，敲声＝清脆<br>48 色泽＝乌黑，根蒂＝稍蜷，敲声＝沉闷<br>49 Ø</p><h4 id="1-5-2"><a href="#1-5-2" class="headerlink" title="1.5.2"></a>1.5.2</h4><p><a href="https://blog.csdn.net/qq_26371477/article/details/102292685?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-102292685-blog-103812745.pc_relevant_antiscanv3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-102292685-blog-103812745.pc_relevant_antiscanv3&amp;utm_relevant_index=10">代码实现</a></p><p><em>与使用单个合取式来进行假设表示相比，使用”析合范式”将使得假设空间具有更强的表示能力.例如</em></p><p><em>好瓜$\leftrightarrow$((色泽=all)$\cap$(根蒂=蜷缩) $\cap$(敲声=all )) $\cup$ ((色泽=乌黑) $\cap$ (根蒂= all)$\cap$(敲声=沉闷)),</em></p><p>会把”(色泽=青绿)$\cap$(根蒂=蜷缩) $\cap$(敲声=清脆 <em>)”以及”(色泽=乌黑)$\cap$(根蒂=硬挺) $\cap$(敲声=沉闷 </em>)”都分类为”好瓜”。若使用最 多包含 $k$个合取式的析合范式来表达表1. 1 西瓜分类问题的假设空 间 ,试估算共有多少种可能的假设.*</p><blockquote><p>知识储备</p><p>合取式：是用合取真值联结词“∧”将两个或两个以上的命题联结起来而形成的命题形式。</p><p>析取式：用析取真值连接词“∨”将两个或两个以上的命题联结而成的一种命题形式</p><p>合取：相当于交集但不是交集</p><p>析取：相当于并集但不是并集</p><p>合取范式（合析范式）：有限个简单析取式构成的合取式</p><p>析取范式（析合范式）：由有限个简单合取式构成的析取式称为析取范式。</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">色泽</th><th style="text-align:center">根蒂</th><th style="text-align:center">敲声</th><th style="text-align:center">好瓜</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">青绿</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">乌黑</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">青绿</td><td style="text-align:center">硬挺</td><td style="text-align:center">清脆</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">乌黑</td><td style="text-align:center">稍缩</td><td style="text-align:center">沉闷</td><td style="text-align:center">否</td></tr></tbody></table></div><p>表中4个样例，3种属性，属性个数分别为2，3，3，假若考虑没有泛化属性和空集的情况下，剔除含通配符和相同的项，得到无冗余的假设空间共有2$\times$3$\times$3=18种假设，这18种假设的自由组合成的析合范式能够唯一的表示所有的假设。</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">色泽=青绿</td><td style="text-align:center">色泽=乌黑</td><td style="text-align:center">——</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">根蒂=蜷缩</td><td style="text-align:center">根蒂=稍蜷</td><td style="text-align:center">根蒂=硬挺</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">敲声=浊响</td><td style="text-align:center">敲声=清脆</td><td style="text-align:center">敲声=沉闷</td></tr></tbody></table></div><p>可列集合为（$a_1<script type="math/tex">b_1</script>c_1$, $a_1b_1c_2$ ,……, $a_2b_3c_3$)，将其简化为（$1,2,3,……,18$),</p><p>$k=1$时，所有的析合范式为：$(1,2,3,……18)$。</p><p>$k=2$时，所有的析合范式为：$((1,2),(1,3),(1,4),(1,5),……(16,17),(16,18),(17,18))$。</p><p>有可能的析合范式的个数为：$17+16+……+3+2+1$=153。</p><p>$k=3$时，析合范式的个数为816,代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">result=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">17</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((i+<span class="hljs-number">1</span>),<span class="hljs-number">19</span>):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((j+<span class="hljs-number">1</span>),<span class="hljs-number">19</span>):<br>            <span class="hljs-built_in">print</span>((i,j,k))<br>            result=result+<span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>$k=4$时，析合范式的个数为3060,代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">result=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> a1 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">16</span>):<span class="hljs-comment">#这里16和循环次数相加就等于20</span><br>    <span class="hljs-keyword">for</span> a2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((a1+<span class="hljs-number">1</span>),<span class="hljs-number">19</span>):<br>        <span class="hljs-keyword">for</span> a3 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((a2+<span class="hljs-number">1</span>),<span class="hljs-number">19</span>):<br>            <span class="hljs-keyword">for</span> a4  <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((a3  + <span class="hljs-number">1</span>), <span class="hljs-number">19</span>):<br>                <span class="hljs-built_in">print</span>((a1 ,a2 ,a3 ,a4 ))<br>                result=result+<span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><h4 id="1-5-3"><a href="#1-5-3" class="headerlink" title="*1.5.3"></a>*1.5.3</h4><p>若数据包含噪声，则假设空间中有可能不存在与所有训练样本都一致 的假设，在此情形下，试设计一种归纳偏好用于假设选择.</p><p><u>不会</u></p><p>数据包含噪声，其含义就是，存在训练集本身的部分数据，其<u>属性取值对应的标记值是错误的</u>。对于噪声，最理想的情况是去除所有噪声，即将这部分“错误”的数据剔除出训练集。但事实上，单从数据集本身来剔除噪声并无通用的办法，甚至无法直接判断哪些数据属于噪声。</p><p>通俗来讲，我们可以先认为所有不矛盾的数据是正确的，只有哪些属性值相同但标记值不同的数据，“相互矛盾”的情况下，才剔除一部分数据使矛盾消除，此时剔除的方法可以归纳为一种偏好。 </p><p>例如，属性值相同的两个数据，其标记值分别为正例和反例，可以设计归纳偏好为：<u>始终保留正例的数据，或始终保留反例的数据。</u><br><a href="https://blog.csdn.net/MaxQuYY/article/details/120287245">原文链接</a></p><h4 id="1-5-4"><a href="#1-5-4" class="headerlink" title="*1.5.4"></a>*1.5.4</h4><p>换用其它性能度量，试证明没有免费的午餐定理成立。</p><p><a href="https://zhuanlan.zhihu.com/p/48493722">公式推导</a></p><h4 id="1-5-5"><a href="#1-5-5" class="headerlink" title="1.5.5"></a>1.5.5</h4><p>试述机器学习能在互联网搜索的哪些环节起什么作用.</p><ol><li>在向搜索引擎提交信息阶段，能够从提交文本中进行信息提取，进行语义分析。</li><li>在搜索引擎进行信息匹配阶段，能够提高问题与各个信息的匹配程度。</li><li>在向用户展示搜索结果的阶段，能够根据用户对结果感兴趣的程度进行排序。 </li></ol><h1 id="第二章-模型评估与选择"><a href="#第二章-模型评估与选择" class="headerlink" title="第二章 模型评估与选择"></a>第二章 模型评估与选择</h1><h3 id="章节主要内容"><a href="#章节主要内容" class="headerlink" title="章节主要内容"></a>章节主要内容</h3><p>在第一章绪论中，我们知道要根据具体的问题选择具体的算法和归纳偏好。那么要怎么判定我们的选择是正确的呢？这就需要拥有一套规范的模型评估与选择方法论了。</p><p>具体的章节思路可参考如下图解。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//5328356-6afc770c7199ac3d.jpeg" alt="img"></p><p><a href="https://www.jianshu.com/p/8e369f73a0cc">参考链接</a></p><h3 id="2-1-经验误差与过拟合"><a href="#2-1-经验误差与过拟合" class="headerlink" title="2.1 经验误差与过拟合"></a><strong>2.1 </strong>经验误差与过拟合</h3><p>——机器学习为什么需要一套模型评估与选择方法论？</p><p>在前一章的学习中，我们知道<u>机器学习是对数据集的泛化过程，即从输入的数据中归纳出一套能适用于所有潜在样本的“普遍规律”</u>。可因为训练数据不够充分，机器学习出来的模型并没办法涵盖所有的情况，这就会导致学习器的实际预测输出与样本的真实输出之间存在“误差”。</p><p>学习器在训练集上的误差称为“经验误差”，在新样本上的误差称为“泛化误差”。很明显，要使得分类器尽可能的有用，我们应该要让泛化误差仅可能的小。可惜在现实环境中，我们很难知道新样本是什么样的，所以我们实际能做的只有努力使经验误差最小化。</p><p>但如果将算法设计的尽可能百分百的满足所有训练样本，就忘了学习器真正要达到的是泛化误差尽可能小，而不是目前的折中方案降低经验误差。而在降低经验误差的道路上，有着机器学习领域最大的难题之一：<u><strong>“过拟合”</strong></u>。</p><p>“过拟合”是指学习器对训练样本学的太好了，导致泛化程度不够（机器学习本身就是一个泛化过程），没法适应新的数据样本。与之相反的还有一个“欠拟合”的概念，就是对训练样本中的一般规律都没学习好。举个例子，你通过姚明这个训练样本来学习一个人类判断器，如果你将身高两米二十以上作为判断是否是人的依据，那就是过拟合了；而如果你没有“直立行走”这样的特征都没有找出来作为判断是否是人的标准，那就是欠拟合了。</p><p>所以，为什么需要一套模型评估与选择的方法论呢？<u><strong>因为我们的训练数据没法真正代表真实的样本空间，而泛化误差无法直接获得，经验误差又因为过拟合的存在而不适合作为标准，所以我们才需要一套模型评估与选择的方法论。</strong></u></p><h4 id="2-1-1-相关概念"><a href="#2-1-1-相关概念" class="headerlink" title="2.1.1 相关概念"></a>2.1.1 相关概念</h4><p>误差分为训练误差、经验误差和泛化误差，前两种为在学习集上的误差，最后一种是在新样本上的误差。</p><p>错误率$E$=分类错误的样本数$a$/总样本数$m$</p><p>精度=$1 - $ 错误率=$1-\frac{a}{m}$</p><p>误差=学习器的实际预测输出-真实输出</p><p><strong>欠拟合与过拟合的例子</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618142530466.png" alt="image-20220618142530466"></p><h3 id="2-2-评估方法"><a href="#2-2-评估方法" class="headerlink" title="2.2  评估方法"></a><strong>2.2 </strong> 评估方法</h3><p>——在已经知道为什么要对模型进行评估后，在不知道泛化误差的情况下，我们该如何进行评估呢？</p><p>一个合理的思路是：<u>既然我们没法拿到新样本来进行泛化误差计算，那么我们可以从训练样本中取出一部分来，假装它是一组新样本，并用这些样本计算出来的误差作为泛化误差的近似。</u>这组选出来的样本被称为“测试集”，测试集上的误差被称为测试误差。我们学习本书的一个主要目的是学会机器学习领域的脉络和背后逻辑，这种评估思路是科学研究领域的一个常用思路。领悟这种思路有助于我们解决其它领域上的问题）</p><p>不过我们需要注意一点，那就是测试集应该尽量不与训练集重合，否则测试集计算出的误差将没法准确代表该学习器的泛化能力。</p><p>基于这个考虑，书中列出了以下几种把包含$m$个样例的数据集$D$划分为训练集$S$和测试集$T$的办法。</p><h4 id="［1］留出法（hold-out）"><a href="#［1］留出法（hold-out）" class="headerlink" title="［1］留出法（hold-out）"></a><strong>［1］留出法（hold-out）</strong></h4><p>直接将$D$划分为互斥的两部分$S和T$，在$S$上训练出模型后，用$T$来评估测试误差，即 $D=S\cup T$，$S\cap T=\empty$。</p><p>需要注意的是训练/测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外的偏差而对最终结果产生影响。</p><blockquote><p>“分层采样” (stratified sampling)：一种保留类别比例的采样方式. 例如通过对 D 进行分层采样而获得含 70% 样本的训练集 S 和含 30% 样本的测试集 T， 若 D 包含 500 个正例、 500 个反例，则分层采样得到的 S 应包含 350 个正例、 350 个反例?而 T 则包含 150 个正例和 150 个反例；若 S、 T 中样本类别比例差别很大，则误差估计将由于训练/测试数据分布的差异 而产生偏差.</p></blockquote><p>在样本数量上的划分上，为了平衡模型的准确性与测试结果的保真性，常见做法是将大约 2/3～ 4/5 的样本用于训练，剩余样本用于测试（一般而言，测试集至少应含 30 个样例）。</p><h4 id="［2］交叉验证法（cross-validation）"><a href="#［2］交叉验证法（cross-validation）" class="headerlink" title="［2］交叉验证法（cross validation）"></a><strong>［2］交叉验证法（cross validation）</strong></h4><p>将数据集 $D $划 分为 $k $个互斥子集，即$D=D_1\cup D_2\cup ……\cup D_k$，$D_i\cap D_j=\empty $，每次用$k-1 $个子集的并集作为训练集，余下的那个子集作为测试集；对获得的 $k$组训练/测试集进行 $k$ 次训练和测试，得到这 $k$ 个测试结果的均值。</p><p>显然，交叉验证法评估结果的稳定性和保真性在很大程度上取决于 $k $的取值，为强调这一点，通常把交叉验证法称为 “$ k $折交叉验证” (k-fold cross validation). $k $最常用的取值是 10，此时称为 10 折交叉验 证；其他常用的$k$值有 5、 20 等.</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618155420458.png" alt="image-20220618155420458"></p><p>交叉验证法的一 个特例:留一法(Leave-One-Out，简称 LOO) . 假定数据集 $D$ 中包含 $m$ 个样本，令 $k=m$ ，即子集数量设定为样本数量。</p><blockquote><p>10次10 折交叉验证法与100 次留出法都是进行了 100 次训练/测试</p></blockquote><h4 id="［3］自助法（bootstrapping）"><a href="#［3］自助法（bootstrapping）" class="headerlink" title="［3］自助法（bootstrapping）"></a><strong>［3］自助法（bootstrapping）</strong></h4><p>每次从$D$中随机复制一个样本到$D1$中，重复$m$次，会得到一个拥有$m$个数据样本的$D1$数据集。显然，$D$中的一部分数据会多次出现在$D1$中，而另一部分样本不出现。根据平均分布概率计算，大约有36.8%的数据不会被复制到$D1$中。</p><p>可以做一个简单的估计，样本在 $m$ 次采样中始终不被采到的概率是 $(1-\frac{1}{m})^m$， 取极限得到$\lim_{m\to \infin}(1-\frac{1}{m})^m \to \frac{1}{e} \approx. 0.368$</p><p>于是我们可将$ D’ $用作训练集， $D/D’ $用作测试集；这样实际评估的模型与期望评估的模型都使用 $m $个训练样本，而我们仍有数据总量约 $1/3$ 的，没在训练集中出现的样本用于测试。这样的测试结果，亦称”包外估计” (out-of-bag estimate).</p><h4 id="［4］注意点"><a href="#［4］注意点" class="headerlink" title="［4］注意点"></a><strong>［4］注意点</strong></h4><p>训练/测试集的划分要尽可能保持数据分布一致性。</p><p>单次划分往往不够稳定可靠，一般要采用若干次随机划分、重复进行实验评估后取平均值作为评估结果。</p><p>训练/测试集的划分比例没有完美答案，训练样本多会使得模型更接近$D$，测试样本多会使得评估结果更可靠，这其中的取舍因人/场景而异。常见的训练/测试划分比例是2:1～4:1。</p><h4 id="［5］调参"><a href="#［5］调参" class="headerlink" title="［5］调参"></a><strong>［5］调参</strong></h4><p>不同的参数其实就代表着不同的模型了。一般参数分两种：一类是算法的参数，亦称“超参数”，如聚类要分的簇数量$k$；一类是模型的参数，如神经网络中每个节点的权重。前者多为人工选择一组候选，后者是让机器自己学习。</p><p>常用的做法是对每个参数选定一个范围和变化步长，<u>例如在 [0， 0.2] 范围内以 0.05 为步长，则实际要评估的候选参数值有 5 个，最终是从这 5 个候选值中产生选定值。简单估算一下：假定算法有 3 个参数，每个参数仅考虑 5 个候选 值，这样对每一组训练/测试集就有 53 = 125 个模型需考察；</u>很多强大的学习算 法有大量参数需设定，这将导致极大的调参工程量，例如大型”深度学习模型甚至有上百亿个参数。</p><p>调参是机器学习的重点，也是决定模型性能的关键。一般调参过程中，会将训练数据再次划分为训练集和验证集（validation set）。具体包含关系如下：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220619171542448.png" alt="image-20220619171542448"></p><h4 id="［6］适用性"><a href="#［6］适用性" class="headerlink" title="［6］适用性"></a><strong>［6］适用性</strong></h4><p>自助法在数据集较小、难以有效划分训练/测试集时很有用</p><p>自助法产生的数据集改变了初始数据集的分布，这会引入估计偏差。因此，在初始数据量足够时，留出法和交叉验证法更常用一些。</p><p>留出法和交叉验证法由于都把数据集中的一部分用来测试，没有参与训练，因此必然会引入一些因训练样本规模不同而导致的估计偏差，留一法受影响较小，但计算复杂度又太高了。</p><h3 id="2-3-性能度量"><a href="#2-3-性能度量" class="headerlink" title="2.3  性能度量"></a><strong>2.3 </strong> 性能度量</h3><p>——在了解了有效可行实验评估方法后，接下来我们需要了解一下具体的衡量模型泛化能力的评价标准，即性能度量（performance measure）</p><p>性能度量反映了任务需求，使用不同的性能度量会导致对模型的评判结果不同。这意味着模型的“好坏”是相对的，什么样的模型是好的，不仅取决于算法和数据，还决定于任务需求。</p><p>在预测任务中，给定样例集 $D = {(x1 , y1) , (x2 ， y2)， . . . , (xm, ym)} $， 其中 $yi$ 是示例 $xi$ 的真实标记。要评估学习器 $f$ 的性能，就要把学习器预测结果 $f(x)$  与真实标记  $y$ 进行比较。</p><p>回归任务<strong>最常用的性能度量</strong>是”<strong>均方误差</strong>“ (mean squared error)：</p><script type="math/tex; mode=display">E(f;D)=\frac{1}{m}\sum_{i=1}^{m}(f(xi)-yi)^2</script><p>更一般的，对于数据分布 $Ð$ 和概率密度函数 $p(.) $， 均方误差可描述为</p><script type="math/tex; mode=display">E(f;Ð)=\int_{x～Ð}(f(x)-y)^2p(x)dx</script><h4 id="2-3-1-错误率与精度"><a href="#2-3-1-错误率与精度" class="headerlink" title="2.3.1 错误率与精度"></a>2.3.1 错误率与精度</h4><p>对样例集 $D$，分类错误率定义为：</p><script type="math/tex; mode=display">E(f;D)=\frac{1}{m}\sum_{i=1}^{m}I(f(xi)\ne yi)</script><p>精度则定义为：</p><script type="math/tex; mode=display">acc(f;D)=\frac{1}{m}\sum_{i=1}^{m}I(f(xi)= yi)=1-E(f;D)</script><p>更一般的，对于数据分布 $Ð$ 和概率密度函数 $p(.)$ ，错误率与精度可分别描述为</p><script type="math/tex; mode=display">E(f;Ð)=\int_{x～Ð}(f(x)\ne y)p(x)dx</script><script type="math/tex; mode=display">acc(f;Ð)=\int_{x～Ð}(f(x)= y)p(x)dx=1-E(f;Ð)</script><h4 id="2-3-2-查准率、查全率与-F1"><a href="#2-3-2-查准率、查全率与-F1" class="headerlink" title="2.3.2 查准率、查全率与$F1$"></a>2.3.2 查准率、查全率与$F1$</h4><p>查准率和查全率可以理解为”挑出的西瓜中有多少比例是好瓜”，或者”所有好瓜中有多少比例被挑了出来”，或者”检索出的信息中有多少比例是用户感兴趣的” 和”用户感兴趣的信息中有多少被检索出来了”。</p><p>对于二分类问题，可将样例根据其真实类别与学习器预测类别的组合划分为真正例 (true positive) 、假正例 (false positive) 、真反例 (true negative) 、 假反例 (false negative) 四种情形，令 $TP、 FP、 TN、 FN$ 分别表示其对应的样例数，则显然有 $TP+FP+TN+FN=样例总数$。分类结果的误差矩阵或者精度矩阵称为”混淆矩阵” (confusion matrix)。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618175331853.png" alt="image-20220618175331853"></p><p>查准率 $P $ 与查全率 $R$ 分别定义为：</p><p>$P=\frac{TP}{TP+FP}$  =  真正例 / 预测出的正例</p><p>$R=\frac{TP}{TP+FN}$ =。真正例 / 实际上的正例</p><p>二者通常呈反比。</p><p>举个例子：假设有10个西瓜，6个好瓜，4个坏瓜。我们将这十个瓜按照预测结果排序，最可能是好瓜的排在前头，最不可能的排在最后，然后控制学习器的分类阀值来依次逐个把样本作为好瓜来进行预测，则可以计算出不同的阀值时的$P$和$R$如下表所示：</p><div class="table-container"><table><thead><tr><th>指标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>TP</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>6</td><td>6</td><td>6</td><td>6</td></tr><tr><td>FN</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>FP</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>TN</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>P</td><td>X</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>6/7</td><td>6/8</td><td>6/9</td><td>6/10</td></tr><tr><td>R</td><td>0</td><td>1/6</td><td>2/6</td><td>3/6</td><td>4/6</td><td>5/6</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>由上边例子可以看到，P和R的值也基本满足了一方升高，另一方下降的状况，通常只有在一些简单的任务（比如我举的这个）中，才可能使查全率和查准率都很高。以查准率为纵轴、查全率为横轴作图，就得到了查准率－查全率曲线，简称“P-R曲线”。</p><p>再举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//20160721114615857-20220619182907525.png" alt="img"></p><p>Inst#是样本序号，图中有20个样本。Class是ground truth 标签，p是positive样本（正例），n当然就是negative（负例） score是分类器对于该样本属于正例的可能性的打分。因为一般模型输出的不是0,1的标注，而是小数，相当于置信度。</p><p>然后设置一个从高到低的阈值y，大于等于阈值y的被正式标注为正例，小于阈值y的被我正式标注为负例。</p><p>显然，设置n个阈值，就能得到n种标注结果，评判模型好不好使。</p><p>比如阈值0.9，只有第一个样本被判断为正例，那么我的查准率precision就是100%，但是查全率recall就是10%。阈值0.1，所有样本都被我判断为正例，查全率是100%，查准率就是50%</p><p>最后我能得到若干对precision，recall值(P,R) :  (1, 0.1),… ,(0.5,1),将这若干对画在图上，再连接起来就是这个pr曲线了。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//20160721111312507.png" alt="img"></p><p>在进行比较时，若一个学习器的P-R曲线被另一个学习器的曲线完全“包住”，则可断言后者的性能优于前者。当曲线有相交时，很难断言两者的优劣。真要判别时，“平衡点”（Break-Even Point）是一个不错的度量方法。下图是一个具体的示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220618181148275.png" alt="image-20220618181148275"></p><p>平衡点(Break-Event Point，简称 BEP)，它是” 查准率=查全率”时的取值，例如上图中基于 BEP的比较，可认为学习器 A 优于 B。</p><p>但 BEP 还是过于简化了些，更常用的是 F1 度量：</p><script type="math/tex; mode=display">F1=\frac{2\times P\times R}{P+R}=\frac{2\times TP}{样例总数+TP-TN}</script><p>$F1$ 是基于查准率与查 全率的调和平均 (harinonic mean)定义的:</p><script type="math/tex; mode=display">\frac{1}{F1}=\frac{1}{2}.(\frac{1}{P}+\frac{1}{R})</script><p>在不同的条件下，对查准率和查全率的重视程度有所不同。比如在大数据推送时，为了少打扰用户，更希望能推荐用户感兴趣的广告，此时查准率要比查全率更重要；在追捕逃犯时，为了不漏掉逃犯，此时查全率比查准率更重要。为了表达出对查准率/查全率的不同偏好，定义了$F1 $度量的一般形式</p><script type="math/tex; mode=display">F_\beta=\frac{(1+\beta^2)\times P \times R}{(\beta^2 \times P)+R}</script><p>$ß&gt; 1$ 时查全率有更大影响 ; $ß &lt; 1$ 时查准率有更大影响。</p><p>很多时候我们有多个二分类混淆矩阵，例如进行多次训练/测试，每次得到一个混淆矩阵；或是在多个数据集上进行训练/测试，希望估计算法的”全局” 性能；甚或是执行多分类任务，每两两类别的组合都对应一个混淆矩阵，总之，我们希望在 $n$ 个二分类混淆矩阵上综合考察查准率和查全率。</p><p>一种直接的做法是先在各混淆矩阵上分别计算出查准率和查全率，记为 $(P_1， R_1 ) ， (P_2 ， R_2) ，…… ， (Pn ， Rn)$ ，再计算平均值，这样就得到”宏查准率” ($macro-P$) 、”宏查全率” ($macro-R$) ，以及相应的”宏 $F1$” ($macro-F1$):</p><script type="math/tex; mode=display">macro-P=\frac{1}{n}\sum^n_{i=1}P_i</script><script type="math/tex; mode=display">macro-R=\frac{1}{n}\sum^n_{i=1}R_i</script><script type="math/tex; mode=display">macro-F1=\frac{2\times macro-P \times macro-R}{macro-P+macro-R}</script><p>还可先将各混 淆矩阵的对应元素进行平均，得到 $TP 、FP 、 TN 、FN$ 的平均值，分别记为 $\overline{TP}、 \overline{FP}、 \overline{TN}、 \overline{FN}$，再基于这些平均值计算出”微查准率 “(micro-P) 、 “微查全率” (micro-R)和”微F1” (micro-F1):</p><script type="math/tex; mode=display">micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FP}}</script><script type="math/tex; mode=display">micro-P=\frac{\overline{TP}}{\overline{TP}+\overline{FN}}</script><script type="math/tex; mode=display">micro-F1=\frac{2\times micro-P\times micro-R}{micro-P+micro-R}</script><h4 id="2-3-3-ROC-与-AUC"><a href="#2-3-3-ROC-与-AUC" class="headerlink" title="2.3.3 ROC 与 AUC"></a>2.3.3 ROC 与 AUC</h4><p>ROC：“受试者工作特征”（receiver operating characteristic）曲线，与P-R 曲线类似，只不过取用“真正利率”（TPR ）作为纵轴，“假正例率”（FPR）作为横轴 ，两者分别定义为</p><script type="math/tex; mode=display">TPR=\frac{TP}{TP+FN},FPR=\frac{FP}{TN+FP}</script><p>显示 ROC 曲线的图称为 “ROC 图”，显然，对角线对应于 “随机猜测” 模型，而点 ($0，1)$ 则对应于将所有正例排在所有反例之前的”理想模型”。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220619155415423.png" alt="image-20220619155415423"></p><p>现实任务中测试样例有限 ，无法产生图 a 中的光滑 ROC 曲线，只能绘制出如图 b 所示的近似 ROC 曲线。绘图过程很简单：给定 $m^+ $个正例和$m^-$ 个反例，根据学习器预测结果对样例进行排序，然后把分类阈值设为最大，即把所有样例均预测为反例，此时真正例率和假正例率均为 0， 在坐标$ (0， 0)$ 处标记一个点。然后，将分类阈值依次设为每个样例的预测值，即依次将每个样例划分为正例。设前一个标记点坐标为 $(x， y) $， 当前若为真正例，则对应标记点的坐标为 $(x， y + \frac{1}{m^+})$ ;当前若为假正例，则对应标记点的坐标为 ($( x + \frac{1}{m^-},y)$ ，然后用线段连接相邻点即得。</p><p>​        进行学习器的比较时，与 P-R 图相似， 若一个学习器的 ROC 曲线被另 一个学习器的曲线完全”包住”， 则可断言后者的性能优于前者；若两个学习 器 的 ROC 曲线发生交叉，则难以一般性地断言两者孰优孰劣。此时如果一定要进行比较，则较为合理的判据是比较 ROC 曲线下的面积，即 AUC (Area Under ROC Curve) 。</p><p>​        从定义可知， AUC 可通过对 ROC 曲 线下各部分的面积求和而得,估算为</p><script type="math/tex; mode=display">AUC=\frac{1}{2}\sum^{m-1}_{i=1}(x_{i+1}-x_i).(y_i+y_{i+1})</script><h4 id="2-3-4-代价敏感错误率与代价曲线"><a href="#2-3-4-代价敏感错误率与代价曲线" class="headerlink" title="2.3.4 代价敏感错误率与代价曲线"></a>2.3.4 代价敏感错误率与代价曲线</h4><p>代价敏感错误率代表数据的平均总体代价。</p><p>不同类型的错误所造成的后果不同，为权衡不同类型错误所造成的不同损失，可为错误赋予”非均等代价” (unequa1 cost)。以二分类任务为例，我们可根据任务的领域知识设定一个”代价矩阵” (cost matrix) ，其中 $cost_{ij} $表示将第$ i $类样本预测为第 $j $类样本的代价。一般来说， $cost_{ii} = 0$；若将第 0 类判别为第 1 类所造成的损失更大，则 $cost_{01} &gt; cost_{10}$; 损失程度相差越大， $cost_{01} 与 cost_{10}$ 值的差别越大。</p><div class="table-container"><table><thead><tr><th style="text-align:center">真实</th><th style="text-align:center">预测</th><th style="text-align:center">类别</th><th></th></tr></thead><tbody><tr><td style="text-align:center">类别</td><td style="text-align:center">第0类</td><td style="text-align:center">第1类</td><td></td></tr><tr><td style="text-align:center">第0类</td><td style="text-align:center">0</td><td style="text-align:center">$cost_{01{}}$</td><td></td></tr><tr><td style="text-align:center">第1类</td><td style="text-align:center">$cost_{10}$</td><td style="text-align:center">0</td></tr></tbody></table></div><p>上面的例子中都隐式地假设了均等代价，所定义的错误率是直接计算错误次数。而在非均等代价下，我们所希望的不再是简单地最小化错误次数，而是希望最小化”总体代价” (total cost). 若将表中的第 0 类作为正类、第 1 类作为反类，令 $D^+$ 与 $D^-$分别代表样例集 D 的正例子集和反例子集，则”代价敏感” (cost-sensitive)错误率为</p><script type="math/tex; mode=display">E(f;D;cost)=\frac{1}{m}(\sum_{x_i\in D^+}I(f(x_i)\ne y_i)\times cost_{01}+\sum_{x_i\in D^-}I(f(x_i)\ne y_i)\times cost_{10})</script><p>在非均等代价下， ROC 曲线不能直接反映出学习器的期望总体代价，而”代价曲线” (cost curve) 则可达到该目的.代价曲线图的横轴是取值为 [0,1]的正例概率代价</p><script type="math/tex; mode=display">P(+)cost=\frac{p\times cost_{01}}{p\times cost_{01}+(1-p)\times cost_{10}}</script><p>其中 $p$ 是样例为正例的概率；纵轴是取值为 [0,1] 的归一化代价。</p><script type="math/tex; mode=display">P(+)cost=\frac{FNP\times p\times cost_{01}+FNP\times (1-p)\times cost_{10}}{p\times cost_{01}+(1-p)\times cost_{10}}</script><p>其中 $FPR$ 是假正例率， $FNR = 1 - TPR$ 是假反例率。</p><p>代价曲线的绘制很简单：ROC 曲线上每一点对应了代价平面上的一条线段 ， 设 ROC 曲线上点的坐标为 $(TPR， FPR)$ ，则可相应计算出 $FNR$，然后在代价平面上绘制 一条从 $(0， FPR)$ 到 $(1 ，FNR)$ 的线段，线段下的面积即表示了该条件下的期望总体代价；如此将 ROC 曲线上的每个点转化为代价平面上的一条线段，然后取所有线段的下界，围成的面积即为在所有条件下学习器的期望总体代价。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220619191716330.png" alt="image-20220619191716330"></p><h3 id="2-4-比较检验"><a href="#2-4-比较检验" class="headerlink" title="2.4  比较检验"></a><strong>2.4 </strong> 比较检验</h3><p>——有了实验评估方法和性能度量，就要研究如何应用方法和度量指标去对学习器的性能进行评估比较了</p><p>研究怎么来做“比较”是很有必要的，因为第一，我们要的是<strong>泛化性能</strong>，但是能用的只是测试性能；第二，测试性能和测试集的选择对测试结果有很大影响；第三，有的机器学习算法本身也有随机性，对同一测试集的多次测试结果也可能会不同。</p><p>为了解决这些问题，统计假设检验（hypothesis test）为我们提供了重要的依据。</p><h4 id="2-4-1-假设检验"><a href="#2-4-1-假设检验" class="headerlink" title="2.4.1 假设检验"></a>2.4.1 假设检验</h4><blockquote><p>西瓜书介绍的是假设检验方法，个人认为更好的方式应该是求泛化性能的置信区间，而不是进行假设检验。置信区间不仅可以得到泛化性能的一个区间，同时它也可以进行假设检验。所以，置信区间完全可以替换掉假设检验。</p><p>泛化性能的估计值 u=k/n，它是泛化性能p的一个无偏估计，E(u)=p，u的方差为 u<em>(1-u)/n，基于中心极限定理知道 u 渐进符合正态分布 N[p,u</em>(1-u)/n]。知道了u的抽样分布，u的置信区间就可以计算出来。</p><p><a href="https://zhuanlan.zhihu.com/p/259232881">如何计算置信区间</a></p></blockquote><p>假设检验中的“假设”是对学习器泛化错误率分布的某种猜想或判断，现实任务中学习器的泛化错误率不可知，只能获知其测试错误率，尽管二者未必相同，但肯定相似，因此， 可根据测试错误率估推出泛化错误率的分布。</p><p>然后通过假设的验证结果来对不同的学习器或模型的性能进行判断。比如假设“学习器A和B性能相同”，当该假设被拒绝时，说明学习器A和B具有显著差异，这时候错误率较低的学习器性能较优。</p><p>假设检验的具体逻辑和使用方法是这样的：</p><p>［1］设定一个假设，比如“一个机器学习真正的泛化错误率不大于0.3”</p><p>［2］设定一个置信概率“显著度a”，a的一般取值为0.05、0.1；a代表的意思是当我们的假设成立的概率在（1-a，1］的范围内时，我们认为是成立的。</p><p>［3］计算使假设在置信范围内成立的最大值是多少，比如根据上边［1］中的假设，要使泛化错误率不大于0.3成立，即泛化错误率小于0.3的概率大于（1-a）。要计算这个，我们要算出要使错误率大于0.3的概率之和小于a时的最大泛化错误率是多少。</p><p>［4］比较计算出的满足假设的最大值和我们实际计算出的值，如果我们实际计算出来的错误率已经大于最大可能的错误率了，说明假设不成立。</p><p>［5］在这里的假设中，假设不成立说明我们的学习器错误率要大于0.3啊，这是个很烂的学习器，我们还需要继续调优。</p><p>在实际实验时，我们会多次使用留出法或交叉验证法进行多次训练/测试，那么我们实际上会得到多个测试错误率（这里假设为$k$个）。我们可以通过求这些错误率的平均和方差来将假设检验转换为自由度为$k-1$的$ t $分布。通过查询 $t$ 检验常用临界表可以很方便的计算出假设是否成立。</p><p>书中提到的交叉验证 $t $检验、Friedman检验与Nemenyi后续检验都是基于一样的假设检验流程的稍微变化。其中交叉验证 $t$ 检验是针对两种学习器之间性能的比较，Friedman检验与Nemenyi后续检验是针对多个学习器之间性能的比较。在这里就不一一介绍了。</p><h3 id="2-5-偏差与方差"><a href="#2-5-偏差与方差" class="headerlink" title="2.5 偏差与方差"></a><strong>2.5 </strong>偏差与方差</h3><p>——对学习算法除了通过实验估计其泛化性能，我们还需要理解“为什么”具有这样的性能，“偏差与方差分解”（bias-variance decomposition）是解释学习算法泛化性能的一种重要工具。</p><p>省略具体的算法和公式推导过程，偏差与方差分解是对学习算法的期望泛化错误率的分解，分解结果是下边这个重要的公式</p><p>$E(f;D)=bias^2(x)+var(x)+\varepsilon^2$</p><p>也就是说，泛化误差可分解为偏差、方差与噪声之和。</p><p>其中，偏差度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法的拟合能力；方差度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所带来的影响；噪声则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。</p><p>偏差-方差分解说明，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。</p><p>一般来说，偏差与方差是有冲突的。要使偏差小则需要算法对数据充分拟合，这就有可能会导致过拟合，这样对新样本的适应性差，就会导致方差变高。反之亦然，拟合过低，偏差较大，但是方差会相对较低。</p><blockquote><p>很多学习算法都可控制训练程度，例如决策树可控制层数，神经网络可控制训练轮数，集成学习方法可控制基学习器个数。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220619224405067.png" alt="image-20220619224405067"></p><h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h3><p>泛化误差无法获得，经验误差因为过拟合的存在而不适合作为标准，导致我们需要专门的模型评估方法来测量学习器的效果。</p><p>专门的模型评估方法是通过从数据集中选取一部分数据作为测试集来对训练出的模型进行验证，以测试误差来近似泛化误差实现的。</p><p>测试误差体现在具体的性能度量指标上，我们要根据具体情况选择对应的指标。</p><p>假设检验是我们对学习器性能进行比较的有效方法。</p><p>泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。</p><p>通常来讲，更多的数据胜过更好的算法：对一批数据使用高明的算法，比不上用普通算法但是引入一部分外部数据源的效果要好。</p><p><a href="http://anand.typepad.com/datawocky/2008/03/more-data-usual.html">额外阅读</a></p><h3 id="2-7-习题"><a href="#2-7-习题" class="headerlink" title="2.7 习题"></a>2.7 习题</h3><h4 id="2-7-1"><a href="#2-7-1" class="headerlink" title="2.7.1"></a>2.7.1</h4><p><em>数据集包含 1000 个样本，其中 500 个正例、 500 个反例，将其划分为包含 70% 样本的训练集和 30% 样本的测试集用于留出法评估，试估算共有多少种划分方式。</em></p><p>500个正例和500个反例，根据分层抽样的原则，30%的测试样本共300个，其中必须包含150个正例和150个反例。若不考虑样本其他的分布情况，则选取方式为：从500个正例中随机抽取150个，再从500个反例中随机抽取150个，两个过程相互独立，则共有$(C_{500}^{150})^2$种方式。</p><h4 id="2-7-2"><a href="#2-7-2" class="headerlink" title="2.7.2"></a>2.7.2</h4><p><em>数据集包含 100 个样本，其中正、反例各一半，假定学习算法所产生的模型是将新样本预测为训练样本数较多的类别(训练样本数相同时进行随机猜测)，试给出用 10 折交叉验证法和留一法分别对错误率进行评估所得的结果。</em></p><p>10 折交叉验证法：将样本集划分为10个同分布不相交的子集，将其中9个作为训练集，1个作为测试集，每个划分可得到10次不同的训练和验证。对于题目所述的模型，总是将新样本预测为训练样本较多的类别，但每一次验证时，训练集的正例和反例一样多，将会进行随机猜测。每次都进行随即猜测，其错误率的期望是50%。</p><p>留一法：$k$折交叉验证中$k$等于样本个数的特例。在题目所述的情况下，即将100个样本每次取出1个样本用于测试，99个用于训练。当1个测试样本为正例时，99个训练样本为50个反例和49个正例，新样本将被预测为出现较多的反例，而测试样本的ground truth是正例，必然会预测错误。当测试样本为反例时同理必然会预测错误，此时错误率的期望为100%。</p><h4 id="2-7-3"><a href="#2-7-3" class="headerlink" title="2.7.3"></a>2.7.3</h4><p><em>若学习器 A 的 F1 值比学习器 B 高，试析 A 的 BEP 值是否也比 B 高。</em></p><p>F1：查准率P和查全率R的调和平均；</p><p>BEP：Beak-Even Point，P-R曲线上P = R时二者的取值。</p><p>F1和BEP有概念上的巨大差异，二者没有必然联系。P-R曲线的定义是：学习器将所有样本按“可能是正例”的概率从前向后排序，然后依次将前若干个样本按正例进行预测，所得出的预测结论。注意此时<u>BEP曲线只是衡量了学习器进行“排序”的性能，并不包含最终预测的结果。</u>也就是说，给定了P-R曲线的情况下，根据不同的预测策略，会产生不同的P和R。<u>而F1是一个确定的概念，是在P和R都确定的情况下计算出的二者的调和平均。</u>因此在同一P-R曲线上，F1在不同的位置有不同的取值。</p><p>因此对于题目所述的假设，我们很容易给出反例：对于R-P曲线完全相同的两个学习器，二者的P-R曲线上存在两个不同位置，使得对应的F1值不同。不妨设F1值较大的位置所对应的预测策略为学习器A，另一个为B，此时学习器A的F1值比学习器B高，但二者P-R曲线完全相同，也有相同的BEP值。</p><h4 id="2-7-4"><a href="#2-7-4" class="headerlink" title="2.7.4"></a>2.7.4</h4><p><em>试述真正例率(TPR) 、假正例率 (FPR)与查准率(P) 、查全率(R)之间的联系。</em></p><p>查全率: 真实正例被预测为正例的比例。<br>真正例率: 真实正例被预测为正例的比例。<br>显然查全率与真正例率是相等的。</p><p>查准率:预测为正例的实例中真实正例的比例。<br>假正例率: 真实反例被预测为正例的比例。<br>两者并没有直接的数值关系。</p><h4 id="2-7-5"><a href="#2-7-5" class="headerlink" title="*2.7.5"></a>*2.7.5</h4><p><em>试证明式(2.22).</em></p><p><a href="https://datawhalechina.github.io/pumpkin-book/#/chapter2/chapter2?id=_221">南瓜书中有证明，但同时，根据南瓜书的建议</a></p><blockquote><p>对于初学机器学习的小白，西瓜书第1章和第2章的公式<strong>强烈不建议深究</strong>，简单过一下即可，等你学得有点飘的时候再回来啃都来得及。</p></blockquote><h4 id="2-7-6"><a href="#2-7-6" class="headerlink" title="2.7.6"></a>2.7.6</h4><p><em>试述错误率与 ROC 曲线的联系。</em></p><p>ROC曲线本质上只反映学习器的“排序能力”，而具体的预测策略则取决于在ROC曲线上的哪一点作截断。当确定了一种预测策略时，才会对应一个确定的错误率。因此可以说，ROC曲线上的每一点，对应了学习器一种情况下的错误率。</p><h4 id="2-7-7"><a href="#2-7-7" class="headerlink" title="2.7.7"></a>2.7.7</h4><p><em>试证明任意一条 ROC 曲线都有一条代价曲线与之对应，反之亦然.</em></p><p>代价曲线、ROC曲线、P-R曲线都是为了描述某一学习器的“排序能力”而引入的概念。ROC曲线下方的面积仅能在“错误代价均等”的条件下反应学习器的排序质量，而在错误代价并不均等的情况下，引入代价矩阵后，应当使用代价曲线来反应考虑代价的排序质量。但不论使用哪一种曲线，衡量哪一种面积，一旦学习器给定，其排序质量是一定的，则三种曲线都是确定的。从这一角度来看，任意一条ROC曲线都对应了一个确定的学习器，而该学习器有唯一确定的代价曲线，反之亦然。</p><p>若要严格证明该结论，西瓜书给出了ROC曲线和代价曲线的转换方法：ROC曲线上每一点对应了代价平面上的一条线段，设ROC曲线上点的坐标为(FPR, TPR)，则可计算相应的FNR，然后再代价平面上绘制一条从(0, FPR)到(1, FNR)的线段，如此求出ROC曲线上所有点对应的线段，其下界围成的曲线即代价曲线。同理，在代价曲线上寻找一个连续的分段，将其线段计算出相应的FPR与FNR，再计算出TPR，即得到ROC曲线上的一个点，连接所有如此的到的点即得ROC曲线。</p><h4 id="2-7-8"><a href="#2-7-8" class="headerlink" title="2.7.8"></a>2.7.8</h4><p><em>Min-Max规范化与z-score规范化如下所示。试析二者的优缺点</em></p><p>Min−max规范化方法简单，而且保证规范化后所有元素都是正的，每当有新的元素进来，只有在该元素大于最大值或者小于最小值时才要重新计算全部元素。但是若存在一个极大(小)的元素，会导致其他元素变的非常小(大)。</p><p>z−score标准化对个别极端元素不敏感，且把所有元素分布在0的周围，一般情况下元素越多，0周围区间会分布大部分的元素，每当有新的元素进来，都要重新计算方差与均值。</p><h4 id="2-7-9"><a href="#2-7-9" class="headerlink" title="2.7.9"></a>2.7.9</h4><p><em>试述 χ2 检验过程.</em></p><p><a href="http://guoze.me/2015/09/07/chi-square/">参考链接</a></p><h4 id="2-7-10"><a href="#2-7-10" class="headerlink" title="2.7.10*"></a>2.7.10*</h4><p><em>试述在Friedman 检验中使用式 (2.34) 与 (2.35) 的区别.</em></p><p><a href="https://www.cnblogs.com/daigz1224/p/7163342.html">参考链接</a></p><h1 id="第三章-线性模型"><a href="#第三章-线性模型" class="headerlink" title="第三章 线性模型"></a>第三章 线性模型</h1><h3 id="章节主要内容-1"><a href="#章节主要内容-1" class="headerlink" title="章节主要内容"></a>章节主要内容</h3><p>线性模型形式简单、易于建模，许多功能更为强大的非线性模型可在线性模型的基础上通过引入层级结构或高维映射而得（神经网络就是一个例子，后边学习神经网络时会发现其实神经网络的每个神经元就是一个广义的线性模型）</p><p><a href="https://www.jianshu.com/p/04786709258b">思维导图</a></p><p>基本知识：</p><p><a href="https://www.jianshu.com/p/af0a4f71c05a">最小二乘法</a></p><p><a href="https://www.jianshu.com/p/bcfc11c216a3">极大似然法</a></p><h3 id="3-1-基本形式"><a href="#3-1-基本形式" class="headerlink" title="3.1 基本形式"></a>3.1 基本形式</h3><p>——线性模型的背后逻辑以及变型思路</p><p>线性模型的本质是通过训练数据学习出一个通过样本数据的属性的线性组合来进行预测的函数。</p><p>线性模型具体是什么，简单来说和我们学过的线性函数是一样的，我们学过的线性函数形式一般为：$y = ax + b$，在这里$a，b$代表系数，也就是我们模型要学习的东西，代表的是属性，也就是我们的特征。</p><p>给定由 $d$ 个属性描述的示例$x=(x_1;x_2;……;x_d)$ ， 其中$x_i$是 $x$ 在第 $i$ 个属性上的取值，线性模型(linear model)试图学得一个通过属性的线性组合来进行预测的函数，即$f(x)=w_1x_1+w_2x_2+……+w_dx_d+b$ ，一般用向量形式写成$f(x)=w^Tx+b$ ，其中$w=(w_1;w_2;…;w_d)$ ，$w$ 和 $b$ 学得之后，模型就得以确定。</p><p>举一个例子，在西瓜样例中，</p><script type="math/tex; mode=display">f_{好瓜}(x)=0.2\times x_{色泽}+0.5\times x_{根蒂}+0.3\times x_{敲声}+1</script><p>其中0.2,0.5,0.3还有1 都是属于线性模型通过训练数据学到的系数，而其中的色泽，根蒂，敲声属于一个样本的各个特征，我们在本章中先从回归讲起，然后讨论二分类再讨论多分类问题。 </p><p>二分类：新闻可以分为体育、非体育等两个类别，这就是一个典型的二分类任务，1可以代表正类，0代表负类。</p><p>多分类：新闻可以分为体育、财经、其它等三个类别，这就是一个典型的多分类任务。</p><p><a href="https://zhuanlan.zhihu.com/p/270458779">二分类、多分类、多标签分类的基础、原理、算法和工具</a></p><h3 id="3-2-线性回归"><a href="#3-2-线性回归" class="headerlink" title="3.2 线性回归"></a>3.2 线性回归</h3><p>——<strong>线性模型最基础的算法</strong></p><p>首先我们考虑最简单的问题，也就是只有一个输入属性的情况。</p><p>对离散属性，若属性值间存在”序” (order)关系，可通过连续化将其转化为连续值，例如二值属性”身高”的取值——“高” “矮”可转化为 {1.0,0.0}，三值属性”高度” 的取值”高” “中” “低”可转化为 {1.0, 0.5, 0.0}；若属性值间不存在序关 系，假定有 $k$ 个属性值，则通常转化为 $k$ 维向量，例如属性”瓜类”的取值”西瓜”、”南瓜”、”黄瓜”可转化为(0,0,1),(0,1,0),(1,0,0)。</p><p>线性回归试图学得$f(x_i)=wx_i+b$ ，使得$f(x_i)\approx y_i$ ，</p><p><u><em>如何确定 $ω$ 和 $b$ 呢？显然，关键在于如何衡量$ f(x) $与 $y$ 之间的差别。</em></u></p><p>这时候需要用到均方误差了，也就是我们常说的”欧式距离“，我们可以通过让均方误差最小化来求解需要的$w,b$。即</p><script type="math/tex; mode=display">(w^*,b^*)=arg\min_{(w,b)}\sum^m_{i=1}(f(x_i)-y_i)^2=arg\min_{(w,b)}\sum^m_{i=1}(y_i-wx_i-b)^2</script><p>求解$w$和$b$使所有样本到一条直线上的欧氏距离之和最小，称为线性回归模型的最小二乘”参数估计” (parameter estimation).。我们可将上式对 $ω $和 $b$ 分别求导，得到</p><script type="math/tex; mode=display">\frac{\partial{E_{w,b}}}{\partial w}=2(w\sum^m_{i=1}x_i^2-\sum^m_{i=1}x_i(y_i-b))</script><script type="math/tex; mode=display">\frac{\partial{E_{w,b}}}{\partial b}=2(mb-\sum^m_{i=1}(y_i-wx_i))</script><p>令导数等于0可得到$w$和$b$最优解的闭式解：</p><script type="math/tex; mode=display">w=\frac{\sum^m_{i=1}y_i(x_i-\overline{x})}{\sum^m_{i=1}x_i^2-\frac{1}{m}(\sum^m_{i=1}x_i)^2}</script><script type="math/tex; mode=display">b=\frac{1}{m}\sum^m_{i=1}(y_i-wx_i)</script><p>其中$\overline{x}=\frac{1}{m}\sum^m_{i=1}x_i$为 $x$ 的均值。</p><p><strong>整理一下思路：线性回归要得到式子①，那么①里面的未知数怎么求，利用②式子最小二乘法求，通过对②求偏导等于0，来得到解，即式子③和式子④</strong></p><p>当我们的问题中存在的不止一个特征，我们称之为多元线性回归，形式与上述过程类似。<br>把$w,b$吸入向量模式，表示形式为$\hat{w}=(w;b)$，然后把数据集$D$表示为一个$m*(d+1)$的大小矩阵，前$d$行对应$d$个属性，最后一行元素置为$1$，即</p><script type="math/tex; mode=display">X=\left|    \begin{matrix}    x_{11} & x_{12} & \cdots & x_{1d} & 1\\    x_{21} & x_{22} & \cdots & x_{2d} & 1\\    \vdots & \vdots & \ddots & \vdots & \vdots\\    x_{m1} & x_{m2} & \cdots & x_{md} & 1 \\    \end{matrix}    \right|=\left|    \begin{matrix}    x_1^T &1\\    x_2^T &1\\    \vdots & \vdots\\    x_m^T &1\\    \end{matrix}    \right|</script><p>再把标记也写成向量形式$y=(y_1;y_2;…;y_m)$，则类似于单变量线性回归模型，有</p><script type="math/tex; mode=display">\hat{w}^*=argmin_{\hat{w}}(y-X\hat{w})^T{}(y-X\hat{w})</script><p>令$E_\hat{w}=(y-X\hat{w})^T{}(y-X\hat{w})$，对$\hat{w}$求导得到：</p><script type="math/tex; mode=display">\frac{\partial E_{\hat{w}}}{ \partial\hat w}=2X^T(X\hat w-y)</script><p>令上式为零可得 $\hat w$ 最优解的闭式解。假设当为满秩矩阵或正定矩阵时<script type="math/tex">\hat{w^*}=(X^TX)^{-1}X^Ty</script>，回归模型为<script type="math/tex">f(\hat{x_i})=\hat{x_i}(X^TX)^{-1}X^Ty</script>。<br> <strong>【注】现实任务往往<script type="math/tex">X^TX</script>不满秩，所以会有多个$\hat{w}$，此时结果由算法的学习偏好决定。</strong></p><p>下面说一下线性模型的变种，有时候我们的$y$和$x$之间不是线性变化，比如说y是跟随$x$呈现指数变化，这就导致了一个问题，$y=w<em>x+b$不能再表示他们之间的关系，那么这时候应该通过一个“<em>*联系函数</em></em>”，如上面我们举出来的例子，如果$y$和$wx+b$之间不再是线性而是指数变换，这是我们可以对$y$进行取对数操作</p><script type="math/tex; mode=display">ln y=w^Tx+b</script><p>这个取对的操作就相当于在原先的等式之间又加上了一个函数，这个函数我们就叫作联系函数，而我们把上面的式子叫做对数线性回归。<br> 我们再回味一下为什么这么做呢？因为$y$和$x$之间不再具有某种线性关系，取而代之的是一种指数关系，那我们怎么将这种指数关系表示出来呢？将$y$进行取对操作，这样$lny$又一次和$wx+b$呈现一种线性关系，这实际上是一种空间映射。这就是”对数线性回归” (log-linear regression) ，它实际上是在试图让 $e^{w^Tx+ b} $ 逼近 $y$。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220620162127816.png" alt="image-20220620162127816"></p><p>如上图所示，这里的对数函数起到了<u>将线性回归模型的预测值与真实标记联系起来的作用</u>。</p><p>更一般地，考虑单调可微函数$ g(.) $， 令</p><script type="math/tex; mode=display">y=g^{-1}(w^Tx+b)</script><p>$g(.) $连续且充分光滑，这样得到的模型称为”广义线性模型” (generalized linear model) ，其中函数$g(.)$ 称为”联系函数” (link function).。显然?，对数线性回归是广义线性模型在$g(.) = ln(.) $时的特例.</p><h3 id="3-3-对数几率回归"><a href="#3-3-对数几率回归" class="headerlink" title="3.3 对数几率回归"></a>3.3 对数几率回归</h3><p>——<strong>线性回归函数的变型</strong></p><p>这里的对数几率回归是我们经常见到的一种算法：logistic回归，虽然它叫做回归算法，但实际上它是一种分类算法。</p><p>上一节说的是如何使用线性模型进行回归学习，但是如何利用线性模型进行分类算法呢？这时候就需要我们的联系函数，只要能找到一个函数可以将预测值与真实标签联系起来就可以。</p><p>考虑二分类任务，其输出标记$y$是[0，1]之中的一个，但是线性模型$w*x+b$预测出来是一个实际的值，我们应该把值转换成$0/1$，最理想的是”单位阶跃函数”</p><script type="math/tex; mode=display">y=\left\{\begin{array}{c}    0,z<0\\    0.5,z=0\\    1,z>0\end{array}\right.</script><p>即若预测值 $ z$ 大于零就判为正例，小于零则判为反例，预测值为临界值零则可任意判别，如图所示为单位阶跃函数与对数几率函数。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220620163011834.png" alt="image-20220620163011834"></p><p>从图中可看出单位阶跃函数并不连续，因此不能直接用作广义线性模型中的联系函数$g^-(.)$，于是我们用对数几率函数这种近似单位阶跃函数且单调可微的函数来作为其替代函数。</p><script type="math/tex; mode=display">y=\frac{1}{1+e^{-z}}</script><p>对数几率函数与对数函数是不同的，它是一种”Sigmod”函数，几率是什么意思呢？假设为正例的概率是$y$那么$y/1-y$就表示几率。</p><p>我们要时刻记住这个函数为什么出现在这里，他是为了<strong>将我们的输出转换成别的函数，这个对数几率函数将作为我们的联系函数</strong>。</p><p>我们将上一节讲的线性函数代入到对数几率函数中得到如下所示</p><script type="math/tex; mode=display">y=\frac{1}{1+e^{-(w^Tx+b)}}</script><p>进行变换之后我们将含$w$以及$b$的放在等式的一边，其余的放在另一边，如下所示</p><script type="math/tex; mode=display">ln\frac{y}{1-y}=w^Tx+b</script><p>由此可以看出，我们是在用线性回归模型的预测结果去逼近真实标记的对数几率(即几率的对数)，其中对数几率表示的是$x$做为正例的可能性。</p><p>那么如何求得<script type="math/tex">w,b</script>，这里用了<strong>极大似然法</strong>(推导就不列出来)。最后得到一个关于β的高阶可导连续凸函数</p><script type="math/tex; mode=display">l(β)=\sum_{i=1}^m(-y_iβ^T\hat{x_i}+\ln(1+e^{β^T\hat{x_i}}))</script><p>通过梯度下降法、牛顿法等都可求得这个函数的最优解<script type="math/tex">β^*=argmin_βl(β)</script>。</p><h3 id="3-4线性判别分析"><a href="#3-4线性判别分析" class="headerlink" title="3.4线性判别分析"></a>3.4线性判别分析</h3><p>——<strong>线性模型在多分类场景下的应用</strong></p><p><strong>线性判别分析（LDA）：设法将样例投到一条线上，同类样例尽可能接近，不同样例间尽可能远离，将新样例投到线上通过其位置来分类。</strong>简单点就是正例尽量投在一起，反例投一起，正反例尽可能远离，拿到新样例投上去看更接近哪。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220620171630343.png" alt="image-20220620171630343"></p><p>LDA 的二维示意图”+”、 “ “分别代表正例和反例，椭圆表示数据簇的外轮廓，虚线表示投影， 红色实心园和实心三角形分别表示两类样本投影后的中心点。</p><p>LDA常常用于二分类问题以及多分类的降维处理，我们先讲解关于二分类的问题。由于两类数据过于繁多，导致无法直接对数据属于哪一类进行判断，LDA的基本思想是对于两类数据，想办法将两类数据映射到一条合适的直线上，此时只需要找到直线上一个可以将两类数据分开到两边的点，就可以直观且简便地判断某个样本数据属于哪一类了。</p><p>但并不是所有直线都可以找到这个分界点，如下图所示，紫色与红色分别代表两类数据，左侧将两类数据的一部分映射到一起了显然增加了判断难度，右侧可以找到一个蓝色的点将两类数据区分开来,相对于左侧图像而言，右侧映射到直线的数据，具有类内尽可能聚集，不同类数据尽可能分散的特点，如何利用数学公式去描述这种特点，就是Linear Discriminant Analysis(LDA)的任务了。<br><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc2MjEz,size_16,color_FFFFFF,t_70.png" alt="img"></p><h4 id="二分类线性判别分析"><a href="#二分类线性判别分析" class="headerlink" title="二分类线性判别分析"></a><strong>二分类线性判别分析</strong></h4><p>首先需要理解映射的概念，具体内容在<a href="https://blog.csdn.net/qq_41876213/article/details/107695663">PCA降维的投影</a>部分中讲解过，简单来说，若单位向量$θ $是直线$l $上的单位向量，那么样本数据$x_i $在直线$l$上的投影距离为$\theta^Tx_i$。类别$k$的样本平均向量为</p><script type="math/tex; mode=display">u^k=\frac{1}{m^k}\sum^{m^k}_{i=1}x_i,k\in c</script><p><a href="https://blog.csdn.net/qq_41876213/article/details/108140335">详细推导过程及代码实现见链接</a></p><p>数据集<script type="math/tex">D=\{(x_i,y_i)\}_{i=1}^m,y_i\in\{0,1\}</script>，令<script type="math/tex">X_i、u_i、\sum{i}</script>分别表示<script type="math/tex">i\in\{0,1\}</script>类示例的集合、均值向量、协方差矩阵，$w$表示直线。<br> 线性判别分析有两个目标:①同类样例投影点尽可能接近，即同类投影点协方差<script type="math/tex">（w^T\sum{0w}+w^T\sum{1w}</script>  尽可能小，②异类尽可能远离，即类中心点之间的距离<script type="math/tex">||w^Tu_0-w^Tu_1||^2_2</script>尽可能大。所以同时还要考虑二者，则可以得到最大化目标</p><script type="math/tex; mode=display">J={\frac{||w^Tu_0-w^Tu_1||^2_2}{w^T\sum_0{w}+w^T\sum_{1}{w}}}={\frac{w^T{(u_0-u_1)}(u_0-u_1)^Tw}{w^T(\sum_0+\sum_1)w}})①</script><p> 定义“类内散度矩阵”</p><script type="math/tex; mode=display">S_w=\sum_0+\sum_1=\sum_{x∈X_0}(x-u_0)(x-u_0)^T+\sum_{x∈X_1}(x-u_1)(x-u_1)^T</script><p>定义“类间散度矩阵”</p><script type="math/tex; mode=display">S_b=(u_0-u_1)(u_0-u_1)^T</script><p> 将式子①重写为</p><script type="math/tex; mode=display">J=\frac{w^TS_bw}{w^TS_ww}</script><p>这就是LDA要求的最大化目标，即<script type="math/tex">S_b与S_w</script>的“广义瑞利商”。那么$w$怎么求呢？因为上式分子分母都有$w$二次项所以解$w$长度无关只和方向有关。由拉格朗日乘子式得</p><script type="math/tex; mode=display">S_bw={\lambda}S_ww</script><p>λ是拉格朗日乘子。</p><p>又因为$S_bw$方向衡为$u_0-u_1$，所以令<script type="math/tex">S_bw={\lambda}(u_0-u_1)</script>代入上式最终得$w=S_w^{-1}(u_0-u_1)$。</p><h4 id="多分类线性判别分析"><a href="#多分类线性判别分析" class="headerlink" title="多分类线性判别分析"></a>多分类线性判别分析</h4><p>假设存在$N$个类，且第$i$类示例数为$m_i$；</p><p>定义“全局散度矩阵”</p><script type="math/tex; mode=display">S_t=S_b+S_w=\sum_{i=1}^m(x_i-u)(x_i-u)^T①</script><p><strong>【注】$u$是所有示例的均值向量</strong><br>定义“每个类别的散度矩阵之和”</p><script type="math/tex; mode=display">S_w=\sum_{i=1}^NS_{w_i}②</script><p>**【注】<script type="math/tex">S_{w_i}=\sum_{x∈X_i}(x-u_i)(x-u_i)^T</script><br>由上式①和②得</p><script type="math/tex; mode=display">S_b=S_t-S_w=\sum_{i=1}^Nm_i(u_i-u)(u_i-u)^T</script><p>所以多分类LDA有多种实现方法，使用<script type="math/tex">S_b,S_t,S_w</script>任何两个就可以了。</p><h3 id="3-5-多分类学习"><a href="#3-5-多分类学习" class="headerlink" title="3.5 多分类学习"></a>3.5 多分类学习</h3><p>——<strong>线性模型在多分类场景下的应用</strong></p><p>多分类学习有两个思路。一种是将二分类学习方法推广到多分类，比如上一节讲到的LDA。另一种则是利用二分类的学习器来解决多分类问题。下面讨论第二种。</p><p>多分类学习的基本思路是“拆解法”，即将多分类任务拆为若干个二分类任务求解。</p><p><strong>拆解法步骤：</strong></p><p>1.通过拆分策略对问题进行【<strong>拆分】</strong>；</p><p>2.为拆分出的每个二分类任务【<strong>训练】</strong>一个分类器；</p><p>3.对各个分类器的结果进行【<strong>集成】</strong>，以获得多分类结果。</p><p>最经典的拆分策略有以下三种：</p><p>多分类学习有N个类别$C_1,C_2,…,C_N$，给定数据集$D={(x_1,y_1),…,(x_m,y_m)},y_i\in {C_1,…,C_n}$。</p><p><strong>［1］“一对一”（One vs One，简称OvO）</strong></p><p>将 N 个分类分别两两配对，从而【<strong>拆分】</strong>成 $N(N-1)/2$ 个二分类任务；【<strong>训练</strong>】时为了区分 $C_i$和 $C_j$ 这两个分类，这 $N(N-1)/2$ 个分类器中的一个将 $C_i$ 作为正例， $C_j $作为反例；测试时候将新样本同时提交给所有分类器，将得到 $N(N-1)/2$ 个分类结果，【<strong>集成】</strong>的方法是通过投票在这些结果中选出最终结果。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-437db32129fdc1d411ac560bfa0f8842_1440w.jpg" alt="img"></p><p><strong>［2］“一对其余”（One vs Rest，简称OvR）</strong></p><p>将N个分类中的一个类拿出来作为一个分类器的正例，其余均设置为反例，从而【拆分】成N个分类任务；【训练】得到N个分类结果；【集成】的方法是考虑各被判为正例的分类器的置信度，选择置信度大的类别标记作为分类的结果。（如果只有一个，直接选择）</p><p>我们看到OvO和OvR相比，前者要训练的分类器要多得多，因此存储和测试开销要相对多些。但是在训练时，因为前者每个分类器只使用部分数据，而后者要用全量数据，所以类别多时，OvO的训练开销要更小一些。</p><p>至于预测性能，则取决于数据分布，在多数情况下两者差不多。</p><p><strong>［3］“多对多”（Many vs Many，简称MvM）</strong></p><p>每次将若干个类别作为正类，若干个其它类作为反类。显然，OvO和OvR是MvM的特例。但其正反类的划分必须有特殊的设计，不能随意选取。一种最常用的MvM技术是：“纠错输出码”（Error Correcting Output Codes，简称ECOC）</p><p>ECOC过程主要分两步：</p><ul><li><p>编码：对N个类进行M次划分，产生M个分类器。</p></li><li><p>解码：M个分类器对测试样本进行预测，得到M个预测标记，将其组成编码；这个编码与N个类别各自的编码进行比较，返回其中距离最小的类别作为最终预测的结果。</p></li></ul><p>编码形式又分为二元码和三元码，前者指定“正类”、“反类”，后者又多一个“停用类”。</p><p>以二元ECOC码为例：如下图，首先，将<script type="math/tex">N(N=4)</script>个类通过设计构造成<script type="math/tex">M(M=5)</script>个分类器$(f_1,f_2,f_3,f_4,f_5)$，每个分类器为每个类分配了一个标记结果(-1/+1)，这样一来，每个类$C_i,i\in{1,N}$都获得了一个$M$位的编码，这个编码就是【各类所对应的编码】。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//v2-2c27bcec29d2a98b0a4725775cb8b2c4_1440w.jpg" alt="img"></p><p>当有一个测试例$A$时，先将 A 依照次序放入 $M$ 个分类器中，得到了$ M$ 个分类标记结果$(-1，-1，+1，-1，+1)$；再将这 $M$ 个标记结果编成一个纠错输出码$（-1-1+1-1+1）$；最后去和【各类所对应的编码】进行比较海明距离或欧式距离，距离最短的对应编码对应的分类就是结果。（图中结果为 $C_3$）</p><p>海明距离：每个分类器对样本的分类结果如果和$C_1$类不一致，则计数加1，否则不加，结果为：0+1+1+1+0 = 3</p><p>欧式距离：每个分类器对样本的分类结果减去$C_1$类的分类划分，差值的平方和的开方，结果为：$\sqrt{( 0+4+4+4+0)}$ = $\sqrt12$ ＝<script type="math/tex">2\sqrt3</script></p><p>纠错输出码还有一个功能是为分类器的错误进行修正。比如正确的分类结果是$（-1，-1，+1，-1，+1）$，但如果分类器 $f_2$ 出了错误，得到的结果就是$（-1，+1，+1，-1，+1)$。但通过这一套编码，可以让最终的结果仍为$C_3$ 。</p><p>分类器越多，ECOC编码越长，纠错能力越强，但开销越大；而且，如果分类有限，那么可组合的数目也有限，码长超过一定程度，也没有意义了。</p><p>同等长度的编码，【各类所对应的编码】之间计算出的距离越远，编码的纠错能力越强，但当码长到达一定程度时，无法得出最优解。</p><p><a href="https://blog.csdn.net/lafengxiaoyu/article/details/107886065">ECOC编码详解</a></p><h3 id="3-6-类别不平衡问题"><a href="#3-6-类别不平衡问题" class="headerlink" title="3.6 类别不平衡问题"></a>3.6 类别不平衡问题</h3><p>——<strong>类别不平衡时的调优方案</strong></p><p>类别不平衡（class-imbalance），就是指分类任务中不同类别的训练样例数目差别很大的情况。例如有 998 个反例，但正例只有 2 个，那么学 习方法只需返回一个永远将新样本预测为反例的学习器，就能达到 99.8% 的精度；然而这样的学习器往往没有价值，因为它不能预测出任何正例。</p><p>目前类别不平衡性学习的一个基本策略是“再缩放”（rescaling），现有技术大体上有以下三种做法：</p><p><strong>［1］欠采样（undersampling）</strong></p><p>去除样例过多的类别中的一部分样例，使得正、反例数目接近。代表性算法EasyEnsemble，将反例划分为若干个集合供不同学习器使用，这样对每个学习器来看都进行了欠采样，但在全局来看却不会丢失重要信息。</p><p><strong>［2］过采样（oversampling）</strong></p><p>对样例少的类别增加数据，使得正、反例数目接近。过采样法不能简单地对初始正例样本进行重复采样，否则会招致严重的过拟合。代表性算法SMOTE是通过对训练集里的正例进行插值来产生额外的正例。</p><p><strong>［3］阈值移动（threshold-moving）</strong></p><p>一般我们对二分类法的正负值的判定阈值是基于中间值0.5来判断的，这是基于分类器认为真实正、反例可能性相同的认知下的判断，即分类器决策规则为：</p><p>若$ y / ( 1 - y ) &gt; 1$，则预测为正例②</p><p>然而，当训练集中正、反例不同时，令$m^+$表示正例数，$m^-$表示反例数，则观察几率为：$m^+/m^-$，这时我们应该改变分类器决策规则为：</p><p>若$ y / ( 1 - y ) &gt; m^+/m-$，则预测为正例③</p><p>将③代入②中，我们可以得到新的决策规则：</p><p>若</p><script type="math/tex; mode=display">\frac{ y'} { (1 - y') }= \frac{y} {(1 - y)} \times \frac{m^-}{m^+} > 1</script><p>则预测为正例</p><p>这种在用训练好的分类器进行预测时，将决策规则根据数据分布来进行移动的方法就是阈值移动。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>［1］线性模型是一个形式简单、易于建模的机器学习模型，因为$w$直观表达了各属性在预测中的重要性，因此线性模型有很好的可解释性</p><p>［2］线性回归背后的逻辑是用模型的预测值去逼近真实标记$y$，并通过计算训练样本在向量空间上距离模型线的欧式距离之和的最小值来确定参数$w和b$</p><p>［3］线性回归可写成广义线性模型形式：$g(y) = wx + b$，通过选择不同的联系函数$g(.)$会构成不同的线性回归模型</p><p>［4］在遇到多分类学习任务时，基本的解决思路是“拆解法”，即将多分类任务拆为若干个二分类任务求解</p><p>［5］当不同类别的样例数不同时，会造成类别不平衡问题，解决该问题的基本策略是对数据进行“再缩放”</p><h3 id="3-7-习题"><a href="#3-7-习题" class="headerlink" title="3.7 习题"></a>3.7 习题</h3><p><a href="https://www.jianshu.com/p/49ef509ef874">习题答案</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarDown使用教程</title>
    <link href="/2022/06/16/MarkDown%E6%95%99%E7%A8%8B/"/>
    <url>/2022/06/16/MarkDown%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="MarkDown基础"><a href="#MarkDown基础" class="headerlink" title="MarkDown基础"></a>MarkDown基础</h1><p><a href="https://www.bilibili.com/video/av87982836#reply2366896129">基础篇视频讲解链接</a><br><a href="https://www.bilibili.com/video/av88551739/">画图篇视频讲解链接</a></p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 标题名字（井号的个数代表标题的级数）</span><br></code></pre></td></tr></table></figure><p>快捷键（<strong>⌘ + 数字</strong>）</p><h1 id="一级标题使用1个"><a href="#一级标题使用1个" class="headerlink" title="一级标题使用1个"></a>一级标题使用1个</h1><h2 id="二级标题使用2个"><a href="#二级标题使用2个" class="headerlink" title="二级标题使用2个"></a>二级标题使用2个</h2><h3 id="三级标题使用3个"><a href="#三级标题使用3个" class="headerlink" title="三级标题使用3个"></a>三级标题使用3个</h3><h4 id="四级标题使4用个"><a href="#四级标题使4用个" class="headerlink" title="四级标题使4用个"></a>四级标题使4用个</h4><h5 id="五级标题使用5个"><a href="#五级标题使用5个" class="headerlink" title="五级标题使用5个"></a>五级标题使用5个</h5><h6 id="六级标题使用6个"><a href="#六级标题使用6个" class="headerlink" title="六级标题使用6个"></a>六级标题使用6个</h6><h6 id="最多支持六级标题"><a href="#最多支持六级标题" class="headerlink" title="# 最多支持六级标题"></a># 最多支持六级标题</h6><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><h3 id="删除线（-⇧-）"><a href="#删除线（-⇧-）" class="headerlink" title="删除线（^ + ⇧ + `）"></a>删除线<strong>（^ + ⇧ + `）</strong></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这就是 ~~删除线~~ (使用波浪号)<br></code></pre></td></tr></table></figure><p>这就是 <del>删除线</del> (使用波浪号)</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 <span class="hljs-emphasis">*斜体*</span> 的 <span class="hljs-emphasis">_文本_</span><br></code></pre></td></tr></table></figure><p>这是用来 <em>斜体</em> 的 _文本_</p><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 <span class="hljs-strong">**加粗**</span> 的 <span class="hljs-strong">__文本__</span><br></code></pre></td></tr></table></figure><p>这是用来 <strong>加粗</strong> 的 <strong>文本</strong></p><h3 id="斜体-加粗（加粗⌘-b-斜体⌘-i）"><a href="#斜体-加粗（加粗⌘-b-斜体⌘-i）" class="headerlink" title="斜体+加粗（加粗⌘+b, 斜体⌘+i）"></a>斜体+加粗<strong>（加粗⌘+b, 斜体⌘+i）</strong></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 <span class="hljs-strong">**<span class="hljs-emphasis">*斜体+加粗*</span>**</span> 的 <span class="hljs-strong">__<span class="hljs-emphasis">_文本_</span>__</span><br></code></pre></td></tr></table></figure><p>这是用来 <strong><em>斜体+加粗</em></strong> 的 <strong>_文本_</strong></p><h3 id="下划线（⌘-u）"><a href="#下划线（⌘-u）" class="headerlink" title="下划线（⌘ + u）"></a>下划线<strong>（⌘ + u）</strong></h3><p>下划线是HTML语法</p><p><code>下划线</code> <u>下划线(快捷键<code>command</code>+<code>u</code>，视频中所有的快捷键都是针对Mac系统，其他系统可自行查找)</u></p><h3 id="高亮（需勾选扩展语法）"><a href="#高亮（需勾选扩展语法）" class="headerlink" title="高亮（需勾选扩展语法）"></a>高亮（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">这是用来 ==斜体+加粗== 的文本<br></code></pre></td></tr></table></figure><p>这是用来 ==斜体+加粗== 的文本</p><h3 id="下标（需勾选扩展语法）"><a href="#下标（需勾选扩展语法）" class="headerlink" title="下标（需勾选扩展语法）"></a>下标（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">水 H~2~O <br>双氧水 H~2~O~2~ <br></code></pre></td></tr></table></figure><p>水 H~2~O </p><p>双氧水 H~2~O~2~</p><h3 id="上标（需勾选扩展语法）"><a href="#上标（需勾选扩展语法）" class="headerlink" title="上标（需勾选扩展语法）"></a>上标（需勾选扩展语法）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">面积 m^2^ <br>体积 m^3^<br></code></pre></td></tr></table></figure><p>面积 m^2^<br>体积 m^3^</p><h3 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h3><p> Emoji 支持表情符号，你可以用系统默认的 Emoji 符号（ Windows 用户不一定支持，自己试下~）。 也可以用图片的表情，输入 <code>:</code> 将会出现智能提示。  </p><h4 id="一些表情例子"><a href="#一些表情例子" class="headerlink" title="一些表情例子"></a>一些表情例子</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">:smile: :laughing: :dizzy<span class="hljs-emphasis">_face: :sob: :cold_</span>sweat: :sweat<span class="hljs-emphasis">_smile:  :cry: :triumph: :heart_</span>eyes: :relaxed: :sunglasses: :weary:<br><br>:+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat<span class="hljs-emphasis">_drops: :hankey: :exclamation: :anger:</span><br><span class="hljs-emphasis"></span><br></code></pre></td></tr></table></figure><p>:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile:  :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary: :+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger:</p><p>(  Mac: <code>control</code>+<code>command</code>+<code>space</code>点选)</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><h2 id="快速生成表格（⌘-⌥-T）"><a href="#快速生成表格（⌘-⌥-T）" class="headerlink" title="快速生成表格（⌘ + ⌥ + T）"></a><strong>快速生成表格（⌘ + ⌥ + T）</strong></h2><h2 id="按行选中（⌘-l）"><a href="#按行选中（⌘-l）" class="headerlink" title="按行选中（⌘ + l）"></a><strong>按行选中（⌘ + l）</strong></h2><p>使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">name | price<br>--- | ---<br>fried chicken | 19<br>cola|5<br></code></pre></td></tr></table></figure><blockquote><p>为了使 Markdown 更清晰，<code>|</code> 和 <code>-</code> 两侧需要至少有一个空格（最左侧和最右侧的 <code>|</code> 外就不需要了）。</p></blockquote><div class="table-container"><table><thead><tr><th>name</th><th>price</th></tr></thead><tbody><tr><td>fried chicken</td><td>19</td></tr><tr><td>cola</td><td>5</td></tr></tbody></table></div><p>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 <code>|</code> 来标记单元格边界，在表头下方的分隔线标记中加入 <code>:</code>，即可标记下方单元格内容的对齐方式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">|    name       | price |<br>| :------------ | :---: |<br>| fried chicken | 19    |<br>| cola          |  32   |<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">name</th><th style="text-align:center">price</th></tr></thead><tbody><tr><td style="text-align:left">fried chicken</td><td style="text-align:center">19</td></tr><tr><td style="text-align:left">cola</td><td style="text-align:center">32</td></tr></tbody></table></div><p>使用快捷键<code>command</code>+<code>opt</code>+<code>T</code>更方便(段落→表格→插入表格，即可查看快捷键)</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;“后悔创业”<br></code></pre></td></tr></table></figure><blockquote><p>“后悔创业”</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&gt;也可以在引用中<br>&gt;&gt;使用嵌套的引用<br></code></pre></td></tr></table></figure><blockquote><p>也可以在引用中</p><blockquote><p>使用嵌套的引用</p></blockquote></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表—符号-空格（⌥-⌘-u）"><a href="#无序列表—符号-空格（⌥-⌘-u）" class="headerlink" title="无序列表—符号 空格（⌥ + ⌘ + u）"></a>无序列表—符号 空格<strong>（⌥ + ⌘ + u）</strong></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 可以使用 <span class="hljs-code">`*`</span> 作为标记<br><span class="hljs-bullet">+</span> 也可以使用 <span class="hljs-code">`+`</span><br><span class="hljs-bullet">-</span> 或者 <span class="hljs-code">`-`</span><br></code></pre></td></tr></table></figure><ul><li>可以使用 <code>*</code> 作为标记</li></ul><ul><li>也可以使用 <code>+</code></li></ul><ul><li>或者 <code>-</code></li></ul><h3 id="有序列表—数字-空格（⌥-⌘-o）"><a href="#有序列表—数字-空格（⌥-⌘-o）" class="headerlink" title="有序列表—数字 . 空格（⌥ + ⌘ + o）"></a>有序列表—数字 <code>.</code> 空格<strong>（⌥ + ⌘ + o）</strong></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 有序列表以数字和 <span class="hljs-code">`.`</span> 开始；<br><span class="hljs-bullet">3.</span> 数字的序列并不会影响生成的列表序列；<br><span class="hljs-bullet">4.</span> 但仍然推荐按照自然顺序（1.2.3...）编写。<br></code></pre></td></tr></table></figure><ol><li><p>有序列表以数字和 <code>.</code> 开始；</p></li><li><p>数字的序列并不会影响生成的列表序列；</p></li><li><p>但仍然推荐按照自然顺序（1.2.3…）编写。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">可以使用：数字\. 来取消显示为列表（用反斜杠进行转义）<br></code></pre></td></tr></table></figure></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码块（⌘-⌥-c）"><a href="#代码块（⌘-⌥-c）" class="headerlink" title="代码块（⌘ + ⌥ + c）"></a>代码块<strong>（⌘ + ⌥ + c）</strong></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">```语言名称</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">也可以通过 <span class="hljs-code">``，插入行内代码（`</span> 是 <span class="hljs-code">`Tab`</span> 键上边、数字 <span class="hljs-code">`1`</span> 键左侧的那个按键）：<br><br>例如 <span class="hljs-code">`Markdown`</span><br></code></pre></td></tr></table></figure><p><code>Markdown</code></p><h3 id="公式块（⌘-⌥-b）"><a href="#公式块（⌘-⌥-b）" class="headerlink" title="公式块（⌘ + ⌥ + b）"></a>公式块（⌘ + ⌥ + b）</h3><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><p>代码块中的文本（包括 Markdown 语法）都会显示为原始内容</p><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>可以在一行中使用三个或更多的 <code>*</code>、<code>-</code> 或 <code>_</code> 来添加分隔线（``）：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-section">------</span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-section">___</span></span></span><br></code></pre></td></tr></table></figure><hr><hr><hr><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>跳转至文章开头<strong><em>（⌘ + 向上箭头）\</em></strong><br>跳转至文章结尾<strong><em>（⌘ + 向下箭头）\</em></strong></p><h3 id="外部跳转—超链接"><a href="#外部跳转—超链接" class="headerlink" title="外部跳转—超链接"></a>外部跳转—超链接</h3><p>格式为 <code>[link text](link)</code>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">帮助文档</span>](<span class="hljs-link">https://support.typora.io/Links/#faq</span>)<br></code></pre></td></tr></table></figure><p><a href="https://support.typora.io/Links/#faq">帮助文档</a></p><h3 id="内部跳转—本文件内跳（Typora支持）"><a href="#内部跳转—本文件内跳（Typora支持）" class="headerlink" title="内部跳转—本文件内跳（Typora支持）"></a>内部跳转—本文件内跳（Typora支持）</h3><p>格式为 <code>[link text](#要去的目的地--标题）</code>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">我想跳转</span>](<span class="hljs-link">#饼图（Pie）</span>)<br></code></pre></td></tr></table></figure><blockquote><p>Open Links in Typora</p><p>You can use <code>command+click</code> (macOS), or <code>ctrl+click</code> (Linux/Windows) on links in Typora to jump to target headings, or open them in Typora, or open in related apps.</p></blockquote><p><a href="#饼图（Pie）">我想跳转</a></p><h3 id="自动链接（⌘-k）"><a href="#自动链接（⌘-k）" class="headerlink" title="自动链接（⌘ + k）"></a>自动链接<strong>（⌘ + k）</strong></h3><p>使用 <code>&lt;&gt;</code> 包括的 URL 或邮箱地址会被自动转换为超链接：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml">&lt;https://www.baidu.com&gt;</span><br><br>&lt;123@email.com&gt;<br></code></pre></td></tr></table></figure><p><a href="https://www.baidu.com">https://www.baidu.com</a></p><p><a href="mailto:123@email.com">123@email.com</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">自己起的图片名字</span>](<span class="hljs-link">图片地址或者图片本地存储的路径</span>)<br></code></pre></td></tr></table></figure><h3 id="网上的图片"><a href="#网上的图片" class="headerlink" title="网上的图片"></a>网上的图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">friedChicken</span>](<span class="hljs-link">https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg</span>)<br></code></pre></td></tr></table></figure><p><img src="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&amp;quality=100&amp;size=b4000_4000&amp;sec=1580814517&amp;di=2630beac440e5dab0e44c7286a3b2b61&amp;src=http://imgsrc.baidu.com/forum/w=580/sign=12c730c4ff03738dde4a0c2a831ab073/9497794f9258d1091818e6d6d858ccbf6d814d1b.jpg" alt="炸鸡"></p><h3 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">friedChicken</span>](<span class="hljs-link">friedChicken.jpg</span>)<br>在同一个文件夹里（用相对路径）<br>或者直接拷贝<br></code></pre></td></tr></table></figure><h2 id="利用Markdown画图（需勾选扩展语法）"><a href="#利用Markdown画图（需勾选扩展语法）" class="headerlink" title="利用Markdown画图（需勾选扩展语法）"></a>利用Markdown画图（需勾选扩展语法）</h2><p>markdown画图也是轻量级的，功能并不全。</p><p>Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。Mermaid 作为一个使用 JS 渲染的库，生成的不是一个“图片”，而是一段 HTML 代码。</p><p>（不同的编辑器渲染的可能不一样）</p><h3 id="流程图-graph"><a href="#流程图-graph" class="headerlink" title="流程图(graph)"></a>流程图(graph)</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph 方向描述<br><span class="hljs-code">    图表中的其他语句...</span><br></code></pre></td></tr></table></figure><p>关键字graph表示一个流程图的开始，同时需要指定该图的方向。</p><p>其中“方向描述”为：</p><div class="table-container"><table><thead><tr><th style="text-align:left">用词</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">TB</td><td style="text-align:left">从上到下</td></tr><tr><td style="text-align:left">BT</td><td style="text-align:left">从下到上</td></tr><tr><td style="text-align:left">RL</td><td style="text-align:left">从右到左</td></tr><tr><td style="text-align:left">LR</td><td style="text-align:left">从左到右</td></tr></tbody></table></div><blockquote><p>T = TOP，B = BOTTOM，L = LEFT，R = RIGHT，D = DOWN</p></blockquote><p>最常用的布局方向是TB、LR。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB;<br>  A--&gt;B<br>  B--&gt;C<br>  C--&gt;A<br> <br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB;  A--&gt;B  B--&gt;C  C--&gt;A</code></pre><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph LR;<br>  A--&gt;B<br>  B--&gt;C<br>  C--&gt;A<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph LR;  A--&gt;B  B--&gt;C  C--&gt;A</code></pre><h4 id="流程图常用符号及含义"><a href="#流程图常用符号及含义" class="headerlink" title="流程图常用符号及含义"></a>流程图常用符号及含义</h4><h5 id="节点形状"><a href="#节点形状" class="headerlink" title="节点形状"></a>节点形状</h5><div class="table-container"><table><thead><tr><th style="text-align:left">表述</th><th style="text-align:left">说明</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:left">id[文字]</td><td style="text-align:left">矩形节点</td><td>表示过程，也就是整个流程中的一个环节</td></tr><tr><td style="text-align:left">id(文字)</td><td style="text-align:left">圆角矩形节点</td><td>表示开始和结束</td></tr><tr><td style="text-align:left">id((文字))</td><td style="text-align:left">圆形节点</td><td>表示连接。为避免流程过长或有交叉，可将流程切开。成对</td></tr><tr><td style="text-align:left">id{文字}</td><td style="text-align:left">菱形节点</td><td>表示判断、决策</td></tr><tr><td style="text-align:left">id&gt;文字]</td><td style="text-align:left">右向旗帜状节点</td></tr></tbody></table></div><p><strong>单向箭头线段</strong>：表示流程进行方向</p><blockquote><p>id即为节点的唯一标识，A~F 是当前节点名字，类似于变量名，画图时便于引用</p><p>括号内是节点中要显示的文字，默认节点的名字和显示的文字都为A</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br>  A<br>  B(圆角矩形节点)<br>  C[矩形节点]<br>  D((圆形节点))<br>  E&#123;菱形节点&#125;<br>  F&gt;右向旗帜状节点] <br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB  A  B(圆角矩形节点)  C[矩形节点]  D((圆形节点))  E&#123;菱形节点&#125;  F&gt;右向旗帜状节点]</code></pre><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br><span class="hljs-code">    begin(出门)--&gt; buy[买炸鸡]</span><br><span class="hljs-code">    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;</span><br><span class="hljs-code">    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家)</span><br><span class="hljs-code">    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack</span><br><span class="hljs-code">    </span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB    begin(出门)--&gt; buy[买炸鸡]    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack(回家)    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack    </code></pre><h5 id="连线"><a href="#连线" class="headerlink" title="连线"></a>连线</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br>  A1--&gt;B1<br>  A2---B2<br>  A3--text---B3<br>  A4--text--&gt;B4<br>  A5-.-B5<br>  A6-.-&gt;B6<br>  A7-.text.-B7<br>  A8-.text.-&gt;B8<br>  A9===B9<br>  A10==&gt;B10<br>  A11==text===B11<br>  A12==text==&gt;B12<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB  A1--&gt;B1  A2---B2  A3--text---B3  A4--text--&gt;B4  A5-.-B5  A6-.-&gt;B6  A7-.text.-B7  A8-.text.-&gt;B8  A9===B9  A10==&gt;B10  A11==text===B11  A12==text==&gt;B12</code></pre><pre><code class=" mermaid">graph TB A ---B</code></pre><h5 id="子图表"><a href="#子图表" class="headerlink" title="子图表"></a>子图表</h5><p>使用以下语法添加子图表</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">subgraph 子图表名称<br><span class="hljs-code">    子图表中的描述语句...</span><br><span class="hljs-code">end</span><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">graph TB<br><span class="hljs-code">  subgraph 买炸鸡前</span><br><span class="hljs-code">    begin(出门)--&gt; buy[出门买炸鸡]</span><br><span class="hljs-code">    end</span><br><span class="hljs-code">    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;</span><br><span class="hljs-code">    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack(回家)</span><br><span class="hljs-code">    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">graph TB  subgraph 买炸鸡前    begin(出门)--&gt; buy[出门买炸鸡]    end    buy --&gt; IsRemaining&#123;&quot;还有没有炸鸡？&quot;&#125;    IsRemaining --没有--&gt; sad[&quot;伤心&quot;]--&gt; goBack(回家)    IsRemaining --&gt;|有|happy[买完炸鸡开心]--&gt; goBack</code></pre><h3 id="序列图-sequence-diagram"><a href="#序列图-sequence-diagram" class="headerlink" title="序列图(sequence diagram)"></a>序列图(sequence diagram)</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram <br><span class="hljs-code">[参与者1][消息线][参与者2]:消息体</span><br><span class="hljs-code">    ...</span><br></code></pre></td></tr></table></figure><blockquote><p><code>sequenceDiagram</code> 为每幅时序图的固定开头</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">Title: 买炸鸡</span><br><span class="hljs-code">    救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？</span><br><span class="hljs-code">    炸鸡店小哥--&gt;&gt;救救: 没有，要现炸</span><br><span class="hljs-code"></span><br><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagramTitle: 买炸鸡    救救-&gt;&gt;炸鸡店小哥: 还有炸鸡吗？    炸鸡店小哥--&gt;&gt;救救: 没有，要现炸</code></pre><h4 id="参与者（participant）"><a href="#参与者（participant）" class="headerlink" title="参与者（participant）"></a>参与者（participant）</h4><p>传统时序图概念中参与者有角色和类对象之分，但这里我们不做此区分，用参与者表示一切参与交互的事物，可以是人、类对象、系统等形式。中间竖直的线段从上至下表示时间的流逝。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 参与者 1</span><br><span class="hljs-code">    participant 参与者 2</span><br><span class="hljs-code">    ...</span><br><span class="hljs-code">    participant 简称 as 参与者 3 #该语法可以在接下来的描述中使用简称来代替参与者 3</span><br></code></pre></td></tr></table></figure><blockquote><p><code>participant &lt;参与者名称&gt;</code> 声明参与者，语句次序即为参与者横向排列次序。</p></blockquote><h4 id="消息线"><a href="#消息线" class="headerlink" title="消息线"></a>消息线</h4><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-&gt;</td><td style="text-align:left">无箭头的实线</td></tr><tr><td style="text-align:left">—&gt;</td><td style="text-align:left">无箭头的虚线</td></tr><tr><td style="text-align:left">-&gt;&gt;</td><td style="text-align:left">有箭头的实线（主动发出消息）</td></tr><tr><td style="text-align:left">–-&gt;&gt;</td><td style="text-align:left">有箭头的虚线（响应）</td></tr><tr><td style="text-align:left">-x</td><td style="text-align:left">末端为叉的实线（表示异步）</td></tr><tr><td style="text-align:left">—x</td><td style="text-align:left">末端为叉的虚线（表示异步）</td></tr></tbody></table></div><h4 id="处理中-激活框"><a href="#处理中-激活框" class="headerlink" title="处理中-激活框"></a>处理中-激活框</h4><p>从消息接收方的时间线上标记一小段时间，表示对消息进行处理的时间间隔。</p><p>在消息线末尾增加 <code>+</code> ，则消息接收者进入当前消息的“处理中”状态；<br>在消息线末尾增加 <code>-</code> ，则消息接收者离开当前消息的“处理中”状态。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="hljs-code">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="hljs-code">    99 -x +seller:给我炸！</span><br><span class="hljs-code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -x +seller:给我炸！    seller --&gt;&gt; -99: 您的炸鸡好了！    </code></pre><h4 id="注解（note）"><a href="#注解（note）" class="headerlink" title="注解（note）"></a>注解（note）</h4><p>语法如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Note 位置表述 参与者: 标注文字<br></code></pre></td></tr></table></figure><p>其中位置表述可以为</p><div class="table-container"><table><thead><tr><th style="text-align:left">表述</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">right of</td><td style="text-align:left">右侧</td></tr><tr><td style="text-align:left">left of</td><td style="text-align:left">左侧</td></tr><tr><td style="text-align:left">over</td><td style="text-align:left">在当中，可以横跨多个参与者</td></tr></tbody></table></div><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    Note over 99,seller : 热爱炸鸡</span><br><span class="hljs-code">    Note left of 99 : 女</span><br><span class="hljs-code">    Note right of seller : 男</span><br><span class="hljs-code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="hljs-code">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="hljs-code">    99 -x +seller : 给我炸！</span><br><span class="hljs-code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br><span class="hljs-code"></span><br><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    Note over 99,seller : 热爱炸鸡    Note left of 99 : 女    Note right of seller : 男    99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -x +seller : 给我炸！    seller --&gt;&gt; -99: 您的炸鸡好了！</code></pre><h4 id="循环（loop）"><a href="#循环（loop）" class="headerlink" title="循环（loop）"></a>循环（loop）</h4><p>在条件满足时，重复发出消息序列。（相当于编程语言中的 while 语句。）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">   </span><br><span class="hljs-code">    99 -&gt;&gt; seller: 还有炸鸡吗？</span><br><span class="hljs-code">    seller --&gt;&gt; 99: 没有，要现炸。</span><br><span class="hljs-code">    99 -&gt;&gt; +seller:给我炸！</span><br><span class="hljs-code">    loop 三分钟一次</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 我的炸鸡好了吗？</span><br><span class="hljs-code">        seller --&gt;&gt; 99 : 正在炸</span><br><span class="hljs-code">    end</span><br><span class="hljs-code">    seller --&gt;&gt; -99: 您的炸鸡好了！</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥       99 -&gt;&gt; seller: 还有炸鸡吗？    seller --&gt;&gt; 99: 没有，要现炸。    99 -&gt;&gt; +seller:给我炸！    loop 三分钟一次        99 -&gt;&gt; seller : 我的炸鸡好了吗？        seller --&gt;&gt; 99 : 正在炸    end    seller --&gt;&gt; -99: 您的炸鸡好了！</code></pre><h4 id="选择（alt）"><a href="#选择（alt）" class="headerlink" title="选择（alt）"></a>选择（alt）</h4><p>在多个条件中作出判断，每个条件将对应不同的消息序列。（相当于 if 及 else if 语句。）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram    <br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？</span><br><span class="hljs-code">    seller --&gt;&gt; 99 : 可卖的炸鸡数</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    alt 可卖的炸鸡数 &gt; 3</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 买三只！</span><br><span class="hljs-code">    else 1 &lt; 可卖的炸鸡数 &lt; 3</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 有多少买多少</span><br><span class="hljs-code">    else 可卖的炸鸡数 &lt; 1</span><br><span class="hljs-code">        99 -&gt;&gt; seller : 那我明天再来</span><br><span class="hljs-code">    end</span><br><span class="hljs-code"></span><br><span class="hljs-code">    seller --&gt;&gt; 99 : 欢迎下次光临</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram        participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？    seller --&gt;&gt; 99 : 可卖的炸鸡数        alt 可卖的炸鸡数 &gt; 3        99 -&gt;&gt; seller : 买三只！    else 1 &lt; 可卖的炸鸡数 &lt; 3        99 -&gt;&gt; seller : 有多少买多少    else 可卖的炸鸡数 &lt; 1        99 -&gt;&gt; seller : 那我明天再来    end    seller --&gt;&gt; 99 : 欢迎下次光临</code></pre><h4 id="可选（opt）"><a href="#可选（opt）" class="headerlink" title="可选（opt）"></a>可选（opt）</h4><p>在某条件满足时执行消息序列，否则不执行。相当于单个分支的 if 语句。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br><span class="hljs-code">    participant 99 as 救救</span><br><span class="hljs-code">    participant seller as 炸鸡店小哥</span><br><span class="hljs-code">    99 -&gt;&gt; seller : 买炸鸡</span><br><span class="hljs-code">    opt 全都卖完了</span><br><span class="hljs-code">        seller --&gt;&gt; 99 : 下次再来</span><br><span class="hljs-code">    end</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram    participant 99 as 救救    participant seller as 炸鸡店小哥    99 -&gt;&gt; seller : 买炸鸡    opt 全都卖完了        seller --&gt;&gt; 99 : 下次再来    end</code></pre><h4 id="并行（Par）"><a href="#并行（Par）" class="headerlink" title="并行（Par）"></a>并行（Par）</h4><p>将消息序列分成多个片段，这些片段并行执行。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sequenceDiagram<br>   participant 99 as 救救<br>   participant seller as 炸鸡店小哥<br>   <br><span class="hljs-code">    99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！</span><br><span class="hljs-code"></span><br><span class="hljs-code">    par 并行执行</span><br><span class="hljs-code">        seller -&gt;&gt; seller : 装可乐</span><br><span class="hljs-code">    and</span><br><span class="hljs-code">        seller -&gt;&gt; seller : 炸炸鸡</span><br><span class="hljs-code">    end</span><br><span class="hljs-code"></span><br><span class="hljs-code">    seller --&gt;&gt; 99 : 您的炸鸡好了！</span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">sequenceDiagram   participant 99 as 救救   participant seller as 炸鸡店小哥       99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！    par 并行执行        seller -&gt;&gt; seller : 装可乐    and        seller -&gt;&gt; seller : 炸炸鸡    end    seller --&gt;&gt; 99 : 您的炸鸡好了！</code></pre><h3 id="饼图（Pie）"><a href="#饼图（Pie）" class="headerlink" title="饼图（Pie）"></a>饼图（Pie）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">pie<br><span class="hljs-code">    title Pie Chart</span><br><span class="hljs-code">    &quot;Dogs&quot; : 386</span><br><span class="hljs-code">    &quot;Cats&quot; : 85</span><br><span class="hljs-code">    &quot;Rats&quot; : 150 </span><br></code></pre></td></tr></table></figure><pre><code class=" mermaid">pie    title Pie Chart    &quot;Dogs&quot; : 386    &quot;Cats&quot; : 85    &quot;Rats&quot; : 150     &quot;panda&quot; : 200</code></pre><blockquote><p><a href="http://support.typora.io/Draw-Diagrams-With-Markdown/">Typora支持mermaid的官方链接</a></p></blockquote><h3 id="甘特图（gantt）"><a href="#甘特图（gantt）" class="headerlink" title="甘特图（gantt）"></a>甘特图（gantt）</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"> title 标题<br>dateFormat 日期格式<br>section 部分名<br>任务名:参数一, 参数二, 参数三, 参数四，参数五<br><br> //参数一：crit（是否重要，红框框） 或者 不填<br> //参数二：done（已完成）、active（正在进行） 或者 不填(表示为待完成状态)<br> //参数三：取小名 或者 不填<br> //参数四：任务开始时间<br> //参数五：任务结束时间<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://mermaid-js.github.io/mermaid/#/gantt">官方教程</a></p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gantt</span><br>       <span class="hljs-attribute">dateFormat</span>  YYYY-MM-DD<br>       <span class="hljs-attribute">title</span> Adding GANTT diagram functionality to mermaid<br><br>       <span class="hljs-attribute">section</span> A section<br>       <span class="hljs-attribute">Completed</span> task            :done,    des1, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span>,<span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">08</span><br>       <span class="hljs-attribute">Active</span> task               :active,  des2, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">09</span>, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Future</span> task               :         des3, after des2, <span class="hljs-number">5</span>d<br>       <span class="hljs-attribute">Future</span> task2              :         des4, after des3, <span class="hljs-number">5</span>d<br><br>       <span class="hljs-attribute">section</span> Critical tasks<br>       <span class="hljs-attribute">Completed</span> task in the critical line :crit, done, <span class="hljs-number">2014</span>-<span class="hljs-number">01</span>-<span class="hljs-number">06</span>,<span class="hljs-number">24</span>h<br>       <span class="hljs-attribute">Implement</span> parser and jison          :crit, done, after des1, <span class="hljs-number">2</span>d<br>       <span class="hljs-attribute">Create</span> tests for parser             :crit, active, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Future</span> task in critical line        :crit, <span class="hljs-number">5</span>d<br>       <span class="hljs-attribute">Create</span> tests for renderer           :<span class="hljs-number">2</span>d<br>       <span class="hljs-attribute">Add</span> to mermaid                      :<span class="hljs-number">1</span>d<br><br>       <span class="hljs-attribute">section</span> Documentation<br>       <span class="hljs-attribute">Describe</span> gantt syntax               :active, a1, after des1, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Add</span> gantt diagram to demo page      :after a1  , <span class="hljs-number">20</span>h<br>       <span class="hljs-attribute">Add</span> another diagram to demo page    :doc1, after a1  , <span class="hljs-number">48</span>h<br><br>       <span class="hljs-attribute">section</span> Last section<br>       <span class="hljs-attribute">Describe</span> gantt syntax               :after doc1, <span class="hljs-number">3</span>d<br>       <span class="hljs-attribute">Add</span> gantt diagram to demo page      :<span class="hljs-number">20</span>h<br>       <span class="hljs-attribute">Add</span> another diagram to demo page    :<span class="hljs-number">48</span>h<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">gantt       dateFormat  YYYY-MM-DD       title Adding GANTT diagram functionality to mermaid       section A section       Completed task            :done,    des1, 2014-01-06,2014-01-08       Active task               :active,  des2, 2014-01-09, 3d       Future task               :         des3, after des2, 5d       Future task2              :         des4, after des3, 5d       section Critical tasks       Completed task in the critical line :crit, done, 2014-01-06,24h       Implement parser and jison          :crit, done, after des1, 2d       Create tests for parser             :crit, active, 3d       Future task in critical line        :crit, 5d       Create tests for renderer           :2d       Add to mermaid                      :1d       section Documentation       Describe gantt syntax               :active, a1, after des1, 3d       Add gantt diagram to demo page      :after a1  , 20h       Add another diagram to demo page    :doc1, after a1  , 48h       section Last section       Describe gantt syntax               :after doc1, 3d       Add gantt diagram to demo page      :20h       Add another diagram to demo page    :48h</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Labview</title>
    <link href="/2022/06/16/Labiew/"/>
    <url>/2022/06/16/Labiew/</url>
    
    <content type="html"><![CDATA[<h2 id="如何动态选择曲线可见性"><a href="#如何动态选择曲线可见性" class="headerlink" title="如何动态选择曲线可见性"></a>如何动态选择曲线可见性</h2><p>利用属性节点。首先找到属性节点，活动曲线。</p><p>首先给大家说明一下，LV里面，不管是列表框，还是表格，都会有一个活动单元格，活动曲线之类的。</p><p>你要操作某一个单元格或者曲线，首先你得让这个 单元格或者曲线变为活动单元格，然后才可以操纵活动单元格的属性。</p><p>所以，<u>活动XX的，一定要在前面板中设置，不然你的属性，都是默认是对曲线0或者单元格0做的设置。</u></p><p>下面是用来设置曲线显示的方法，用了一个循环，集体设置属性。这个<u>最好放到一个事件结构里，避免反复轮询控件而降低程序使用效率</u>。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709163115081-20220709163143790-20220709163149596.png" alt="image-20220709163115081"></p><h2 id="错误簇的使用"><a href="#错误簇的使用" class="headerlink" title="错误簇的使用"></a>错误簇的使用</h2><p>错误簇其实就是一个簇，里面放了三个控件，一个布尔，一个代码，一个源。</p><p>按名称解绑簇 ，提取了错误簇里的 status元素。这个元素如果是真，表示有错误发生，可以用来停止while循环。</p><p>当然也有人利用错误簇强制vi执行顺序的，毕竟LabVIEW是数据流的编程。</p><p><strong>LabVIEW自带有一些函数是有错误，仍旧执行，可以通过查看帮助文档看相关介绍</strong></p><h2 id="串口读取问题"><a href="#串口读取问题" class="headerlink" title="串口读取问题"></a>串口读取问题</h2><h4 id="用属性节点得到缓冲字节数"><a href="#用属性节点得到缓冲字节数" class="headerlink" title="用属性节点得到缓冲字节数"></a>用属性节点得到缓冲字节数</h4><p>读取缓冲区字节数这个“<strong>黄金组合</strong>”时，前面要加延时等待，等待仪器响应，等待缓冲区收到数据。如下图画圈地方所示。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709163245461.png" alt="image-20220709163245461"></p><h4 id="保证串口接收数据的完整性"><a href="#保证串口接收数据的完整性" class="headerlink" title="保证串口接收数据的完整性"></a>保证串口接收数据的完整性</h4><p>串口这块逻辑都是一样的，收到数据很容易，重点在于如何保证<strong>接收帧的完整性</strong>。</p><p>1，如何保证接收数据是正常接收的，这个可以在帧尾用校验码，累加求和，或者CRC校验。发送时候把校验码加在数据帧最后，解析时候在计算一下校验，对比下，不对则抛弃。</p><p>2，校验前，还是要获取一个正常排列的数据。比如接收10个字节，那么第一个字节帧头，确实是帧头，而不是错位的。有的就需要拼接了。</p><p>3，有些数据帧比较复杂，比如数据帧长度不一样，那要做的条件判断就很多了，需要一个一个解析。</p><p>建议采用两步读取的方法，第一次读取长度为1的数据。如果超时则忽略；如果不超时，延时一段时间再将所有数据读上来，然后再拼接上第一个字符。此方法最能保证传输完整性，相当于用第一个字符做硬触发。</p><h4 id="用串口助手可以正常发送接收，用LabVIEW编程却不能"><a href="#用串口助手可以正常发送接收，用LabVIEW编程却不能" class="headerlink" title="用串口助手可以正常发送接收，用LabVIEW编程却不能"></a>用串口助手可以<strong>正常发送接收</strong>，用LabVIEW编程却不能</h4><p>串口助手勾选了发送新行，LabVIEW没有对这个<strong>发送新行</strong>处理。</p><p>解决方法有好几种：</p><ol><li><p>最粗暴的，就是自己输入字符串控件里敲个回车。</p></li><li><p>正常点，在程序框图里，输入字符串控件后面，用连接字符串，默默地加上16进制的0D0A。也就是串口助手里的“发送新行”的功能。<strong>勾选“</strong>发送新行”时候，串口助手为我们默认都加了这两个字符。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709163337127.png" alt="image-20220709163337127"></p></li><li><p>不想敲16进制的0D0A字符串也可以，字符串选板默认有一个常量，叫“行结束符常量”，用这个可以和0D0A一样的效果。</p></li></ol><h4 id="高亮调试能收到数据，但是正常运行，就收不到数据"><a href="#高亮调试能收到数据，但是正常运行，就收不到数据" class="headerlink" title="高亮调试能收到数据，但是正常运行，就收不到数据"></a>高亮调试能收到数据，但是正常运行，就收不到数据</h4><p>这个问题最常见的解决方式，就是加<strong>等待延时</strong>，因为高亮执行时，写入缓冲区后，执行到读取缓冲区速度慢，这个时候缓冲区可以读取到数据。而正常执行，延时太短，缓冲区没有数据。可以把上述的100ms改大即可。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709163430732.png" alt="image-20220709163430732"></p><p>当然，还有一个常见原因，就是程序读到数据了，但是一闪而过（以上这个程序只是举例，和真实案例有差距），因为这个程序字符串不能显示历史字符串。而串口助手都可以显示历史数据的。</p><h2 id="局部变量问题"><a href="#局部变量问题" class="headerlink" title="局部变量问题"></a>局部变量问题</h2><h4 id="情境一"><a href="#情境一" class="headerlink" title="情境一"></a>情境一</h4><p>TEST A的vi输出了一个结果Result A，然后给TEST B作为输入，但是TEST B的输入，却总是不对，导致TEST B计算有问题。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709163503057.png" alt="image-20220709163503057"></p><p>以上程序中，看似Result A被TEST A赋值了。其实TEST B这个vi的输入值在整个程序一运行就执行了，数据流已经进入了TEST B的输入那儿。前面的A的vi输出并不会刷新后面B的输入。</p><p>估计有些初学者会说，上图用错误簇数据流限制了B 必须在A后面执行呀。是的，限制了。但是变量却无所谓的数据流限制，程序一运行就给B输入了。所以，一般建议大家规范编程，能用连线的尽量连线，局部变量除了上述问题外，还会存在其他问题。</p><h4 id="情境二"><a href="#情境二" class="headerlink" title="情境二"></a>情境二</h4><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709163625734.png" alt="image-20220709163625734"></p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709163657324.png" alt="image-20220709163657324"></p><p>问题出在使用FOR解析读取的数据这儿。FOR有一个特性，输入是数组时候，可以不连接左上角的<strong>N</strong> 这个端子，FOR会自动按数组的大小执行对应次数。但是，这个VISA读取有时候串口读不到数据，是空的，那么这个FOR执行次数是0。</p><p>如果FOR执行次数是0，那么穿过FOR的连线，<strong>输出就会是默认值（一般是空）</strong>，也就是说，连线的数据，穿过了FOR后，数据无法传递给FOR后面的函数。所以，吃亏还是吃亏在了基础知识，但是很多人估计书本学习不会遇到，毕竟这个靠实际调试才会发现。</p><p>所以，如果要改程序，请用移位寄存器，稍微改一下就可以解决这个问题啦。如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//640-20220617120800417.png" alt="图片"></p><h2 id="Labview状态机的介绍与程序示例"><a href="#Labview状态机的介绍与程序示例" class="headerlink" title="Labview状态机的介绍与程序示例"></a>Labview状态机的介绍与程序示例</h2><h5 id="一、状态机简介"><a href="#一、状态机简介" class="headerlink" title="一、状态机简介"></a>一、状态机简介</h5><p>  状态机是在工程应用中使用最多的设计模型。使用状态机，我们可以很容易的实现程序流程图中的判断、分支。<br>  Labview状态机是由一个While循环、一个条件结构和一个移位寄存器组成的。其中while循环用来保证程序可以连续的运行；条件结构的各种分支中的代码用来描述状态机的各种状态，以及下一状态的选择；移位寄存器用来将之前状态所作出的选择传递到下一次循环的选择端子。</p><h5 id="二、状态机的基本框架"><a href="#二、状态机的基本框架" class="headerlink" title="二、状态机的基本框架"></a>二、状态机的基本框架</h5><p>状态机主要由3部分组成，包括一个while循环，一个条件结构，以及while循环的移位寄存器，其中while循环用于保证程序的持续运行，条件结构用于处理不同状态的执行，移位寄存器用于实现从一个状态跳转到另外一个状态。</p><p>此外一个重要的变量构建是：<strong>枚举常量</strong>表示了两组成对的数据，一组是字符串，一组是数值，两者一一对应，在前面板上，能直观地看到字符串，在程序面板上则简单地表示为数值型数据，整个枚举型数据的值可以是预定义的多个数据中的任何一个值。</p><p>考虑到以后<strong>对状态机修改及维护的方便</strong>， 通常，我们将该枚举常量保存为一个<strong>自定义控件</strong>，将该自定义控件作为枚举常量引入状态机中，当我们需要对状态变量迚行修改的时候，只需要对这个自定义控件迚行一次修改，更新，就能对该状态机中任何位置的状态变量迚行统一的管理了。</p><p>状态机的状态转换：有5种方法</p><p>1、默认状态：无论这个状态执行如何，都无条件转入下一个状态</p><p>2、选择转换 ：利用真假选择函数来实现，在逻辑子VI输出为真时，跳入真分支的状态，迚行State1，为假时，跳入假分支的状态，迚行State2，这个方式在两个可能状态的情况下非常简单和好用，但如果下一个状态的有可能是三个或三个以上的状态呢？ </p><p>后两种方式就是处理这个情况的 </p><p>3、条件结构转换 ：条件结构的多个分支分别对应了不同的下一状态值，根据逻辑判断子VI输出的结果，跳入不同的分支以选择不同的状态，当子VI输出1时，跳入State1, </p><p>4、转换数组转换：条件结构虽然解决了多个状态选择的问题，但从结构上来看不太直观，管理不够方便，我们可以把所有待选择的状态放入数组中，通过逻辑判断子VI输出不同的索引值直接从数组中索引出下一个状态输出到移位寄存器 </p><p><a href="https://blog.csdn.net/ba_wang_mao/article/details/119799081">状态机傻瓜入门教程</a></p><h2 id="元素同址操作结构"><a href="#元素同址操作结构" class="headerlink" title="元素同址操作结构"></a>元素同址操作结构</h2><p>使用元素同址操作结构用于控制LabVIEW编译器更高效地执行常见操作，以及提高内存使用效率。</p><p>许多LabVIEW操作要求LabVIEW对数据复制并保存在内存中，因此降低了执行速度且增加到了内存占用。<br>元素同址操作结构使用边框节点或与结构的边框相连接的节点来进行数据操作。移动或删除边框节点时，LabVIEW自动将结构另一侧的对应节点移动或删除。<br>与传统的LabVIEW编程方法相比，元素同址操作结构在执行常见的LabVIEW操作时效率更高。<br>下列程序框图显示了如何通过使用元素同址操作结构提高VI执行及内存使用的效率：<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709165559615.png" alt="image-20220709165559615"></p><p>在上面的程序框图中，LabVIEW对一个32位无符号整数数组进行索引，将数组的第三个元素递增，再将新元素替换数组中同一位置上的元素。</p><p>如需替换同一数组中的新值，替换数组子集函数要求对数组和数组索引值连线至函数的数组和索引输入端。</p><p>运行VI时，LabVIEW将为数组生成一个副本并将该副本保存在内存中。</p><p>使用元素同址操作结构可避免额外为数组及其索引值生成副本，如下列程序框图所示。<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//image-20220709165917459.png" alt="image-20220709165917459"></p><p>在上面的程序框图中，元素同址操作结构的数组索引/替换元素边框节点对一个32位无符号整数数组进行索引，将数组的第三个元素递增，再将新元素替换数组中原位置上的元素。整个过程与第一个程序框图类似。然而在本例中，LabVIEW无需创建数组值的副本并将其保存于内存。</p><p>元素同址操作结构将数组中每个已索引的元素以结构右侧的节点取代。由于结构要求取代原有的数组元素，而LabVIEW编译器也可识别出需要替换的元素，故LabVIEW无需创建或保存数组或数组元素的副本并保存在内存中。</p><h2 id="降低CPU利用率及卡顿"><a href="#降低CPU利用率及卡顿" class="headerlink" title="降低CPU利用率及卡顿"></a>降低CPU利用率及卡顿</h2><p>从增加程序运行速度和效率的角度：</p><p>1、执行处禁止VI调试可以大大提高VI运行速度，降低内存利用。</p><p>2、根据实际需要选择短数据类型，节约空间，提高效率。注意溢出即可。</p><p>3、循环中加入几十至几百毫秒的延时，避免作无谓的运算。</p><p>4、文件的读写放在循环外。</p><p>5、涉及界面刷新的相关属性节点放在循环外。</p><p>6、局部变量、全局变量的读写放在循环外。</p><p>7、利用等待用户反馈的时间做下一步工作。</p><p>进一步从内存的角度：</p><p>1、把复杂VI分解为数个子VI。</p><p>2、没必要时不要设置子VI的可重入性，避免生成副本增加开销。</p><p>3、避免在子VI中使用子VI前面板控件的属性节点。</p><p>4、打开句柄后要关闭，避免内存泄露。</p><p>5、缓存重用技术：如果可能，用变量代替常量；使用移位寄存器/元素同址操作操作等；子VI连接板实现变量效果实现缓存重用</p><p>6、输入输出参数排布，最左边和最右边，尽量循环外。</p><p>7、优化数据流结构，分支看能不能进行直连实现重用。</p><p>降低CPU占有率:</p><p>CPU的身高是循环处理的太快，通过降低循环速度可以有效的降低CPU占有率。</p><h2 id="多循环引入队列"><a href="#多循环引入队列" class="headerlink" title="多循环引入队列"></a>多循环引入队列</h2><p>我们可以使用“多循环”来解决程序并行运行的问题，那么程序中的两个循环如何进行数据交互和共享呢？最普通的方式是采用全局变量或局域变量，但是当两个循环执行的速率不相等时，必然会造成数据的丢失或重复。如前所述，LabVIEW提供了队列操作函数，允许数据的发送者和接受者之间建立一条缓冲通道，这样就避免了循环不同步带来的影响。这里就用到了我们常说的队列函数，由于队列中的元素是“先进先出”的，因此确保了接收到的数据是有序的。</p><p> 在LabVIEW的队列操作中（入列和出列函数），提供了timeout选项以处理数据缓冲区的溢出或不足。当数据溢出时，入列函数（数据进入队列）将停止发送数据（处于等待状态），直到缓冲区存在数据空间或者达到了timeout设置的时间；而当数据不足时，出列函数（数据流出队列）将停止接收数据（处于等到状态），直到缓冲区进入了新的数据或者达到了timeout设置的时间。</p><p>实例介绍生产者消费者循环的基本特性以及队列操作的特点：</p><p>例程提供了操作方式控件控制生产者和消费者的数据传递速率，包含五种状态：不生产只消费、生成快于消费、生成速率等于消费速率、生成慢于消费、只生产不消费。</p><p>代码包括三个循环，分别是生产者循环，消费者循环，状态循环</p><p><img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//931855-20180121144518756-33953560.png" alt="img"></p><p>将生产者的【枚举+条件结构】改成【枚举+事件结构】，即变成了消费者生产者（事件模式）；<img src="https://cdn.jsdelivr.net/gh/moyudexiaosong/picGo-use//931855-20180121153604193-604180882.png" alt="img"></p><p>实际中应该避免由于<strong>timeout（超时）</strong>设置为-1而导致的无限等待和死循环。</p><h2 id="VI可重入性"><a href="#VI可重入性" class="headerlink" title="VI可重入性"></a>VI可重入性</h2><p>正常的labview是多线程设计语言，而我们在执行VI时的规则是通过VI的命名来分别调用实现的。</p><p>打开VI的Highlight调试工具，可以看出两个Wait.vi实例的调用并不是同时执行的，而是依次按顺序执行的，至于哪一个实例先执行是不确定的。这是由于LabVIEW本身是并行设计的，从理论上而言，两个VI的实例是同步执行的，但是如果两个Wait.vi实例同时执行必定会产生参数赋值紊乱，因为LabVIEW只允许内存中存在一个名称的VI。</p><p>如果在一个顺序结构里要同时进行两个vi的调用，采用的方法是单击ctrl+I,在新点出来的对话框中选择执行框里边的可重入选择Reentrant execution，这样的话再次运行上述实例用时长为并行执行的时间。事实上，LabVIEW的可重入技术相当于在原有VI的基础上产生了一个相同的副本，打开Wait.vi从标题栏可以看出VI的名称为Wait.vi:1(clone)。同理这是由于LabVIEW中不允许内存中的VI存在同名，VI的可重入技术相当于产生了与原VI具有同样功能的新VI并且修改了该VI的命名。 </p><p>在实际应用中，需要根据情况决定是否设置VI的可重入属性，灵活使用。并不是需要将所有的VI都设置为可重入，那将占据大量的内存资源。</p><h2 id="布尔控件机械动作"><a href="#布尔控件机械动作" class="headerlink" title="布尔控件机械动作"></a>布尔控件机械动作</h2><p>总共6种机械动作，m（mouse）表示操作控件时鼠标的动作，v(value)表示控件输出值，RD（Read）表示VI读取控件的时刻。<br>下面分别介绍这六种动作：</p><ul><li><p>1、单击时转换</p><pre><code class="hljs"> 这种机械动作相当于机械开关，单击鼠标后，立即改变状态，并保持改变的状态，改变的时刻是鼠标单击的时刻。再次单击后，恢复原来的状态，与VI是否读取控件无关。</code></pre></li><li><p>2、释放时转换</p><pre><code class="hljs"> 当鼠标释放后，立即改变状态。改变的时刻是鼠标按键释放的时刻。再次单击鼠标并释放鼠标时，恢复原来的状态，与VI是否读取控件无关。</code></pre></li><li><p>3、单击时转换保持到鼠标释放</p><pre><code class="hljs"> 这种机械动作相当于机械按钮。鼠标单击时控件状态立即改变，鼠标按键释放后立即恢复，保持时间取决于单击和释放之间的时间间隔。</code></pre></li><li><p>4、单击时触发</p><pre><code class="hljs"> 单击控件时改变控件值，保留该控件值直到VI读取该控件。此时，即使长按鼠标按钮控件也将返回至其默认值。该动作与断路器相似，适用于停止While循环或令VI在每次用户设置控件时只执行一次。单按钮控件不可选择该动作。</code></pre></li><li><p>5、释放时触发</p><pre><code class="hljs"> 仅当在控件的图片边界内单击一次鼠标后放开鼠标按钮时，控件值改变。VI读取该动作一次，则控件返回至其默认值。该动作与对话框按钮和系统按钮的动作相似。单按钮控件不可选择该动作。</code></pre></li><li>6、保持触发直到鼠标释放<pre><code class="hljs"> 单击控件时改变控件值，保留该控件值直到VI读取该值一次或用户释放鼠标按钮，取决于二者发生的先后。单按钮控件不可选择该动作。</code></pre></li></ul><p>其实最简单的方法就是看懂机械动作的图标。图标非常形象，只要理解了这六种机械动作的含义，很容易选对机械动作的</p>]]></content>
    
    
    
    <tags>
      
      <tag>labview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建Hexo博客</title>
    <link href="/2022/06/16/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/06/16/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo-GitHub-文章发布原理"><a href="#Hexo-GitHub-文章发布原理" class="headerlink" title="Hexo + GitHub 文章发布原理"></a>Hexo + GitHub 文章发布原理</h2><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a56bynskj20k909naaw.jpg" alt="image-20220616123316035"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a530lrdgj20qk0m5gol.jpg" alt="image-20220616112321010"></p><h2 id="step1-配置环境"><a href="#step1-配置环境" class="headerlink" title="step1.配置环境"></a>step1.配置环境</h2><p>Git</p><p>Node.js</p><p>step1.github上建立仓库</p><p><em>仓库名称和注册名一致</em></p><h2 id="step2-生成SSH-Keys"><a href="#step2-生成SSH-Keys" class="headerlink" title="step2.生成SSH Keys"></a><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a53aguqmj212f0j40vl.jpg" alt="image-20220616113621975">step2.生成SSH Keys</h2><p>在任意文件夹下进入Git Bash，输入ssh检测是否已经安装ssh</p><p>输入<code>ssh-keygen -t rsa -C &quot;注册GitHub用的邮箱&quot;</code></p><p>敲四次回车</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a53j6kxhj20tf0axq42.jpg" alt="image-20220616113950805">在以下文件夹中获得刚生成的密钥，pub里是公钥，复制公钥</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a53qm5b8j20so05o74j.jpg" alt="image-20220616114046868">在GitHub中粘贴</p><p>测试ssh是否绑定成功，<code>ssh -T git@github.com</code></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a54si3wlj20l201lt8q.jpg" alt="image-20220616121224727"></p><p>绑定成功</p><h2 id="step3-本地生成博客内容"><a href="#step3-本地生成博客内容" class="headerlink" title="step3.本地生成博客内容"></a>step3.本地生成博客内容</h2><p>新建文件夹Blog</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">npm install -g hexo-cli #安装hexo，Mac用户需要加sudo<br><br>hexo init #已安装过需要初始化<br><br>hexo g #生成<br><br>hexo s #启动服务，打开本地服务器<br></code></pre></td></tr></table></figure><h2 id="step4-发布博客到互联网"><a href="#step4-发布博客到互联网" class="headerlink" title="step4.发布博客到互联网"></a>step4.发布博客到互联网</h2><p>Hexo 博客文件夹目录结构如下：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>_config.yml: 博客的配置文件</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a555r2doj21130793z4.jpg" alt="image-20220616122404265"></p><p>打开博客配置文件，做出如下修改</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3a55jpj2ij20y305oq35.jpg" alt="image-20220616122503416"></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">deploy:<br>  type: git<br>  repository: https://github.com/moyudexiaosong/moyudexiaosong.github.io<br>  branch: main<br></code></pre></td></tr></table></figure><p><code>npm install hexo-deployer-git --save #安装上传工具</code></p><p><code>hexo d</code> #上传互联网</p><p>第一次要输入注册名和密码，密码（令牌）</p><p>上传成功，找到网址</p><p>查看当前git用户名和邮箱</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">git config user.name<br>git config user.email<br></code></pre></td></tr></table></figure><p>修改</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">git config --global user.name &quot;zhangsan(新的用户名)&quot;<br>git config --global user.email &quot;123456@qq.com(新的邮箱)&quot;<br>git config --global user.password &quot;123456(新的密码)&quot;<br><span class="hljs-params">#</span> 这里的zhangsan和邮箱都是你修改之后的用户名和邮箱<br></code></pre></td></tr></table></figure><p>step4.安装主题</p><p><code>npm install --save hexo-theme-fluid</code></p><p>然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。</p><p>将_config.yml下的theme的值landscape修改为fluid，这样才能使用到主题fluids</p><h2 id="step5-hexo基本配置"><a href="#step5-hexo基本配置" class="headerlink" title="step5.hexo基本配置"></a>step5.hexo基本配置</h2><p>在文件根目录下的<code>_config.yml</code>，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考<a href="https://hexo.io/zh-cn/docs/configuration">官方的配置</a>描述。</p><h5 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h5><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>title</code></td><td style="text-align:center">网站标题</td></tr><tr><td style="text-align:center"><code>subtitle</code></td><td style="text-align:center">网站副标题</td></tr><tr><td style="text-align:center"><code>description</code></td><td style="text-align:center">网站描述</td></tr><tr><td style="text-align:center"><code>author</code></td><td style="text-align:center">您的名字</td></tr><tr><td style="text-align:center"><code>language</code></td><td style="text-align:center">网站使用的语言</td></tr><tr><td style="text-align:center"><code>timezone</code></td><td style="text-align:center">网站时区。Hexo 默认使用您电脑的时区。<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</td></tr></tbody></table></div><p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p><h6 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><h5 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h5><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">title: Hello World<br>date: 2013/7/13 20:46:25<br>---<br></code></pre></td></tr></table></figure><p>下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>layout</code></td><td style="text-align:center">布局</td></tr><tr><td style="text-align:center"><code>title</code></td><td style="text-align:center">标题</td></tr><tr><td style="text-align:center"><code>date</code></td><td style="text-align:center">建立日期</td></tr><tr><td style="text-align:center"><code>updated</code></td><td style="text-align:center">更新日期</td></tr><tr><td style="text-align:center"><code>comments</code></td><td style="text-align:center">开启文章的评论功能</td></tr><tr><td style="text-align:center"><code>tags</code></td><td style="text-align:center">标签（不适用于分页）</td></tr><tr><td style="text-align:center"><code>categories</code></td><td style="text-align:center">分类（不适用于分页）</td></tr><tr><td style="text-align:center"><code>permalink</code></td><td style="text-align:center">覆盖文章网址</td></tr></tbody></table></div><h6 id="layout（布局）"><a href="#layout（布局）" class="headerlink" title="layout（布局）"></a>layout（布局）</h6><p>当你每一次使用代码</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo new paper<br></code></pre></td></tr></table></figure><p>它其实默认使用的是<code>post</code>这个布局，也就是在<code>source</code>文件夹下的<code>_post</code>里面。</p><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>，它们分别对应不同的路径，而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><div class="table-container"><table><thead><tr><th style="text-align:center">布局</th><th style="text-align:center">路径</th></tr></thead><tbody><tr><td style="text-align:center"><code>post</code></td><td style="text-align:center"><code>source/_posts</code></td></tr><tr><td style="text-align:center"><code>page</code></td><td style="text-align:center"><code>source</code></td></tr><tr><td style="text-align:center"><code>draft</code></td><td style="text-align:center"><code>source/_drafts</code></td></tr></tbody></table></div><p>而new这个命令其实是：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo new [layout] &lt;title&gt; <span class="hljs-params">#</span>这个layout默认是post<br></code></pre></td></tr></table></figure><h6 id="page"><a href="#page" class="headerlink" title="page"></a>page</h6><p>如果你想另起一页，那么可以使用</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo new page board<br></code></pre></td></tr></table></figure><p>系统会自动给你在source文件夹下创建一个board文件夹，以及board文件夹中的index.md.</p><h6 id="draft"><a href="#draft" class="headerlink" title="draft"></a>draft</h6><p>draft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo new draft newpage<br></code></pre></td></tr></table></figure><p>如果你的草稿文件写的过程中，想要预览一下，那么可以使用</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo server --draft<br></code></pre></td></tr></table></figure><p>在本地端口中开启服务预览。</p><p>如果你的草稿文件写完了，想要发表到post中，</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">hexo publish draft newpage<br></code></pre></td></tr></table></figure><p>就会自动把newpage.md发送到post中。</p><h2 id="Step6-Live2D看板娘"><a href="#Step6-Live2D看板娘" class="headerlink" title="Step6.Live2D看板娘"></a>Step6.Live2D看板娘</h2><p>安装插件</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-helper-live2d</span><br></code></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 是否启动</span><br>  <span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">local</span> <span class="hljs-comment"># 默认</span><br>  <span class="hljs-attr">pluginRootPath:</span> <span class="hljs-string">live2dw/</span>  <span class="hljs-comment"># 插件在站点上的根目录(相对路径)</span><br>  <span class="hljs-attr">pluginJsPath:</span> <span class="hljs-string">lib/</span>  <span class="hljs-comment"># 脚本文件相对与插件根目录路径</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span>  <span class="hljs-comment"># 模型文件相对与插件根目录路径</span><br>  <span class="hljs-attr">tagMode:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br>  <span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 调试, 是否在控制台输出日志</span><br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget</span>  <span class="hljs-comment"># 模型文件</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span> <span class="hljs-comment"># 定位方向 left right top bottom</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">150</span>  <span class="hljs-comment"># 小人宽度</span><br>    <span class="hljs-attr">height:</span> <span class="hljs-number">300</span> <span class="hljs-comment"># 小人高度</span><br>    <span class="hljs-attr">hOffset:</span> <span class="hljs-number">-15</span>  <span class="hljs-comment"># 水平偏移</span><br>    <span class="hljs-attr">vOffset:</span> <span class="hljs-number">-15</span>  <span class="hljs-comment"># 垂直偏移</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 手机端是否显示</span><br>  <span class="hljs-attr">react:</span><br>    <span class="hljs-attr">opacity:</span> <span class="hljs-number">0.7</span>  <span class="hljs-comment"># 模型透明度</span><br></code></pre></td></tr></table></figure><p>选择人物</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs gams">live2d-widget-<span class="hljs-keyword">model</span>-chitose<br>live2d-widget-<span class="hljs-keyword">model</span>-epsilon2_1<br>live2d-widget-<span class="hljs-keyword">model</span>-gf<br>live2d-widget-<span class="hljs-keyword">model</span>-haru/<span class="hljs-number">01</span> (use npm install --save live2d-widget-<span class="hljs-keyword">model</span>-haru)<br>live2d-widget-<span class="hljs-keyword">model</span>-haru/<span class="hljs-number">02</span> (use npm install --save live2d-widget-<span class="hljs-keyword">model</span>-haru)<br>live2d-widget-<span class="hljs-keyword">model</span>-haruto<br>live2d-widget-<span class="hljs-keyword">model</span>-hibiki<br>live2d-widget-<span class="hljs-keyword">model</span>-hijiki<br>live2d-widget-<span class="hljs-keyword">model</span>-izumi<br>live2d-widget-<span class="hljs-keyword">model</span>-koharu<br>live2d-widget-<span class="hljs-keyword">model</span>-miku<br>live2d-widget-<span class="hljs-keyword">model</span>-ni-j<br>live2d-widget-<span class="hljs-keyword">model</span>-nico<br>live2d-widget-<span class="hljs-keyword">model</span>-nietzsche<br>live2d-widget-<span class="hljs-keyword">model</span>-nipsilon<br>live2d-widget-<span class="hljs-keyword">model</span>-nito<br>live2d-widget-<span class="hljs-keyword">model</span>-shizuku<br>live2d-widget-<span class="hljs-keyword">model</span>-tororo<br>live2d-widget-<span class="hljs-keyword">model</span>-tsumiki<br>live2d-widget-<span class="hljs-keyword">model</span>-unitychan<br>live2d-widget-<span class="hljs-keyword">model</span>-wanko<br>live2d-widget-<span class="hljs-keyword">model</span>-z16<br></code></pre></td></tr></table></figure><p>进行安装</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save 上面对应的代码</span><br></code></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">model:</span><br><span class="hljs-symbol">    use:</span> live2d-widget  <span class="hljs-meta">## 选择的模型文件</span><br></code></pre></td></tr></table></figure><h2 id="Step7-设置图床"><a href="#Step7-设置图床" class="headerlink" title="Step7.设置图床"></a>Step7.设置图床</h2><h6 id="创建-GitHub-仓库"><a href="#创建-GitHub-仓库" class="headerlink" title="创建 GitHub 仓库"></a>创建 GitHub 仓库</h6><h6 id="使用-jsDelivr-进行-CDN-加速"><a href="#使用-jsDelivr-进行-CDN-加速" class="headerlink" title="使用 jsDelivr 进行 CDN 加速"></a>使用 jsDelivr 进行 CDN 加速</h6><h6 id="使用PicGo上传图片"><a href="#使用PicGo上传图片" class="headerlink" title="使用PicGo上传图片"></a>使用PicGo上传图片</h6><h6 id="Typora-配置-PicGo-上传"><a href="#Typora-配置-PicGo-上传" class="headerlink" title="Typora 配置 PicGo 上传"></a>Typora 配置 PicGo 上传</h6><ul><li><p>打开 PicGo 软件，找到<code>图床设置</code>中的<code>GitHub图床</code>，填写相关信息。</p></li><li><ul><li><strong>设定仓库名【必填】</strong>：填写<code>你的用户名/你的仓库名</code>，比如我的 yifeng-talking/pictures</li><li><strong>设定分支名【必填】</strong>：填写<code>main</code></li><li><strong>设定Token【必填】</strong>：在Github主页点击自己头像后，依次选择【Settings】-&gt;【Developer settings】-&gt;【Personal access tokens】-&gt;【Generate new token】，填写Note描述（随便），设置过期时间Expiration为永不过期No expiration，设定勾选【repo】，然后点击下方的【Generate token】生成一个Token，这个Token只会显示一次，自行保存，然后复制到 PicGo 中。</li><li>指定存储路径【选填】：填写图片要存储的路径，比如填【images/】，这样就会在仓库下创建一个名为 images 的文件夹，图片将会储存在此文件夹中，这里不填。</li><li><strong>设定自定义域名【选填】</strong>：图片上传后，PicGo 会按照【自定义域名+上传的图片名】的方式生成访问链接，放到剪贴板上，因为我们要使用 jsDeliver 进行加速，因而这里设置为<code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名</code>，比如我设置为<strong><a href="https://cdn.jsdelivr.net/gh/yifeng-talking/pictures">https://cdn.jsdelivr.net/gh/yifeng-talking/pictures</a></strong></li></ul></li><li><ul><li>打开 Typera，点击【文件】 -&gt; 【偏好设置】-&gt; 【图像】，然后进行如下配置，其中 PicGo 路径是你的 PicGo 的安装路径。</li></ul></li></ul><h2 id="Step8-设置内联公式"><a href="#Step8-设置内联公式" class="headerlink" title="Step8.设置内联公式"></a>Step8.设置内联公式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-kramed --save<br></code></pre></td></tr></table></figure><p>更换Hexo的markdown渲染引擎，<a href="https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fsun11%2Fhexo-renderer-kramed">hexo-renderer-kramed</a>引擎是在默认的渲染引擎<a href="https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fhexojs%2Fhexo-renderer-marked">hexo-renderer-marked</a>的基础上修改了一些bug，两者比较接近，也比较轻量级。</p><p>执行上面的命令，先卸载原来的渲染引擎，再安装新的。</p><p>然后，跟换引擎后行间公式可以正确渲染了，但是这样还没有完全解决问题，行内公式的渲染还是有问题，因为<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fsun11%2Fhexo-renderer-kramed">hexo-renderer-kramed</a>引擎也有语义冲突的问题。接下来到博客根目录下，找到node_modules\kramed\lib\rules\inline.js，把第11行的escape变量的值做相应的修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br>  <span class="hljs-attr">escape</span>: <span class="hljs-regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span><br></code></pre></td></tr></table></figure><p>这一步是在原基础上取消了对\,{,}的转义(escape)。<br>同时把第20行的em变量也要做相应的修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*[\s\S])+?)\*(?!\*)/,</span><br>  <span class="hljs-attr">em</span>: <span class="hljs-regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span><br></code></pre></td></tr></table></figure><p>如果已经开启主题，需要先修改配置文件，再在文章的Front-matter里打开math开关，如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">math</span>: <span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029?utm_source=app&amp;app_version=5.5.0">hexo史上最全搭建教程</a></p><p><a href="https://zhuanlan.zhihu.com/p/60578464#:~:text=%E4%BD%BF%E7%94%A8%20Hexo%2BGitHub%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%88%E5%B0%8F%E7%99%BD%E5%90%91%EF%BC%89%201%20%E5%87%86%E5%A4%87%202%20%E8%BF%9E%E6%8E%A5%20Github....,Hexo%20%E5%88%B0%20GitHub%20Pages%206%20%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89....%207%20%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8">使用 Hexo+GitHub 搭建个人免费博客教程</a></p><p><a href="https://baijiahao.baidu.com/s?id=1710047962336524256&amp;wfr=spider&amp;for=pc">高速稳定图床</a></p><p><a href="https://www.jianshu.com/p/7ab21c7f0674">在Hexo中渲染MathJax数学公式</a></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
