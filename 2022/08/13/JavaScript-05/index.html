

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.jpg">
  <link rel="icon" href="/img/icon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="JavaScript 基础 - 第五天一、构造器和操作符 “new”常规的 &amp;#123;...&amp;#125; 语法允许创建一个对象。但是我们经常需要创建很多类似的对象，例如多个用户或菜单项等。 这可以使用构造函数和 &quot;new&quot; 操作符来实现。 构造函数构造函数在技术上是常规函数。不过有两个约定：  它们的命名以大写字母开头。 它们只能由 &quot;new&quot; 操作符来">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 05">
<meta property="og:url" content="http://example.com/2022/08/13/JavaScript-05/index.html">
<meta property="og:site_name" content="摸鱼之家">
<meta property="og:description" content="JavaScript 基础 - 第五天一、构造器和操作符 “new”常规的 &amp;#123;...&amp;#125; 语法允许创建一个对象。但是我们经常需要创建很多类似的对象，例如多个用户或菜单项等。 这可以使用构造函数和 &quot;new&quot; 操作符来实现。 构造函数构造函数在技术上是常规函数。不过有两个约定：  它们的命名以大写字母开头。 它们只能由 &quot;new&quot; 操作符来">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/photo19.jpeg">
<meta property="article:published_time" content="2022-08-12T17:32:46.000Z">
<meta property="article:modified_time" content="2022-08-13T20:29:41.745Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/photo19.jpeg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>JavaScript 05 - 摸鱼之家</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"AwHBUAjSP1GvDVpiBgxfS2Pg-gzGzoHsz","app_key":"kMsGLN3hzkQJuLrmqQBgquFF","server_url":"https://awhbuajs.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>快乐老家</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                主页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                档案馆
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                目录
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/photo19.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JavaScript 05"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-13 01:32" pubdate>
          August 13, 2022 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k words
        
      </span>
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JavaScript 05</h1>
            
              <p class="note note-info">
                
                  
                    Last updated on 3 days ago
                  
                
              </p>
            
            <div class="markdown-body">
              
              <hr>
<h1 id="JavaScript-基础-第五天"><a href="#JavaScript-基础-第五天" class="headerlink" title="JavaScript 基础 - 第五天"></a>JavaScript 基础 - 第五天</h1><h2 id="一、构造器和操作符-“new”"><a href="#一、构造器和操作符-“new”" class="headerlink" title="一、构造器和操作符 “new”"></a>一、构造器和操作符 “new”</h2><p>常规的 <code>&#123;...&#125;</code> 语法允许创建一个对象。但是我们经常需要创建很多类似的对象，例如多个用户或菜单项等。</p>
<p>这可以使用构造函数和 <code>&quot;new&quot;</code> 操作符来实现。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/constructor-new#gou-zao-han-shu">构造函数</a></h3><p>构造函数在技术上是常规函数。不过有两个约定：</p>
<ol>
<li>它们的命名以大写字母开头。</li>
<li>它们只能由 <code>&quot;new&quot;</code> 操作符来执行。</li>
</ol>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Jack&quot;</span>);<br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// Jack</span><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">isAdmin</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<p>当一个函数被使用 <code>new</code> 操作符执行时，它按照以下步骤：</p>
<ol>
<li>一个新的空对象被创建并分配给 <code>this</code>。</li>
<li>函数体执行。通常它会修改 <code>this</code>，为其添加新的属性。</li>
<li>返回 <code>this</code> 的值，即整个新对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-comment">// this = &#123;&#125;;（隐式创建）</span><br><br>  <span class="hljs-comment">// 添加属性到 this</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// return this;（隐式返回）</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以 <code>new User(&quot;Jack&quot;)</code> 的结果是相同的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Jack&quot;</span>,<br>  <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">false</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>现在，如果我们想创建其他用户，我们可以调用 <code>new User(&quot;Ann&quot;)</code>，<code>new User(&quot;Alice&quot;)</code> 等。比每次都使用字面量创建要短得多，而且更易于阅读。</p>
<p>这是构造器的主要目的 —— 实现可重用的对象创建代码。</p>
<p>让我们再强调一遍 —— 从技术上讲，任何函数（除了箭头函数，它没有自己的 <code>this</code>）都可以用作构造器。即可以通过 <code>new</code> 来运行，它会执行上面的算法。</p>
<p><u>“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 <code>new</code> 来运行。</u></p>
<p><strong>new function() { … }</strong></p>
<p>如果我们有许多行用于创建单个复杂对象的代码，我们可以将它们封装在一个立即调用的构造函数中，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个函数并立即使用 new 调用它</span><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isAdmin</span> = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// ……用于用户创建的其他代码</span><br>  <span class="hljs-comment">// 也许是复杂的逻辑和语句</span><br>  <span class="hljs-comment">// 局部变量等</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p><u>这个构造函数不能被再次调用</u>，因为它不保存在任何地方，只是被创建和调用。因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。</p>
<h3 id="构造器的-return"><a href="#构造器的-return" class="headerlink" title="构造器的 return"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/constructor-new#gou-zao-qi-de-return">构造器的 return</a></h3><p>通常，构造器没有 <code>return</code> 语句。它们的任务是将所有必要的东西写入 <code>this</code>，并自动转换为结果。</p>
<p>但是，如果这有一个 <code>return</code> 语句，那么规则就简单了：</p>
<ul>
<li>如果 <code>return</code> 返回的是一个对象，则返回这个对象，而不是 <code>this</code>。</li>
<li>如果 <code>return</code> 返回的是一个原始类型，则忽略。</li>
</ul>
<p>换句话说，带有对象的 <code>return</code> 返回该对象，在所有其他情况下返回 <code>this</code>。</p>
<p>例如，这里 <code>return</code> 通过返回一个对象覆盖 <code>this</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">BigUser</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;<br><br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Godzilla&quot;</span> &#125;;  <span class="hljs-comment">// &lt;-- 返回这个对象</span><br>&#125;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigUser</span>().<span class="hljs-property">name</span> );  <span class="hljs-comment">// Godzilla，得到了那个对象</span><br></code></pre></td></tr></table></figure>
<p>这里有一个 <code>return</code> 为空的例子（或者我们可以在它之后放置一个原始类型，没有什么影响）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SmallUser</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>;<br><br>  <span class="hljs-keyword">return</span>; <span class="hljs-comment">// &lt;-- 返回 this</span><br>&#125;<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmallUser</span>().<span class="hljs-property">name</span> );  <span class="hljs-comment">// John</span><br></code></pre></td></tr></table></figure>
<p>通常构造器没有 <code>return</code> 语句。这里我们主要为了完整性而提及返回对象的特殊行为。</p>
<p><strong>省略括号</strong></p>
<p>顺便说一下，如果没有参数，我们可以省略 <code>new</code> 后的括号：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>; <span class="hljs-comment">// &lt;-- 没有参数</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br></code></pre></td></tr></table></figure>
<p>这里省略括号不被认为是一种“好风格”，但是规范允许使用该语法。</p>
<h3 id="构造器中的方法"><a href="#构造器中的方法" class="headerlink" title="构造器中的方法"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/constructor-new#gou-zao-qi-zhong-de-fang-fa">构造器中的方法</a></h3><p>我们不仅可以将属性添加到构造器中，还可以添加方法。</p>
<p>例如，下面的 <code>new User(name)</code> 用给定的 <code>name</code> 和方法 <code>sayHi</code> 创建了一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;My name is: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> );<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> john = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;John&quot;</span>);<br><br>john.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// My name is: John</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">john = &#123;</span><br><span class="hljs-comment">   name: &quot;John&quot;,</span><br><span class="hljs-comment">   sayHi: function() &#123; ... &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://zh.javascript.info/classes">类</a> 是用于创建复杂对象的一个更高级的语法，我们稍后会讲到。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/constructor-new#zong-jie">总结</a></h3><ul>
<li>构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其命名首字母要大写。</li>
<li>构造函数只能使用 <code>new</code> 来调用。这样的调用意味着在开始时创建了空的 <code>this</code>，并在最后返回填充了值的 <code>this</code>。</li>
</ul>
<p>我们可以使用构造函数来创建多个类似的对象。</p>
<p>JavaScript 为许多内建的对象提供了构造函数：比如日期 <code>Date</code>、集合 <code>Set</code> 以及其他我们计划学习的内容。</p>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/constructor-new#tasks">任务</a></h3><h4 id="两个函数-——-一个对象"><a href="#两个函数-——-一个对象" class="headerlink" title="两个函数 —— 一个对象"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/constructor-new#liang-ge-han-shu-yi-ge-dui-xiang">两个函数 —— 一个对象</a></h4><p>是否可以创建像 <code>new A() == new B()</code> 这样的函数 <code>A</code> 和 <code>B</code>？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123; ... &#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) &#123; ... &#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> A;<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B;<br><br><span class="hljs-title function_">alert</span>( a == b ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>是的，这是可以的。</p>
<p>如果一个函数返回一个对象，那么 <code>new</code> 返回那个对象而不是 <code>this</code>。</p>
<p>所以它们可以，例如，返回相同的外部定义的对象 <code>obj</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj=&#123;&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> obj<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-keyword">return</span> obj<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> A;<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B;<br><br><span class="hljs-title function_">alert</span>( a == b ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<h4 id="创建-new-Calculator"><a href="#创建-new-Calculator" class="headerlink" title="创建 new Calculator"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/constructor-new#chuang-jian-newcalculator">创建 new Calculator</a></h4><p>重要程度: 5</p>
<p>创建一个构造函数 <code>Calculator</code>，它创建的对象中有三个方法：</p>
<ul>
<li><code>read()</code> 使用 <code>prompt</code> 请求两个值并把它们记录在对象的属性中。</li>
<li><code>sum()</code> 返回这些属性的总和。</li>
<li><code>mul()</code> 返回这些属性的乘积。</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> calculator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br>calculator.<span class="hljs-title function_">read</span>();<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Sum=&quot;</span> + calculator.<span class="hljs-title function_">sum</span>() );<br><span class="hljs-title function_">alert</span>( <span class="hljs-string">&quot;Mul=&quot;</span> + calculator.<span class="hljs-title function_">mul</span>() );<br></code></pre></td></tr></table></figure>
<p>解决方案</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Calculator</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>=<span class="hljs-literal">null</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>=<span class="hljs-literal">null</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">read</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>=<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入第一个值&quot;</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>=<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入第二个值&quot;</span>)<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sum</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> -(-<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>-<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>)<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mul</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>*<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> calculator=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>()<br>calculator.<span class="hljs-title function_">read</span>()<br><span class="hljs-title function_">alert</span>(calculator.<span class="hljs-title function_">sum</span>())<br><span class="hljs-title function_">alert</span>(calculator.<span class="hljs-title function_">mul</span>())<br></code></pre></td></tr></table></figure>
<p>构造函数不同于直接创建对象，而是一个函数，所以每一个语句都要用<code>;</code>或换行分割，并且也没有本身属性，所以必须用this来调用属性和方法。</p>
<h4 id="创建-new-Accumulator"><a href="#创建-new-Accumulator" class="headerlink" title="创建 new Accumulator"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/constructor-new#chuang-jian-newaccumulator">创建 new Accumulator</a></h4><p>重要程度: 5</p>
<p>创建一个构造函数 <code>Accumulator(startingValue)</code>。</p>
<p>它创建的对象应该：</p>
<ul>
<li>将“当前 value”存储在属性 <code>value</code> 中。起始值被设置到构造器 <code>startingValue</code> 的参数。</li>
<li><code>read()</code> 方法应该使用 <code>prompt</code> 来读取一个新的数字，并将其添加到 <code>value</code> 中。</li>
</ul>
<p>换句话说，<code>value</code> 属性是所有用户输入值与初始值 <code>startingValue</code> 的总和。</p>
<p>下面是示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> accumulator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Accumulator</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 初始值 1</span><br><br>accumulator.<span class="hljs-title function_">read</span>(); <span class="hljs-comment">// 添加用户输入的 value</span><br>accumulator.<span class="hljs-title function_">read</span>(); <span class="hljs-comment">// 添加用户输入的 value</span><br><br><span class="hljs-title function_">alert</span>(accumulator.<span class="hljs-property">value</span>); <span class="hljs-comment">// 显示这些值的总和</span><br></code></pre></td></tr></table></figure>
<p>答案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Accumulator</span>(<span class="hljs-params">startingValue</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>=startingValue<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">read</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>+=<span class="hljs-built_in">parseInt</span>(<span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;请输入一个值&quot;</span>))<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> acc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Accumulator</span>(<span class="hljs-number">5</span>)<br>acc.<span class="hljs-title function_">read</span>()<br>acc.<span class="hljs-title function_">read</span>()<br><span class="hljs-title function_">alert</span>(acc.<span class="hljs-property">value</span>)<br></code></pre></td></tr></table></figure>
<p>在构造函数里定义方法时，等号左边是为函数命名，而不是声明函数，记得别加括号。</p>
<h2 id="二、可选链-“-”"><a href="#二、可选链-“-”" class="headerlink" title="二、可选链 “?.”"></a>二、可选链 “?.”</h2><p><strong>最近新增的特性</strong></p>
<p>这是一个最近添加到 JavaScript 的特性。 旧式浏览器可能需要 polyfills.</p>
<p>可选链 <code>?.</code> 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误。</p>
<h3 id="“不存在的属性”的问题"><a href="#“不存在的属性”的问题" class="headerlink" title="“不存在的属性”的问题"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/optional-chaining#bu-cun-zai-de-shu-xing-de-wen-ti">“不存在的属性”的问题</a></h3><p>举个例子，假设我们有很多个 <code>user</code> 对象，其中存储了我们的用户数据。</p>
<p>我们大多数用户的地址都存储在 <code>user.address</code> 中，街道地址存储在 <code>user.address.street</code> 中，但有些用户没有提供这些信息。</p>
<p>在这种情况下，当我们尝试获取 <code>user.address.street</code>，而该用户恰好没提供地址信息，我们则会收到一个错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// 一个没有 &quot;address&quot; 属性的 user 对象</span><br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span>); <span class="hljs-comment">// Error!</span><br></code></pre></td></tr></table></figure>
<p>这是预期的结果。JavaScript 的工作原理就是这样的。因为 <code>user.address</code> 为 <code>undefined</code>，尝试读取 <code>user.address.street</code> 会失败，并收到一个错误。</p>
<p>但是在很多实际场景中，我们更希望得到的是 <code>undefined</code>（表示没有 <code>street</code> 属性）而不是一个错误。</p>
<p>还有另一个例子。在 Web 开发中，我们可以使用特殊的方法调用（例如 <code>document.querySelector(&#39;.elem&#39;)</code>）以对象的形式获取一个网页元素，如果没有这种对象，则返回 <code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 如果 document.querySelector(&#x27;.elem&#x27;) 的结果为 null，则这里不存在这个元素</span><br><span class="hljs-keyword">let</span> html = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.elem&#x27;</span>).<span class="hljs-property">innerHTML</span>; <span class="hljs-comment">// 如果 document.querySelector(&#x27;.elem&#x27;) 的结果为 null，则会出现错误</span><br></code></pre></td></tr></table></figure>
<p>同样，如果该元素不存在，则访问 <code>null</code> 的 <code>.innerHTML</code> 属性时会报错。在某些情况下，当元素的缺失是没问题的时候，我们希望避免出现这种错误，而是接受 <code>html = null</code> 作为结果。</p>
<p>我们如何实现这一点呢？</p>
<p>可能最先想到的方案是在访问该值的属性之前，使用 <code>if</code> 或条件运算符 <code>?</code> 对该值进行检查，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;;<br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">address</span> ? user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span> : <span class="hljs-literal">undefined</span>);<br></code></pre></td></tr></table></figure>
<p>这样可以，这里就不会出现错误了……但是不够优雅。就像你所看到的，<code>&quot;user.address&quot;</code> 在代码中出现了两次。</p>
<p>对于嵌套层次更深的属性，代码会变得更丑，因为需要更多的重复。</p>
<p>例如，让我们以相同的方式尝试获取 <code>user.address.street.name</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// user 没有 address 属性</span><br><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-property">address</span> ? user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span> ? user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span>.<span class="hljs-property">name</span> : <span class="hljs-literal">null</span> : <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure>
<p>这样就太扯淡了，并且这可能导致写出来的代码很难让别人理解。</p>
<p>这里有一种更好的实现方式，就是使用 <code>&amp;&amp;</code> 运算符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// user 没有 address 属性</span><br><br><span class="hljs-title function_">alert</span>( user.<span class="hljs-property">address</span> &amp;&amp; user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span> &amp;&amp; user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span>.<span class="hljs-property">name</span> ); <span class="hljs-comment">// undefined（不报错）</span><br></code></pre></td></tr></table></figure>
<p>依次对整条路径上的属性使用与运算进行判断，以确保所有节点是存在的（如果不存在，则停止计算），但仍然不够优雅。</p>
<p>就像你所看到的，在代码中我们仍然重复写了好几遍对象属性名。例如在上面的代码中，<code>user.address</code> 被重复写了三遍。</p>
<p>这就是为什么可选链 <code>?.</code> 被加入到了 JavaScript 这门编程语言中。那就是彻底地解决以上所有问题！</p>
<h3 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/optional-chaining#ke-xuan-lian">可选链</a></h3><p>如果可选链 <code>?.</code> 前面的值为 <code>undefined</code> 或者 <code>null</code>，它会停止运算并返回 <code>undefined</code>。</p>
<p><strong>为了简明起见，在本文接下来的内容中，我们会说如果一个属性既不是 <code>null</code> 也不是 <code>undefined</code>，那么它就“存在”。</strong></p>
<p>换句话说，例如 <code>value?.prop</code>：</p>
<ul>
<li>如果 <code>value</code> 存在，则结果与 <code>value.prop</code> 相同，</li>
<li>否则（当 <code>value</code> 为 <code>undefined/null</code> 时）则返回 <code>undefined</code>。</li>
</ul>
<p>下面这是一种使用 <code>?.</code> 安全地访问 <code>user.address.street</code> 的方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;&#125;; <span class="hljs-comment">// user 没有 address 属性</span><br><br><span class="hljs-title function_">alert</span>( user?.<span class="hljs-property">address</span>?.<span class="hljs-property">street</span> ); <span class="hljs-comment">// undefined（不报错）</span><br></code></pre></td></tr></table></figure>
<p>代码简洁明了，也不用重复写好几遍属性名。?在哪边，哪边就是不确认但需要返回的量。</p>
<p>这里是一个结合 <code>document.querySelector</code> 使用的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> html = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.elem&#x27;</span>)?.<span class="hljs-property">innerHTML</span>; <span class="hljs-comment">// 如果没有符合的元素，则为 undefined</span><br></code></pre></td></tr></table></figure>
<p>即使 对象 <code>user</code> 不存在，使用 <code>user?.address</code> 来读取地址也没问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-literal">null</span>;<br><br><span class="hljs-title function_">alert</span>( user?.<span class="hljs-property">address</span> ); <span class="hljs-comment">// undefined</span><br><span class="hljs-title function_">alert</span>( user?.<span class="hljs-property">address</span>.<span class="hljs-property">street</span> ); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>
<p>请注意：<code>?.</code> 语法使其前面的值成为可选值，但不会对其后面的起作用。</p>
<p><strong>不要过度使用可选链</strong></p>
<p>我们应该只将 <code>?.</code> 使用在一些东西可以不存在的地方。</p>
<p>例如，如果根据我们的代码逻辑，<code>user</code> 对象必须存在，但 <code>address</code> 是可选的，那么我们应该这样写 <code>user.address?.street</code>，而不是这样 <code>user?.address?.street</code>。</p>
<p>那么，如果 <code>user</code> 恰巧为 undefined，我们会看到一个编程错误并修复它。否则，如果我们滥用 <code>?.</code>，会导致代码中的错误在不应该被消除的地方消除了，这会导致调试更加困难。</p>
<p><strong><code>?.</code> 前的变量必须已声明</strong></p>
<p>如果未声明变量 <code>user</code>，那么 <code>user?.anything</code> 会触发一个错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ReferenceError: user is not defined</span><br>user?.<span class="hljs-property">address</span>;<br></code></pre></td></tr></table></figure>
<p><strong>短路效应</strong></p>
<p>正如前面所说的，如果 <code>?.</code> 左边部分不存在，就会立即停止运算（“短路效应”）。</p>
<p>因此，如果在 <code>?.</code> 的右侧有任何进一步的函数调用或操作，它们均不会执行。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>;<br><br>user?.<span class="hljs-title function_">sayHi</span>(x++); <span class="hljs-comment">// 没有 &quot;user&quot;，因此代码执行没有到达 sayHi 调用和 x++</span><br><br><span class="hljs-title function_">alert</span>(x); <span class="hljs-comment">// 0，值没有增加</span><br></code></pre></td></tr></table></figure>
<p><strong>其它变体：?.( )，?.[ ]</strong></p>
<ul>
<li><p><code>?.()</code>用于访问不确定是否存在的方法</p>
<p>在下面这段代码中，有些用户具有 <code>admin</code> 方法，而有些没有：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> userAdmin = &#123;<br>  <span class="hljs-title function_">admin</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;I am admin&quot;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> userGuest = &#123;&#125;;<br><br>userAdmin.<span class="hljs-property">admin</span>?.(); <span class="hljs-comment">// I am admin</span><br><br>userGuest.<span class="hljs-property">admin</span>?.(); <span class="hljs-comment">// 啥都没发生（没有这样的方法）</span><br></code></pre></td></tr></table></figure>
<p>如果 <code>admin</code> 函数存在，那么就调用运行它（对于 <code>userAdmin</code>）。否则（对于 <code>userGuest</code>）运算停止，没有报错。</p>
</li>
<li><p><code>?.[]</code>用于访问不确定是否存在对象的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;firstName&quot;</span>;<br><br><span class="hljs-keyword">let</span> user1 = &#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> user2 = <span class="hljs-literal">null</span>;<br><br><span class="hljs-title function_">alert</span>( user1?.[key] ); <span class="hljs-comment">// John</span><br><span class="hljs-title function_">alert</span>( user2?.[key] ); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>还可以将 <code>?.</code> 跟 <code>delete</code> 一起使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> user?.<span class="hljs-property">name</span>; <span class="hljs-comment">// 如果 user 存在，则删除 user.name</span><br></code></pre></td></tr></table></figure>
<p><strong>我们可以使用 <code>?.</code> 来安全地读取或删除，但不能写入</strong></p>
<p>可选链 <code>?.</code> 不能用在赋值语句的左侧。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> user = <span class="hljs-literal">null</span>;<br><br>user?.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;John&quot;</span>; <span class="hljs-comment">// Error，不起作用</span><br><span class="hljs-comment">// 因为它在计算的是：undefined = &quot;John&quot;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/optional-chaining#zong-jie">总结</a></h3><p>可选链 <code>?.</code> 语法有三种形式：</p>
<ol>
<li><code>obj?.prop</code> —— 如果 <code>obj</code> 存在则返回 <code>obj.prop</code>，否则返回 <code>undefined</code>。</li>
<li><code>obj?.[prop]</code> —— 如果 <code>obj</code> 存在则返回 <code>obj[prop]</code>，否则返回 <code>undefined</code>。</li>
<li><code>obj.method?.()</code> —— 如果 <code>obj.method</code> 存在则调用 <code>obj.method()</code>，否则返回 <code>undefined</code>。</li>
</ol>
<p>正如我们所看到的，这些语法形式用起来都很简单直接。<code>?.</code> 检查左边部分是否为 <code>null/undefined</code>，如果不是则继续运算。</p>
<p><code>?.</code> 链使我们能够安全地访问嵌套属性。</p>
<p>但是，我们应该谨慎地使用 <code>?.</code>，根据我们的代码逻辑，仅在当左侧部分不存在也可接受的情况下使用为宜。以保证在代码中有编程上的错误出现时，也不会对我们隐藏。</p>
<h2 id="三、symbol-类型"><a href="#三、symbol-类型" class="headerlink" title="三、symbol 类型"></a>三、symbol 类型</h2><p>根据规范，只有两种原始类型可以用作对象属性键：</p>
<ul>
<li>字符串类型</li>
<li>symbol 类型</li>
</ul>
<p>否则，如果使用另一种类型，例如数字，它会被自动转换为字符串。所以 <code>obj[1]</code> 与 <code>obj[&quot;1&quot;]</code> 相同，而 <code>obj[true]</code> 与 <code>obj[&quot;true&quot;]</code> 相同。</p>
<p>到目前为止，我们一直只使用字符串。</p>
<p>现在我们来看看 symbol 能给我们带来什么。</p>
<h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/symbol#symbol">symbol</a></h3><p>“symbol” 值表示唯一的标识符。</p>
<p>可以使用 <code>Symbol()</code> 来创建这种类型的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>();<br></code></pre></td></tr></table></figure>
<p>创建时，我们可以给 symbol 一个描述（也称为 symbol 名），这在代码调试时非常有用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// id 是描述为 &quot;id&quot; 的 symbol</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>symbol 保证是唯一的。即使我们创建了许多具有相同描述的 symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。</p>
<p>例如，这里有两个描述相同的 symbol —— 它们不相等：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-keyword">let</span> id2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-title function_">alert</span>(id1 == id2); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<p>如果你熟悉 Ruby 或者其他有 “symbol” 的语言 —— 别被误导。JavaScript 的 symbol 是不同的。</p>
<p>所以，总而言之，symbol 是带有可选描述的“原始唯一值”。让我们看看我们可以在哪里使用它们。</p>
<p><strong>symbol 不会被自动转换为字符串</strong></p>
<p>JavaScript 中的大多数值都支持字符串的隐式转换。例如，我们可以 <code>alert</code> 任何值，都可以生效。symbol 比较特殊，它不会被自动转换。</p>
<p>例如，这个 <code>alert</code> 将会提示出错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-title function_">alert</span>(id); <span class="hljs-comment">// 类型错误：无法将 symbol 值转换为字符串。</span><br></code></pre></td></tr></table></figure>
<p>这是一种防止混乱的“语言保护”，因为字符串和 symbol 有本质上的不同，不应该意外地将它们转换成另一个。</p>
<p>如果我们真的想显示一个 symbol，我们需要在它上面调用 <code>.toString()</code>，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-title function_">alert</span>(id.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// Symbol(id)，现在它有效了</span><br></code></pre></td></tr></table></figure>
<p>或者获取 <code>symbol.description</code> 属性，只显示描述（description）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-title function_">alert</span>(id.<span class="hljs-property">description</span>); <span class="hljs-comment">// id</span><br></code></pre></td></tr></table></figure>
<h3 id="“隐藏”属性"><a href="#“隐藏”属性" class="headerlink" title="“隐藏”属性"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/symbol#yin-cang-shu-xing">“隐藏”属性</a></h3><p>symbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。</p>
<p>例如，如果我们使用的是属于第三方代码的 <code>user</code> 对象，我们想要给它们添加一些标识符。</p>
<p>我们可以给它们使用 symbol 键：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-comment">// 属于另一个代码</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br>user[id] = <span class="hljs-number">1</span>;<span class="hljs-comment">//给user对象添加id属性，并且赋值为1</span><br><br><span class="hljs-title function_">alert</span>( user[id] ); <span class="hljs-comment">// 我们可以使用 symbol 作为键来访问数据</span><br></code></pre></td></tr></table></figure>
<p>使用 <code>Symbol(&quot;id&quot;)</code> 作为键，比起用字符串 <code>&quot;id&quot;</code> 来有什么好处呢？</p>
<p>由于 <code>user</code> 对象属于另一个代码库，所以向它们添加字段是不安全的，因为我们可能会影响代码库中的其他预定义行为。但 symbol 属性不会被意外访问到。第三方代码不会知道新定义的 symbol，因此将 symbol 添加到 <code>user</code> 对象是安全的。</p>
<p>另外，假设另一个脚本希望在 <code>user</code> 中有自己的标识符，以实现自己的目的。</p>
<p>那么，该脚本可以创建自己的 <code>Symbol(&quot;id&quot;)</code>，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br>user[id] = <span class="hljs-string">&quot;Their id value&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>我们的标识符和它们的标识符之间不会有冲突，因为 symbol 总是不同的，即使它们有相同的名字。</p>
<p>……但如果我们处于同样的目的，使用字符串 <code>&quot;id&quot;</code> 而不是用 symbol，那么 <strong>就会</strong> 出现冲突：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span> &#125;;<br><br><span class="hljs-comment">// 我们的脚本使用了 &quot;id&quot; 属性。</span><br>user.<span class="hljs-property">id</span> = <span class="hljs-string">&quot;Our id value&quot;</span>;<br><br><span class="hljs-comment">// ……另一个脚本也想将 &quot;id&quot; 用于它的目的……</span><br><br>user.<span class="hljs-property">id</span> = <span class="hljs-string">&quot;Their id value&quot;</span><br><span class="hljs-comment">// 砰！无意中被另一个脚本重写了 id！</span><br></code></pre></td></tr></table></figure>
<h3 id="对象字面量中的-symbol"><a href="#对象字面量中的-symbol" class="headerlink" title="对象字面量中的 symbol"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/symbol#dui-xiang-zi-mian-liang-zhong-de-symbol">对象字面量中的 symbol</a></h3><p>如果我们要在对象字面量 <code>&#123;...&#125;</code> 中使用 symbol，则需要使用方括号<code>[]</code>把它括起来。</p>
<p>就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  [id]: <span class="hljs-number">123</span> <span class="hljs-comment">// 而不是 &quot;id&quot;：123</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这是因为我们需要变量 <code>id</code> 的值作为键，而不是字符串 “id”。</p>
<h3 id="symbol-在-for…in-中会被跳过"><a href="#symbol-在-for…in-中会被跳过" class="headerlink" title="symbol 在 for…in 中会被跳过"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/symbol#symbol-zai-forin-zhong-hui-bei-tiao-guo">symbol 在 for…in 中会被跳过</a></h3><p>symbol 属性不参与 <code>for..in</code> 循环。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>  [id]: <span class="hljs-number">123</span><br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user) <span class="hljs-title function_">alert</span>(key); <span class="hljs-comment">// name, age（没有 symbol）</span><br><br><span class="hljs-comment">// 使用 symbol 任务直接访问</span><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Direct: &quot;</span> + user[id]); <span class="hljs-comment">// Direct: 123</span><br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">Object.keys(user)</a> 也会忽略它们。这是一般“隐藏符号属性”原则的一部分。如果另一个脚本或库遍历我们的对象，它不会意外地访问到符号属性。</p>
<p>相反，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 会同时复制字符串和 symbol 属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><span class="hljs-keyword">let</span> user = &#123;<br>  [id]: <span class="hljs-number">123</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, user);<br><br><span class="hljs-title function_">alert</span>( clone[id] ); <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure>
<p>这里并不矛盾，就是这样设计的。这里的想法是当我们克隆或者合并一个 object 时，通常希望 <strong>所有</strong> 属性被复制（包括像 <code>id</code> 这样的 symbol）。</p>
<h3 id="全局-symbol"><a href="#全局-symbol" class="headerlink" title="全局 symbol"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/symbol#quan-ju-symbol">全局 symbol</a></h3><p>有时我们想要名字相同的 symbol 具有相同的实体。例如，应用程序的不同部分想要访问的 symbol <code>&quot;id&quot;</code> 指的是完全相同的属性。</p>
<p>为了实现这一点，这里有一个 <strong>全局 symbol 注册表</strong>。我们可以在其中创建 symbol 并在稍后访问它们，它可以确保每次访问相同名字的 symbol 时，返回的都是相同的 symbol。</p>
<p>要从注册表中读取（不存在则创建）symbol，请使用 <code>Symbol.for(key)</code>。</p>
<p>该调用会检查全局注册表，如果有一个描述为 <code>key</code> 的 symbol，则返回该 symbol，否则将创建一个新 symbol（<code>Symbol(key)</code>），并通过给定的 <code>key</code> 将其存储在注册表中。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 从全局注册表中读取</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>); <span class="hljs-comment">// 如果该 symbol 不存在，则创建它</span><br><br><span class="hljs-comment">// 再次读取（可能是在代码中的另一个位置）</span><br><span class="hljs-keyword">let</span> idAgain = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-comment">// 相同的 symbol</span><br><span class="hljs-title function_">alert</span>( id === idAgain ); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>注册表内的 symbol 被称为 <strong>全局 symbol</strong>。如果我们想要一个应用程序范围内的 symbol，可以在代码中随处访问 —— 这就是它们的用途。</p>
<p><strong>这听起来像 Ruby</strong></p>
<p>在一些编程语言中，例如 Ruby，每个名字都有一个 symbol。</p>
<p>正如我们所看到的，在 JavaScript 中，全局 symbol 也是这样的。</p>
<h3 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/symbol#symbolkeyfor">Symbol.keyFor</a></h3><p>我们已经看到，对于全局 symbol，<code>Symbol.for(key)</code> 按名字返回一个 symbol。相反，通过全局 symbol 返回一个名字，我们可以使用 <code>Symbol.keyFor(sym)</code>：</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 通过 name 获取 symbol</span><br><span class="hljs-keyword">let</span> sym = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-keyword">let</span> sym2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>);<br><br><span class="hljs-comment">// 通过 symbol 获取 name</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(sym) ); <span class="hljs-comment">// name</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(sym2) ); <span class="hljs-comment">// id</span><br></code></pre></td></tr></table></figure>
<p><code>Symbol.keyFor</code> 内部使用全局 symbol 注册表来查找 symbol 的键。所以它不适用于非全局 symbol。如果 symbol 不是全局的，它将无法找到它并返回 <code>undefined</code>。</p>
<p>也就是说，所有 symbol 都具有 <code>description</code> 属性。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> globalSymbol = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-keyword">let</span> localSymbol = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(globalSymbol) ); <span class="hljs-comment">// name，全局 symbol</span><br><span class="hljs-title function_">alert</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(localSymbol) ); <span class="hljs-comment">// undefined，非全局</span><br><br><span class="hljs-title function_">alert</span>( localSymbol.<span class="hljs-property">description</span> ); <span class="hljs-comment">// name</span><br></code></pre></td></tr></table></figure>
<h2 id="系统-symbol"><a href="#系统-symbol" class="headerlink" title="系统 symbol"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/symbol#xi-tong-symbol">系统 symbol</a></h2><p>JavaScript 内部有很多“系统” symbol，我们可以使用它们来微调对象的各个方面。</p>
<p>它们都被列在了 <a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/#sec-well-known-symbols">众所周知的 symbol</a> 表的规范中：</p>
<ul>
<li><code>Symbol.hasInstance</code></li>
<li><code>Symbol.isConcatSpreadable</code></li>
<li><code>Symbol.iterator</code></li>
<li><code>Symbol.toPrimitive</code></li>
<li>……</li>
</ul>
<p>例如，<code>Symbol.toPrimitive</code> 允许我们将对象描述为原始值转换。我们很快就会看到它的使用。</p>
<p>当我们研究相应的语言特征时，我们对其他的 symbol 也会慢慢熟悉起来。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/symbol#zong-jie">总结</a></h3><p><code>symbol</code> 是唯一标识符的基本类型</p>
<p>symbol 是使用带有可选描述（name）的 <code>Symbol()</code> 调用创建的。</p>
<p>symbol 总是不同的值，即使它们有相同的名字。如果我们希望同名的 symbol 相等，那么我们应该使用全局注册表：<code>Symbol.for(key)</code> 返回（如果需要的话则创建）一个以 <code>key</code> 作为名字的全局 symbol。使用 <code>Symbol.for</code> 多次调用 <code>key</code> 相同的 symbol 时，返回的就是同一个 symbol。</p>
<p>symbol 有两个主要的使用场景：</p>
<ol>
<li><p>“隐藏” 对象属性。</p>
<p>如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 symbol 并使用它作为属性的键。symbol 属性不会出现在 <code>for..in</code> 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。</p>
<p>因此我们可以使用 symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。</p>
</li>
<li><p>JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 <code>Symbol.*</code> 访问。我们可以使用它们来改变一些内建行为。例如，在本教程的后面部分，我们将使用 <code>Symbol.iterator</code> 来进行 <a target="_blank" rel="noopener" href="https://zh.javascript.info/iterable">迭代</a> 操作，使用 <code>Symbol.toPrimitive</code> 来设置 <a target="_blank" rel="noopener" href="https://zh.javascript.info/object-toprimitive">对象原始值的转换</a> 等等。</p>
</li>
</ol>
<p>从技术上说，symbol 不是 100% 隐藏的。有一个内建方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols(obj)</a> 允许我们获取所有的 symbol。还有一个名为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys">Reflect.ownKeys(obj)</a> 的方法可以返回一个对象的 <strong>所有</strong> 键，包括 symbol。但大多数库、内建方法和语法结构都没有使用这些方法。</p>
<h2 id="四、对象-——-原始值转换"><a href="#四、对象-——-原始值转换" class="headerlink" title="四、对象 —— 原始值转换"></a>四、对象 —— 原始值转换</h2><p>JavaScript 不允许自定义运算符对对象的处理方式。与其他一些编程语言（Ruby，C++）不同）。</p>
<p>在进行此类运算时，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值）。</p>
<p>这是一个重要的限制：因为 <code>obj1 + obj2</code>（或者其他数学运算）的结果不能是另一个对象！</p>
<p>例如，我们无法使用对象来表示向量或矩阵（或成就或其他），把它们相加并期望得到一个“总和”向量作为结果。这样的想法是行不通的。</p>
<p>因此，由于我们从技术上无法实现此类运算，所以在实际项目中不存在对对象的数学运算。如果你发现有，除了极少数例外，通常是写错了。</p>
<p>本章将介绍对象是如何转换为原始值的，以及如何对其进行自定义。</p>
<p>我们有两个目的：</p>
<ol>
<li>让我们在遇到类似的对对象进行数学运算的编程错误时，能够更加理解到底发生了什么。</li>
<li>也有例外，这些操作也可以是可行的。例如日期相减或比较（<code>Date</code> 对象）。我们稍后会遇到它们。</li>
</ol>
<h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/object-toprimitive#zhuan-huan-gui-ze">转换规则</a></h3><ol>
<li><code>true</code>和<code>false</code>不会转换为布尔值。只有字符串和数字转换。</li>
<li>数字转换发生在对象相减或应用数学函数时。例如，<code>Date</code> 对象（将在 <a target="_blank" rel="noopener" href="https://zh.javascript.info/date">日期和时间</a> 一章中介绍）可以相减，<code>date1 - date2</code> 的结果是两个日期之间的差值。</li>
<li>至于字符串转换 —— 通常发生在我们像 <code>alert(obj)</code> 这样输出一个对象和类似的上下文中。</li>
</ol>
<p>我们可以使用特殊的对象方法，自己实现字符串和数字的转换。</p>
<p>现在让我们一起探究技术细节，因为这是深入讨论该主题的唯一方式。</p>
<h3 id="hint"><a href="#hint" class="headerlink" title="hint"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/object-toprimitive#hint">hint</a></h3><p>JavaScript 是如何决定应用哪种转换的？</p>
<p>类型转换在各种情况下有三种变体。它们被称为 “hint”，在 <a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/#sec-toprimitive">规范</a> 所述：</p>
<ul>
<li><p><code>&quot;string&quot;</code>对象到字符串的转换</p>
</li>
<li><p><code>&quot;number&quot;</code>对象到数字的转换</p>
</li>
<li><p><code>&quot;default&quot;</code>在少数情况下发生，当运算符“不确定”期望值的类型时。</p>
</li>
</ul>
<p>上面这些规则看起来比较复杂，但在实践中其实挺简单的。</p>
<p>除了一种情况（<code>Date</code> 对象，我们稍后会讲到）之外，所有内建对象都以和 <code>&quot;number&quot;</code> 相同的方式实现 <code>&quot;default&quot;</code> 转换。我们也可以这样做。</p>
<p><strong>为了进行转换，JavaScript 尝试查找并调用三个对象方法：</strong></p>
<ol>
<li><code>obj[Symbol.toPrimitive](hint)</code> —— 带有 symbol 键 <code>Symbol.toPrimitive</code>（系统 symbol）的方法，如果这个方法存在的话，</li>
<li>否则，如果 hint 是 <code>&quot;string&quot;</code> —— 尝试调用 <code>obj.toString()</code> 或 <code>obj.valueOf()</code>。</li>
<li>否则，如果 hint 是 <code>&quot;number&quot;</code> 或 <code>&quot;default&quot;</code> —— 尝试调用 <code>obj.valueOf()</code> 或 <code>obj.toString()</code>。</li>
</ol>
<h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/object-toprimitive#symboltoprimitive">Symbol.toPrimitive</a></h3><p>我们从第一个方法开始。有一个名为 <code>Symbol.toPrimitive</code> 的内建 symbol，它被用来给转换方法命名，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params">hint</span>) &#123;<br>  <span class="hljs-comment">// 这里是将此对象转换为原始值的代码</span><br>  <span class="hljs-comment">// 它必须返回一个原始值</span><br>  <span class="hljs-comment">// hint = &quot;string&quot;、&quot;number&quot; 或 &quot;default&quot; 中的一个</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果 <code>Symbol.toPrimitive</code> 方法存在，则它会被用于所有 hint，无需更多其他方法。</p>
<p>例如，这里 <code>user</code> 对象实现了它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">money</span>: <span class="hljs-number">1000</span>,<br><br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>](hint) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`hint: <span class="hljs-subst">$&#123;hint&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> hint == <span class="hljs-string">&quot;string&quot;</span> ? <span class="hljs-string">`&#123;name: &quot;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>&quot;&#125;`</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-property">money</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 转换演示：</span><br><span class="hljs-title function_">alert</span>(user); <span class="hljs-comment">// hint: string -&gt; &#123;name: &quot;John&quot;&#125;</span><br><span class="hljs-title function_">alert</span>(+user); <span class="hljs-comment">// hint: number -&gt; 1000</span><br><span class="hljs-title function_">alert</span>(user + <span class="hljs-number">500</span>); <span class="hljs-comment">// hint: default -&gt; 1500</span><br></code></pre></td></tr></table></figure>
<p>从代码中我们可以看到，根据转换的不同，<code>user</code> 变成一个自描述字符串或者一个金额。<code>user[Symbol.toPrimitive]</code> 方法处理了所有的转换情况。</p>
<h3 id="toString-valueOf"><a href="#toString-valueOf" class="headerlink" title="toString/valueOf"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/object-toprimitive#tostringvalueof">toString/valueOf</a></h3><p>如果没有 <code>Symbol.toPrimitive</code>，那么 JavaScript 将尝试寻找 <code>toString</code> 和 <code>valueOf</code> 方法：</p>
<ul>
<li>对于 <code>&quot;string&quot;</code> hint：调用 <code>toString</code> 方法，如果它不存在，则调用 <code>valueOf</code> 方法（因此，对于字符串转换，优先调用 <code>toString</code>）。</li>
<li>对于其他 hint：调用 <code>valueOf</code> 方法，如果它不存在，则调用 <code>toString</code> 方法（因此，对于数学运算，优先调用 <code>valueOf</code> 方法）。</li>
</ul>
<p><code>toString</code> 和 <code>valueOf</code> 方法很早己有了。它们不是 symbol（那时候还没有 symbol 这个概念），而是“常规的”字符串命名的方法。它们提供了一种可选的“老派”的实现转换的方法。</p>
<p>这些方法必须返回一个原始值。如果 <code>toString</code> 或 <code>valueOf</code> 返回了一个对象，那么返回值会被忽略（和这里没有方法的时候相同）。</p>
<p>默认情况下，普通对象具有 <code>toString</code> 和 <code>valueOf</code> 方法：</p>
<ul>
<li><code>toString</code> 方法返回一个字符串 <code>&quot;[object Object]&quot;</code>。</li>
<li><code>valueOf</code> 方法返回对象自身。</li>
</ul>
<p>下面是一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>&#125;;<br><br><span class="hljs-title function_">alert</span>(user); <span class="hljs-comment">// [object Object]</span><br><span class="hljs-title function_">alert</span>(user.<span class="hljs-title function_">valueOf</span>() === user); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>所以，如果我们尝试将一个对象当做字符串来使用，例如在 <code>alert</code> 中，那么在默认情况下我们会看到 <code>[object Object]</code>。</p>
<p>让我们实现一下这些方法来自定义转换。</p>
<p>例如，这里的 <code>user</code> 执行和前面提到的那个 <code>user</code> 一样的操作，使用 <code>toString</code> 和 <code>valueOf</code> 的组合（而不是 <code>Symbol.toPrimitive</code>）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">money</span>: <span class="hljs-number">1000</span>,<br><br>  <span class="hljs-comment">// 对于 hint=&quot;string&quot;</span><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`&#123;name: &quot;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>&quot;&#125;`</span>;<br>  &#125;,<br><br>  <span class="hljs-comment">// 对于 hint=&quot;number&quot; 或 &quot;default&quot;</span><br>  <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">money</span>;<br>  &#125;<br><br>&#125;;<br><br><span class="hljs-title function_">alert</span>(user); <span class="hljs-comment">// toString -&gt; &#123;name: &quot;John&quot;&#125;</span><br><span class="hljs-title function_">alert</span>(+user); <span class="hljs-comment">// valueOf -&gt; 1000</span><br><span class="hljs-title function_">alert</span>(user + <span class="hljs-number">500</span>); <span class="hljs-comment">// valueOf -&gt; 1500</span><br></code></pre></td></tr></table></figure>
<p>我们可以看到，执行的动作和前面使用 <code>Symbol.toPrimitive</code> 的那个例子相同。</p>
<p>通常我们希望有一个“全能”的地方来处理所有原始转换。在这种情况下，我们可以只实现 <code>toString</code>，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-title function_">alert</span>(user); <span class="hljs-comment">// toString -&gt; John</span><br><span class="hljs-title function_">alert</span>(user + <span class="hljs-number">500</span>); <span class="hljs-comment">// toString -&gt; John500</span><br></code></pre></td></tr></table></figure>
<p>如果没有 <code>Symbol.toPrimitive</code> 和 <code>valueOf</code>，<code>toString</code> 将处理所有原始转换。</p>
<h3 id="转换可以返回任何原始类型"><a href="#转换可以返回任何原始类型" class="headerlink" title="转换可以返回任何原始类型"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/object-toprimitive#zhuan-huan-ke-yi-fan-hui-ren-he-yuan-shi-lei-xing">转换可以返回任何原始类型</a></h3><p>关于所有原始转换方法，有一个重要的点需要知道，就是它们不一定会返回 “hint” 的原始值。</p>
<p>没有限制 <code>toString()</code> 是否返回字符串，或 <code>Symbol.toPrimitive</code> 方法是否为 <code>&quot;number&quot;</code> hint 返回数字。</p>
<p>唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。</p>
<p><strong>历史原因</strong></p>
<p>由于历史原因，如果 <code>toString</code> 或 <code>valueOf</code> 返回一个对象，则不会出现 error，但是这种值会被忽略（就像这种方法根本不存在）。这是因为在 JavaScript 语言发展初期，没有很好的 “error” 的概念。</p>
<p>相反，<code>Symbol.toPrimitive</code> 更严格，它 <strong>必须</strong> 返回一个原始值，否则就会出现 error。</p>
<h3 id="进一步的转换"><a href="#进一步的转换" class="headerlink" title="进一步的转换"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/object-toprimitive#jin-yi-bu-de-zhuan-huan">进一步的转换</a></h3><p>我们已经知道，许多运算符和函数执行类型转换，例如乘法 <code>*</code> 将操作数转换为数字。</p>
<p>如果我们将对象作为参数传递，则会出现两个运算阶段：</p>
<ol>
<li>对象被转换为原始值（通过前面我们描述的规则）。</li>
<li>如果还需要进一步计算，则生成的原始值会被进一步转换。</li>
</ol>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-comment">// toString 在没有其他方法的情况下处理所有转换</span><br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-title function_">alert</span>(obj * <span class="hljs-number">2</span>); <span class="hljs-comment">// 4，对象被转换为原始值字符串 &quot;2&quot;，之后它被乘法转换为数字 2。</span><br></code></pre></td></tr></table></figure>
<ol>
<li>乘法 <code>obj * 2</code> 首先将对象转换为原始值（字符串 “2”）。</li>
<li>之后 <code>&quot;2&quot; * 2</code> 变为 <code>2 * 2</code>（字符串被转换为数字）。</li>
</ol>
<p>二元加法在同样的情况下会将其连接成字符串，因为它更愿意接受字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;2&quot;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-title function_">alert</span>(obj + <span class="hljs-number">2</span>); <span class="hljs-comment">// 22（&quot;2&quot; + 2）被转换为原始值字符串 =&gt; 级联</span><br></code></pre></td></tr></table></figure>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/object-toprimitive#zong-jie">总结</a></h3><p>对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。</p>
<p>这里有三种类型（hint）：</p>
<ul>
<li><code>&quot;string&quot;</code>（对于 <code>alert</code> 和其他需要字符串的操作）</li>
<li><code>&quot;number&quot;</code>（对于数学运算）</li>
<li><code>&quot;default&quot;</code>（少数运算符，通常对象以和 <code>&quot;number&quot;</code> 相同的方式实现 <code>&quot;default&quot;</code> 转换）</li>
</ul>
<p>规范明确描述了哪个运算符使用哪个 hint。</p>
<p>转换算法是：</p>
<ol>
<li><p>调用 <code>obj[Symbol.toPrimitive](hint)</code> 如果这个方法存在，</p>
</li>
<li><p>否则，如果 hint 是</p>
</li>
</ol>
   <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;string&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>尝试调用 <code>obj.toString()</code> 或 <code>obj.valueOf()</code>，无论哪个存在。</li>
</ul>
<ol>
<li>否则，如果 hint 是</li>
</ol>
   <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;number&quot;</span><br></code></pre></td></tr></table></figure>
<p>   或者</p>
   <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;default&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>尝试调用 <code>obj.valueOf()</code> 或 <code>obj.toString()</code>，无论哪个存在。</li>
</ul>
<p>所有这些方法都必须返回一个原始值才能工作（如果已定义）。</p>
<p>在实际使用中，通常只实现 <code>obj.toString()</code> 作为字符串转换的“全能”方法就足够了，该方法应该返回对象的“人类可读”表示，用于日志记录或调试。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%89%8D%E7%AB%AF/" class="category-chain-item">前端</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/JavaScript/">#JavaScript</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/13/vue3-x-01/" title="vue3.x 基础语法篇">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">vue3.x 基础语法篇</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/12/JavaScript-04/" title="JavaScript 04">
                        <span class="hidden-mobile">JavaScript 04</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="vcomment" class="comment"></div> 
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
  <script>
    var notify = '' == true ? true : false;
    var verify = '' == true ? true : false;
      window.onload = function() {
          new Valine({
              el: '#vcomment',
              app_id: "AwHBUAjSP1GvDVpiBgxfS2Pg-gzGzoHsz",
              app_key: "kMsGLN3hzkQJuLrmqQBgquFF",
              placeholder: "说点什么",
              avatar:"retro",
              visitor: true       

          });
      }
  </script>

 
  <noscript>Please enable JavaScript to view the comments</noscript>



  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  




  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  
    
  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>

  <script defer src="/js/leancloud.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/yinghua.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiantiao.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxingxing.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":-15,"vOffset":-15},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
